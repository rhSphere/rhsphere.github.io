<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Depeng&#39;s Blog</title>
  
  <subtitle>北京邮电大学研究生在读</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.blogs.rhsphere.com/"/>
  <updated>2019-10-23T06:15:36.946Z</updated>
  <id>https://www.blogs.rhsphere.com/</id>
  
  <author>
    <name>Depeng Lu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>遍历HashMap的方法</title>
    <link href="https://www.blogs.rhsphere.com/2019/10/23/tranverse-hashmap.html"/>
    <id>https://www.blogs.rhsphere.com/2019/10/23/tranverse-hashmap.html</id>
    <published>2019-10-23T06:12:58.000Z</published>
    <updated>2019-10-23T06:15:36.946Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><h2 id="遍历HashMap"><a href="#遍历HashMap" class="headerlink" title="遍历HashMap"></a>遍历HashMap</h2><p>最近看源码比较多，从源码中收获很多。 其中Iterator 的方法建议忘记了再跟一些源码，看看是怎么来的。</p><p>不废话，直接上代码。</p><h2 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> algo09.hashmap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 遍历hashMap的方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: rhsphere</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>: 2019-10-23 13:52 by jdk 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TraverseHashMap</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**1.遍历键值对，使用Map.Entry map.entrySet() public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()  */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tranverse1</span><span class="params">(Map&lt;String, Integer&gt; map)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Key:"</span> + entry.getKey());</span><br><span class="line">            System.out.println(<span class="string">"Value:"</span> + entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 2.显示调用 map.entrySet() 的集合迭代器 EntrySet的 iterator */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tranverse2</span><span class="params">(Map&lt;String, Integer&gt; map)</span> </span>&#123;</span><br><span class="line">        Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; iterator = map.entrySet().iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            Map.Entry&lt;String, Integer&gt; entry = iterator.next();</span><br><span class="line">            System.out.println(<span class="string">"Key:"</span> + entry.getKey());</span><br><span class="line">            System.out.println(<span class="string">"Value:"</span> + entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 3.遍历Key,使用map.keySet() */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tranverse3</span><span class="params">(Map&lt;String, Integer&gt; map)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Key:"</span> + key);</span><br><span class="line">            System.out.println(<span class="string">"Value:"</span> + map.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** 4.遍历Value,使用map.values() */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tranverse4</span><span class="params">(Map&lt;String, Integer&gt; map)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v : map.values())</span><br><span class="line">            System.out.println(<span class="string">"Value:"</span> + v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">        map.put(<span class="string">"一"</span>, <span class="number">1</span>);</span><br><span class="line">        map.put(<span class="string">"二"</span>, <span class="number">2</span>);</span><br><span class="line">        map.put(<span class="string">"三"</span>, <span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">"=====遍历键值对====="</span>);</span><br><span class="line">        tranverse1(map);</span><br><span class="line">        System.out.println(<span class="string">"=====遍历键值对====="</span>);</span><br><span class="line">        tranverse2(map);</span><br><span class="line">        System.out.println(<span class="string">"=====遍历键值对====="</span>);</span><br><span class="line">        tranverse3(map);</span><br><span class="line">        System.out.println(<span class="string">"=====遍历键值对====="</span>);</span><br><span class="line">        tranverse4(map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="HashMap" scheme="https://www.blogs.rhsphere.com/categories/HashMap/"/>
    
    
      <category term="HashMap" scheme="https://www.blogs.rhsphere.com/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>递归、动规、分治、贪婪算法的一些总结</title>
    <link href="https://www.blogs.rhsphere.com/2019/10/10/conclusions-for-some-algos.html"/>
    <id>https://www.blogs.rhsphere.com/2019/10/10/conclusions-for-some-algos.html</id>
    <published>2019-10-10T12:35:35.000Z</published>
    <updated>2019-10-10T12:55:47.296Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><h1 id="递归和动态规划的比较"><a href="#递归和动态规划的比较" class="headerlink" title="递归和动态规划的比较"></a>递归和动态规划的比较</h1><p>动态规划(Dynamic Programming, DP)是一项虽简单但较难掌握的技术，一个容易识别和求解DP问题的方法时通过求解尽可能多的问题。<br>“Programming”一词并不是指编程，而是填充表格（类似线性规划）。</p><h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p>尽管递归问题五花八门，但题型大都类似。<br>一个问题是不是递归的，<strong>就看它能不能分解成子问题进行求解。</strong></p><p>当你听到问题是这么开头的：“设计一个算法，计算第n个……”，“编写代码列出前n个……”，“实现一个方法，计算所有……”等等，那么这个问题基本就是一个递归问题。</p><p>递归的解法，根据定义，就是从较小的子问题逐渐逼近原始问题。<br>很多时候，只要在f(n-1)的解法中 <strong>加入、移除某些东西或者稍作修改</strong>就能计算出f(n)。而在其他情况下，答案可能更为复杂。</p><p>你应该双管齐下，自下而上和自上而下两种递归解法都要考虑。简单构造法对递归问题就很奏效。</p><h2 id="自下而上的递归"><a href="#自下而上的递归" class="headerlink" title="自下而上的递归"></a>自下而上的递归</h2><p>自下而上的递归往往最为直观。首先要知道如何解决简单情况下的问题，比如，只有一个元素的列表，找出有两个、三个元素的列表的解法，依此类推。这种接法的关键在于，如何从先前解出来的答案，构建出后续情况的答案。</p><h2 id="自上而下的递归"><a href="#自上而下的递归" class="headerlink" title="自上而下的递归"></a>自上而下的递归</h2><p>自上而下的递归可能比较复杂，不过对某些问题很有必要。遇到此类问题时，我们要思考如何才能将情况N下的问题分解成多个子问题。同时注意子问题是否重叠了。</p><h1 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h1><p>分治（Divide and Conquer）法递归地将问题分解成两个或多个同类型的子问题，直到这些子问题简单到能够直接求解，然后将这些子问题的解合成为原始问题的解。</p><p>分治一般包括如下步骤：</p><ol><li>分（divide）： 将初始问题分割成多个子问题，这些子问题是与初始问题同类型的规模更小的实例。</li><li><strong>递归（recursion）：</strong> 递归求解子问题。</li><li>治（conquer）：合理地组合子问题的解。</li></ol><p>分治法递归地求解子问题，所有问题一般按照递归进行定义，用 <strong>主定理（Master theorem）</strong> 容易求得这些递归问题的时间复杂度。</p><h2 id="分治法的应用"><a href="#分治法的应用" class="headerlink" title="分治法的应用"></a>分治法的应用</h2><ul><li>二分查找</li><li>归并排序</li><li>快速排序</li><li>中间值查找</li><li>最大最小值查找</li><li>矩阵乘法</li><li>最近点对问题</li></ul><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>如果听到问题是求一个最优解（通常是求最大值或最小值），而且该问题能够分解成若干子问题，并且子问题之间还有重叠的更小的子问题，就可以考虑用动态规划来解决这个问题。</p><h2 id="动态规划的四个特点（剑指Offer总结）"><a href="#动态规划的四个特点（剑指Offer总结）" class="headerlink" title="动态规划的四个特点（剑指Offer总结）"></a>动态规划的四个特点（剑指Offer总结）</h2><ol><li>求一个问题的最优解；</li><li>整体问题的最优解是依赖各个子问题的最优解；</li><li>把大问题分解成若干小问题，这些小问题之间还有相互重叠的更小的子问题；</li><li>由于子问题在分解大问题的过程中重复出现，为了避免重复求解子问题，用从下往上的顺序先计算小问题的最优解并存储下来，再以此为基础求取大问题的最优解。 <strong>从上往下分析问题，从下往上求解问题。</strong></li></ol><h2 id="动态规划的四个特点"><a href="#动态规划的四个特点" class="headerlink" title="动态规划的四个特点"></a>动态规划的四个特点</h2><ol><li>最优子结构</li><li>子问题重叠</li><li>有边界</li><li>子问题独立</li></ol><h2 id="动态规划和分治法的主要区别"><a href="#动态规划和分治法的主要区别" class="headerlink" title="动态规划和分治法的主要区别"></a>动态规划和分治法的主要区别</h2><p>对于分治法，子问题是相互独立的，而在动态规划中子问题可能是重叠的，通过使用备忘录（用一个表来保存已解决子问题的答案），对于大部分问题，动态规划能够将待求解问题的复杂度由指数级降低为多项式级。</p><p>动态规划主要包含以下两个部分：</p><ul><li>递归： 递归求解子问题。</li><li>备忘录： 将已计算的值存储在表中。</li></ul><p>动态规划 = 递归 + 备忘录</p><h2 id="动态规划算法例子"><a href="#动态规划算法例子" class="headerlink" title="动态规划算法例子"></a>动态规划算法例子</h2><ul><li>许多字符串算法，如最长公共子序列、最长递增子序列、最长公共子串、编辑距离等</li><li>关于图的有效求解算法，如寻找图中最短距离的Bellman-Ford算法、Floyd的所有定点间最短路径算法等</li><li>链矩阵乘法</li><li>子集和</li><li>0/1背包问题</li><li>旅行商问题等</li></ul><h1 id="贪婪算法"><a href="#贪婪算法" class="headerlink" title="贪婪算法"></a>贪婪算法</h1><p>贪婪算法将问题分为多个阶段。在每一个阶段，选取当前状态下的最优决策，而不考虑对后续决策的影响。这意味着算法在执行过程中会选取某些 <strong>局部最优解</strong>。贪婪算法假设通过局部最优解可以获得全局最优解。</p><h2 id="贪婪算法的要素"><a href="#贪婪算法的要素" class="headerlink" title="贪婪算法的要素"></a>贪婪算法的要素</h2><ol><li>贪婪选择性质</li><li>最优子结构</li></ol><h3 id="贪婪选择性质"><a href="#贪婪选择性质" class="headerlink" title="贪婪选择性质"></a>贪婪选择性质</h3><p>全局最优解可以通过寻找局部最优解获得（贪婪），局部最优解的选择可能依赖于之前的决策。通过迭代方式算法进行一个个贪婪选择，将原问题简化为规模更小的问题。</p><h3 id="最优子结构"><a href="#最优子结构" class="headerlink" title="最优子结构"></a>最优子结构</h3><p>如果原问题的最优解包含子问题的最优解，则认为该问题具有最优子结构。这意味着可以对子问题求解并构建规模更大的解。</p><h2 id="贪婪算法的优缺点"><a href="#贪婪算法的优缺点" class="headerlink" title="贪婪算法的优缺点"></a>贪婪算法的优缺点</h2><p><em>优点：</em><br>直观，易于理解和编程实现。当前的决策不会对已经计算出的结果有任何影响，因此不需要再对已有的局部解进行检查。</p><p><em>缺点：</em><br>选择局部最优不是对于所有问题都是用，所以贪婪算法并不总能得到最优解。在许多情况下，无法保证最优解能够产生局部最优解。</p><p>通常需要用数学的方式来证明贪婪选择是正确的。</p><h2 id="贪婪算法的应用"><a href="#贪婪算法的应用" class="headerlink" title="贪婪算法的应用"></a>贪婪算法的应用</h2><ul><li>排序问题，选择排序、拓扑排序</li><li>优先队列，堆排序</li><li>哈夫曼编码</li><li>Prim和Kruskal算法</li><li>加权图的最短路径算法（Dijkstra算法）</li><li>硬币找零问题</li><li>分数背包问题</li><li>并查集的按大小或高度合并问题（或排名）</li><li>任务调度算法</li><li>求解复杂问题的近似算法</li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Sum-up" scheme="https://www.blogs.rhsphere.com/categories/Sum-up/"/>
    
    
      <category term="Sum-up" scheme="https://www.blogs.rhsphere.com/tags/Sum-up/"/>
    
  </entry>
  
  <entry>
    <title>110. Balanced Binary Tree</title>
    <link href="https://www.blogs.rhsphere.com/2019/08/29/balanced-binary-tree.html"/>
    <id>https://www.blogs.rhsphere.com/2019/08/29/balanced-binary-tree.html</id>
    <published>2019-08-28T17:00:23.000Z</published>
    <updated>2019-08-28T17:17:17.534Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><p>参考<a href="https://blogs.rhsphere.com/leetcode/2019/08/02/tree-depth.html" target="_blank" rel="noopener">剑指Offer(55) 题目二 平衡二叉树判定</a>的思路。<br><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">LeetCode 110 英文版</a><br><a href="https://leetcode-cn.com/problems/balanced-binary-tree/" target="_blank" rel="noopener">LeetCode 110 中文版</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p><p>本题中，一棵高度平衡二叉树定义为：</p><p>一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。</p><p>示例 1:</p><p>给定二叉树 [3,9,20,null,null,15,7]</p><pre><code>3</code></pre><p>   / \<br>  9  20<br>    /  \<br>   15   7<br>返回 true 。</p><p>示例 2:</p><p>给定二叉树 [1,2,2,3,3,null,null,4,4]</p><pre><code>   1  / \ 2   2/ \</code></pre><p>   3   3<br>  / \<br> 4   4<br>返回 false 。</p><h2 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: leetcode 110</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: rhsphere</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>: 2019-08-29 01:08 by jdk 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BalancedBinaryTree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line"></span><br><span class="line">        TreeNode(<span class="keyword">int</span> x) &#123;</span><br><span class="line">            val = x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getDepth(root) != -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = getDepth(root.left);</span><br><span class="line">        <span class="keyword">if</span> (left == -<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = getDepth(root.right);</span><br><span class="line">        <span class="keyword">if</span> (right == -<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.abs(left - right) &gt; <span class="number">1</span> ? -<span class="number">1</span> : Math.max(left + <span class="number">1</span>, right + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Easy" scheme="https://www.blogs.rhsphere.com/categories/Easy/"/>
    
    
      <category term="Recursive" scheme="https://www.blogs.rhsphere.com/tags/Recursive/"/>
    
      <category term="Tree" scheme="https://www.blogs.rhsphere.com/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>104. Maximum Depth of Binary Tree</title>
    <link href="https://www.blogs.rhsphere.com/2019/08/29/max-depth-of-binary-tree.html"/>
    <id>https://www.blogs.rhsphere.com/2019/08/29/max-depth-of-binary-tree.html</id>
    <published>2019-08-28T16:45:11.000Z</published>
    <updated>2019-08-28T17:16:03.789Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><h2 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h2><p>参考<a href="https://blogs.rhsphere.com/leetcode/2019/08/02/tree-depth.html" target="_blank" rel="noopener">剑指Offer(55) 题目一 二叉树的深度</a>的思路。<br><a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">LeetCode 104 英文版</a><br><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">LeetCode 104 中文版</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p>示例： 给定二叉树 [3,9,20,null,null,15,7]，</p><pre><code>3</code></pre><p>   / \<br>  9  20<br>    /  \<br>   15   7<br>返回它的最大深度 3 。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>时间复杂度：我们每个结点只访问一次，因此时间复杂度为 O(N)<br>其中 N 是结点的数量。<br>空间复杂度：在最糟糕的情况下，树是完全不平衡的，例如每个结点只剩下左子结点，递归将会被调用 N 次（树的高度），因此保持调用栈的存储将是 O(N) 但在最好的情况下（树是完全平衡的），树的高度将是 log(N)。因此，在这种情况下的空间复杂度将是 O(log(N))。</p><h2 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: leetcode 104</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: rhsphere</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>: 2019-08-29 00:46 by jdk 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxDepthOfBinaryTree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line"></span><br><span class="line">        TreeNode(<span class="keyword">int</span> x) &#123;</span><br><span class="line">            val = x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> left_height = maxDepth(root.left);</span><br><span class="line">            <span class="keyword">int</span> right_height = maxDepth(root.right);</span><br><span class="line">            <span class="keyword">return</span> Math.max(left_height, right_height) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Easy" scheme="https://www.blogs.rhsphere.com/categories/Easy/"/>
    
    
      <category term="Recursive" scheme="https://www.blogs.rhsphere.com/tags/Recursive/"/>
    
      <category term="Tree" scheme="https://www.blogs.rhsphere.com/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>226. Invert Binary Tree</title>
    <link href="https://www.blogs.rhsphere.com/2019/08/28/invert-binary-tree.html"/>
    <id>https://www.blogs.rhsphere.com/2019/08/28/invert-binary-tree.html</id>
    <published>2019-08-27T17:12:36.000Z</published>
    <updated>2019-08-27T17:19:02.350Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><h2 id="翻转二叉树"><a href="#翻转二叉树" class="headerlink" title="翻转二叉树"></a>翻转二叉树</h2><p>注意区分和<a href="https://blogs.rhsphere.com/leetcode/2019/07/09/mirror-of-binary-tree.html" target="_blank" rel="noopener">剑指Offer(27) 二叉树的镜像</a>的区别，另一种迭代解法待完成。</p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>翻转一棵二叉树。</p><p>示例：</p><p>输入：</p><pre><code>4</code></pre><p>   /   \<br>  2     7<br> / \   / \<br>1   3 6   9<br>输出：</p><pre><code>4</code></pre><p>   /   \<br>  7     2<br> / \   / \<br>9   6 3   1<br>备注: 这个问题是受到 Max Howell 的 原问题 启发的 ：</p><p>谷歌：我们90％的工程师使用您编写的软件(Homebrew)，但是您却无法在面试时在白板上写出翻转二叉树这道题，这太糟糕了。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>既然树中的每个节点都只被访问一次，那么时间复杂度就是 O(n)O(n)，其中 nn 是树中节点的个数。在反转之前，不论怎样我们至少都得访问每个节点至少一次，因此这个问题无法做地比 O(n)O(n) 更好了。</p><p>本方法使用了递归，在最坏情况下栈内需要存放 O(h)O(h) 个方法调用，其中 hh 是树的高度。由于 h\in O(n)h∈O(n)，可得出空间复杂度为 O(n)O(n)。</p><h2 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: rhsphere</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>: 2019-08-28 01:06 by jdk 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InvertBinaryTree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//这里的left、right顺序注意</span></span><br><span class="line">        TreeNode left = invertTree(root.left);</span><br><span class="line">        TreeNode right = invertTree(root.right);</span><br><span class="line">        root.left = right;</span><br><span class="line">        root.right = left;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Easy" scheme="https://www.blogs.rhsphere.com/categories/Easy/"/>
    
    
      <category term="Recursive" scheme="https://www.blogs.rhsphere.com/tags/Recursive/"/>
    
      <category term="Tree" scheme="https://www.blogs.rhsphere.com/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>101. Symmetric Tree</title>
    <link href="https://www.blogs.rhsphere.com/2019/08/28/Symmetric-tree.html"/>
    <id>https://www.blogs.rhsphere.com/2019/08/28/Symmetric-tree.html</id>
    <published>2019-08-27T16:58:34.000Z</published>
    <updated>2019-08-27T17:19:09.522Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><h2 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h2><p>本题和 <a href="https://blogs.rhsphere.com/leetcode/2019/07/09/symmetrical-binary-tree.html" target="_blank" rel="noopener">剑指Offer(28) 对称的二叉树</a> 相似，请完成迭代解法。</p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个二叉树，检查它是否是镜像对称的。</p><p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p><pre><code>1</code></pre><p>   / \<br>  2   2<br> / \ / \<br>3  4 4  3<br>但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</p><pre><code>1</code></pre><p>   / \<br>  2   2<br>   \   \<br>   3    3<br>说明:</p><p>如果你可以运用递归和迭代两种方法解决这个问题，会很加分。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>如果一个树的左子树与右子树镜像对称，那么这个树是对称的。</p><p>因此，该问题可以转化为：两个树在什么情况下互为镜像？</p><p>如果同时满足下面的条件，两个树互为镜像：</p><ol><li>它们的两个根结点具有相同的值。</li><li>每个树的右子树都与另一个树的左子树镜像对称。</li></ol><p>时间复杂度：O(n)，因为我们遍历整个输入树一次，所以总的运行时间为 O(n)，其中 n 是树中结点的总数。</p><p>空间复杂度：递归调用的次数受树的高度限制。在最糟糕情况下，树是线性的，其高度为 O(n)。因此，在最糟糕的情况下，由栈上的递归调用造成的空间复杂度为 O(n))。</p><h2 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: leetcode 101 使用递归</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: rhsphere</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>: 2019-08-28 00:53 by jdk 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StmmetricTree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isMirror(root, root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isMirror</span><span class="params">(TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> &amp;&amp; q == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> || q == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> p.val == q.val &amp;&amp; isMirror(p.left, q.right) &amp;&amp; isMirror(p.right, q.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Easy" scheme="https://www.blogs.rhsphere.com/categories/Easy/"/>
    
    
      <category term="Recursive" scheme="https://www.blogs.rhsphere.com/tags/Recursive/"/>
    
      <category term="Tree" scheme="https://www.blogs.rhsphere.com/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>100. Same Tree</title>
    <link href="https://www.blogs.rhsphere.com/2019/08/28/same-tree.html"/>
    <id>https://www.blogs.rhsphere.com/2019/08/28/same-tree.html</id>
    <published>2019-08-27T16:33:29.000Z</published>
    <updated>2019-08-27T16:46:01.619Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><h2 id="相同的树"><a href="#相同的树" class="headerlink" title="相同的树"></a>相同的树</h2><p>思考：本题使用迭代法如何做？</p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定两个二叉树，编写一个函数来检验它们是否相同。</p><p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p><p>示例 1:</p><p>输入:       1         1<br>          / \       / \<br>         2   3     2   3</p><pre><code>[1,2,3],   [1,2,3]</code></pre><p>输出: true<br>示例 2:</p><p>输入:      1          1<br>          /           \<br>         2             2</p><pre><code>[1,2],     [1,null,2]</code></pre><p>输出: false<br>示例 3:</p><p>输入:       1         1<br>          / \       / \<br>         2   1     1   2</p><pre><code>[1,2,1],   [1,1,2]</code></pre><p>输出: false</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>最简单的策略是使用递归。首先判断 p 和 q 是不是 null，然后判断它们的值是否相等。</p><p>时间复杂度 : O(N)O(N)，其中 N 是树的结点数，因为每个结点都访问一次。</p><p>空间复杂度 : 最优情况（完全平衡二叉树）时为 O(\log(N))O(log(N))，最坏情况下（完全不平衡二叉树）时为 {O}(N)O(N)，用于维护递归栈。</p><h2 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">**</span><br><span class="line"> * <span class="meta">@description</span>: leetcode <span class="number">100</span> 使用递归</span><br><span class="line"> * <span class="meta">@author</span>: rhsphere</span><br><span class="line"> * <span class="meta">@since</span>: <span class="number">2019</span>-<span class="number">08</span>-<span class="number">28</span> <span class="number">00</span>:<span class="number">33</span> by jdk <span class="number">1.8</span></span><br><span class="line"> */</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SameTree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span>  <span class="title">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> &amp;&amp; q == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> || q == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (p.val != q.val)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Easy" scheme="https://www.blogs.rhsphere.com/categories/Easy/"/>
    
    
      <category term="Recursive" scheme="https://www.blogs.rhsphere.com/tags/Recursive/"/>
    
      <category term="Tree" scheme="https://www.blogs.rhsphere.com/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>【目录】 《剑指Offer》Java思路与实现</title>
    <link href="https://www.blogs.rhsphere.com/2019/08/27/catalog-of-swording-offers.html"/>
    <id>https://www.blogs.rhsphere.com/2019/08/27/catalog-of-swording-offers.html</id>
    <published>2019-08-27T15:01:11.000Z</published>
    <updated>2019-08-27T15:14:22.976Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><h1 id="剑指Offer目录"><a href="#剑指Offer目录" class="headerlink" title="剑指Offer目录"></a>剑指Offer目录</h1><p><a href="https://blogs.rhsphere.com/leetcode/2019/03/21/singleton.html" target="_blank" rel="noopener">    2) 实现Singleton模式  </a></p><p><a href="https://blogs.rhsphere.com/leetcode/2019/03/21/duplication-in-array.html" target="_blank" rel="noopener">    3) 找出数组中重复的数字/不修改数组找出重复的数字 </a></p><p><a href="https://blogs.rhsphere.com/leetcode/2019/03/24/find-in-partially-sorted-matrix.html" target="_blank" rel="noopener">    4) 二维数组中的查找 </a></p><p><a href="https://blogs.rhsphere.com/leetcode/2019/03/24/replace-spaces.html" target="_blank" rel="noopener">　　5) 替换空格/无序字母排序 </a></p><p><a href="https://blogs.rhsphere.com/leetcode/2019/03/26/print-list-from-head-to-tail.html" target="_blank" rel="noopener">　　6) 从尾到头打印链表 </a></p><p><a href="https://blogs.rhsphere.com/leetcode/2019/03/27/construct-binary-tree.html" target="_blank" rel="noopener">　　7) 重建二叉树 </a></p><p>　　7) 二叉树的下一个结点 </p><p>　　8) 用两个栈实现队列 </p><p>　　9) 斐波那契数列及青蛙跳台阶问题 </p><p>　　10) 旋转数组的最小数字 </p><p>　　11) 矩阵中的路径 </p><p>　　12) 机器人的运动范围 </p><p>　　13) 剪绳子 </p><p>　　14) 二进制中1的个数 </p><p>　　15) 数值的整数次方 </p><p>　　16) 打印1到最大的n位数 </p><p>　　17) 在O(1)时间删除链表结点 </p><p>　　18) 删除链表中重复的结点 </p><p>　　19) 正则表达式匹配 </p><p>　　20) 表示数值的字符串 </p><p>　　21) 调整数组顺序使奇数位于偶数前面 </p><p>　　22) 链表中倒数第k个结点 </p><p>　　23) 链表中环的入口结点 </p><p>　　24) 反转链表 </p><p>　　25) 合并两个排序的链表 </p><p>　　26) 树的子结构 </p><p>　　27) 二叉树的镜像 </p><p>　　28) 对称的二叉树 </p><p>　　29) 顺时针打印矩阵</p><p>　　30) 包含min函数的栈</p><p>　　31) 栈的压入、弹出序列  </p><p>　　32) 从上往下打印二叉树</p><p>　　33) 二叉搜索树的后序遍历序列 </p><p>　　34) 二叉树中和为某一值的路径 </p><p>　　35) 复杂链表的复制 </p><p>　　36) 二叉搜索树与双向链表</p><p>　　37) 序列化二叉树</p><p>　　38) 字符串的排列 </p><p>　　39) 数组中出现次数超过一半的数字 </p><p>　　40) 最小的k个数 </p><p>　　41) 数据流中的中位数</p><p>　　42) 连续子数组的最大和</p><p>　　43) 从1到n整数中1出现的次数</p><p>　　44) 数字序列中某一位的数字</p><p>　　45) 把数组排成最小的数</p><p>　　46) 把数字翻译成字符串</p><p>　　47) 礼物的最大价值</p><p>　　48) 最长不含重复字符的子字符串</p><p>　　50-1) 字符串中第一个只出现一次的字符</p><p>　　50-2) 字符流中第一个只出现一次的字符</p><p>　　51)数组中的逆序对</p><p>　　52) 两个链表的第一个公共结点</p><p>　　53-1) 数字在排序数组中出现的次数</p><p>　　53-2) 0到n-1中缺失的数字</p><p>　　53-3) 数组中数值和下标相等的元素</p><p>　　54) 二叉搜索树的第k个结点</p><p>　　55-1) 二叉树的深度</p><p>　　55-2) 平衡二叉树</p><p>　　56-1) 数组中只出现一次的两个数字</p><p>　　56-2) 数组中唯一只出现一次的数字</p><p>　　57-1) 和为s的两个数字</p><p>　　57-2) 为s的连续正数序列</p><p>　　58-1) 翻转单词顺序</p><p>　　58-2) 左旋转字符串</p><p>　　59-1) 滑动窗口的最大值</p><p>　　59-2) 队列的最大值</p><p>　　60) n个骰子的点数</p><p>　　61) 扑克牌的顺子</p><p>　　62) 圆圈中最后剩下的数字</p><p>　　63) 股票的最大利润</p><p>　　64) 求1+2+…+n</p><p>　　65) 不用加减乘除做加法</p><p>　　66) 构建乘积数组</p><p>　　67) 把字符串转换成整数</p><p>　　68) 树中两个结点的最低公共祖先</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="剑指Offer" scheme="https://www.blogs.rhsphere.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="catalog" scheme="https://www.blogs.rhsphere.com/tags/catalog/"/>
    
  </entry>
  
  <entry>
    <title>Scanner类的几个方法</title>
    <link href="https://www.blogs.rhsphere.com/2019/08/13/scanner.html"/>
    <id>https://www.blogs.rhsphere.com/2019/08/13/scanner.html</id>
    <published>2019-08-13T14:49:13.000Z</published>
    <updated>2019-08-13T16:06:50.032Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><h2 id="Scanner类的几个方法"><a href="#Scanner类的几个方法" class="headerlink" title="Scanner类的几个方法"></a>Scanner类的几个方法</h2><p>通过Scanner类可以后去用户输入，创建Scanner对象的基本语法如下：</p><pre><code>Scanner sc = new Scanner(System.in);</code></pre><p>System.in代表标准输入，即键盘输入，但这个标准输入流是 InputStream 类的实例，使用不太方便，而且键盘输入内容都是文本内容，所以可以使用 InputStreamReader 将其转换为字符输入流，普通的 Reader 读取输入内容依然不太方便，可以将普通的 Reader 再次包装成BufferedReader，利用 BufferedReader 的 readLine() 方法可以一次读取一行内容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KeyInTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (InputStreamReader reader = <span class="keyword">new</span> InputStreamReader(System.in);</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(reader)) &#123;</span><br><span class="line">            String line = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">while</span> ((line = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (line.equals(<span class="string">"exit"</span>))</span><br><span class="line">                    System.exit(<span class="number">1</span>);</span><br><span class="line">                System.out.println(<span class="string">"输入内容为："</span> + line);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">            ioe.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>nextInt()、next()和nextLine():</strong></p><p>nextInt(): it only reads the int value, nextInt() places the cursor（光标） in the same line after reading the input.<br>    nextInt()只读取数值，剩下”\n”还没有读取，并将cursor放在本行中。</p><p>next(): read the input only till the space. It can’t read two words separated by space. Also, next() places the cursor in the same line after reading the input.（next()只读空格之前的数据，并且cursor指向本行）<br>　　next() 方法遇见第一个有效字符（非空格，非换行符）时，开始扫描，当遇见第一个分隔符或结束符(空格或换行符)时，结束扫描，获取扫描到的内容，即获得第一个扫描到的不含空格、换行符的单个字符串。</p><p>nextLine(): reads input including space between the words (that is, it reads till the end of line \n). Once the input is read, nextLine() positions the cursor in the next line.<br>    nextLine()时，则可以扫描到一行内容并作为一个字符串而被获取到。</p><h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://www.blogs.rhsphere.com/categories/Java/"/>
    
    
      <category term="java" scheme="https://www.blogs.rhsphere.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>动态代理(二)</title>
    <link href="https://www.blogs.rhsphere.com/2019/08/13/dynamic-proxy-more.html"/>
    <id>https://www.blogs.rhsphere.com/2019/08/13/dynamic-proxy-more.html</id>
    <published>2019-08-13T03:35:31.000Z</published>
    <updated>2019-10-23T06:19:21.016Z</updated>
    
    <content type="html"><![CDATA[<p class="description">JDK动态代理涉及java.lang.reflect包中的两个类，Proxy和InvocationHandler。Proxy利用InvocationHandler动态创建一个符合某一接口的实例，生成目标类的代理对象。InvocationHandler可以实现接口定义横切逻辑，并通过反射机制调用目标类的代码，动态地将横切逻辑和业务逻辑编织在一起。</p><a id="more"></a><h2 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h2><p>下面摘自：《疯狂java讲义 第四版》 p857</p><p>当程序使用反射方式为指定接口生成系列动态代理对象时，这些动态代理对象的实现类实现了一个或多个接口。动态代理对象就需要实现一个或多个接口里定义的所有方法，但问题是：系统怎么知道如何实现这些方法？ 这个时候就轮到 InvocationHandler 对象登场了，当执行动态代理对象里的方法时，实际上会替换成调用 InvocationHandler 对象的 invoke 方法。</p><p>在 Java 中，动态代理类的生成主要涉及对 ClassLoader 的使用。以 CGLIB 为例，使用 CGLIB 生成动态代理，首先需要生成 Enhancer 类实例，并指定用于处理代理业务的回调类。在 Enhancer.create() 方法中，会使用 DefaultGeneratorStrategy.Generate() 方法生成动态代理类的字节码，并保存在 byte 数组中。接着使用 ReflectUtils.defineClass() 方法，通过反射，调用 ClassLoader.defineClass() 方法，将字节码装载到 ClassLoader 中，完成类的加载。最后使用 ReflectUtils.newInstance() 方法，通过反射，生成动态类的实例，并返回该实例。基本流程是根据指定的回调类生成 Class 字节码—通过 defineClass() 将字节码定义为类—使用反射机制生成该类的实例。</p><p>程序中可以采用先生成一个动态代理类，然后通过动态代理类来创建代理对象的方式生成一个动态代理对象。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个InvocationHandler对象</span></span><br><span class="line">InvocationHandler handler = <span class="keyword">new</span>  MyInvocationHandler(...);</span><br><span class="line"><span class="comment">//使用Proxy生成一个动态代理类 proxyClass</span></span><br><span class="line">Class proxyClass = Proxy.getProxyClass(Foo.class.getClassLoader(), <span class="keyword">new</span> Class[] &#123;Foo.class&#125;);</span><br><span class="line"><span class="comment">//获取proxyClass类中带一个InvocationHandler参数的构造器</span></span><br><span class="line">Constructor ctor = proxyClass.getConstructor(<span class="keyword">new</span> Class[] &#123;InvocationHandler.class&#125;);</span><br><span class="line"><span class="comment">//调用ctor的newInstance方法来创建动态实例</span></span><br><span class="line">Foo f = (Foo) ctor.newInstance(<span class="keyword">new</span> Object[] &#123;handler&#125;);</span><br></pre></td></tr></table></figure><p>上面的代码也可以简化成如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个InvocationHandler对象</span></span><br><span class="line">InvocationHandler handler = <span class="keyword">new</span> MyInvocationHandler(...);</span><br><span class="line"><span class="comment">//使用Proxy直接生成一个动态代理对象</span></span><br><span class="line">Foo f = (Foo) Proxy.newProxyInstance(Foo.class.getClassLoader(), </span><br><span class="line"><span class="keyword">new</span> Class[] &#123;Foo.class&#125;, handler);</span><br></pre></td></tr></table></figure><p>下面的代码来自于《精通Spring 4.x企业应用开发实战》 P224</p><h3 id="业务逻辑横切代码"><a href="#业务逻辑横切代码" class="headerlink" title="业务逻辑横切代码"></a>业务逻辑横切代码</h3><p>业务逻辑实现类的代码，省去ForumService接口类和PerformanceMonitor的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForumServiceImpl</span> <span class="keyword">implements</span> <span class="title">ForumService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeTopic</span><span class="params">(<span class="keyword">int</span> topicId)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 横切逻辑</span></span><br><span class="line">        <span class="comment">// PerformanceMonitor.begin();  </span></span><br><span class="line">        System.out.println(<span class="string">"模拟删除Topic记录"</span> + topicId);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.currentThread().sleep(<span class="number">20</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// PerformanceMonitor.end()</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeForum</span><span class="params">(<span class="keyword">int</span> forumId)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// PerformanceMonitor.begin();</span></span><br><span class="line">        System.out.println(<span class="string">"模拟删除Topic记录"</span> + forumId);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.currentThread().sleep(<span class="number">20</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// PerformanceMonitor.end();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="横切逻辑"><a href="#横切逻辑" class="headerlink" title="横切逻辑"></a>横切逻辑</h3><p>将业务类中性能监视横切代码移除后，放置到InvocationHandler中，代码如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PerformanceHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PerformanceHandler</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, </span></span></span><br><span class="line"><span class="function"><span class="params">        Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// 横切逻辑代码定义在PerformanceMonitor中</span></span><br><span class="line">        PerformanceMonitor.begin(target.getClass().getName() + <span class="string">"."</span> + method.getName());</span><br><span class="line">        <span class="comment">// 使用反射方法调用业务类的目标方法</span></span><br><span class="line">        Object obj = method.invoke(target, args);</span><br><span class="line">        <span class="comment">// 横切逻辑</span></span><br><span class="line">        PerformanceMonitor.end();</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>invoke(Object proxy, Method method, Object[] args)方法，其中，proxy是最终生成的代理实例，一般不会用到；method是被代理目标实例的某个具体方法，通过它可以发起目标实例方法的反射调用；args是被代理实例某个方法的入参，在方法反射时调用。<br>其次，在构造参数里通过target传入希望被代理的目标对象，在接口方法invoke(Object proxy, Method method, Object[] args)里，将目标实例传递给method.invoke()方法，并调用目标实例的方法。</p><p>proxy代表动态代理对象，method代表正在执行的方法，args代表调用目标方法是传入的实参。</p><p>下面通过Proxy结合PerformanceHandler创建ForumService接口的代理实例。</p><h3 id="创建代理实例"><a href="#创建代理实例" class="headerlink" title="创建代理实例"></a>创建代理实例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForumServiceTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">proxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//  希望被代理的目标业务类</span></span><br><span class="line">        ForumService target = <span class="keyword">new</span> ForumServiceImpl();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  将目标业务类和横切代码编织到一起</span></span><br><span class="line">        PerformanceHandler handler = <span class="keyword">new</span> PerformanceHandler(target);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  根据编织了目标业务类逻辑和性能监视横切逻辑的</span></span><br><span class="line">        <span class="comment">//  InvocationHandler实例创建代理实例</span></span><br><span class="line">        ForumService proxy = (ForumService) Proxy.newProxyInstance(</span><br><span class="line">            target.getClass().getClassLoader(),</span><br><span class="line">            target.getClass().getInterface(),</span><br><span class="line">            handler);</span><br><span class="line">        <span class="comment">//  调用代理实例</span></span><br><span class="line">        proxy.removeForum(<span class="number">10</span>);</span><br><span class="line">        proxy.removeTopic(<span class="number">1024</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Proxy.newProxyInstance() 方法的第一个入参为类加载器；第二个入参为创建代理实例所需实现的一组接口；第三个入参是整合了业务逻辑和横切逻辑的编织器对象。</p><h2 id="JDK动态代理另一种简洁写法"><a href="#JDK动态代理另一种简洁写法" class="headerlink" title="JDK动态代理另一种简洁写法"></a>JDK动态代理另一种简洁写法</h2><p>以下代码来自于 Java EE 互联网轻量级框架整合开发</p><h3 id="接口类和实现类的定义"><a href="#接口类和实现类的定义" class="headerlink" title="接口类和实现类的定义"></a>接口类和实现类的定义</h3><p>在动态代理中必须使用接口，CGLib不需要。<br>下面的代码分别是简单的接口和被代理类的定义。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceImpl</span> <span class="keyword">implements</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello world"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动态代理绑定和代理逻辑实现"><a href="#动态代理绑定和代理逻辑实现" class="headerlink" title="动态代理绑定和代理逻辑实现"></a>动态代理绑定和代理逻辑实现</h3><p>要实现动态代理要两个步骤，首先，建立起代理对象和被代理对象的关系（将目标业务类和横切代码编织到一起），然后实现代理逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkProxyExample</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object target = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">bind</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">            target.getClass().getClassLoader(),</span><br><span class="line">            target.getClass().gerInterfaces(),</span><br><span class="line">            <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, </span></span></span><br><span class="line"><span class="function"><span class="params">        Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"before..."</span>);</span><br><span class="line"></span><br><span class="line">        Object obj = method.invoke(target, args);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"after..."</span>);</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试动态代理类"><a href="#测试动态代理类" class="headerlink" title="测试动态代理类"></a>测试动态代理类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkProxyExampleTest</span> </span>&#123;</span><br><span class="line">    JdkProxyExample jdk = <span class="keyword">new</span> JdkProxyExample();</span><br><span class="line"></span><br><span class="line">    Service proxy = (Service) jdk.bind(<span class="keyword">new</span> ServiceImpl());</span><br><span class="line"></span><br><span class="line">    proxy.sayHello();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>bind方法同时完成了两步。</p><h2 id="CGLib动态代理"><a href="#CGLib动态代理" class="headerlink" title="CGLib动态代理"></a>CGLib动态代理</h2><p>使用JDK创建代理有一个限制，即只能为接口创建代理。Proxy的接口方法中newProxyInstance(ClassLoader loder, Class[] interfaces, InvocationHandler hander)，第二个入参就是需要代理实例实现的接口列表。<br>假如对一个简单业务表的操作也需要创建5个类（领域对象、DAO接口、DAO实现类、Service接口和Service实现类）吗？<br>对于没有通过接口定义业务方法的类，可以使用CGLib动态创建代理实例。</p><p>CGLib采用底层的字节码技术，可以为一个类创建子类，在子类中采用方法拦截的技术拦截父类方法的调用并顺势织入横切逻辑。</p><p>值得一提的是，由于CGLib采用动态创建子类的方式生成代理对象，所以不能对目标类中的final或private方法进行代理。</p><h3 id="CglibProxy"><a href="#CglibProxy" class="headerlink" title="CglibProxy"></a>CglibProxy</h3><p>下面代码可以创建，为任何类织入性能监视横切逻辑代理对象的代理创建器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibProxy</span> <span class="title">implemets</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 增强类对象</span></span><br><span class="line">    <span class="keyword">private</span> Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(Class cls)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 设置需要创建子类的类</span></span><br><span class="line">        enhancer.setSuperClass(cls);</span><br><span class="line">        <span class="comment">/* 定义代理逻辑对象为当前对象，要求当前对象实现</span></span><br><span class="line"><span class="comment">        * MethodInterceptor方法</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过字节码技术动态创建子类实例</span></span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *代理逻辑方法，拦截父类所有方法的调用</span></span><br><span class="line"><span class="comment">    * obj 目标类的实例</span></span><br><span class="line"><span class="comment">    * method 目标类方法的反射对象</span></span><br><span class="line"><span class="comment">    * args 方法的动态入参</span></span><br><span class="line"><span class="comment">    * proxy 代理类实例</span></span><br><span class="line"><span class="comment">    * result 代理逻辑方法返回</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Objcet obj, Method method, Object[] args,</span></span></span><br><span class="line"><span class="function"><span class="params">        MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        PerformanceMonitor.begin(obj.getClass().getName() + <span class="string">"."</span> + method.getName());</span><br><span class="line">        <span class="comment">// CGLib反射调用父类中的方法</span></span><br><span class="line">        Objcet result = proxy.invokeSuper(obj, args);</span><br><span class="line">        PerformanceMonitor.end();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用户可以通过getProxy(Class cla)方法动态创建一个动态代理类。</p><h3 id="Cglib测试代码"><a href="#Cglib测试代码" class="headerlink" title="Cglib测试代码"></a>Cglib测试代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> org.testg.annotations.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForumServiceTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">proxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CglibProxy proxy = <span class="keyword">new</span> CglibProxy();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  通过动态生成子类的方式创建代理类</span></span><br><span class="line">        ForumServiceImpl forumService = (ForumServiceImpl) </span><br><span class="line">        proxy.getProxy(ForumServiceImpl.class);</span><br><span class="line"></span><br><span class="line">        forumService.removeForum(<span class="number">10</span>);</span><br><span class="line">        forumService.removeTopic(<span class="number">1024</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><h3 id="拦截器接口"><a href="#拦截器接口" class="headerlink" title="拦截器接口"></a>拦截器接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">before</span><span class="params">(Object proxy, Object target, Method method, Objcet[] args)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">around</span><span class="params">(Object proxy, Object target, Method method, Objcet[] args)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">after</span><span class="params">(Object proxy, Object target, Method method, Objcet[] args)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Interceptor实现类"><a href="#Interceptor实现类" class="headerlink" title="Interceptor实现类"></a>Interceptor实现类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">before</span><span class="params">(Object proxy, Object target, Method method, Objcet[] args)</span> </span>&#123;</span><br><span class="line">        System.err.println(<span class="string">"反射方法前逻辑"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">(Object proxy, Object target, Method method, Objcet[] args)</span> </span>&#123;</span><br><span class="line">        System.err.println(<span class="string">"反射方法后逻辑"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">around</span><span class="params">(Object proxy, Object target, Method method, Objcet[] args)</span> </span>&#123;</span><br><span class="line">        System.err.println(<span class="string">"取代了目标实例的方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在JDK动态代理中使用拦截器"><a href="#在JDK动态代理中使用拦截器" class="headerlink" title="在JDK动态代理中使用拦截器"></a>在JDK动态代理中使用拦截器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterceptorJdkProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 目标实例</span></span><br><span class="line">    <span class="keyword">private</span> Objcet target;</span><br><span class="line">    <span class="comment">// 拦截器全限定名</span></span><br><span class="line">    <span class="keyword">private</span> String interceptorClass = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InterceptorJdkProxy</span><span class="params">(Objcet target, String interceptorClass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">        <span class="keyword">this</span>.interceptorClass = interceptorClass;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">bind</span><span class="params">(Object target, String interceptorClass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">            target.getClass().getClassLoader(),</span><br><span class="line">            target.getClass().getInterfaces(),</span><br><span class="line">            <span class="keyword">new</span> InterceptorJdkProxy(target, interceptorClass));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, </span></span></span><br><span class="line"><span class="function"><span class="params">        Object[] args)</span>  <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (interceptorClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> method.invoke(target, args);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Object result = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        Interceptor inceptor = (Interceptor) </span><br><span class="line">            Class.forName(interceptorClass).newInstance();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (interceptor.before(proxy, target, method, args)) &#123;</span><br><span class="line">            result = method.invoke(target, args);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            inceptor.around(proxy, target, method, args);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        interceptor.after(proxy, target, method, args);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;JDK动态代理涉及java.lang.reflect包中的两个类，Proxy和InvocationHandler。Proxy利用InvocationHandler动态创建一个符合某一接口的实例，生成目标类的代理对象。InvocationHandler可以实现接口定义横切逻辑，并通过反射机制调用目标类的代码，动态地将横切逻辑和业务逻辑编织在一起。&lt;/p&gt;
    
    </summary>
    
      <category term="动态代理" scheme="https://www.blogs.rhsphere.com/categories/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    
    
      <category term="动态代理" scheme="https://www.blogs.rhsphere.com/tags/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer(31) 栈的压入、弹出序列</title>
    <link href="https://www.blogs.rhsphere.com/2019/08/03/stack-push-pop-order.html"/>
    <id>https://www.blogs.rhsphere.com/2019/08/03/stack-push-pop-order.html</id>
    <published>2019-08-03T12:46:22.000Z</published>
    <updated>2019-08-03T13:22:37.843Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><h2 id="栈的压入、弹出序列"><a href="#栈的压入、弹出序列" class="headerlink" title="栈的压入、弹出序列"></a>栈的压入、弹出序列</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1、2、3、4、5是某栈的压栈序列，序列4、5、3、2、1是该压栈序列对应的一个弹出序列，但4、3、5、1、2就不可能是该压栈序列的弹出序列。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>建立一个栈，按照压栈序列依次进行入栈操作，按出栈序列的顺序依次弹出数字。在出栈时，若下一个要出栈的数字与栈顶数字相同则弹出。如果压栈序列中的所有数字都入栈后没有完全出栈成功则代表两个序列不匹配，返回false。</p><h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><ol><li><p>功能测试（两个数组长度不同；两个数组对应；两个数组不对应）</p></li><li><p>特殊测试（数组为空；null；一个数字的数组）</p></li></ol><h2 id="java代码"><a href="#java代码" class="headerlink" title="java代码"></a>java代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: rhsphere</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>: 2019-08-03 21:06 by jdk 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackPushPopOrder</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPopOrder</span><span class="params">(<span class="keyword">int</span>[] pushA, <span class="keyword">int</span>[] popA)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (pushA == <span class="keyword">null</span> || popA == <span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">if</span> (pushA.length != popA.length || popA.length == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"><span class="keyword">int</span> popIndex = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> pushIndex = <span class="number">0</span>; pushIndex &lt; pushA.length; pushIndex++) &#123;</span><br><span class="line">stack.push(pushA[pushIndex]);</span><br><span class="line"><span class="keyword">while</span> (!stack.empty() &amp;&amp; stack.peek() == popA[popIndex]) &#123;</span><br><span class="line">stack.pop();</span><br><span class="line">popIndex++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> stack.empty();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] pushA = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] popA = &#123;<span class="number">4</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line">        StackPushPopOrder demo = <span class="keyword">new</span> StackPushPopOrder();</span><br><span class="line">        System.out.println(demo.isPopOrder(pushA, popA));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>弄清楚栈的出栈逻辑。</li></ol><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="剑指Offer" scheme="https://www.blogs.rhsphere.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="Stack" scheme="https://www.blogs.rhsphere.com/tags/Stack/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer(30) 包含min函数的栈</title>
    <link href="https://www.blogs.rhsphere.com/2019/08/03/stack-with-min.html"/>
    <id>https://www.blogs.rhsphere.com/2019/08/03/stack-with-min.html</id>
    <published>2019-08-03T12:31:42.000Z</published>
    <updated>2019-08-03T12:42:50.945Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><h2 id="包含min函数的栈"><a href="#包含min函数的栈" class="headerlink" title="包含min函数的栈"></a>包含min函数的栈</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>  定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的min函数。在该栈中，调用min、push及pop的时间复杂度都是O(1)。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>最初想法是定义一个成员变量min来存放最小元素，但是当最小元素弹出后，min就需要相应改变，所以必须把每次的最小值都存储下来。考虑采用一个辅助栈来存放最小值：</p><p>　　栈  3，4，2，5，1</p><p>　   辅助栈 3， 3，2，2，1<br>（压入时，把每次的最小元素（之前最小元素与新入栈元素的较小值）保存起来放到辅助栈中）</p><h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><ol><li>新压入数字更大</li><li>新压入数字最小</li><li>弹出数字最小</li><li>弹出数字不是最小</li></ol><h2 id="java代码"><a href="#java代码" class="headerlink" title="java代码"></a>java代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 剑指offer30</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: rhsphere</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>: 2019-08-03 20:35 by jdk 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackWithMin</span> </span>&#123;</span><br><span class="line">Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">Stack&lt;Integer&gt; aux = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">stack.push(node);</span><br><span class="line"><span class="keyword">if</span> (aux.empty() || aux.peek() &gt; node) &#123;</span><br><span class="line">aux.push(node);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">aux.push(stack.peek());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!stack.empty()) &#123;</span><br><span class="line">stack.pop();</span><br><span class="line">aux.pop();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> aux.peek();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>构造辅助栈用来装数据。</li></ol><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="剑指Offer" scheme="https://www.blogs.rhsphere.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="Stack" scheme="https://www.blogs.rhsphere.com/tags/Stack/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer(60) n个骰子的点数</title>
    <link href="https://www.blogs.rhsphere.com/2019/08/03/dices-probability.html"/>
    <id>https://www.blogs.rhsphere.com/2019/08/03/dices-probability.html</id>
    <published>2019-08-03T09:30:57.000Z</published>
    <updated>2019-08-03T09:35:28.979Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><h2 id="n个骰子的点数"><a href="#n个骰子的点数" class="headerlink" title="n个骰子的点数"></a>n个骰子的点数</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>对于n个骰子，要计算出每种点数和的概率，我们知道投掷n个骰子的总情况一共有6^n种，因此只需要计算出某点数和的情况一共有几种，即可求出该点数之和的概率。</p><p>　　方法一：基于递归的方法，效率较低</p><p>　　易知，点数之和s的最小值为n，最大值为6<em>n，因此我们考虑用一个大小为（6</em>n-n+1）的数组存放不同点数之和的情况个数，那么，如果点数之和为x，那么把它出现的情况总次数放入数组种下标为x-n的元素里。</p><p>　　确定如何存放不同点数之和的次数后，我们要计算出这些次数。我们把n个骰子分为1个骰子和n-1个骰子，这1</p><p>个骰子可能出现1~6个点数，由该骰子的点数与后面n-1个骰子的点数可以计算出总点数；而后面的n-1个骰子又可以分为1个和n-2个，把上次的点数，与现在这个骰子的点数相加，再和剩下的n-2个骰子的点数相加可以得到总点数……，即可以用递归实现。在获得最后一个骰子的点数后可以计算出几个骰子的总点数，令数组中该总点数的情况次数+1，即可结束遍历。</p><p>　　方法二：基于循环求骰子点数，时间性能好</p><p>　　用数组存放每种骰子点数和出现的次数。令数组中下标为n的元素存放点数和为n的次数。我们设置循环，每个循环多投掷一个骰子，假设某一轮循环中，我们已知了各种点数和出现的次数；在下一轮循环时，我们新投掷了一个骰子，那么此时点数和为n的情况出现的次数就等于上一轮点数和为n-1,n-2,n-3,n-4,n-5,n-6的情况出现次数的总和。从第一个骰子开始，循环n次，就可以求得第n个骰子时各种点数和出现的次数。</p><p>　　我们这里用两个数组来分别存放本轮循环与下一轮循环的各种点数和出现的次数，不断交替使用。</p><h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><ol><li><p>功能测试（1，2，3，4个骰子）</p></li><li><p>特殊测试（0个）</p></li><li><p>性能测试（11个）</p></li></ol><h2 id="java代码"><a href="#java代码" class="headerlink" title="java代码"></a>java代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.NumberFormat;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: rhsphere</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>: 2019-08-03 17:08 by jdk 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DicesProbability</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_VALUE = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法一：递归解法</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printProbability1</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (number &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] prob = <span class="keyword">new</span> <span class="keyword">int</span>[MAX_VALUE * number - number + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//下标为1，对应的值代表点数之和为i+number总共出现的情况次数</span></span><br><span class="line">        <span class="comment">//点数从 number ~ MAX_VALUE * number, 所以数组大小为6 * number - number + 1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prob.length; i++)</span><br><span class="line">            prob[i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= MAX_VALUE; i++)</span><br><span class="line">            calProb(prob, number, number - <span class="number">1</span>, i);  <span class="comment">//第一次掷筛子，总点数只能是1~6</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> totalProb = (<span class="keyword">int</span>) Math.pow(MAX_VALUE, number);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prob.length; i++) &#123;</span><br><span class="line">            <span class="keyword">double</span> ratio = (<span class="keyword">double</span>) prob[i] / totalProb;</span><br><span class="line">            NumberFormat format = NumberFormat.getPercentInstance();</span><br><span class="line">            format.setMaximumFractionDigits(<span class="number">2</span>);  <span class="comment">//设置保留几位小数</span></span><br><span class="line">            System.out.println(<span class="string">"点数和为"</span> + (i + number) + <span class="string">"的概率为："</span> + format.format(ratio));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算每种点数出现的次数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> number:骰子总个数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> curNumber:当前剩余骰子个数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sum:各个骰子加起来的总点数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">calProb</span><span class="params">(<span class="keyword">int</span>[] prob, <span class="keyword">int</span> number, <span class="keyword">int</span> curNumber, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (curNumber == <span class="number">0</span>) &#123;</span><br><span class="line">            prob[sum - number]++;   <span class="comment">//总数为sum的情况存放在sum-number下标中</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= MAX_VALUE; i++)</span><br><span class="line">            calProb(prob, number, curNumber-<span class="number">1</span>,sum+i);  <span class="comment">//相当于剩余的骰子少一个，总点数增加。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法二：基于循环求骰子点数，时间性能好</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printProbability2</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(number&lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;  <span class="comment">//错误</span></span><br><span class="line">        <span class="keyword">int</span>[][] probabilities = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][number*MAX_VALUE+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//[2]代表用两个数组交替保存，[number*maxValue+1]是指点数为所在下标时，该点数出现的总次数。</span></span><br><span class="line">        <span class="comment">//probabilities[*][0]是没用的，只是为了让下标对应点数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;number*MAX_VALUE;j++) &#123;</span><br><span class="line">                probabilities[i][j]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">6</span>;i++)</span><br><span class="line">            probabilities[<span class="number">0</span>][i]=<span class="number">1</span>;  <span class="comment">//第一个骰子出现的情况</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> curNumber=<span class="number">2</span>;curNumber&lt;=number;curNumber++) &#123;   <span class="comment">//当前是第几个骰子</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;curNumber;i++)</span><br><span class="line">                probabilities[<span class="number">1</span>-flag][i]=<span class="number">0</span>;  <span class="comment">//前面的数据清零</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=curNumber;i&lt;=curNumber*MAX_VALUE;i++) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">6</span> &amp;&amp; j&lt;=i ;j++) &#123;</span><br><span class="line">                    probabilities[<span class="number">1</span>-flag][i]+=probabilities[flag][i-j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            flag=<span class="number">1</span>-flag;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> totalP = (<span class="keyword">int</span>) Math.pow(MAX_VALUE, number);  <span class="comment">//所有情况总共出现的次数</span></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i=number;i&lt;= number*<span class="number">6</span>;i++) &#123;</span><br><span class="line">            <span class="keyword">double</span> ratio = (<span class="keyword">double</span>)probabilities[flag][i]/totalP;</span><br><span class="line">            NumberFormat format = NumberFormat.getPercentInstance();</span><br><span class="line">            format.setMaximumFractionDigits(<span class="number">8</span>);<span class="comment">//设置保留几位小数</span></span><br><span class="line">            System.out.println(<span class="string">"点数和为"</span>+(i+number)+<span class="string">"的概率为:"</span>+format.format(ratio));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"=========方法一============"</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">3</span>;i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"-----骰子数为"</span>+i+<span class="string">"时-----"</span>);</span><br><span class="line">            printProbability1(i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"-----骰子数为"</span>+<span class="number">11</span>+<span class="string">"时-----"</span>);</span><br><span class="line">        printProbability1(<span class="number">11</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"=========方法二============"</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">3</span>;i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"-----骰子数为"</span>+i+<span class="string">"时-----"</span>);</span><br><span class="line">            printProbability2(i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"-----骰子数为"</span>+<span class="number">11</span>+<span class="string">"时-----"</span>);</span><br><span class="line">        printProbability1(<span class="number">11</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>int类型相除，要得到double类型，需要提前将其中一个变成double类型</li></ol><p>　　　例如：double ratio = (double)probabilities[i]/totalP;</p><ol start="2"><li>输出百分数的方法，利用NumberFormat</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NumberFormat format = NumberFormat.getPercentInstance();</span><br><span class="line">format.setMaximumFractionDigits(<span class="number">8</span>);<span class="comment">//设置保留几位小数</span></span><br><span class="line">System.out.println(<span class="string">"点数和为"</span>+(i+number)+<span class="string">"的概率为:"</span>+format.format(ratio));</span><br></pre></td></tr></table></figure><ol start="3"><li><p>第二种方法，不是骰子点数的角度出发，而是从点数之和出发，点数之和有：f(n)=f(n-1)+……f(n-6)，非常巧妙。</p></li><li><p>用两个数组交替存放，学会使用变量flag，flag=1-flag。</p></li><li><p>代码中没有把骰子的最大点数硬编码为6，而是用变量maxValue来表示，具有可拓展性。以后自己编程时也要注意这些量是否可以不用硬编码，从而提高扩展性。</p></li><li><p>提高数学建模能力，不管采取哪种思路，都要先想到用数组来存放n个骰子的每个点数和出现的次数。</p></li></ol><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="剑指Offer" scheme="https://www.blogs.rhsphere.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
  </entry>
  
  <entry>
    <title>剑指Offer(59-2) 队列的最大值</title>
    <link href="https://www.blogs.rhsphere.com/2019/08/03/queue-with-max.html"/>
    <id>https://www.blogs.rhsphere.com/2019/08/03/queue-with-max.html</id>
    <published>2019-08-03T08:12:37.000Z</published>
    <updated>2019-08-03T09:03:19.365Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><h2 id="队列的最大值"><a href="#队列的最大值" class="headerlink" title="队列的最大值"></a>队列的最大值</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>请定义一个队列并实现函数max得到队列里的最大值，要求函数max、push_back和pop_front的时间复杂度都是O(1)。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>与滑动窗口的最大值一题相似，利用一个双端队列来存储当前队列里的最大值以及之后可能的最大值。</p><p>　　在定义题目要求功能的队列时，除了定义一个队列data存储数值，还需额外用一个队列maxmium存储可能的最大值；此外，还要定义一个数据结构，用于存放数据以及当前的index值，用于删除操作时确定是否删除maxmium中最大值。</p><p>　　</p><h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><p>　尾部插入不同大小数字，删除头部数字。插入删除同时获取最大值。</p><h2 id="java代码"><a href="#java代码" class="headerlink" title="java代码"></a>java代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: rhsphere</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>: 2019-08-03 16:52 by jdk 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueWithMax</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayDeque&lt;InternalData&gt; data = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> ArrayDeque&lt;InternalData&gt; maximum = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">InternalData</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> number;</span><br><span class="line">        <span class="keyword">int</span> index;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">InternalData</span><span class="params">(<span class="keyword">int</span> number, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.number = number;</span><br><span class="line">            <span class="keyword">this</span>.index = index;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> curIndex;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pushBack</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        InternalData curData = <span class="keyword">new</span> InternalData(number, curIndex);</span><br><span class="line">        data.addLast(curData);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!maximum.isEmpty() &amp;&amp; maximum.getLast().number &lt; number)</span><br><span class="line">            maximum.removeLast();</span><br><span class="line">        maximum.addLast(curData);</span><br><span class="line"></span><br><span class="line">        curIndex++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">popFront</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (data.isEmpty()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"队列为空，无法删除"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        InternalData curData = data.removeFirst();</span><br><span class="line">        <span class="keyword">if</span> (curData.index == maximum.getFirst().index)</span><br><span class="line">            maximum.removeFirst();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (maximum == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"队列为空，无法删除"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maximum.getFirst().number;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="剑指Offer" scheme="https://www.blogs.rhsphere.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="Deque" scheme="https://www.blogs.rhsphere.com/tags/Deque/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer(59-1) 滑动窗口的最大值</title>
    <link href="https://www.blogs.rhsphere.com/2019/08/03/max-in-window.html"/>
    <id>https://www.blogs.rhsphere.com/2019/08/03/max-in-window.html</id>
    <published>2019-08-03T03:44:01.000Z</published>
    <updated>2019-08-03T08:12:16.111Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><h2 id="滑动窗口的最大值"><a href="#滑动窗口的最大值" class="headerlink" title="滑动窗口的最大值"></a>滑动窗口的最大值</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个数组和滑动窗口的大小，请找出所有滑动窗口里的最大值。例如，如果输入数组{2, 3, 4, 2, 6, 2, 5, 1}及滑动窗口的大小3，那么一共存在6个滑动窗口，它们的最大值分别为{4, 4, 6, 6, 6, 5}</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>　蛮力直接在每个滑动窗口依次比较找出最大值，时间复杂度太高。</p><p>　　我们考虑把每个可能成为最大值的数字记录下来，就可以快速的得到最大值。</p><p>　　思路：建立一个两端开口的队列，放置所有可能是最大值的数字（存放的其实是对应的下标），且最大值位于队列开头。从头开始扫描数组，</p><p>　　如果遇到的数字比队列中所有的数字都大，那么它就是最大值，其它数字不可能是最大值了，将队列中的所有数字清空，放入该数字，该数字位于队列头部；</p><p>　　如果遇到的数字比队列中的所有数字都小，那么它还有可能成为之后滑动窗口的最大值，放入队列的末尾；</p><p>　　如果遇到的数字比队列中最大值小，最小值大，那么将比它小数字不可能成为最大值了，删除较小的数字，放入该数字。</p><p>　　由于滑动窗口有大小，因此，队列头部的数字如果其下标离滑动窗口末尾的距离大于窗口大小，那么也删除队列头部的数字。</p><p>　　注：队列中存放的是下标，以上讲的 队列头部的数字 均指 队列头部的下标所指向的数字。写代码时不要弄混了。</p><h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><ol><li><p>功能测试（数组数字递增、递减、无序）</p></li><li><p>边界值测试（滑动窗口大小位0、1、大于或者等于数组长度）</p></li><li><p>特殊输入测试（null）</p></li></ol><h2 id="java代码"><a href="#java代码" class="headerlink" title="java代码"></a>java代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: rhsphere</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>: 2019-08-03 11:47 by jdk 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxInWindow</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">maxInWindow</span><span class="params">(<span class="keyword">int</span>[] num, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">ArrayList&lt;Integer&gt; max = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (num == <span class="keyword">null</span> || num.length &lt;= <span class="number">0</span> || size &lt;= <span class="number">0</span> || size &gt; num.length)</span><br><span class="line"><span class="keyword">return</span> max;</span><br><span class="line"></span><br><span class="line">ArrayDeque&lt;Integer&gt; indexDeque = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size - <span class="number">1</span>; i++) &#123;</span><br><span class="line"><span class="keyword">while</span> (!indexDeque.isEmpty() &amp;&amp; num[i] &gt; num[indexDeque.getLast()])</span><br><span class="line">indexDeque.removeLast();</span><br><span class="line">indexDeque.addLast(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &lt; num.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line"><span class="keyword">while</span> (!indexDeque.isEmpty() &amp;&amp; num[i] &gt; num[indexDeque.getLast()])</span><br><span class="line">indexDeque.removeLast();</span><br><span class="line"><span class="keyword">if</span> (!indexDeque.isEmpty &amp;&amp; (i - indexDeque.getFirst()) &gt;= size)</span><br><span class="line">indexDeque.removeFirst();</span><br><span class="line"></span><br><span class="line">indexDeque.addLast(i);</span><br><span class="line">max.add(num[indexDeque.getFirst()]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>关于ArrayDeque 的方法总结：<br>待总结</li></ol><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="剑指Offer" scheme="https://www.blogs.rhsphere.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="Deque" scheme="https://www.blogs.rhsphere.com/tags/Deque/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer(58) 翻转字符串</title>
    <link href="https://www.blogs.rhsphere.com/2019/08/03/reverse-words.html"/>
    <id>https://www.blogs.rhsphere.com/2019/08/03/reverse-words.html</id>
    <published>2019-08-03T02:59:02.000Z</published>
    <updated>2019-08-03T08:12:07.552Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><h1 id="翻转单词顺序"><a href="#翻转单词顺序" class="headerlink" title="翻转单词顺序"></a>翻转单词顺序</h1><h2 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h2><p>输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串”I am a student. “，则输出”student. a am I”。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>一开始自己觉得要用split()方法，但这要开辟新的数组，占内存空间，不行。</p><p>　　首先实现翻转整个句子：只需要在首尾两端各放置一个指针，交换指针所指的数字，两端指针往中间移动即可。之后根据空格的位置，对每个单词使用同样的方法翻转即可。</p><h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><ol><li><p>功能测试（句子中有一个/多个单词，空格在开头、中间、结尾）</p></li><li><p>边界值测试（null，空字符串，句子全为空格）</p></li></ol><h2 id="java代码"><a href="#java代码" class="headerlink" title="java代码"></a>java代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: rhsphere</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>: 2019-08-03 10:53 by jdk 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReverseWordsInSentence</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">reverseSetence</span><span class="params">(<span class="keyword">char</span>[] chars)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (chars == <span class="keyword">null</span> || chars.length &lt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> String.valueOf(chars);</span><br><span class="line"></span><br><span class="line"><span class="comment">//翻转整个句子</span></span><br><span class="line">reverseSub(chars, <span class="number">0</span>, chars.length-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//翻转单词（指针指向单词的第一个和最后一个）</span></span><br><span class="line"><span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> end = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (start &lt; chars.length) &#123;</span><br><span class="line"><span class="keyword">while</span> (end &lt; chars.length &amp;&amp; chars[end] != <span class="string">' '</span>)</span><br><span class="line">end++;</span><br><span class="line">reverseSub(chars, start, end - <span class="number">1</span>);</span><br><span class="line">start = ++end;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> String.valueOf(chars);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverseSub</span><span class="params">(<span class="keyword">char</span>[] chars, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line"><span class="keyword">char</span> tmp = chars[start];</span><br><span class="line">chars[start] = chars[end];</span><br><span class="line">chars[end] = tmp;</span><br><span class="line">start++;</span><br><span class="line">end--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="左旋字符串"><a href="#左旋字符串" class="headerlink" title="左旋字符串"></a>左旋字符串</h1><h2 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h2><p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如输入字符串”abcdefg”和数字2，该函数将返回左旋转2位得到的结果”cdefgab”。</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>本题思路和上一道题翻转单词顺序的原理一模一样，只是上一道题有空格，这道题没空格，其实这道题还更简单。先分别翻转前半部分字符串和后半部分字符串，最后翻转整个字符串即可。</p><h3 id="测试用例-1"><a href="#测试用例-1" class="headerlink" title="测试用例"></a>测试用例</h3><ol><li><p>功能测试（对长度为n的字符串，左旋转-1,0,1,2,n-1,n,n+1位）</p></li><li><p>边界值测试（null）</p></li></ol><h2 id="java代码-1"><a href="#java代码-1" class="headerlink" title="java代码"></a>java代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: rhsphere</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>: 2019-08-03 11:33 by jdk 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeftRotateString</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">leftRotateString</span><span class="params">(<span class="keyword">char</span>[] chars, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (chars == <span class="keyword">null</span> || chars.length &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> String.valueOf(chars);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">0</span> || n &gt; chars.length)</span><br><span class="line">            <span class="keyword">return</span> String.valueOf(chars);</span><br><span class="line"></span><br><span class="line">        reverseSub(chars, <span class="number">0</span>, n-<span class="number">1</span>);</span><br><span class="line">        reverseSub(chars, n, chars.length - <span class="number">1</span>);</span><br><span class="line">        reverseSub(chars, <span class="number">0</span>, chars.length - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> String.valueOf(chars);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reverseSub</span><span class="params">(<span class="keyword">char</span>[] chars, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">            <span class="keyword">char</span> tmp = chars[start];</span><br><span class="line">            chars[start] = chars[end];</span><br><span class="line">            chars[end] = tmp;</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>这道题看似是移动字符，其实是翻转字符串实现的，要记住这类方法。</li></ol><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="剑指Offer" scheme="https://www.blogs.rhsphere.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="Two Pointers" scheme="https://www.blogs.rhsphere.com/tags/Two-Pointers/"/>
    
      <category term="String" scheme="https://www.blogs.rhsphere.com/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer(57) 和为s的数字</title>
    <link href="https://www.blogs.rhsphere.com/2019/08/03/two-number-with-sum.html"/>
    <id>https://www.blogs.rhsphere.com/2019/08/03/two-number-with-sum.html</id>
    <published>2019-08-03T01:51:32.000Z</published>
    <updated>2019-08-03T02:52:28.036Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><h1 id="和为s的两个数字"><a href="#和为s的两个数字" class="headerlink" title="和为s的两个数字"></a>和为s的两个数字</h1><h2 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h2><p>　　输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，输出任意一对即可。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>从头开始遍历数字，确定一个数字后，对后面的数字遍历，判断和是否为s，这种方法复杂度为O(n^2)，效率太低。</p><p>　　我们考虑到，如果一个数字比较小，那么另一个数字一定比较大，同时数字为递增排列；所以，我们设置两个指针，一个指针small从第一个数字（最小）出发，另一个指针big从最后一个数字（最大）出发：</p><p>　　当small加big的和小于s时，只需要将small指向后一个数字（更大），继续判断；</p><p>　　当small加big的和大于s时，只需要将big指向前一个数字（更小），继续判断；</p><p>　　当small加big的和等于s时，求解完成。</p><p>　　由于是从两边往中间移动，所以不会有跳过的情况，时间复杂度为O(n)。</p><h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><ol><li><p>功能测试（存在/不存在和为s的一对数字）</p></li><li><p>特殊输入测试（null）</p></li></ol><h2 id="java代码"><a href="#java代码" class="headerlink" title="java代码"></a>java代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: rhsphere</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>: 2019-08-03 09:54 by jdk 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoNumberWithSum</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">findNumberWithSum</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high = arr.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[low] + arr[high] == sum) &#123;</span><br><span class="line">                list.add(arr[low]);</span><br><span class="line">                list.add(arr[high]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;  <span class="keyword">else</span> <span class="keyword">if</span> (arr[low] + arr[high] &lt; sum) &#123;</span><br><span class="line">                low++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                high--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>利用两个指针从两端向中间扫描，要学会这种技巧。</li></ol><h1 id="和为s的连续正数序列"><a href="#和为s的连续正数序列" class="headerlink" title="和为s的连续正数序列"></a>和为s的连续正数序列</h1><h2 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h2><p>输入一个正数s，打印出所有和为s的连续正数序列（至少含有两个数）。例如输入15，由于1+2+3+4+5=4+5+6=7+8=15，所以结果打印出3个连续序列1～5、4～6和7～8。</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p><strong>指针法：</strong><br>类似(57-1) 和为s的两个数字的方法，用两个指针small和big分别代表序列的最大值和最小值。令small从1开始，big从2开始。</p><p>　　当从small到big的序列的和小于s时，增加big，使序列包含更多数字；（记得更新序列之和）</p><p>　　当从small到big的序列的和大于s时，增加small，使序列去掉较小的数字；（记得更新序列之和）</p><p>　　当从small到big的序列的和等于s时，此时得到一个满足题目要求的序列，输出，然后继续将small增大，往后面找新的序列。</p><p>　　序列最少两个数字，因此，当small到了s/2时，就可以结束判断了。</p><p><strong>数学分析法：</strong><br>　参考自牛客网，丁满历险记的答案。</p><p>　　对于一个长度为n的连续序列，如果它们的和等于s，有：</p><p>　　1）当n为奇数时，s/n恰好是连续序列最中间的数字，即n满足 (n&amp;1)==1 &amp;&amp; s%n==0</p><p>　　2）当n为偶数时，s/n恰好是连续序列中间两个数字的平均值，小数部分为0.5，即n满足 (s%n)*2==n （判断条件中包含了n为偶数的判断）</p><p>　　得到满足条件的n后，相当于得到了序列的中间数字s/n，所以可以得到第一个数字为 (s / n) - (n - 1) / 2，结合长度n可以得到所有数字。</p><p>　　此外，在什么范围内找n呢？我们知道n至少等于2，那至多等于多少？n最大时，序列从1开始，根据等差数列的求和公式根据等差数列的求和公式：S = (1 + n) * n / 2，可以得到n应该小于sqrt(2s)，所以只需要从n=2到sqrt(2s)来判断满足条件的n，继而输出序列。</p><h3 id="测试用例-1"><a href="#测试用例-1" class="headerlink" title="测试用例"></a>测试用例</h3><ol><li><p>功能测试（存在/不存在和为s的序列）</p></li><li><p>边界值测试（s=3）</p></li></ol><h2 id="java代码-1"><a href="#java代码-1" class="headerlink" title="java代码"></a>java代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: rhsphere</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>: 2019-08-03 10:09 by jdk 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContinuousSequenceWithSum</span> </span>&#123;</span><br><span class="line">    <span class="comment">//方法一：双指针法</span></span><br><span class="line"><span class="keyword">public</span> ArrrayList&lt;ArrayList&lt;Integer&gt;&gt; findContinuousSeq(<span class="keyword">int</span> sum) &#123;</span><br><span class="line">ArrayList&lt;ArrayList&lt;Integer&gt;&gt; seqList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sum &lt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> seqList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> small = <span class="number">1</span>; </span><br><span class="line"><span class="keyword">int</span> big =<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> curSum = small + big;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (small &lt;= sum/<span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (curSum == sum) &#123;</span><br><span class="line">ArrayList&lt;Integer&gt; seq = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = small; i &lt;= big; i++)</span><br><span class="line">seq.add(i);</span><br><span class="line">seqList.add(seq);</span><br><span class="line">curSum -= small;</span><br><span class="line">small++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (curSum &lt; sum) &#123;</span><br><span class="line">big++;</span><br><span class="line">curSum += big;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (curSum &gt; sum) &#123;</span><br><span class="line">curSum -= small;</span><br><span class="line">small--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> seqList;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ol><li><p>还是利用两个指针，这个技巧要学会</p></li><li><p>代码中求连续序列的和，并没有每次遍历计算，而是根据每次操作的情况而在之前的结果上进行加减，可以提高效率，值得学习</p></li><li><p>题目57-1) 和为s的两个数字中的指针是从两端开始，本题指针从1，2开始，注意指针的初始设置。</p></li><li><p>方法二中，当s/n的余数为0.5时，s%n的结果是n/2，而不是1。</p></li></ol><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="剑指Offer" scheme="https://www.blogs.rhsphere.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="Two Pointers" scheme="https://www.blogs.rhsphere.com/tags/Two-Pointers/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer(56) 数组中数字出现的次数</title>
    <link href="https://www.blogs.rhsphere.com/2019/08/02/number-appear-once.html"/>
    <id>https://www.blogs.rhsphere.com/2019/08/02/number-appear-once.html</id>
    <published>2019-08-02T12:40:53.000Z</published>
    <updated>2019-08-02T14:03:23.896Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><h1 id="数组中数字出现的次数"><a href="#数组中数字出现的次数" class="headerlink" title="数组中数字出现的次数"></a>数组中数字出现的次数</h1><p>题目一：数组中只出现一次的两个数字 </p><h2 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h2><p>一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>　记住：两个相同的数字异或等于0.</p><p>　　如果数组中只有一个数字只出现一次，我们从头到尾异或每个数字，那么最终的结果刚好是那个只出现一次的数字。</p><p>　　而本题里数组中有两个数字只出现一次，如果能够将数组分为两部分，两部分中都只有一个数字只出现一次，那么就可以解决该问题了。</p><p>　　求解方法：</p><p>　　我们依旧从头到尾异或每个数字，那么最终的结果就是这两个只出现一次的数字的异或结果，由于两个数不同，因此这个结果数字中一定有一位为1，把结果中第一个1的位置记为第n位。因为是两个只出现一次的数字的异或结果，所以这两个数字在第n位上的数字一定是1和0。</p><p>　　 接下来我们根据数组中每个数字的第n位上的数字是否为1来进行分组，恰好能将数组分为两个都只有一个数字只出现一次的数组，对两个数组从头到尾异或，就可以得到这两个数了。</p><h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><ol><li>功能测试（数组中有多对重复的数字；无重复的数字）</li></ol><h2 id="java代码"><a href="#java代码" class="headerlink" title="java代码"></a>java代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: rhsphere</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>: 2019-08-02 20:55 by jdk 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumbersAppearOnce</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findNumsAppearOnce</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span>[] num1, <span class="keyword">int</span>[] num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)</span><br><span class="line">        res ^= arr[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> indexOf1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (((res &amp; <span class="number">1</span>) == <span class="number">0</span>) &amp;&amp; (indexOf1 &lt;= <span class="number">32</span>)) &#123;</span><br><span class="line">        res = res &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        indexOf1++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        num1[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        num2[<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (((arr[i] &gt;&gt; indexOf1) &amp; <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">        num1[<span class="number">0</span>] ^= arr[i];</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        num2[<span class="number">0</span>] ^= arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><p>当一个数字出现两次（或者偶数次）时，用异或^ 可以进行消除。一定要牢记 异或的这个功能！</p></li><li><p>将一组数字分为两组，可以根据某位上是否为1来进行分组，即根据和1相与（&amp;1）的结果来进行分组。</p></li><li><p>判断某个数x的第n位（如第3位）上是否为1，</p></li></ol><p>　　　　1）通过 x&amp;00000100 的结果是否为0 来判断。（不能根据是否等于1来判断）</p><p>　　　　2）通过（x&gt;&gt;3)&amp;1 是否为0 来判断</p><ol start="4"><li>将某个数x右移m位，一定要写成 x=x&gt;&gt;m；而不能只写成 x&gt;&gt;m；这个语句</li></ol><h1 id="数组中唯一只出现一次的数字"><a href="#数组中唯一只出现一次的数字" class="headerlink" title="数组中唯一只出现一次的数字"></a>数组中唯一只出现一次的数字</h1><h2 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h2><p>在一个数组中除了一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>　这道题中数字出现了三次，无法像56-1) 数组中只出现一次的两个数字一样通过利用异或位运算进行消除相同个数字。但是仍然可以沿用位运算的思路。</p><p>　　将所有数字的二进制表示的对应位都加起来，如果某一位能被三整除，那么只出现一次的数字在该位为0；反之，为1。</p><h3 id="测试用例-1"><a href="#测试用例-1" class="headerlink" title="测试用例"></a>测试用例</h3><ol><li>功能测试（唯一出现的数字是0，正数，负数；重复出现的数字是0，正数，负数）</li></ol><h2 id="java代码-1"><a href="#java代码-1" class="headerlink" title="java代码"></a>java代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: rhsphere</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>: 2019-08-02 21:51 by jdk 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumberAppear</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findNumsAppearOnce</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line"><span class="keyword">int</span>[] bitSum = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">32</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++)</span><br><span class="line">bitSum[i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> bitMask = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">31</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line"><span class="keyword">int</span> bit = arr[i] &amp; bitMask;</span><br><span class="line"><span class="keyword">for</span> (bit != <span class="number">0</span>)</span><br><span class="line">bitSum[i] += <span class="number">1</span>;</span><br><span class="line">bitMask = bitMask &lt;&lt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">res = res &lt;&lt; <span class="number">1</span>;</span><br><span class="line">res += (bitSum[i] % <span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ol><li>判断某个数x的第n位（如第3位）上是否为1，</li></ol><p>　　　　1）通过 x&amp;00000100 的结果是否为0 来判断。（不能根据是否等于1来判断）</p><p>　　　　2）通过（x&gt;&gt;3)&amp;1 是否为0 来判断</p><ol start="2"><li>通过number&amp;bitMask的结果是否为0（不能用1判断），bitMask=1不断左移，可以将一个数的二进制存储到32位的数组中。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> number = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> bitMask = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">31</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">    <span class="keyword">int</span> bit = number &amp; bitMask;  <span class="comment">//注意arr[i]&amp;bitMask不一定等于1或者0，有可能等于00010000</span></span><br><span class="line">    <span class="keyword">if</span>(bit != <span class="number">0</span>)</span><br><span class="line">        bits[j] =<span class="number">1</span>;</span><br><span class="line">    bitMask = bitMask &lt;&lt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>通过以下代码实现二进制转化为数字（注意左移语句的位置）：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">    result = result &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    result += bits[i];</span><br><span class="line">    <span class="comment">//result=result&lt;&lt;1;  //不能放在后面，否则最前面一位就没了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="剑指Offer" scheme="https://www.blogs.rhsphere.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="Array" scheme="https://www.blogs.rhsphere.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer(55) 二叉树的深度</title>
    <link href="https://www.blogs.rhsphere.com/2019/08/02/tree-depth.html"/>
    <id>https://www.blogs.rhsphere.com/2019/08/02/tree-depth.html</id>
    <published>2019-08-02T11:29:45.000Z</published>
    <updated>2019-08-02T12:37:27.025Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><h1 id="二叉树的深度"><a href="#二叉树的深度" class="headerlink" title="二叉树的深度"></a>二叉树的深度</h1><p>题目一：二叉树的深度<br>题目二：平衡二叉树</p><h2 id="二叉树的深度-1"><a href="#二叉树的深度-1" class="headerlink" title="二叉树的深度"></a>二叉树的深度</h2><p>输入一棵二叉树的根结点，求该树的深度。从根结点到叶结点依次经过的/结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>简洁理解：</p><p>　　树的深度=max(左子树深度，右子树深度)+1，采用递归实现。</p><h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><ol><li><p>功能测试（左斜树、右斜树、普通树）</p></li><li><p>边界值测试（一个结点）</p></li><li><p>特殊测试（null）</p></li></ol><h2 id="java代码"><a href="#java代码" class="headerlink" title="java代码"></a>java代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 剑指offer55</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: rhsphere</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>: 2019-08-02 19:29 by jdk 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeDepth</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">        TreeNode left, right;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">treeDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left = treeDepth(root.left);</span><br><span class="line">    <span class="keyword">int</span> right = treeDepth(root.right);</span><br><span class="line">    <span class="keyword">return</span> Math.max(left + <span class="number">1</span>, right + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>深度从递归的角度理解，很赞，要记住。</li></ol><h1 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h1><h2 id="平衡二叉树判定"><a href="#平衡二叉树判定" class="headerlink" title="平衡二叉树判定"></a>平衡二叉树判定</h2><p>输入一棵二叉树的根结点，判断该树是不是平衡二叉树。如果某二叉树中任意结点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>　在(55-1) 二叉树的深度基础上修改：计算树的深度，树的深度=max(左子树深度，右子树深度)+1。在遍历过程中，判断左右子树深度相差是否超过1，如果不平衡，则令树的深度=-1，用来表示树不平衡。最终根据树的深度是否等于-1来确定是否为平衡树。</p><h3 id="测试用例-1"><a href="#测试用例-1" class="headerlink" title="测试用例"></a>测试用例</h3><ol><li><p>功能测试（左斜树、右斜树、平衡或者不平衡树）</p></li><li><p>特殊测试（一个结点，null）</p></li></ol><h2 id="java代码-1"><a href="#java代码-1" class="headerlink" title="java代码"></a>java代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: rhsphere</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>: 2019-08-02 20:29 by jdk 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BanlancedBST</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">        TreeNode left, right;</span><br><span class="line">        TreeNode (<span class="keyword">int</span> val) &#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IntBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getDepth(root) != -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left = getDepth(root.left);</span><br><span class="line">    <span class="keyword">if</span> (left == -<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> right = getDepth(root.right);</span><br><span class="line">    <span class="keyword">if</span> (right == -<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Math.abs(left - right) &gt; <span class="number">1</span> ? -<span class="number">1</span> : Math.max(left, right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ol><li>在判断出树不平衡后，进行剪枝（即代码中直接返回-1，不再对其他子树进行判断），以提高效率。</li></ol><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="剑指Offer" scheme="https://www.blogs.rhsphere.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="Tree" scheme="https://www.blogs.rhsphere.com/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer(54) 二叉搜索树的第k大节点</title>
    <link href="https://www.blogs.rhsphere.com/2019/08/02/kth-node-in-BST.html"/>
    <id>https://www.blogs.rhsphere.com/2019/08/02/kth-node-in-BST.html</id>
    <published>2019-08-02T06:39:59.000Z</published>
    <updated>2019-08-02T11:26:11.343Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><h2 id="二叉搜索树的第K大节点"><a href="#二叉搜索树的第K大节点" class="headerlink" title="二叉搜索树的第K大节点"></a>二叉搜索树的第K大节点</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一棵二叉搜索树，请找出其中的第k小的结点。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>设置全局变量index=0，对BST进行中序遍历，每遍历一个结点，index+1，当index=k时，该结点即为所求结点。</p><h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><ol><li><p>功能测试（左斜树、右斜树、普通树）</p></li><li><p>边界值测试（k=1,k=结点数目）</p></li><li><p>特殊测试（null，k&lt;=0，k&gt;结点数目）</p></li></ol><h2 id="java代码"><a href="#java代码" class="headerlink" title="java代码"></a>java代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: rhsphere</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>: 2019-08-02 14:42 by jdk 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KthNodeInBST</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">        TreeNode left, right;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">kthNode</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    TreeNode p = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span> || k &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">    p = getKthNode(root, k);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">getKthNode</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    TreeNode kthNode = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root.left != <span class="keyword">null</span>)</span><br><span class="line">    kthNode = getKthNode(root.left, k);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(kthNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">    index++;</span><br><span class="line">    <span class="keyword">if</span> (k == index)</span><br><span class="line">    kthNode = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (kthNode == <span class="keyword">null</span> &amp;&amp; root.right != <span class="keyword">null</span>)</span><br><span class="line">    kthNode = getKthNode(root.right, k);</span><br><span class="line"></span><br><span class="line">    reurn kthNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><p>熟练掌握二叉搜索树和中序遍历。</p></li><li><p>用中序遍历实现功能时，一定要注意返回值是否满足要求。</p></li></ol><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="剑指Offer" scheme="https://www.blogs.rhsphere.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="BST" scheme="https://www.blogs.rhsphere.com/tags/BST/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer(53-3) 数组中数值和下标相等的元素</title>
    <link href="https://www.blogs.rhsphere.com/2019/08/02/get-number-same-as-index.html"/>
    <id>https://www.blogs.rhsphere.com/2019/08/02/get-number-same-as-index.html</id>
    <published>2019-08-02T06:30:13.000Z</published>
    <updated>2019-08-02T06:38:06.500Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><h2 id="数组中数值和下标相等的元素"><a href="#数组中数值和下标相等的元素" class="headerlink" title="数组中数值和下标相等的元素"></a>数组中数值和下标相等的元素</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>假设一个单调递增的数组里的每个元素都是整数并且是唯一的。请编程实现一个函数找出数组中任意一个数值等于其下标的元素。例如，在数组{-3, -1,1, 3, 5}中，数字3和它的下标相等。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>　同53-1和53-2一样，不再从头到尾遍历，由于是排序数组，我们继续考虑使用二分查找算法：</p><p>　　  1）当中间数字等于其下标时，中间数字即为所求数字；</p><p>　　  2）当中间数字大于其下标时，在左半部分区域寻找；</p><p>　　  2）当中间数字小于其下标时，在右半部分区域寻找；</p><h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><ol><li><p>功能测试（包含/不包含与下标相等的数字）</p></li><li><p>边界值测试（数字位于数组开头、中间或者结尾；仅一个数字数组）</p></li><li><p>特殊测试（null）</p></li></ol><h2 id="java代码"><a href="#java代码" class="headerlink" title="java代码"></a>java代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: rhsphere</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>: 2019-08-02 14:33 by jdk 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerIdenticalToIndex</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumberSameAsIndex</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> high = arr.length - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (arr[mid] &gt; mid) &#123;</span><br><span class="line">high = mid - <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &lt; mid) &#123;</span><br><span class="line">low = mid +１;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="剑指Offer" scheme="https://www.blogs.rhsphere.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="Array" scheme="https://www.blogs.rhsphere.com/tags/Array/"/>
    
      <category term="BinarySearch" scheme="https://www.blogs.rhsphere.com/tags/BinarySearch/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer(53-2) 0到n-1中缺失的数字</title>
    <link href="https://www.blogs.rhsphere.com/2019/08/02/missing-number.html"/>
    <id>https://www.blogs.rhsphere.com/2019/08/02/missing-number.html</id>
    <published>2019-08-02T03:17:47.000Z</published>
    <updated>2019-08-02T03:31:26.922Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><h2 id="0-n-1中缺失的数字"><a href="#0-n-1中缺失的数字" class="headerlink" title="0 ~ n-1中缺失的数字"></a>0 ~ n-1中缺失的数字</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0到n-1之内。在范围0到n-1的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>　如果从头到尾依次比较值与小标是否相等，时间复杂度为O(n)，效率低。</p><p>　　由于是排序数组，我们继续考虑使用二分查找算法，结合上图可知：</p><p>　　　　当中间数字等于其下标时，我们在后半部分查找；</p><p>　　　　当中间数字不等于其下标时，</p><p>　　　　1）如果中间数字的前一个数字也不等于其下标，则在前半部分查找；</p><p>　　　　2）如果中间数字的前一个数字等于其下标，则说明中间数字的下标即为我们所要找的数字。</p><h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><ol><li><p>功能测试（缺失数字位于数组开头、中间或者结尾）</p></li><li><p>边界值测试（数字只有0或1）</p></li><li><p>特殊测试（null）</p></li></ol><h2 id="java代码"><a href="#java代码" class="headerlink" title="java代码"></a>java代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: rhsphere</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>: 2019-08-02 11:21 by jdk 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MissingNumber</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMissingNum</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr.length &lt;= <span class="number">0</span> || arr == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high = arr.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (low + high) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (arr[mid] != mid) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mid == <span class="number">0</span> || arr[mid -<span class="number">1</span>] == mid - <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">return</span> mid;</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="剑指Offer" scheme="https://www.blogs.rhsphere.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="Array" scheme="https://www.blogs.rhsphere.com/tags/Array/"/>
    
      <category term="BinarySearch" scheme="https://www.blogs.rhsphere.com/tags/BinarySearch/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer(53-1) 数字在排序数组中出现的次数</title>
    <link href="https://www.blogs.rhsphere.com/2019/08/02/number-of-k.html"/>
    <id>https://www.blogs.rhsphere.com/2019/08/02/number-of-k.html</id>
    <published>2019-08-02T01:20:17.000Z</published>
    <updated>2019-08-02T03:17:10.370Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><h2 id="数字在排序数组中出现的次数"><a href="#数字在排序数组中出现的次数" class="headerlink" title="数字在排序数组中出现的次数"></a>数字在排序数组中出现的次数</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>统计一个数字在排序数组中出现的次数。例如输入排序数组{1, 2, 3, 3,3, 3, 4, 5}和数字3，由于3在这个数组中出现了4次，因此输出4。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><a href="https://blogs.rhsphere.com/leetcode/2019/04/15/binary-search.html" target="_blank" rel="noopener">二分查找的一种变型</a></p><p>分析：对于例子来说，如果采用二分法找到某一个3后，再往前遍历和往后遍历到第一个和最后一个3，在长度为n的数组中有可能出现O(n)个3，因此这样的扫描方法时间复杂度为O(n)，效率与从头到尾扫描一样，速度太慢。</p><p>　　这题关键是找到第一个和最后一个3，因此我们尝试改进二分法：中间数字比3大或者小的情况与之前类似，关键是中间数字等于3的情况，这时可以分类讨论如下：</p><p>　　1）如果中间数字的前一个数字也等于3，说明第一个3在前面，继续在前半段查找第一个3；</p><p>　　2）如果中间数字的前一个数字不等于3，说明该位置是第一个3；</p><p>　　3）如果中间数字的后一个数字也等于3，说明最后一个3在后面，继续在后半段查找最后一个3；</p><p>　　2）如果中间数字的后一个数字不等于3，说明该位置是最后一个3；</p><h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><ol><li><p>功能测试（数字出现次数为0、1、2等）</p></li><li><p>边界值测试（数组只有一个数字，查找数字为第一个或者最后一个）</p></li><li><p>特殊测试（null）</p></li></ol><h2 id="java代码"><a href="#java代码" class="headerlink" title="java代码"></a>java代码</h2><h3 id="用二分法的变型"><a href="#用二分法的变型" class="headerlink" title="用二分法的变型"></a>用二分法的变型</h3><p>非递归写法，可以参考文章<a href="https://blogs.rhsphere.com/leetcode/2019/04/15/binary-search.html" target="_blank" rel="noopener">二分查找的一种变型</a>中查找第一个与key相等的元素、查找最后一个与key相等的元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 剑指offer53-1（1）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: rhsphere</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>: 2019-08-02 09:51 by jdk 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumberOfK2</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumberOfK</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> firstK = getFirstEqual(arr, <span class="number">0</span>, arr.length-<span class="number">1</span>, k);</span><br><span class="line"><span class="keyword">if</span> (first == -<span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//这个firstK作为getLastEqual参数有点亮</span></span><br><span class="line"><span class="keyword">int</span> lastK = getLastEqual(arr, firstK, arr.length-<span class="number">1</span>, k);</span><br><span class="line"><span class="keyword">return</span> lastK - firstK + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getFirstEqual</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (arr[mid] &gt;= key) &#123;</span><br><span class="line">right = mid - <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">left = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (left &lt; arr.length &amp;&amp; arr[left] == key)</span><br><span class="line"><span class="keyword">return</span> left;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getLastEqual</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (arr[mid] &lt;= key) &#123;</span><br><span class="line">left = mid + <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">right = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (right &gt;= <span class="number">0</span> &amp;&amp; arr[right] == key)</span><br><span class="line"><span class="keyword">return</span> right;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="递归写法"><a href="#递归写法" class="headerlink" title="递归写法"></a>递归写法</h3><p>剑指offer上的写法，不够简洁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 剑指offer53-1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: rhsphere</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>: 2019-08-02 09:19 by jdk 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumberOfK</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumberOfK</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> firstK = getFirstK(arr, <span class="number">0</span>, arr.length-<span class="number">1</span>, k);</span><br><span class="line"><span class="keyword">if</span> (firstK == -<span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> lastK = getLastK(arr, firstK, arr.length-<span class="number">1</span>, k);</span><br><span class="line"><span class="keyword">return</span> lastK - firstK + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getFirstK</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (left &gt; right)</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (arr[mid] == k) &#123;</span><br><span class="line"><span class="keyword">if</span> (mid == <span class="number">0</span> || arr[mid-<span class="number">1</span>] != k)</span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">right = mid - <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &lt; k) &#123;</span><br><span class="line">left = mid + <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">right = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> getFirstK(arr, left, right, k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getLastK</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (left &gt; right)</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (arr[mid] == k) &#123;</span><br><span class="line"><span class="keyword">if</span> (mid == arr.length - <span class="number">1</span> || arr[mid+<span class="number">1</span>] != k)</span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">left = mid + <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &lt; k) &#123;</span><br><span class="line">left = mid + <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">right = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> getLastK(arr, left, right, k);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="剑指Offer" scheme="https://www.blogs.rhsphere.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="Array" scheme="https://www.blogs.rhsphere.com/tags/Array/"/>
    
      <category term="BinarySearch" scheme="https://www.blogs.rhsphere.com/tags/BinarySearch/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer(52) 两个链表的第一个公共节点</title>
    <link href="https://www.blogs.rhsphere.com/2019/08/01/first-common-node-in-lists.html"/>
    <id>https://www.blogs.rhsphere.com/2019/08/01/first-common-node-in-lists.html</id>
    <published>2019-08-01T13:22:47.000Z</published>
    <updated>2019-08-01T13:55:04.039Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><h2 id="两个链表的第一个公共节点"><a href="#两个链表的第一个公共节点" class="headerlink" title="两个链表的第一个公共节点"></a>两个链表的第一个公共节点</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入两个链表，找出它们的第一个公共结点。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>蛮力法：遍历第一个链表的结点，每到一个结点，就在第二个链表上遍历每个结点，判断是否相等。时间复杂度为O(m*n)，效率低；</p><p>　　使用栈：由于公共结点出现在尾部，所以用两个栈分别放入两个链表中的结点，从尾结点开始出栈比较。时间复杂度O(m+n)，空间复杂度O(m+n)。</p><p>　　利用长度关系：计算两个链表的长度之差，长链表先走相差的步数，之后长短链表同时遍历，找到的第一个相同的结点就是第一个公共结点。</p><p>　　利用两个指针：一个指针顺序遍历list1和list2，另一个指针顺序遍历list2和list1，（这样两指针能够保证最终同时走到尾结点），两个指针找到的第一个相同结点就是第一个公共结点。</p><h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><ol><li><p>功能测试（有/无公共结点；公共结点分别在链表的中间，头结点和尾结点）</p></li><li><p>特殊测试（头结点为null）</p></li></ol><h2 id="java代码"><a href="#java代码" class="headerlink" title="java代码"></a>java代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 剑指offer52</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: rhsphere</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>: 2019-08-01 21:09 by jdk 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstCommonNodesInLists</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        ListNode next = <span class="keyword">null</span>;</span><br><span class="line">        ListNode(<span class="keyword">int</span> val) &#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//方法1：利用长度关系</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">findFirstCommonNode1</span><span class="params">(ListNode list1, ListNode list2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len1 = getLength(list1);</span><br><span class="line">    <span class="keyword">int</span> len2 = getLength(list2);</span><br><span class="line">    <span class="keyword">int</span> lenDiff = len1 - len2;</span><br><span class="line">    ListNode longList = list1;</span><br><span class="line">    ListNode shortList = list2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lenDiff &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    longList =list2;</span><br><span class="line">    shortList = list1;</span><br><span class="line">    lenDiff = - lenDiff;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lenDiff; i++)</span><br><span class="line">    longList = longList.next;</span><br><span class="line">    <span class="keyword">while</span> (longList != <span class="keyword">null</span> &amp;&amp; longList != shortList) &#123;</span><br><span class="line">    longList = longList.next;</span><br><span class="line">    shortList =shortList.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> longList;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">(ListNode list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (list != <span class="keyword">null</span>) &#123;</span><br><span class="line">    len++;</span><br><span class="line">    list = list.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法2：两个指针，p1顺序遍历list1和list2，p2顺序遍历list2和list1；最终一定会相遇</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">findFirstCommonNode2</span><span class="params">(ListNode list1, ListNode list2)</span> </span>&#123;</span><br><span class="line">    ListNode p = list1;</span><br><span class="line">    ListNode q = list2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p != q) &#123;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span>) p = p.next;</span><br><span class="line">    <span class="keyword">if</span> (q != <span class="keyword">null</span>) q = q.next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p != q) &#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="keyword">null</span>) p = list2;</span><br><span class="line">    <span class="keyword">if</span> (q == <span class="keyword">null</span>) q = list1;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1.由于有共同结点时，后面的链表是重合的，所以这道题关键是要保证最后同时遍历到达尾结点，因此就有了后面三种方法：</p><p>　　利用栈的先进后出实现同时到达；</p><p>　　利用长度关系，长链表先行几步，实现同时到达；</p><p>　　两个指针同时遍历两个链表，一个先list1后list2，另一个则相反，也可以实现同时到达。</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="剑指Offer" scheme="https://www.blogs.rhsphere.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="LinkedList" scheme="https://www.blogs.rhsphere.com/tags/LinkedList/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer(51) 数组中逆序对</title>
    <link href="https://www.blogs.rhsphere.com/2019/08/01/inverse-pairs.html"/>
    <id>https://www.blogs.rhsphere.com/2019/08/01/inverse-pairs.html</id>
    <published>2019-08-01T12:05:59.000Z</published>
    <updated>2019-08-01T13:08:23.063Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><h2 id="数组中的逆序对"><a href="#数组中的逆序对" class="headerlink" title="数组中的逆序对"></a>数组中的逆序对</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>在数组中的两个数字如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>如果遍历数组，对每个数字都和后面的数字比较大小，时间复杂度为O(n^2)，效率太低。</p><p>　　利用归并排序的思想，先将数组分解成为n个长度为1的子数组，然后进行两两合并同时排好顺序。</p><p>　　在对两个子区域合并排序时，记左边区域（下标为start~mid）的指针为i，右边区域（下标为mid+1~end）的指针为j，两个指针都指向该区域内最大的数字，排序时：</p><p>　　（1）如果i指向的数字大于j指向的数字，说明：逆序对有j-mid个，我们把i指向的数字放入临时创建的排序数组中，然后令i-1，指向该区域前一个数字，继续进行排序；</p><p>　　（2）如果i指向的数字小于等于j指向的数字，说明暂时不存在逆序对，将j指向的数字放入临时创建的排序数组中，然后令j-1，指向该区域前一个数字，继续进行排序；</p><p>　　（3）某一子区域数字都放入排序数组后，将另一个子区域剩下的数字放入排序数组中，完成排序；</p><p>　　（4）最后将排序好的数字按顺序赋值给原始数组的两个子区域，以便合并后的区域与别的区域合并。</p><h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><ol><li><p>功能测试（普通数组，递增数组，递减数组，含重复数字）</p></li><li><p>边界值测试（数组只有两个数字，只有一个数字）</p></li><li><p>特殊测试（null）</p></li></ol><h2 id="java代码"><a href="#java代码" class="headerlink" title="java代码"></a>java代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 剑指offer51</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: rhsphere</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>: 2019-08-01 20:05 by jdk 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InversePairs</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">inversePairs</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> count = getCount(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (start &gt;= end)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mid = start + ((end - start) &gt;&gt; <span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> left = getCount(arr, start, mid);</span><br><span class="line"><span class="keyword">int</span> right = getCount(arr, mid+<span class="number">1</span>, end);</span><br><span class="line"></span><br><span class="line"><span class="comment">//合并</span></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> i = mid;<span class="comment">//左边区域的指针</span></span><br><span class="line"><span class="keyword">int</span> j = end;<span class="comment">//右边区域的指针</span></span><br><span class="line"><span class="keyword">int</span>[] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[end - start + <span class="number">1</span>];<span class="comment">//临时区域</span></span><br><span class="line"><span class="keyword">int</span> k = end - start;<span class="comment">//临时区域的指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (i &gt;= start &amp;&amp; j &gt;= mid + <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr[i] &gt; arr[j]) &#123;</span><br><span class="line">count += (j - mid);</span><br><span class="line">tmp[k--] = arr[i--];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">tmp[k--] = arr[j--];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下面两句while 不要忘记里面的等号</span></span><br><span class="line"><span class="keyword">while</span> (i &gt;= start)</span><br><span class="line">tmp[k--] = arr[i--];</span><br><span class="line"><span class="keyword">while</span> (j &gt;= mid + <span class="number">1</span>)</span><br><span class="line">tmp[k--] = arr[j--];</span><br><span class="line"></span><br><span class="line"><span class="comment">// k + start 不是很理解</span></span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; tmp.length; k++)</span><br><span class="line">arr[k + start] = tmp[k];</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> count + left + right;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>归并排序的变形，递归的熟练使用。</li></ol><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="剑指Offer" scheme="https://www.blogs.rhsphere.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="Array" scheme="https://www.blogs.rhsphere.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer(50) 第一个只出现一次的字符</title>
    <link href="https://www.blogs.rhsphere.com/2019/07/30/%E5%89%91%E6%8C%87Offer-50-%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6.html"/>
    <id>https://www.blogs.rhsphere.com/2019/07/30/剑指Offer-50-第一个只出现一次的字符.html</id>
    <published>2019-07-30T15:08:07.000Z</published>
    <updated>2019-08-01T11:28:45.697Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><h1 id="字符串中第一个只出现一次的字符"><a href="#字符串中第一个只出现一次的字符" class="headerlink" title="字符串中第一个只出现一次的字符"></a>字符串中第一个只出现一次的字符</h1><h2 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h2><p>在字符串中找出第一个只出现一次的字符。如输入”abaccdeff”，则输出’b’。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>创建哈希表，键值key为字符，值value为出现次数。第一遍扫描：对每个扫描到的字符的次数加一；第二遍扫描：对每个扫描到的字符通过哈希表查询次数，第一个次数为1的字符即为符合要求的输出。</p><p>　　由于字符（char）是长度为8的数据类型，共有256中可能，因此哈希表可以用一个长度为256的数组来代替，数组的下标相当于键值key，对应字符的ASCII码值；数组的值相当于哈希表的值value，用于存放对应字符出现的次数。</p><h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><ol><li><p>功能测试（存在/不存在只出现一次的字符；全部都为只出现一次的字符）</p></li><li><p>特殊测试（null）</p></li></ol><h2 id="java代码"><a href="#java代码" class="headerlink" title="java代码"></a>java代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: rhsphere</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>: 2019-07-31 08:00 by jdk 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstNotRepeatingChar</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">firstNotRepeatingChar</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (str == <span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="string">'\0'</span>;</span><br><span class="line"><span class="keyword">int</span>[] rep = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)</span><br><span class="line">rep[i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line"><span class="keyword">int</span> loc = (<span class="keyword">int</span>) str.charAt(i);</span><br><span class="line">rep[loc] += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line"><span class="keyword">int</span> loc = (<span class="keyword">int</span>) str.charAt(i);</span><br><span class="line"><span class="keyword">if</span> (rep[loc] == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">char</span>) loc;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="string">'\0'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FirstNotRepeatingChar demo =<span class="keyword">new</span> FirstNotRepeatingChar();</span><br><span class="line">        System.out.println((demo.firstNotRepeatingChar(<span class="string">"google"</span>)==<span class="string">'l'</span>));</span><br><span class="line">        System.out.println((demo.firstNotRepeatingChar(<span class="string">"aabccdbd"</span>)==<span class="string">'\0'</span>));</span><br><span class="line">        System.out.println((demo.firstNotRepeatingChar(<span class="string">"$abcdefg"</span>)==<span class="string">'$'</span>));</span><br><span class="line">        System.out.println((demo.firstNotRepeatingChar(<span class="keyword">null</span>)==<span class="string">'\0'</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><p>如果需要创建哈希表，键值为 字符，值为 数字时，可以考虑用数组（length=256）来替代，数组下标表示为字符的ASCII码值。</p></li><li><p>哈希表的时间复杂度为O(1)，要求有较高的查找速度时，可以考虑使用哈希表（Java中可以使用HashMap)</p></li><li><p>如果需要判断多个字符是否在某个字符串中出现过，或者统计多个字符在某个字符串中出现的次数，可以考虑基于数组创建一个简单的哈希表，这样可以用很小的空间消耗换来时间效率的提升。</p></li></ol><h1 id="字符流中第一个只出现一个的字符"><a href="#字符流中第一个只出现一个的字符" class="headerlink" title="字符流中第一个只出现一个的字符"></a>字符流中第一个只出现一个的字符</h1><h2 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h2><p>请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是’g’。当从该字符流中读出前六个字符”google”时，第一个只出现一次的字符是’l’。</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><pre><code>字符只能一个一个从字符流中读出来，因此要定义一个容器来保存字符以及其在字符流中的位置。</code></pre><p>　　为尽可能高效解决问题，要在O(1)时间内往数据容器中插入字符，及其对应的位置，因此这个数据容器可以用哈希表来实现，以字符的ASCII码作为哈希表的键值key，字符对应的位置作为哈希表的值value。</p><p>　　开始时，哈希表的值都初始化为-1，当读取到某个字符时，将位置存入value中，如果之前读取过该字符（即value&gt;=0），将value赋值为-2，代表重复出现过。最后对哈希表遍历，在value&gt;=0的键值对中找到最小的value，该value即为第一个只出现一次的字符，ASCII码为key的字符即为所求字符。</p><h3 id="测试用例-1"><a href="#测试用例-1" class="headerlink" title="测试用例"></a>测试用例</h3><ol><li><p>功能测试（读入一个字符；读入多个字符；所有字符都唯一；所有字符重复）</p></li><li><p>特殊测试（读入0个字符）</p></li></ol><h2 id="java代码-1"><a href="#java代码-1" class="headerlink" title="java代码"></a>java代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: rhsphere</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>: 2019-08-01 18:49 by jdk 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstCharInStream</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> index;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] occurence;</span><br><span class="line"></span><br><span class="line"><span class="function">pubilc <span class="title">FirstCharInStream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">index = <span class="number">0</span>;</span><br><span class="line">occurence = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)</span><br><span class="line">occurence[i] = -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (occurence[(<span class="keyword">int</span>)ch] == -<span class="number">1</span>) &#123;</span><br><span class="line">occurence[(<span class="keyword">char</span>)ch] == index;  <span class="comment">//第一次出现</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (occurence[(<span class="keyword">int</span>)ch] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">occurence[(<span class="keyword">int</span>)ch] = -<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">index++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> minIdx = Integer.MAX_VAULE;</span><br><span class="line"><span class="keyword">char</span> ch = <span class="string">'#'</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (occurence[i] &gt;= <span class="number">0</span> &amp;&amp; occurence[i] &lt; minIdx) &#123;</span><br><span class="line">ch = (<span class="keyword">char</span>) i;</span><br><span class="line">minIdx = occurence[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ol><li>对于数据流、字符流等，需要定义数据容器来保存记录。</li></ol><p>　　　　流和串的区别：</p><p>　　　　1）串：字符串已经保存下来了，能够读取遍历，因此在字符串中第一个只出现一次的字符中，只需要存下每个字符出现的个数，然后直接在字符串中遍历；</p><p>　　　　2）流：字符流没有存下来，无法进行遍历，因此在本题中，只能在数据容器哈希表中遍历，而且哈希表中存放的是对应字符的位置，而不是个数。</p><ol start="2"><li><p>记得会用构造函数来初始化参数；</p></li><li><p>Integer.MAX_VALUE=2^31-1，是32位操作系统（4字节）中最大的符号型整型常量。</p></li><li><p>分清楚：字符与ASCII码的转化，以及 字符形式的数字和整形数字之间的转化。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//字符转化成ASCII码</span></span><br><span class="line"><span class="keyword">char</span> ch_a = <span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">int</span> code_a = (<span class="keyword">int</span>) char_a;  <span class="comment">// =ASCII码97</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ASCII码转化成字符</span></span><br><span class="line"><span class="keyword">char</span> copyCh_a = (<span class="keyword">char</span>) code_a;  <span class="comment">// =ASCII码97对应的字符'a'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//字符形式数字转化为整数</span></span><br><span class="line"><span class="keyword">char</span> c1 = <span class="string">'2'</span>;</span><br><span class="line"><span class="keyword">int</span> n1 = c1 - <span class="string">'0'</span>;   <span class="comment">//=2, 由'2'和'1'的ASCII码相减得到</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//数字转化为字符形式</span></span><br><span class="line"><span class="keyword">char</span> copyC1 = (<span class="keyword">char</span>)(n1 + <span class="string">'0'</span>);  <span class="comment">//='2' ,由'0'的ASCII码加2得到'2'的ASCII码</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>剑指Offer(49) 丑数</title>
    <link href="https://www.blogs.rhsphere.com/2019/07/30/ugly-number.html"/>
    <id>https://www.blogs.rhsphere.com/2019/07/30/ugly-number.html</id>
    <published>2019-07-30T14:27:40.000Z</published>
    <updated>2019-07-30T14:58:47.904Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><h2 id="丑数"><a href="#丑数" class="headerlink" title="丑数"></a>丑数</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>我们把只包含因子2、3和5的数称作丑数（Ugly Number）。求按从小到大的顺序的第1500个丑数。例如6、8都是丑数，但14不是，因为它包含因子7。习惯上我们把1当做第一个丑数。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><strong>直观思路</strong>：逐一判断每个整数是否为丑数，效率太低。</p><p><strong>空间换时间的解法</strong>：</p><p>　　创建数组存放已经排序好的丑数，这将消耗一定的内存开销。根据丑数的定义，丑数应该是另一个丑数的2、3或者5倍的结果，因此，我们从数组中已有的丑数里找到三个丑数T2、T3、T5，它们分别和2、3、5相乘得到的值恰好比已有的最大丑数大，三个乘积中最小的一个就是下一个丑数，存放入数组中，同时更新T2、T3、T5，使它们仍然保持与2、3、5的乘积恰好比已有的最大丑数大。</p><h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><ol><li><p>功能测试（2，3，4，5等）</p></li><li><p>特殊测试（0，1）</p></li><li><p>性能测试（1500等）</p></li></ol><h2 id="java代码"><a href="#java代码" class="headerlink" title="java代码"></a>java代码</h2><h3 id="逐个判断每个整数"><a href="#逐个判断每个整数" class="headerlink" title="逐个判断每个整数"></a>逐个判断每个整数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 暴力法求丑数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: rhsphere</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>: 2019-07-30 22:49 by jdk 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BF_UglyNumber</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getUglyNumber</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> number = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isUgly(number))</span><br><span class="line">                count++;</span><br><span class="line">            <span class="keyword">if</span> (count == index)</span><br><span class="line">                <span class="keyword">return</span> number;</span><br><span class="line">            number++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isUgly</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (number % <span class="number">5</span> == <span class="number">0</span>)</span><br><span class="line">            number /= <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">while</span> (number % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">            number /= <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">while</span> (number % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">            number /= <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> number == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建数组保存已经找到的丑数，用时间换空间的解法"><a href="#创建数组保存已经找到的丑数，用时间换空间的解法" class="headerlink" title="创建数组保存已经找到的丑数，用时间换空间的解法"></a>创建数组保存已经找到的丑数，用时间换空间的解法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: rhsphere</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>: 2019-07-30 22:30 by jdk 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UglyNumber</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getUglyNumber</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] uglyNum = <span class="keyword">new</span> <span class="keyword">int</span>[index];</span><br><span class="line"></span><br><span class="line">        uglyNum[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> index2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> index3 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> index5 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; index; i++) &#123;</span><br><span class="line">            uglyNum[i] = getMinimum(uglyNum[index2] * <span class="number">2</span>,</span><br><span class="line">                    uglyNum[index3] * <span class="number">3</span>, uglyNum[index5] * <span class="number">5</span>);</span><br><span class="line">            <span class="keyword">while</span>(uglyNum[index2] * <span class="number">2</span> &lt;= uglyNum[i])</span><br><span class="line">                index2++;</span><br><span class="line">            <span class="keyword">while</span>(uglyNum[index3] * <span class="number">3</span> &lt;= uglyNum[i])</span><br><span class="line">                index3++;</span><br><span class="line">            <span class="keyword">while</span>(uglyNum[index5] * <span class="number">5</span> &lt;= uglyNum[i])</span><br><span class="line">                index5++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uglyNum[index - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getMinimum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.min(Math.min(a, b), c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>判断m是否为n的因子：即判断n能否被m整除，也就是n%m=0。要掌握判断因子的方法。例如判断丑数的程序如下：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isUgly</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (number % <span class="number">5</span> == <span class="number">0</span>)</span><br><span class="line">        number /= <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">while</span> (number % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">        number /= <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">while</span> (number % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        number /= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> number == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>丑数是另一个丑数的2、3或者5倍，要记住这类特性和规律。特别是在遇到类似的新概念时。</li></ol><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="剑指Offer" scheme="https://www.blogs.rhsphere.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
  </entry>
  
  <entry>
    <title>剑指Offer(48) 最长不含重复自负的子字符串</title>
    <link href="https://www.blogs.rhsphere.com/2019/07/30/longest-substring-without-duplicate.html"/>
    <id>https://www.blogs.rhsphere.com/2019/07/30/longest-substring-without-duplicate.html</id>
    <published>2019-07-30T10:31:32.000Z</published>
    <updated>2019-07-30T10:59:31.903Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><h2 id="最长不含重复字符的子字符串"><a href="#最长不含重复字符的子字符串" class="headerlink" title="最长不含重复字符的子字符串"></a>最长不含重复字符的子字符串</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。假设字符串中只包含从’a’到’z’的字符。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>动态规划法：定义函数f(i)为：以第i个字符为结尾的不含重复字符的子字符串的最大长度。</p><p>　　（1）当第i个字符之前未出现过，则有：f(i)=f(i-1)+1</p><p>　　（2）当第i个字符之前出现过，记该字符与上次出现的位置距离为d</p><p>　　　　1）如果d&lt;=f(i-1)，则有f(i)=d；</p><p>　　　　2）如果d&gt;f(i-1)，则有f(i)=f(i-1)+1；</p><p>　　我们从第一个字符开始遍历，定义两个int变量preLength和curLength来分别代表f(i-1)和f(i)，再创建一个长度为26的pos数组来存放26个字母上次出现的位置，即可根据上述说明进行求解。</p><p>　　注意：每次最大长度和字母出现位置要记得更新。</p><p>　　另一种思路：遍历每个字符，把当前字符看成子字符串的末尾结点，同时更新开头结点，详细代码见Longest Substring Without Repeating Characters</p><h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><ol><li><p>功能测试（一个或者多个字符，全部字符不同/相同）</p></li><li><p>特殊测试（null，空字符串）</p></li></ol><h2 id="java代码"><a href="#java代码" class="headerlink" title="java代码"></a>java代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: rhsphere</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>: 2019-07-30 18:39 by jdk 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongestSubstringWithoutDup</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxLength</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (str == <span class="keyword">null</span> || str.length() &lt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pre = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] pos = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pos.length; i++)</span><br><span class="line">pos[i] = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line"><span class="keyword">int</span> letterNum = str.charAt(i) - <span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">if</span> (pos[letterNum] &lt; <span class="number">0</span> || i - pos[letterNum] &gt; pre) &#123;</span><br><span class="line">cur = pre + <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">cur = i - pos[letterNum];</span><br><span class="line">&#125;</span><br><span class="line">pos[letterNum] = i;</span><br><span class="line"><span class="keyword">if</span> (cur &gt; max)</span><br><span class="line">max = cur;</span><br><span class="line">pre = cur;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(maxLength(<span class="string">"arabcacfr"</span>)==<span class="number">4</span>);</span><br><span class="line">        System.out.println(maxLength(<span class="string">"a"</span>)==<span class="number">1</span>);</span><br><span class="line">        System.out.println(maxLength(<span class="string">"aaa"</span>)==<span class="number">1</span>);</span><br><span class="line">        System.out.println(maxLength(<span class="string">"abcdef"</span>)==<span class="number">6</span>);</span><br><span class="line">        System.out.println(maxLength(<span class="string">""</span>)==<span class="number">0</span>);</span><br><span class="line">        System.out.println(maxLength(<span class="keyword">null</span>)==<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><p>函数f(i)为：以第i个字符为结尾的不含重复字符的子字符串的最大长度。而不是以第i个字符作为开头。第i个字符作为结尾可以方便与下一个字符进行联系。</p></li><li><p>学会用长度为26的数组来存放26个字母所在的位置下标。</p></li></ol><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="剑指Offer" scheme="https://www.blogs.rhsphere.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="Dynamic Programming" scheme="https://www.blogs.rhsphere.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer(47) 礼物的最大价值</title>
    <link href="https://www.blogs.rhsphere.com/2019/07/30/max-value-of-gifts.html"/>
    <id>https://www.blogs.rhsphere.com/2019/07/30/max-value-of-gifts.html</id>
    <published>2019-07-30T02:52:27.000Z</published>
    <updated>2019-07-30T08:35:15.522Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><h2 id="礼物的最大价值"><a href="#礼物的最大价值" class="headerlink" title="礼物的最大价值"></a>礼物的最大价值</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>在一个m×n的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向左或者向下移动一格直到到达棋盘的右下角。给定一个棋盘及其上面的礼物，请计算你最多能拿到多少价值的礼物？</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>动态规划：定义f(i,j)为到达(i,j)位置格子时能拿到的礼物总和的最大值，显然有边界条件，f(i, 0) = arr[0][0] + arr[i][0]， f(0, j) = arr[0][0] + arr[0][j]。则有状态转移方程：f(i,j)=max{f(i,j),f(i,j)} + arr(i,j)。</p><p>　　同上道题一样，如果直接使用递归会产生大量的重复计算，因此，创建辅助的数组来保存中间计算结果。</p><p>　　辅助数组不用和m*n的二维数组一样大，只需要保存上一层的最大值就可以。代码中使用长度为列数n的一位数组作为辅助数组，注释部分为二维辅助数组。</p><h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><ol><li><p>功能测试（多行多列，一行多列，多行一列，一行一列）</p></li><li><p>特殊测试（null）</p></li></ol><h2 id="java代码"><a href="#java代码" class="headerlink" title="java代码"></a>java代码</h2><h3 id="二维数组的辅助空间"><a href="#二维数组的辅助空间" class="headerlink" title="二维数组的辅助空间"></a>二维数组的辅助空间</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: rhsphere</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>: 2019-07-30 10:55 by jdk 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Matrix_MaxValueOfGifts</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxValueOfGifts</span><span class="params">(<span class="keyword">int</span>[][] values)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (values == <span class="keyword">null</span> || values.length &lt;= <span class="number">0</span> || values[<span class="number">0</span>].length &lt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> rows = values.length;</span><br><span class="line"><span class="keyword">int</span> cols = values[<span class="number">0</span>].length;</span><br><span class="line"><span class="keyword">int</span>[][] cache = <span class="keyword">new</span> <span class="keyword">int</span>[rows][cols];</span><br><span class="line"></span><br><span class="line">cache[<span class="number">0</span>][<span class="number">0</span>] = values[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; rows; i++)</span><br><span class="line">cache[i][<span class="number">0</span>] = cache[i-<span class="number">1</span>][<span class="number">0</span>] + values[i][<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; cols; j++)</span><br><span class="line">cache[<span class="number">0</span>][j] = cache[<span class="number">0</span>][j-<span class="number">1</span>] + values[<span class="number">0</span>][j];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; rows; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; cols; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (cache[i-<span class="number">1</span>][j] &gt; cache[i][j-<span class="number">1</span>])</span><br><span class="line">cache[i][j] = cahce[i-<span class="number">1</span>][j] + values[i][j];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cache[i][j] = cache[i][j-<span class="number">1</span>] + values[i][j]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cache[rows-<span class="number">1</span>][cols-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MaxValueOfGifts demo = <span class="keyword">new</span> MaxValueOfGifts();</span><br><span class="line">        <span class="keyword">int</span>[][] values = &#123;&#123;<span class="number">1</span>, <span class="number">10</span>, <span class="number">3</span>, <span class="number">8</span>&#125;, &#123;<span class="number">12</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">6</span>&#125;, &#123;<span class="number">5</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">11</span>&#125;, &#123;<span class="number">3</span>, <span class="number">7</span>, <span class="number">16</span>, <span class="number">5</span>&#125;&#125;;</span><br><span class="line">        System.out.print(<span class="string">"路径："</span>);</span><br><span class="line">        System.out.println(<span class="string">"最大值为："</span> + demo.maxValueOfGifts(values));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一维数组的辅助空间"><a href="#一维数组的辅助空间" class="headerlink" title="一维数组的辅助空间"></a>一维数组的辅助空间</h3><p>分析见剑指offer书本，以及debug模式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 一维辅助空间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: rhsphere</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>: 2019-07-30 11:43 by jdk 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Array_MaxValueOfGifts</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxValueOfGifts</span><span class="params">(<span class="keyword">int</span>[][] values)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (values == <span class="keyword">null</span> || values.length &lt;= <span class="number">0</span> || values[<span class="number">0</span>].length &lt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> rows = values.length;</span><br><span class="line"><span class="keyword">int</span> cols = values[<span class="number">0</span>].length;</span><br><span class="line"><span class="keyword">int</span>[] maxValue = <span class="keyword">new</span> <span class="keyword">int</span>[clos];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> up = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">0</span>)</span><br><span class="line">up = maxValue[j];</span><br><span class="line"><span class="keyword">if</span> (j &gt; <span class="number">0</span>)</span><br><span class="line">left = maxValue[j-<span class="number">1</span>];</span><br><span class="line">maxValue = Math.max(up, left) + value[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> maxValue[cols - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><p>动态规划问题，用公式来表示清楚。</p></li><li><p>动态规划如果有大量重复计算，可以用循环+辅助空间来提高效率。</p></li><li><p>这道题不用二维数组，只需要用一维数组作为辅助空间即可，以后遇到对中间结果的保存问题，看看能否优化辅助空间。</p></li></ol><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="剑指Offer" scheme="https://www.blogs.rhsphere.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="Dynamic Programming" scheme="https://www.blogs.rhsphere.com/tags/Dynamic-Programming/"/>
    
      <category term="matrix" scheme="https://www.blogs.rhsphere.com/tags/matrix/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer(46) 把数字翻译成字符串</title>
    <link href="https://www.blogs.rhsphere.com/2019/07/30/translate-numbers-to-strings.html"/>
    <id>https://www.blogs.rhsphere.com/2019/07/30/translate-numbers-to-strings.html</id>
    <published>2019-07-30T02:16:41.000Z</published>
    <updated>2019-07-30T02:51:23.624Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><h2 id="把数字翻译成字符串"><a href="#把数字翻译成字符串" class="headerlink" title="把数字翻译成字符串"></a>把数字翻译成字符串</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个数字，我们按照如下规则把它翻译为字符串：0翻译成”a”，1翻译成”b”，……，11翻译成”l”，……，25翻译成”z”。一个数字可能有多个翻译。例如12258有5种不同的翻译，它们分别”bccfi”, “bwfi”, “bczi”, “mcfi” 和”mzi” 。请编程实现一个函数用来计算一个数字有多少种不同的翻译方法。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>看到题目，很容易想到使用递归：用f(i)来表示从第i位开始的不同翻译数目，可以得到有：f(i)=f(i+1)+g(i,i+1)*f(i+2)。i和i+1位数字拼起来在10~25范围内时g(i,i+1)的值为1，否则为0。</p><p>　　但是存在重复的子问题，所以递归并非最佳方法，我们从数字的末尾开始计算f(i)，自下而上解决问题，就可以消除重复的子问题了。先算f(len-1)，f(len-2)，再根据公式f(i)=f(i+1)+g(i,i+1)*f(i+2)往前逐步推导到f(0)，这就是最终要求的结果。</p><h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><ol><li><p>功能测试（1个数字；多个数字）</p></li><li><p>特殊测试（负数，0，含25、26等）</p></li></ol><h2 id="java代码"><a href="#java代码" class="headerlink" title="java代码"></a>java代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: rhsphere</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>: 2019-07-30 10:19 by jdk 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TranslateNumbersToStrings</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getTranslationCount</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (number &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">String sNum = String.valueOf(number);</span><br><span class="line"><span class="keyword">int</span> len = sNum.length();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] counts = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="keyword">if</span> (i == len - <span class="number">1</span>) &#123;</span><br><span class="line">counts[i] = <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">count[i] = count[i + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (canBeTrans(sNum, i)) &#123;</span><br><span class="line"><span class="keyword">if</span> (i == len - <span class="number">2</span>) </span><br><span class="line">counts[i] += <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">counts[i] += counts[i + <span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> counts[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">canBeTrans</span><span class="params">(String sNum, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = sNum.charAt(i) - <span class="string">'0'</span>;</span><br><span class="line"><span class="keyword">int</span> b = sNum.charAt(i + <span class="number">1</span>) - <span class="string">'0'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> convert = a * <span class="number">10</span> + b;</span><br><span class="line"><span class="keyword">if</span> (convert &gt;= <span class="number">10</span> &amp;&amp; convert &lt;= <span class="number">25</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TranslateNumbersToStrings demo= <span class="keyword">new</span> TranslateNumbersToStrings();</span><br><span class="line">        System.out.println(demo.getTranslationCount(<span class="number">0</span>)==<span class="number">1</span>);</span><br><span class="line">        System.out.println(demo.getTranslationCount(<span class="number">10</span>)==<span class="number">2</span>);</span><br><span class="line">        System.out.println(demo.getTranslationCount(<span class="number">12258</span>)==<span class="number">5</span>);</span><br><span class="line">        System.out.println(demo.getTranslationCount(-<span class="number">100</span>)==<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><p>递归方法，我们试着用公式描述会比较清晰</p></li><li><p>递归是自上而下解决问题，如果遇到重复的子问题时，考虑自下而上求解，不用递归</p></li><li><p>g(i,i+1)不仅要判断&lt;=25，还要判断&gt;=10，别漏了</p></li></ol><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="剑指Offer" scheme="https://www.blogs.rhsphere.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="String" scheme="https://www.blogs.rhsphere.com/tags/String/"/>
    
      <category term="Dynamic Programming" scheme="https://www.blogs.rhsphere.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer(45) 把数组排成最小的数</title>
    <link href="https://www.blogs.rhsphere.com/2019/07/30/sort-array-for-min-number.html"/>
    <id>https://www.blogs.rhsphere.com/2019/07/30/sort-array-for-min-number.html</id>
    <published>2019-07-30T01:47:10.000Z</published>
    <updated>2019-07-30T02:13:39.679Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><h2 id="把数组排成最小的数"><a href="#把数组排成最小的数" class="headerlink" title="把数组排成最小的数"></a>把数组排成最小的数</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3, 32, 321}，则打印出这3个数字能排成的最小数字321323。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>不好的方法：求出所有全排列（类似字符串的排列 ），将数字拼起来，最后求出所有的最小值。这效率太低，且没有考虑到大数问题。</p><p>　　好的方法：观察规律，自行定义一种排序规则。</p><p>　　对于数字m和n，可以拼接成mn和nm，如果mn&lt;nm，我们定义m小于n。反之则相反。利用这个排序规则，从小排到大即可实现题目要求。</p><p>　　拼接m和n时，要考虑到大数问题，因此将m和n拼接起来的数字转换成字符串处理。因为mn和nm的字符串位数相同，因此它们的大小只需要按照字符串大小的比较规则就可以了。</p><p>　　具体实现：将数字存入ArrayList中，通过利用Collections.sort(List<t> list, Comparator&lt;? super T&gt; c)方法进行排序。Comparator中重写compar()方法来规定比较规则。</t></p><h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><ol><li><p>功能测试（1个数字；多个数字；数字数位有重复）</p></li><li><p>特殊测试（null）</p></li></ol><h2 id="java代码"><a href="#java代码" class="headerlink" title="java代码"></a>java代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">**</span><br><span class="line"> * <span class="meta">@description</span>:</span><br><span class="line"> * <span class="meta">@author</span>: rhsphere</span><br><span class="line"> * <span class="meta">@since</span>: <span class="number">2019</span>-<span class="number">07</span>-<span class="number">30</span> <span class="number">10</span>:<span class="number">05</span> by jdk <span class="number">1.8</span></span><br><span class="line"> */</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SortArrayForMinNumber</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">printMinNumber</span><span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (numbers == <span class="keyword">null</span> || numbers.length &lt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> num : numbers)</span><br><span class="line">list.add(String.valueOf(num));</span><br><span class="line">Collections.sort(list, <span class="keyword">new</span> Comparator&lt;String&gt;()&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">conpare</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">String a = s1 + s2;</span><br><span class="line">String b = s2 + s1;</span><br><span class="line"><span class="keyword">return</span> a.compare(b);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder():</span><br><span class="line"><span class="keyword">for</span>(String str : list)</span><br><span class="line">sb.append(str);</span><br><span class="line"><span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><p>记住Collections.(List<t> list, Comparator&lt;? super T&gt; c)在重写compare()方法的使用。</t></p></li><li><p>小心大数问题，用字符串解决大数问题。</p></li><li><p>遇到类似排序问题，想想自定排序规则是否更加方便</p></li></ol><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="剑指Offer" scheme="https://www.blogs.rhsphere.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="array" scheme="https://www.blogs.rhsphere.com/tags/array/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer(44) 数字序列中某一位的数字</title>
    <link href="https://www.blogs.rhsphere.com/2019/07/30/digits-in-sequence.html"/>
    <id>https://www.blogs.rhsphere.com/2019/07/30/digits-in-sequence.html</id>
    <published>2019-07-30T01:19:44.000Z</published>
    <updated>2019-07-30T01:30:49.411Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><h2 id="数字序列中某一位的数字"><a href="#数字序列中某一位的数字" class="headerlink" title="数字序列中某一位的数字"></a>数字序列中某一位的数字</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从0开始计数）是5，第13位是1，第19位是4，等等。请写一个函数求任意位对应的数字。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>逐一枚举数字，计算每个数字的位数相加，效率太低。</p><p>　　观察规律：</p><p>　　个位数的个数一共有10个，即0~9，共占了10*1位数字；</p><p>　　两位数的个数一共有90个，即10~99，每个数字占两位，共占了90*2位数字；</p><p>　　……</p><p>　　m位数的个数一共有9<em>10^(m-1)个，每个数字占m位，占了9</em>10^(m-1)*m位数字。</p><p>　　判断第n个对的数字是属于几位数，再从几位数中进行寻找。</p><h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><ol><li><p>功能测试（输入19、1000等）</p></li><li><p>边界值测试（输入0、1等）</p></li></ol><h2 id="java代码"><a href="#java代码" class="headerlink" title="java代码"></a>java代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: rhsphere</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>: 2019-07-30 09:18 by jdk 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DigitsInSeq</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">digitAtIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (index &lt; <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">int</span> m = <span class="number">1</span>;  <span class="comment">//m位数</span></span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">          <span class="keyword">int</span> numbers = numbersOfInt(m);  <span class="comment">//m位的个数</span></span><br><span class="line">          <span class="keyword">if</span> (index &lt; numbers * m)</span><br><span class="line">              <span class="keyword">return</span> getDigit(index, m);</span><br><span class="line">          index -= numbers * m;</span><br><span class="line">          m++;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 返回m位数的总个数</span></span><br><span class="line"><span class="comment">     * 例如，两位数一共有90个：10~99；三位数有900个：100~999</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">numbersOfInt</span><span class="params">(<span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) (<span class="number">9</span>*Math.pow(<span class="number">10</span>, m-<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 获取数字</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getDigit</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> number = getFirstNumber(m) + index / m;  <span class="comment">//对应的m位</span></span><br><span class="line">        <span class="keyword">int</span> indexFromRight = m - index % m;  <span class="comment">//在数字中的位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; indexFromRight; i++)</span><br><span class="line">            number /= <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">return</span> number % <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 第一个m位数</span></span><br><span class="line"><span class="comment">     * 例如第一个两位数是10，第一个三位数是100</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getFirstNumber</span><span class="params">(<span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) Math.pow(<span class="number">10</span>, m-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DigitsInSeq demo=<span class="keyword">new</span> DigitsInSeq();</span><br><span class="line">        System.out.println(demo.digitAtIndex(<span class="number">0</span>)==<span class="number">0</span>);</span><br><span class="line">        System.out.println(demo.digitAtIndex(<span class="number">1</span>)==<span class="number">1</span>);</span><br><span class="line">        System.out.println(demo.digitAtIndex(<span class="number">19</span>)==<span class="number">4</span>);</span><br><span class="line">        System.out.println(demo.digitAtIndex(<span class="number">1000</span>)==<span class="number">3</span>);</span><br><span class="line">        System.out.println(demo.digitAtIndex(<span class="number">1001</span>)==<span class="number">7</span>);</span><br><span class="line">        System.out.println(demo.digitAtIndex(<span class="number">1002</span>)==<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="剑指Offer" scheme="https://www.blogs.rhsphere.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
  </entry>
  
  <entry>
    <title>剑指Offer(43) 1~n整数中1出现的次数</title>
    <link href="https://www.blogs.rhsphere.com/2019/07/29/num-of-1-between-1-and-n.html"/>
    <id>https://www.blogs.rhsphere.com/2019/07/29/num-of-1-between-1-and-n.html</id>
    <published>2019-07-29T15:07:54.000Z</published>
    <updated>2019-07-29T15:29:17.884Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><h2 id="1-n整数中1出现的次数"><a href="#1-n整数中1出现的次数" class="headerlink" title="1~n整数中1出现的次数"></a>1~n整数中1出现的次数</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>　输入一个整数n，求从1到n这n个整数的十进制表示中1出现的次数。例如输入12，从1到12这些整数中包含1 的数字有1，10，11和12，1一共出现了5次。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>如果是从头到尾遍历(n次)，对每一个数字都计算其1的个数（lgn次），则时间复杂度为O(nlogn)，运算效率太低。因此必须总结规律，提高效率。</p><p>总结规律如下（思路比《剑指OFFER》一书简单）：</p><p>　　对于整数n，我们将这个整数分为三部分：当前位数字cur，更高位数字high，更低位数字low，如：对于n=21034，当位数是十位时，cur=3，high=210，low=4。</p><p>　　我们从个位到最高位 依次计算每个位置出现1的次数：</p><p>　　1）当前位的数字等于0时，例如n=21034，在百位上的数字cur=0，百位上是1的情况有：00100~00199，01100~01199，……，20100~20199。一共有21<em>100种情况，即high</em>100;</p><p>　　2）当前位的数字等于1时，例如n=21034，在千位上的数字cur=1，千位上是1的情况有：01000~01999，11000~11999，21000~21034。一共有2<em>1000+（34+1）种情况，即high</em>1000+(low+1)。</p><p>　　3）当前位的数字大于1时，例如n=21034，在十位上的数字cur=3，十位上是1的情况有：00010~00019，……，21010~21019。一共有（210+1）<em>10种情况，即(high+1)</em>10。</p><p>　　这个方法只需要遍历每个位数，对于整数n，其位数一共有lgn个，所以时间复杂度为O(logn)。</p><h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><ol><li><p>功能测试（3，45，180等）</p></li><li><p>边界值测试（0，1等）</p></li><li><p>性能测试（输入较大的数字，如1000000等）</p></li></ol><h2 id="java代码"><a href="#java代码" class="headerlink" title="java代码"></a>java代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: rhsphere</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>: 2019-07-29 23:14 by jdk 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumberOf1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i *= <span class="number">10</span>) &#123;  <span class="comment">//i代表位数</span></span><br><span class="line">            <span class="keyword">int</span> high = n / (i * <span class="number">10</span>);   <span class="comment">//更高位数字</span></span><br><span class="line">            <span class="keyword">int</span> low = (n % i);    <span class="comment">//更低位数字</span></span><br><span class="line">            <span class="keyword">int</span> cur = (n / i) % <span class="number">10</span>;  <span class="comment">//当前数字</span></span><br><span class="line">            <span class="keyword">if</span> (cur == <span class="number">0</span>) &#123;</span><br><span class="line">                count += high * i;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( cur == <span class="number">1</span>) &#123;</span><br><span class="line">                count += high * i + (low + <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                count += (high + <span class="number">1</span>) * i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><p>找规律要耐心！欲速则不达。</p></li><li><p>学会提取不同位置的数字，以及更高、更低位置的数字；学会遍历每个位数的循环。</p></li></ol><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="剑指Offer" scheme="https://www.blogs.rhsphere.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="String" scheme="https://www.blogs.rhsphere.com/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer(42) 连续子数组的最大和</title>
    <link href="https://www.blogs.rhsphere.com/2019/07/29/greatest-sum-of-subarrays.html"/>
    <id>https://www.blogs.rhsphere.com/2019/07/29/greatest-sum-of-subarrays.html</id>
    <published>2019-07-29T14:56:30.000Z</published>
    <updated>2019-07-29T15:03:45.265Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><h2 id="连续子数组的最大和"><a href="#连续子数组的最大和" class="headerlink" title="连续子数组的最大和"></a>连续子数组的最大和</h2><p>本题的动态规划解法，待完成。</p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入一个整型数组，数组里有正数也有负数。数组中一个或连续的多个整/数组成一个子数组。求所有子数组的和的最大值。要求时间复杂度为O(n)。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>分析规律，从第一个数字开始累加，若走到某一个数字时，前面的累加和为负数，说明不能继续累加了，要从当前数字重新开始累加。在累加过程中，将每次累加和的最大值记录下来，遍历完成后，返回该数字。</p><h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><ol><li><p>功能测试（输入数组有正有负，全负数，全正数）</p></li><li><p>特殊输入测试（null）</p></li></ol><h2 id="java代码"><a href="#java代码" class="headerlink" title="java代码"></a>java代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: rhsphere</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>: 2019-07-29 23:00 by jdk 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreatestSumOFSubArrays</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> isInvalidInput = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findGreatestSumOfSubarray</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            isInvalidInput = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        isInvalidInput = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> sum = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> maxSum = arr[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                sum = arr[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sum += arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sum &gt; maxSum)</span><br><span class="line">                maxSum = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="剑指Offer" scheme="https://www.blogs.rhsphere.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="array" scheme="https://www.blogs.rhsphere.com/tags/array/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer(41) 数据流中的中位数</title>
    <link href="https://www.blogs.rhsphere.com/2019/07/29/stream-median.html"/>
    <id>https://www.blogs.rhsphere.com/2019/07/29/stream-median.html</id>
    <published>2019-07-29T13:51:57.000Z</published>
    <updated>2019-07-29T14:53:08.547Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><h2 id="数据流中的中位数"><a href="#数据流中的中位数" class="headerlink" title="数据流中的中位数"></a>数据流中的中位数</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>所谓数据流，就是不会一次性读入所有数据，只能一个一个读取，每一步都要求能计算中位数。</p><p>　　将读入的数据分为两部分，一部分数字小，另一部分大。小的一部分采用大顶堆存放，大的一部分采用小顶堆存放。当总个数为偶数时，使两个堆的数目相同，则中位数=大顶堆的最大数字与小顶堆的最小数字的平均值；而总个数为奇数时，使小顶堆的个数比大顶堆多一，则中位数=小顶堆的最小数字。</p><p>因此，插入的步骤如下：</p><p>　　1. 若已读取的个数为偶数（包括0）时，两个堆的数目已经相同，将新读取的数插入到小顶堆中，从而实现小顶堆的个数多一。但是，如果新读取的数字比大顶堆中最大的数字还小，就不能直接插入到小顶堆中了 ，此时必须将新数字插入到大顶堆中，而将大顶堆中的最大数字插入到小顶堆中，从而实现小顶堆的个数多一。</p><p>　　2. 若已读取的个数为奇数时，小顶堆的个数多一，所以要将新读取数字插入到大顶堆中，此时方法与上面类似。</p><h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><ol><li><p>功能测试（读入奇/偶数个数字）</p></li><li><p>边界值测试（读入0个、1个、2个数字）</p></li></ol><h2 id="jav代码"><a href="#jav代码" class="headerlink" title="jav代码"></a>jav代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: rhsphere</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>: 2019-07-29 21:52 by jdk 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamMedian</span> </span>&#123;</span><br><span class="line">PriorityQueue&lt;Integer&gt; minHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;();  <span class="comment">//小顶堆，默认容量11</span></span><br><span class="line">PriorityQueue&lt;Integer&gt; maxHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="number">11</span>, <span class="keyword">new</span> Comparator&lt;Integer&gt;&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer i1, Integer i2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> i2 - i1; </span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Integer num)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (((minHeap.size() + maxHeap.size()) &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">//偶数个时，下个数字加入小顶堆</span></span><br><span class="line"><span class="keyword">if</span> (!maxHeap.isEmpty() &amp;&amp; maxHeap.peek() &gt; num) &#123;</span><br><span class="line">maxHeap.offer(num);</span><br><span class="line">num = maxHeap.poll();</span><br><span class="line">&#125;</span><br><span class="line">minHeap.offer(num);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//奇数个时，下个数字放入大顶堆</span></span><br><span class="line"><span class="keyword">if</span> (!minHeap.isEmpty() &amp;&amp; minHeap.peek() &lt; num) &#123;</span><br><span class="line">minHeap.offer(num);</span><br><span class="line">num = minHeap.poll();</span><br><span class="line">&#125;</span><br><span class="line">maxHeap.offer(num);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Double <span class="title">getMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> ((maxHeap.size() + minHeap.size()) == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line"><span class="keyword">double</span> median;</span><br><span class="line"><span class="keyword">if</span> (((minHeap.size() + maxHeap.size()) &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">median = (maxHeap.peek() + minHeap.peek()) / <span class="number">2.0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">median = minHeap.peek();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> median;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>最大堆 最小堆其实就是优先队列，这里可以用PriorityQueue实现，PriorityQueue默认是一个小顶堆，通过传入自定义的Comparator函数，可以实现大顶堆：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PriorityQueue&lt;Integer&gt; maxHeap = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;(<span class="number">11</span>, <span class="keyword">new</span> Comparator&lt;Integer&gt;()&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer i1, Integer i2)</span> </span>&#123;</span><br><span class="line">retrurn i2 - i1;  <span class="comment">//降序排列</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>PriorityQueue的常用方法有： poll()、 offer(Object)、 size()、 peek()等。</p><ol start="2"><li>平均值定义为double，且 (a+b）/2.0 。</li><li>往最大堆中插入数据时间复杂度是O(logn)，获取最大数的时间复杂度是O(1)。</li><li>这道题关键在于分成两个平均分配的部分，奇偶时分别插入到最大最小堆中，利用最大最小堆性质的插入方法要掌握。</li></ol><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="剑指Offer" scheme="https://www.blogs.rhsphere.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="PriorityQueue" scheme="https://www.blogs.rhsphere.com/tags/PriorityQueue/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer(40) 最小的k个数</title>
    <link href="https://www.blogs.rhsphere.com/2019/07/28/k-least-numbers.html"/>
    <id>https://www.blogs.rhsphere.com/2019/07/28/k-least-numbers.html</id>
    <published>2019-07-28T12:39:28.000Z</published>
    <updated>2019-07-29T13:49:31.272Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><h2 id="最小的k个数"><a href="#最小的k个数" class="headerlink" title="最小的k个数"></a>最小的k个数</h2><p>关于堆排序，堆的下沉操作，圆满解决。</p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入n个整数，找出其中最小的k个数。例如输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>思路一：同剑指offer(39) 数组中出现次数超过一半的数字中使用partition()方法，基于数组的第k个数字调整，使得更小的k个数字都在数组左边即可。</p><p>思路二：依次遍历n个整数，用一个容器存放最小的k个数字，每遇到比容器中最大的数字还小的数字时，将最大值替换为该数字。容器可以使用最大堆或者红黑树来实现。本文根据堆排序的原理来实现。</p><h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><ol><li><p>功能测试（数组中存在/不存在重复数字）</p></li><li><p>边界值测试（k=1或者等于数组长度）</p></li><li><p>特殊测试（null、k&lt;1、k大于数组长度）</p></li></ol><h2 id="java代码"><a href="#java代码" class="headerlink" title="java代码"></a>java代码</h2><h3 id="用partition函数修改数组"><a href="#用partition函数修改数组" class="headerlink" title="用partition函数修改数组"></a>用partition函数修改数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 剑指offer40</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: rhsphere</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>: 2019-07-28 20:47 by jdk 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KLeastNum</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">getLeastNumbers</span><span class="params">(<span class="keyword">int</span>[] input, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(k);</span><br><span class="line"><span class="keyword">if</span> (input == <span class="keyword">null</span> || k &lt;= <span class="number">0</span> || k &gt; input.length) &#123;</span><br><span class="line"><span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> end = input.length - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> index = partition(input, start, end);</span><br><span class="line"><span class="keyword">while</span> (index != k - <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (index &lt; k - <span class="number">1</span>) &#123;</span><br><span class="line">start = index + <span class="number">1</span>;</span><br><span class="line">index = partition(input, start, end);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">end = index - <span class="number">1</span>;</span><br><span class="line">index = partition(input, start, end);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) </span><br><span class="line">list.add(input[i]);</span><br><span class="line"><span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> pivot = arr[startIndex];</span><br><span class="line"><span class="keyword">int</span> low = startIndex;</span><br><span class="line"><span class="keyword">int</span> high = endIndex;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (low != high) &#123;</span><br><span class="line"><span class="keyword">while</span> (low &lt; high &amp;&amp; arr[high] &gt; pivot)</span><br><span class="line">high--;</span><br><span class="line"><span class="keyword">while</span> (low &lt; high &amp;&amp; arr[low] &lt;= pivot) </span><br><span class="line">low++;</span><br><span class="line"><span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line"><span class="keyword">int</span> tmp = arr[low];</span><br><span class="line">arr[low] = arr[high];</span><br><span class="line">arr[high] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">arr[startIndex] = arr[low];</span><br><span class="line">arr[low] = pivot;</span><br><span class="line"><span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="基于堆的容器"><a href="#基于堆的容器" class="headerlink" title="基于堆的容器"></a>基于堆的容器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 基于堆的容器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: rhsphere</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>: 2019-07-29 13:25 by jdk 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KLeastNum_Heap</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">getLeastNum</span><span class="params">(<span class="keyword">int</span>[] input, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (k &lt;= <span class="number">0</span> || k &gt; input.length || input == <span class="keyword">null</span>) </span><br><span class="line"><span class="keyword">return</span> list;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> numbers = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">numbers[i] = input[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = k/<span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">downAdjust(numbers, i, k);</span><br><span class="line"></span><br><span class="line"><span class="comment">//这两句可以写成</span></span><br><span class="line"><span class="comment">//buildHeap(numbers);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; input.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (input[i] &lt; numbers[<span class="number">0</span>]) &#123;</span><br><span class="line">numbers[<span class="number">0</span>] = input[i];</span><br><span class="line">adjustHeap(numbers, <span class="number">0</span>, k);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : numbers)</span><br><span class="line">list.add(i);</span><br><span class="line"><span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">downAdjust</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> parent, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> tmp = arr[parent];</span><br><span class="line"><span class="keyword">int</span> child = <span class="number">2</span> * parent + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (child &lt; length) &#123;</span><br><span class="line"><span class="keyword">if</span> (child + <span class="number">1</span> &lt; length &amp;&amp; arr[child + <span class="number">1</span>] &gt; arr[child])</span><br><span class="line">child++;</span><br><span class="line"><span class="keyword">if</span> (tmp &gt;= arr[child])</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">arr[parent] = arr[child];</span><br><span class="line">parent = child;</span><br><span class="line">child = <span class="number">2</span> * child + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">arr[parent] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buildHeap</span><span class="params">(<span class="keyword">int</span> arr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length/<span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">downAdjust(arr, i, arr.length);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><p>本题就是对快速排序和堆排序的延伸。</p></li><li><p>k小于等于0的情况别忘记了</p></li><li><p>方法二，只需要在原始数组中进行读入操作，而所有的写操作和判断都是在容器中进行的，不用反复读取原始数组，思想非常好。</p></li><li><p>记得要弄清楚是否可以改变原始输入的数组。</p></li><li><p>partition函数：即是快速排序的基础，也可以用来查找n个数中第k大的数字。</p></li><li><p>当涉及到频繁查找和替换最大最小值时，二叉树是非常合适的数据结构，要能想到堆和二叉树。</p></li></ol><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="剑指Offer" scheme="https://www.blogs.rhsphere.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="Heap" scheme="https://www.blogs.rhsphere.com/tags/Heap/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer(39) 数组中出现次数超过一半的数字</title>
    <link href="https://www.blogs.rhsphere.com/2019/07/28/more-than-hanlf-number.html"/>
    <id>https://www.blogs.rhsphere.com/2019/07/28/more-than-hanlf-number.html</id>
    <published>2019-07-28T11:33:07.000Z</published>
    <updated>2019-07-29T05:12:35.937Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><h2 id="数组中出现次数超过一半的数字"><a href="#数组中出现次数超过一半的数字" class="headerlink" title="数组中出现次数超过一半的数字"></a>数组中出现次数超过一半的数字</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>  数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1, 2, 3, 2, 2, 2, 5, 4, 2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>思路一：数字次数超过一半，则说明：排序之后数组中间的数字一定就是所求的数字。</p><p>　　利用partition()函数获得某一随机数字，其余数字按大小排在该数字的左右。若该数字下标刚好为n/2，则该数字即为所求数字；若小于n/2，则在右边部分继续查找；反之，左边部分查找。</p><p>　　思路二：数字次数超过一半，则说明：该数字出现的次数比其他数字之和还多</p><p>　　遍历数组过程中保存两个值：一个是数组中某一数字，另一个是次数。遍历到下一个数字时，若与保存数字相同，则次数加1，反之减1。若次数=0，则保存下一个数字，次数重新设置为1。由于要找的数字出现的次数比其他数字之和还多，那么要找的数字肯定是最后一次把次数设置为1的数字。</p><p>　　也可以这样理解（来源：牛客网 cm问前程）：</p><p>　　采用阵地攻守的思想：<br>　　第一个数字作为第一个士兵，守阵地；count = 1；<br>　　遇到相同元素，count++;<br>　　遇到不相同元素，即为敌人，同归于尽,count–；当遇到count为0的情况，又以新的i值作为守阵地的士兵，继续下去，到最后还留在阵地上的士兵，有可能是主元素。<br>　　再加一次循环，记录这个士兵的个数看是否大于数组一般即可。</p><h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><ol><li><p>功能测试（存在或者不存在超过数组长度一半的数字）</p></li><li><p>特殊测试（null、1个数字）</p></li></ol><h2 id="java代码"><a href="#java代码" class="headerlink" title="java代码"></a>java代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 剑指offer39</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: rhsphere</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>: 2019-07-28 20:21 by jdk 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MoreThanHalfNumber</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> isInputInvalid = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法一：partition方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">moreThanHalfNum</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high = arr.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> index = partition(arr, low, high);</span><br><span class="line">        <span class="keyword">while</span> (index != arr.length &gt;&gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (index &lt; arr.length &gt;&gt; <span class="number">1</span>) &#123;</span><br><span class="line">                low = index + <span class="number">1</span>;</span><br><span class="line">                index = partition(arr, low, high);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                high = index - <span class="number">1</span>;</span><br><span class="line">                index = partition(arr, low, high);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断次数是否超过一半</span></span><br><span class="line">        <span class="keyword">int</span> num = arr[index];</span><br><span class="line">        <span class="keyword">int</span> times = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] == num) &#123;</span><br><span class="line">                times++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (times * <span class="number">2</span> &gt; arr.length) &#123;</span><br><span class="line">            isInputInvalid = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//partition简洁的的单边循环法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pivot = arr[low];</span><br><span class="line">        <span class="keyword">int</span> mark = low;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = low + <span class="number">1</span>; i &lt;= high; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt; pivot) &#123;</span><br><span class="line">                mark++;</span><br><span class="line">                <span class="keyword">int</span> tmp = arr[mark];</span><br><span class="line">                arr[mark] = arr[i];</span><br><span class="line">                arr[i] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[low] = arr[mark];</span><br><span class="line">        arr[mark] = pivot;</span><br><span class="line">        <span class="keyword">return</span> mark;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法二</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">moreThanHalfNum</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> num = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                num = arr[i];</span><br><span class="line">                count++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[i] == num) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                count--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> times = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[i] == num) &#123;</span><br><span class="line">                    times++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (times * <span class="number">2</span> &gt; arr.length) &#123;</span><br><span class="line">                isInputInvalid = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><p>length/2 用 length&gt;&gt;1 来代替，具有更高的效率</p></li><li><p>本题中，找到了所求数字，别忘记判断该数字的次数是否超过一半，感觉很容易忘记进行判断。</p></li><li><p>题目所要求的返回值为int，所以如果数组不满足要求时，无法通过返回值来告知是否出错，所以这道题设置了一个全局变量来进行判断。调用该方法时，需要记得对全局变量进行检查。</p></li><li><p>方法一中，采用了partition()函数，该函数会改变修改的数组，因此在面试的时候，需要和面试官讨论是否可以修改数组。</p></li><li><p>两种方法的时间复杂度均为O(n)。</p></li></ol><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="剑指Offer" scheme="https://www.blogs.rhsphere.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="Array" scheme="https://www.blogs.rhsphere.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer(38) 字符串的排列</title>
    <link href="https://www.blogs.rhsphere.com/2019/07/26/string-permutation.html"/>
    <id>https://www.blogs.rhsphere.com/2019/07/26/string-permutation.html</id>
    <published>2019-07-26T01:47:20.000Z</published>
    <updated>2019-07-26T02:44:15.529Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><h2 id="字符串的排列"><a href="#字符串的排列" class="headerlink" title="字符串的排列"></a>字符串的排列</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>　输入一个字符串，打印出该字符串中字符的所有排列。例如输入字符串abc，则打印出由字符a、b、c所能排列出来的所有字符串abc、acb、bac、bca、cab和cba。（本文代码采用ArrayList<string>接收返回的字符串，并要求不出现重复字符串）</string></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>将字符串看成两部分，一部分是第一个字符，另一部分是后面的所有字符。</p><p>首先确定第一个字符，该字符可以是字符串中的任意一个；固定第一个字符后，求出后面所有字符的排列（相同步骤，采用递归）。</p><p>实现第一个字符的改变，只需要将第一个字符和后面所有字符交换即可。要记得字符串输出后，要将字符交换回来，变成原始的字符串。</p><p>使用递归每次处理一个位置，第一个位置有n种选择，第二个位置有n-1种选择</p><p><strong>假设当前位置是index，需要把其他位置的元素放到index上，则可以将该元素和index位置上的元素交换，这样原来index位置上的元素可以作为下一轮递归函数的index候选之一</strong></p><p>再一次循环中，交换完元素，调用递归函数，最后还需要再交换刚才的两个元素，相当于复原了当前递归函数中的str，在下一轮循环中考虑该index位置上的其他可能的选项。</p><h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><ol><li><p>功能测试（有多个重复字母的字符串、所有字符相同的字符串、一个字符或者多个字符的普通字符串）</p></li><li><p>特殊测试（字符串为null、“”）</p></li></ol><h2 id="java代码"><a href="#java代码" class="headerlink" title="java代码"></a>java代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 剑指offer38 字符串的排列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: rhsphere</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>: 2019-07-26 09:46 by jdk 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringPermutation</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;String&gt; <span class="title">permutation</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (str == <span class="keyword">null</span> || str.length == <span class="number">0</span>) </span><br><span class="line"><span class="keyword">return</span> list;</span><br><span class="line">permutationCore(str.toCahrArray(), <span class="number">0</span>, list);</span><br><span class="line">Collections.sort(list);</span><br><span class="line"><span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">permutationCore</span><span class="params">(<span class="keyword">char</span>[] arr, <span class="keyword">int</span> index, ArrayList&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (index == arr.length - <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (!list.contains(String.valueOf(arr)))  <span class="comment">//判断是否有重复字符</span></span><br><span class="line">list.add(String.valueOf(arr));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; arr.length; i++) &#123;</span><br><span class="line">swap(arr, index, i);</span><br><span class="line">permutationCore(arr, index + <span class="number">1</span>, list);</span><br><span class="line">swap(arr, index, i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span>[] arr, <span class="keyword">int</span> index, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> tmp = <span class="keyword">char</span>[index];</span><br><span class="line"><span class="keyword">char</span>[inde] = <span class="keyword">char</span>[i];</span><br><span class="line"><span class="keyword">char</span>[i] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><p>要对字符串进行修改，可以将字符串转化为字符数组进行修改，也可以考虑使用StringBuilder类。</p></li><li><p>list.contains()方法可以直接判断是否有重复字符串；Collections.sort(list)可以将list中的字符串进行排序。</p></li><li><p>字符串和字符数组间的转化：str.toCharArray()     String.valueOf(strArray)</p></li><li><p>数组在递归过程中进行了交换后，最终要记得交换回来（代码最后几行）</p></li></ol><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="剑指Offer" scheme="https://www.blogs.rhsphere.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="String" scheme="https://www.blogs.rhsphere.com/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer(37) 序列化二叉树</title>
    <link href="https://www.blogs.rhsphere.com/2019/07/25/serialize-binary-tree.html"/>
    <id>https://www.blogs.rhsphere.com/2019/07/25/serialize-binary-tree.html</id>
    <published>2019-07-25T14:10:32.000Z</published>
    <updated>2019-07-26T01:45:43.484Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><h2 id="序列化二叉树"><a href="#序列化二叉树" class="headerlink" title="序列化二叉树"></a>序列化二叉树</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>请实现两个函数，分别用来序列化和反序列化二叉树。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>一般情况下，需要采用前/后序遍历和中序遍历才能确定一个二叉树，但是其实可以只采用前序遍历（从根节点开始），将空节点（null)输出为一个特殊符号（如“$”），就可以确定一个二叉树了。</p><p>　将二叉树序列化为字符串，就是前序遍历的过程，遇见空结点时，序列化为“$”，每个结点间使用逗号分隔开。</p><p>　　将字符串反序列化为二叉树，也使用前序遍历，遇见一个新数字(或者$)就建立一个新结点，不过需要注意的是，数字可能不只是个位数字，因此创建了一个全局Int变量index（在字符串上的移动的指针），以便于截取字符串中当前的结点值。（详见代码）</p><h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><ol><li>功能测试（一个节点；左右斜树；完全二叉树；普通二叉树）</li><li>特殊测试（根节点为null）</li></ol><h2 id="java代码"><a href="#java代码" class="headerlink" title="java代码"></a>java代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 请实现两个函数，分别用来序列化和反序列化二叉树</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: rhsphere</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>: 2019-07-25 22:05 by jdk 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializeBinaryTrees</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line">TreeNode left, right;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.val = val;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">sb.append(<span class="string">"$,"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">sb.append(node.val + <span class="string">","</span>);</span><br><span class="line">sb.append(serialize(node.left));</span><br><span class="line">sb.append(serialize(node.right));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">TreeNode node = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (str == <span class="keyword">null</span> || str.length &lt;= <span class="number">0</span>) </span><br><span class="line"><span class="keyword">return</span> node;</span><br><span class="line"><span class="keyword">int</span> start = index;</span><br><span class="line"><span class="keyword">while</span> (str.charAt(index) != <span class="string">','</span>)</span><br><span class="line">index++;</span><br><span class="line"><span class="keyword">if</span> (!str.substring(start, index).equals(<span class="string">"$"</span>)) &#123;</span><br><span class="line">node = <span class="keyword">new</span> TreeNode(Integer.parseInt(str.substring(start, index)));</span><br><span class="line">index++;</span><br><span class="line">node.left = deserialize(str);</span><br><span class="line">node.right = deserialize(str);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">index++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><p>记住这种序列化的方式，用于表示二叉树时非常方便。</p></li><li><p>字符串中有分割符号时，可以对字符串采用split()方法，变为字符串数组，但是自己觉得数组的保存会消耗一定的空间，因此自己定义了全局变量index，通过substring()方法来截取每一部分的字符串。</p></li><li><p>字符串的比较以后尽量用equal来比较。在对某字符串采用substring()方法得到的字符串用==判断会返回false。substring的==与equal()使用</p></li><li><p>String 转int 类型采用 int i = Integer.parseInt( s ); 不能用Integer.valueOf(s)，这返回的是Integer对象。</p></li><li><p>index++的位置一定不能放错</p></li></ol><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="剑指Offer" scheme="https://www.blogs.rhsphere.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="Tree" scheme="https://www.blogs.rhsphere.com/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer(36) 二叉搜索树与双向链表</title>
    <link href="https://www.blogs.rhsphere.com/2019/07/14/convert-binary-search-tree.html"/>
    <id>https://www.blogs.rhsphere.com/2019/07/14/convert-binary-search-tree.html</id>
    <published>2019-07-14T11:45:49.000Z</published>
    <updated>2019-07-14T12:50:09.727Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><h2 id="二叉搜索树与双向链表"><a href="#二叉搜索树与双向链表" class="headerlink" title="二叉搜索树与双向链表"></a>二叉搜索树与双向链表</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>  输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表，要求不能创建任何新的节点，只能调整树中节点指针。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><pre><code>二叉搜索树、排序链表，想到使用中序遍历。</code></pre><p>要实现双向链表，必须知道当前节点的前一个节点。根据中序遍历，可以知道，当遍历到根节点的时候，左子树已经转化成了一个排序的链表了，根节点的前一节点就是该链表的最后一个节点（这个节点必须记录下来，将遍历函数的返回值设置为该节点即可），连接根节点和前一个节点，此时链表最后一个节点就是根节点了。再处理右子树，遍历右子树，将右子树的最小节点和根节点连接起来即可。左右子树的转化采用递归即可。</p><p>首先想象一下中序遍历的大概代码结构（先处理左子树，再处理根节点，之后处理右子树），假设左子树处理完了，就要处理根节点，而根节点必须知道左子树的最大节点，所以要用函数返回值记录下来；之后处理右子树，右子树的最小节点（也是用中序遍历得到）要和根节点链接。</p><h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><ol><li>功能测试(一个节点；左、右斜树；完全二叉树；普通二叉树)</li><li>特殊测试(根节点为null)</li></ol><h2 id="java代码"><a href="#java代码" class="headerlink" title="java代码"></a>java代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="剑指Offer" scheme="https://www.blogs.rhsphere.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="Tree" scheme="https://www.blogs.rhsphere.com/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer(35) 复杂链表的复制</title>
    <link href="https://www.blogs.rhsphere.com/2019/07/12/cpoy-complex-list.html"/>
    <id>https://www.blogs.rhsphere.com/2019/07/12/cpoy-complex-list.html</id>
    <published>2019-07-12T07:05:19.000Z</published>
    <updated>2019-07-14T06:52:57.482Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><h2 id="复杂链表的复制"><a href="#复杂链表的复制" class="headerlink" title="复杂链表的复制"></a>复杂链表的复制</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>　请实现函数ComplexListNode<em> Clone(ComplexListNode</em> pHead)，复制一个复杂链表。在复杂链表中，每个结点除了有一个m_pNext指针指向下一个点外，还有一个m_pSibling 指向链表中的任意结点或者nullptr。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>思路1：先复制结点，用next链接，最后根据原始结点的sibling指针确定该sibling结点距离头结点的位置，从而对复制结点设置sibling指针。但是该思路对于n个结点的链表，每个结点的sibling都需要O(n)个时间步才能找到，所以时间复杂度为O(n^2)</p><p>　　思路2：复制原始结点N创建N’，用next链接。将&lt;N,N’&gt;的配对信息存放入一个哈希表中；在设置sibling时，通过哈希表，只需要用O(1)的时间即可找到复制结点的sibling。该方法的时间复杂度为O(n)，但空间复杂度为O(n)。</p><p>　　思路3：复制原始结点N创建N’，将N’链接到N的后面；根据原始结点N的sibling可以快速设置N’结点的sibling，最后将这个长链表拆分成原始链表和复制链表（根据奇偶位置）</p><h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><ol><li>功能测试（sibling指向自己；链表只有一个节点；sibling指向null或者指向节点）</li><li>特殊测试（头结点为null）</li></ol><h2 id="java代码"><a href="#java代码" class="headerlink" title="java代码"></a>java代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 剑指offer35题</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: rhsphere</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>: 2019-07-12 15:15 by jdk 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyComplexList</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComplexListNode</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line">ComplexListNode next, sibling;</span><br><span class="line">ComplexListNode(<span class="keyword">int</span> val) &#123;</span><br><span class="line"><span class="keyword">this</span>.val = val;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主程序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ComplexListNode <span class="title">cloneList</span><span class="params">(ComplexListNode head)</span> </span>&#123;</span><br><span class="line">cloneNodes(head);</span><br><span class="line">connectSiblingNodes(head);</span><br><span class="line"><span class="keyword">return</span> reconnectNodes(head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.第一步，复制每个节点，并插入到原节点后面</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cloneNodes</span><span class="params">(ComplexListNode head)</span> </span>&#123;</span><br><span class="line">ComplexListNode pNode = head;</span><br><span class="line"><span class="keyword">while</span> (pNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">ComplexListNode clonedNode = <span class="keyword">new</span> ComplexListNode(pNode.val);</span><br><span class="line">clonedNode.next = pNode.next;</span><br><span class="line">pNode.next = clonedNode;</span><br><span class="line">pNode = clonedNode.next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.第二步，根据原节点的位置，设置sibling的指针</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> ComplexListNode <span class="title">connectSiblingNodes</span><span class="params">(ComplexListNode head)</span> </span>&#123;</span><br><span class="line">ComplexListNode pHead = head;</span><br><span class="line"><span class="keyword">while</span> (pNode != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (pNode.sibling != <span class="keyword">null</span>) </span><br><span class="line">pNode.next.sibling = pNode.sibling.next;</span><br><span class="line">pNode = pNode.next.next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3.第三步，将长链表拆分成原始链表和复制链表（按照奇偶位置）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ComplexListNode <span class="title">reconnectNodes</span><span class="params">(ComplexListNode head)</span> </span>&#123;</span><br><span class="line">ComplexListNode clonedHead = <span class="keyword">null</span>;</span><br><span class="line">ComplexListNode clonedNode = <span class="keyword">null</span>;</span><br><span class="line">ComplexListNode pNode = head;</span><br><span class="line"><span class="keyword">if</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">clonedHead = head.next;</span><br><span class="line">clonedNode = pNode.next;</span><br><span class="line">pNode.next = clonedNode.next;</span><br><span class="line">pNode = pNode.next; <span class="comment">//提前将pNode指向下一个结点，方便判断是否为null</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (pNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">clonedNode.next = pNode.next;</span><br><span class="line">clonedNode = clonedNode.next;</span><br><span class="line">pNode.next = clonedNode.next;</span><br><span class="line">pNode = pNode.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> clonedHead;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>有关于拆分函数，需要画图分析，才能厘清思路；</li><li>复制链表时，在演示节点后面直接插入复制节点，这种方法很方便，有较高的效率。</li></ol><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="剑指Offer" scheme="https://www.blogs.rhsphere.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="LinkedList" scheme="https://www.blogs.rhsphere.com/tags/LinkedList/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer(34) 二叉树中和为某一值的路径</title>
    <link href="https://www.blogs.rhsphere.com/2019/07/11/path-in-tree.html"/>
    <id>https://www.blogs.rhsphere.com/2019/07/11/path-in-tree.html</id>
    <published>2019-07-11T08:47:27.000Z</published>
    <updated>2019-07-12T03:05:53.096Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><h2 id="二叉树中和为某一值的路径"><a href="#二叉树中和为某一值的路径" class="headerlink" title="二叉树中和为某一值的路径"></a>二叉树中和为某一值的路径</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始一直到也借点所经过的节点形成一条路径。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>假设找到了其中一条路径，达到叶结点后，由于没有指向父节点的指针，所以必须 <strong>提前创建一个链表</strong> 存储前面经过的节点。</li><li>由于从根节点出发，所以要想用到使用前序遍历。</li><li><p>利用率I按表存储节点，在该节点完成左右子树的路径搜索后（即递归函数结束，返回到其父节点后），要删除 <strong>该节点</strong>，从而记录别的路径。</p><p> 具体实现：通过前序遍历，从根节点出发，每次在链表中存储便利到的节点，若到达叶子节点，则根据所有节点的和是否等于输入的整数，判断是否打印输出。在当前节点访问结束后，递归函数将会返回到它的父节点，所以在函数退出之前，要删除链表中的当前节点，以确保返回父节点是，储存的路径刚好是从根节点到父节点。</p></li></ol><h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><ol><li>功能测试（一条或者多条对应的路径，无对应路径，节点值为正负零）</li><li>特殊测试（根节点为null）</li></ol><h2 id="java代码"><a href="#java代码" class="headerlink" title="java代码"></a>java代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:题目：输入一棵二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: rhsphere</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>: 2019-07-11 16:58 by jdk 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PathInTree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">        TreeNode left, right;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findPath</span><span class="params">(TreeNode root, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    ArrayList&lt;TreeNode&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    printPath(root, target, list);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printPath</span><span class="params">(TreeNode node, <span class="keyword">int</span> target, ArrayList&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    list.add(node.val);</span><br><span class="line">    target -= node.val;</span><br><span class="line">    <span class="keyword">if</span> (target == <span class="number">0</span> &amp;&amp; node.left == <span class="keyword">null</span> &amp;&amp; node.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Integer integer : list) &#123;</span><br><span class="line">    System.out.print(integer + <span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    printPath(node.left, target, list);</span><br><span class="line">    printPath(node.right, target, list);</span><br><span class="line">    &#125;</span><br><span class="line">    list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="牛客网代码"><a href="#牛客网代码" class="headerlink" title="牛客网代码"></a>牛客网代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 几个要点：</span></span><br><span class="line"><span class="comment"> * 1. 将nodeList和pathList定义成全局变量，避免在方法中的多次传递</span></span><br><span class="line"><span class="comment"> * 2. 在pathList中添加nodeList时，因为nodeList会不断变化，所以必须新建一个list存入</span></span><br><span class="line"><span class="comment"> *    复制ArrayList的方法：newList=new ArrayList&lt;Integer&gt;(oldList)(复制内容，而不是复制地址，</span></span><br><span class="line"><span class="comment"> *    注意与newList=oldList的区分）</span></span><br><span class="line"><span class="comment"> * 3. 在当前结点完成左右子树的路径搜索后，记得删除nodeList中的当前结点</span></span><br><span class="line"><span class="comment"> * 4. target是基本数据类型int，不会受到方法的影响而改变</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PathInTree2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">        TreeNode left, right;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Integer&gt; nodeList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; pathList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    pubilc ArrayList&lt;ArrayList&lt;Integer&gt;&gt; findPath(TreeNode node, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">return</span> pathList;</span><br><span class="line">    nodelist.add(node.val);</span><br><span class="line">    target -= node.val;</span><br><span class="line">    <span class="keyword">if</span> (target == <span class="number">0</span> &amp;&amp; node.left == <span class="keyword">null</span> &amp;&amp; node.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; pathList.size() &amp;&amp; nodeList.size() &lt; pathList.get(i).size())</span><br><span class="line">    i++;</span><br><span class="line">    path.add(i, <span class="keyword">new</span> ArrayList&lt;Integer&gt;(nodeList));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    pathList = findPath(node.left, target);</span><br><span class="line">    pathList = findPath(node.right, target);</span><br><span class="line">    &#125;</span><br><span class="line">    nodeList.remove(nodeList.size() - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> pathList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>二叉树的许多题目都与遍历（包括层次遍历）有关，要深刻理解；根据节点的位置判断使用哪一种遍历。</li><li>而二叉树遍历过程没有父节点指针，要保存路径的话，需要创建容器存储之前的节点。</li><li>熟悉这道题中在每次递归函数结束前删除当前节点的操作，这可以确保返回到父节点时路径刚好是从根节点到父节点。</li></ol><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="剑指Offer" scheme="https://www.blogs.rhsphere.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="Tree" scheme="https://www.blogs.rhsphere.com/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer(33) 二叉搜索树的后续遍历序列</title>
    <link href="https://www.blogs.rhsphere.com/2019/07/11/sequence-of-BST.html"/>
    <id>https://www.blogs.rhsphere.com/2019/07/11/sequence-of-BST.html</id>
    <published>2019-07-11T08:26:29.000Z</published>
    <updated>2019-07-11T08:38:04.787Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><h2 id="二叉搜索数的后续遍历序列"><a href="#二叉搜索数的后续遍历序列" class="headerlink" title="二叉搜索数的后续遍历序列"></a>二叉搜索数的后续遍历序列</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>　输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则返回true，否则返回false。假设输入的数组的任意两个数字都互不相同。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>二叉树后续遍历数组的最后一个数为根节点，剩余数字中，小于根节点的数字（即左子树部分）都排在前面，大于根节点的数字（即右子树部分）都排在后面。<br>根据遍历数组的这个特性，可以编写一个递归函数，用于实现题目所要求的判断功能。</p><h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><ol><li>功能测试（左斜、右斜、能对应的二叉树、不能对应的二叉树）</li><li>特殊测试（null、一个节点）</li></ol><h2 id="java代码"><a href="#java代码" class="headerlink" title="java代码"></a>java代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 剑指offer28</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: rhsphere</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>: 2019-07-11 15:24 by jdk 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SequeneceOfBST</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">        TreeNode left, right;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">verifySequenceOfBST</span><span class="params">(<span class="keyword">int</span>[] sequence)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sequence == <span class="keyword">null</span> || sequence.length &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> verifyCore(sequence, <span class="number">0</span>, sequence.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">verifyCore</span><span class="params">(<span class="keyword">int</span>[] sequence, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt;= end)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = start;</span><br><span class="line">    <span class="keyword">while</span> (sequence[mid] &lt; sequence[end])</span><br><span class="line">    mid++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = mid; i &lt; end; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (sequence[i] &lt; sequence[end])</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> verifyCore(sequence, start, mid - <span class="number">1</span>) </span><br><span class="line">       &amp;&amp; verifyCore(sequence, mid, end - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><p>寻找出序列规律，就能较快得到思路。此题如果改为BST的前序遍历也是相同的思路。</p></li><li><p>对于要求处理二叉树序列的问题：找到根结点后，拆分出左右子树，对左右子树可以进行递归处理。</p></li></ol><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="剑指Offer" scheme="https://www.blogs.rhsphere.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="Tree" scheme="https://www.blogs.rhsphere.com/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer(32) 从上到下打印二叉树</title>
    <link href="https://www.blogs.rhsphere.com/2019/07/10/print-tree.html"/>
    <id>https://www.blogs.rhsphere.com/2019/07/10/print-tree.html</id>
    <published>2019-07-10T11:04:59.000Z</published>
    <updated>2019-07-11T08:25:42.318Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><h1 id="从上往下打印二叉树"><a href="#从上往下打印二叉树" class="headerlink" title="从上往下打印二叉树"></a>从上往下打印二叉树</h1><h2 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h2><p>（一）从上往下打印出二叉树的每一个节点，每一层的节点按照从左到右的顺序打印。</p><h3 id="思路和代码"><a href="#思路和代码" class="headerlink" title="思路和代码"></a>思路和代码</h3><p>不分行从上到下打印二叉树，即二叉树的层序遍历，节点满足先进先出的原则，采用队列。每从队列取出头部节点并打印，若有子节点，把子节点放入队列尾部，直到所有节点打印完毕。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 层序遍历</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: rhsphere</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>: 2019-07-10 19:08 by jdk 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintTree1</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">TreeNode left, right;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.val = val;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printTree1</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) </span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">queue.add(root);</span><br><span class="line"><span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">TreeNode node = queue.element();</span><br><span class="line"><span class="keyword">if</span> (node.left != <span class="keyword">null</span>)</span><br><span class="line">queue.add(node.left);</span><br><span class="line"><span class="keyword">if</span> (node.right != <span class="keyword">null</span>)</span><br><span class="line">queue.add(node.right);</span><br><span class="line">System.out.print(queue.remove().val + <span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h2><p>（二）从上到下按层打印二叉树，同一层的结点按从左到右的顺序打印，每一层打印到一行。</p><h3 id="思路和代码-1"><a href="#思路和代码-1" class="headerlink" title="思路和代码"></a>思路和代码</h3><p>同样使用队列，但是比第一题增加两个变来给你：当前层节点数目pCount，下一层节点数目nextCount。根据当前成节点数目来打印当前层节点，同时计算下一层节点数目，之后令pCount等于nextCount，重复循环，知道打印完毕。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">**</span><br><span class="line"> * <span class="meta">@description</span>:</span><br><span class="line"> * <span class="meta">@author</span>: rhsphere</span><br><span class="line"> * <span class="meta">@since</span>: <span class="number">2019</span>-<span class="number">07</span>-<span class="number">10</span> <span class="number">21</span>:<span class="number">03</span> by jdk <span class="number">1.8</span></span><br><span class="line"> */</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintTree2</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printTree2</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">queue.add(root);</span><br><span class="line">TreeNode current;</span><br><span class="line"><span class="keyword">int</span> pCount = <span class="number">0</span>; <span class="comment">//当前层的节点数</span></span><br><span class="line"><span class="keyword">int</span> nextCount = <span class="number">1</span>; <span class="comment">//下一层节点数</span></span><br><span class="line"><span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">pCount = nextCount;</span><br><span class="line">nextCount = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= pCount; i++) &#123;</span><br><span class="line">current =  queue.element();</span><br><span class="line"><span class="keyword">if</span> (current.left ！= <span class="keyword">null</span>) &#123;</span><br><span class="line">queue.offer(current.left);</span><br><span class="line">nextCount++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (current.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">queue.offer(current.right);</span><br><span class="line">nextCount++;</span><br><span class="line">&#125;</span><br><span class="line">System.out.print(queue.remove().val + <span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目三"><a href="#题目三" class="headerlink" title="题目三"></a>题目三</h2><p>（三）请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</p><h3 id="思路和代码-2"><a href="#思路和代码-2" class="headerlink" title="思路和代码"></a>思路和代码</h3><p>采用两个栈，对于不同层的节点，一个栈用于正向存储，一个栈用于逆向存储，打印出来就正好是相反方向。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: rhsphere</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>: 2019-07-11 10:33 by jdk 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintTree3</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printTree3</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">Stack&lt;TreeNode&gt; stack1 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">Stack&lt;TreeNode&gt; stack2 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">TreeNode node = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">stack1.push(root);</span><br><span class="line"><span class="keyword">while</span> (!stack.empty() || !stack.empty()) &#123;</span><br><span class="line"><span class="keyword">while</span> (!stack.empty()) &#123;</span><br><span class="line">node = stack1.pop();</span><br><span class="line"><span class="keyword">if</span> (node.left != <span class="keyword">null</span>)</span><br><span class="line">stack2.push(node.left);</span><br><span class="line"><span class="keyword">if</span> (node.right != <span class="keyword">null</span>)</span><br><span class="line">stack2.push(node.right);</span><br><span class="line">System.out.println(node.val + <span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line"><span class="keyword">while</span> (!stack2.empty()) &#123;</span><br><span class="line">node = stack2.pop();</span><br><span class="line"><span class="keyword">if</span> (node.right != <span class="keyword">null</span>)</span><br><span class="line">stack1.push(node.right);</span><br><span class="line"><span class="keyword">if</span> (node.left != <span class="keyword">null</span>)</span><br><span class="line">stack1.push(node.left);</span><br><span class="line">System.out.print(node.val + <span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="剑指Offer" scheme="https://www.blogs.rhsphere.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="Tree" scheme="https://www.blogs.rhsphere.com/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer(28) 对称的二叉树</title>
    <link href="https://www.blogs.rhsphere.com/2019/07/09/symmetrical-binary-tree.html"/>
    <id>https://www.blogs.rhsphere.com/2019/07/09/symmetrical-binary-tree.html</id>
    <published>2019-07-09T02:55:04.000Z</published>
    <updated>2019-07-09T03:13:20.024Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><h2 id="对称的二叉树"><a href="#对称的二叉树" class="headerlink" title="对称的二叉树"></a>对称的二叉树</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>还是画图分析，不用分析根结点，只需要分析左右子树。可以看出，左右子树刚好是呈镜像的两颗二叉树，所以：对左子树采用（父-左-右）的前序遍历，右子树采用（父-右-左）的前序遍历，遍历时判断两个结点位置的值是否相等即可。</p><p>也可以这样理解：左树的左子树等于右树的右子树，左树的右子树等于右树的左子树，对应位置刚好相反，判断两子树相反位置上的值是否相等即可。</p><p>使用递归。</p><h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><ol><li>功能测试（对称二叉树；结构不对称的二叉树；结构对称但值不对称二叉树）</li><li>特殊测试（根节点为null；单个节点；所有节点的值都相等的二叉树）</li></ol><h2 id="java代码"><a href="#java代码" class="headerlink" title="java代码"></a>java代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: rhsphere</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>: 2019-07-09 10:18 by jdk 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SymmetricalBinaryTree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetrical</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">//根节点为null时，认为是对称的</span></span><br><span class="line">    <span class="keyword">return</span> isEqual(root.left, root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isEqual</span><span class="params">(TreeNode la, TreeNode lb)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (la == <span class="keyword">null</span> &amp;&amp; lb == <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (la == <span class="keyword">null</span> || lb == <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> la.val == lb.val</span><br><span class="line">       &amp;&amp; isEqual(la.left, lb.right)</span><br><span class="line">       &amp;&amp; isEqual(la.right, lb.left);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="剑指Offer" scheme="https://www.blogs.rhsphere.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="Tree" scheme="https://www.blogs.rhsphere.com/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer(27) 二叉树的镜像</title>
    <link href="https://www.blogs.rhsphere.com/2019/07/09/mirror-of-binary-tree.html"/>
    <id>https://www.blogs.rhsphere.com/2019/07/09/mirror-of-binary-tree.html</id>
    <published>2019-07-09T01:46:35.000Z</published>
    <updated>2019-07-09T02:54:36.991Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><h2 id="二叉树的镜像"><a href="#二叉树的镜像" class="headerlink" title="二叉树的镜像"></a>二叉树的镜像</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>先画图，可以看到用递归很容易求解：先前序遍历，对每个节点交换左右子节点。</p><p>递归使用的3个条件：1）一个问题的解可以分解成几个问题的解；2）这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样；3）存在递归终止条件。</p><h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><ol><li>功能测试（普通二叉树；左斜树、右斜树；一个节点）</li><li>特殊测试（根节点为null）</li></ol><h2 id="java代码"><a href="#java代码" class="headerlink" title="java代码"></a>java代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 输入一个二叉树，该函数输出它的镜像</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: rhsphere</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>: 2019-07-09 10:16 by jdk 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MirrorOfBinaryTree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mirror</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//交换左右子节点</span></span><br><span class="line">        TreeNode tmpNode = root.left;</span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = tmpNode;</span><br><span class="line"></span><br><span class="line">        mirror(root.left);</span><br><span class="line">        mirror(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="剑指Offer" scheme="https://www.blogs.rhsphere.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="Tree" scheme="https://www.blogs.rhsphere.com/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>堆、堆排序、优先队列总结</title>
    <link href="https://www.blogs.rhsphere.com/2019/07/09/heap-heapsort-priorityqueue.html"/>
    <id>https://www.blogs.rhsphere.com/2019/07/09/heap-heapsort-priorityqueue.html</id>
    <published>2019-07-09T01:20:48.000Z</published>
    <updated>2019-07-09T01:27:02.188Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><h2 id=""><a href="#" class="headerlink" title=" "></a> </h2><p><a href="https://blogs.rhsphere.com/leetcode/2019/07/08/heap.html" target="_blank" rel="noopener">1. Heap（堆）</a></p><p><a href="https://blogs.rhsphere.com/leetcode/2019/04/01/heapsort-easy.html" target="_blank" rel="noopener">2. HeapSort（堆排序）</a></p><p><a href="https://blogs.rhsphere.com/leetcode/2019/07/08/priority-queue.html" target="_blank" rel="noopener">3. PriorityQueue（优先队列）</a></p><p><a href="https://blogs.rhsphere.com/leetcode/2019/03/06/stack-queue-priorityQueue.html" target="_blank" rel="noopener">4. PriorityQueue with Generic Type （优先队列-泛型）</a></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Sum-up" scheme="https://www.blogs.rhsphere.com/categories/Sum-up/"/>
    
    
      <category term="Heap" scheme="https://www.blogs.rhsphere.com/tags/Heap/"/>
    
      <category term="PriorityQueue" scheme="https://www.blogs.rhsphere.com/tags/PriorityQueue/"/>
    
      <category term="HeapSort" scheme="https://www.blogs.rhsphere.com/tags/HeapSort/"/>
    
  </entry>
  
  <entry>
    <title>堆</title>
    <link href="https://www.blogs.rhsphere.com/2019/07/08/heap.html"/>
    <id>https://www.blogs.rhsphere.com/2019/07/08/heap.html</id>
    <published>2019-07-08T12:10:22.000Z</published>
    <updated>2019-07-29T13:49:39.457Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><h2 id="堆的应用"><a href="#堆的应用" class="headerlink" title="堆的应用"></a>堆的应用</h2><p>重点掌握大顶堆的下沉操作，尤其函数 downAdjust(int[] arr, int parentIndex, int length)的实现。</p><h3 id="利用堆求-Top-K"><a href="#利用堆求-Top-K" class="headerlink" title="利用堆求 Top K"></a>利用堆求 Top K</h3><p>“求top K 问题”抽象成两类。一类是针对静态数据集合，也就是说数据集合事先确定，不会再变。另一类是针对静态数据集合，也就是说数据集合事先并不确定，有数据动态地加入到集合中。</p><p>针对静态数据，如何在一个包含n个数据的数组中，查找前K大数据呢？</p><p>可以维护一个大小为K的大顶堆，顺序遍历数组，从数组中去除数据与堆顶元素比较。如果比堆顶元素大，就把堆顶元素删除，并且将这个元素插入到堆中；如果比堆顶元素小，则不做处理，继续遍历数组。这样等数组中的数据都遍历完之后，堆中的数据就是前K大数据了。</p><p>遍历数组需要O(n)的时间复杂度，一次堆化操作需要O(logK)的时间复杂度，所以最坏情况下，n个元素都入堆一次，时间复杂度就是O(nlogK)。</p><p>针对动态数据求得Top K就是实时Top K。一个数据集合中有两个操作，一个是添加数据，另一个询问当前的前K大数据。</p><p>如果每次询问前K大数据，我们都给予当前的数据重新计算的话，那时间复杂度就是O(nlogK)，n表示当前的数据的大小。实际上，可以一直都维护一个K大小的小顶堆，当有数据被添加到集合中是，就拿它与堆顶的元素对比。如果比堆顶元素大，我们就把堆顶元素删除，并且将这个元素插入到堆中；如果比堆顶元素小，则不做处理。这样，无论任何时候需要查询当前的前K大数据，都可以立刻发那会给他。</p><h3 id="利用堆求中位数"><a href="#利用堆求中位数" class="headerlink" title="利用堆求中位数"></a>利用堆求中位数</h3><p>动态的求数据集合的中位数。 </p><p>这一小节只记录一些概念性的知识，对于具体内容查看极客时间专栏。</p><p>如果数据的个数是奇数，把数据从小到大排列，那第 n/2 + 1个数据就是中位数；如果数据是偶数的话，那么处于中间未知的数据有两个，第n/2个和第n/2 + 1个数据，这是随意取一个作为中位数。</p><p>99百分位响应时间。如果有n个数据，将数据从小到大排列之后，99百分位数大约就是第n * 99%个数据。</p><h2 id="堆的实现"><a href="#堆的实现" class="headerlink" title="堆的实现"></a>堆的实现</h2><p>下面实现的是大顶堆。<br>堆有自我调整的操作，对于二叉堆，有如下几种操作：</p><ul><li>插入节点。 插入位置总是位于二叉树的最后一个位置，然后作为childIndex和parentIndex比较大小。</li><li>删除节点。 总是删除堆顶的元素，然后把最后一个位置的元素放在堆顶，然后向下调整位置。</li><li>构建二叉树。本质上就是让所以非叶子节点依次下沉。</li></ul><p>下面证明，对于完全二叉树来说，<strong>下标从n/2 + 1 到 n的节点都是叶子节点</strong>？ 使用反证法证明即可：</p><p>使用数组存储表示完全二叉树时，从 <strong>数组下标为1开始存储数据，数组下标为i的节点，左子节点为2i, 右子节点为2i + 1.</strong> 这个结论很重要（可以用数学归纳法证明)，将此结论记为『原理1』，以下证明会用到这个原理。</p><p>如果下标为n/2 + 1的节点不是叶子节点，即它存在子节点，按照『原理1』，它的左子节点为：2(n/2 + 1) = n + 2，大家明显可以看出，这个数字已经大于n + 1，超出了实现完全二叉树所用数组的大小（数组下标从1开始记录数据，对于n个节点来说，数组大小是n + 1），左子节点都已经超出了数组容量，更何况右子节点。以此类推，很容易得出：下标大于n/2 + 1的节点肯定都是也叶子节点了，故而得出结论：对于完全二叉树来说，下标从n/2 + 1 到 n的节点都是叶子节点</p><p><strong>数组下标为0开始存储数据，数组下标为i的节点，左子节点为2i + 1, 右子节点为2i + 2。下标为n/2 到 n - 1的节点都是叶子节点，那么最后一个非叶子节点是n/2 - 1</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 二叉堆</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: rhsphere</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>: 2019-07-04 16:30 by jdk 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Heap</span> </span>&#123;</span><br><span class="line"><span class="comment">//上浮操作</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">upAdjust</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> childIndex = arr.length - <span class="number">1</span>;  <span class="comment">//孩子节点</span></span><br><span class="line"><span class="keyword">int</span> parentIndex = (childIndex - <span class="number">1</span>) / <span class="number">2</span>; </span><br><span class="line"><span class="comment">//保存插入的叶子节点值，用于最后的赋值</span></span><br><span class="line"><span class="keyword">int</span> tmp = arr[childIndex];</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (childIndex &gt; <span class="number">0</span> &amp;&amp; tmp &gt; arr[parentIndex]) &#123;</span><br><span class="line">arr[childIndex] = arr[parentIndex];</span><br><span class="line">childIndex = parentIndex;</span><br><span class="line">parentIndex = (parentIndex - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">arr[childIndex] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 下沉调整</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr          待调整的堆</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parentIndex  要下沉的父节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> length       堆的有效大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">downAdjust</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> parentIndex, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line"><span class="comment">//保存父节点的值，用于最后赋值</span></span><br><span class="line"><span class="keyword">int</span> tmp = arr[parentIndex];</span><br><span class="line"><span class="comment">//左孩子节点</span></span><br><span class="line"><span class="keyword">int</span> childIndex = <span class="number">2</span> * parentIndex + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (childIndex &lt; length) &#123;</span><br><span class="line"><span class="comment">//如果有右孩子节点，且右孩子的值大于左孩子的值，则定位到右孩子</span></span><br><span class="line"><span class="keyword">if</span> (childIndex + <span class="number">1</span> &lt; length &amp;&amp;</span><br><span class="line">arr[childIndex + <span class="number">1</span>] &gt; arr[childIndex]) &#123;</span><br><span class="line">childIndex++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果父节点大于等于，任何一个孩子的值，直接跳出</span></span><br><span class="line"><span class="keyword">if</span> (tmp &gt;= arr[childIndex])</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//给父节点单向赋值，最后的一个坑填上tmp即可</span></span><br><span class="line">arr[parentIndex] = arr[childIndex];</span><br><span class="line">parentIndex = childIndex;         <span class="comment">//父节点的下标</span></span><br><span class="line">childIndex = <span class="number">2</span> * parentIndex + <span class="number">1</span>;  <span class="comment">//左孩子节点下标</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最后一个坑位，填上tmp</span></span><br><span class="line">arr[parentIndex] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> staitc <span class="keyword">void</span> <span class="title">buildIndex</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line"><span class="comment">//从最后一个非叶子节点开始，依次下沉</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length/<span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">downAdjust(arr, i, arr.length);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Heap" scheme="https://www.blogs.rhsphere.com/categories/Heap/"/>
    
    
      <category term="Heap" scheme="https://www.blogs.rhsphere.com/tags/Heap/"/>
    
  </entry>
  
  <entry>
    <title>优先队列</title>
    <link href="https://www.blogs.rhsphere.com/2019/07/08/priority-queue.html"/>
    <id>https://www.blogs.rhsphere.com/2019/07/08/priority-queue.html</id>
    <published>2019-07-08T08:56:49.000Z</published>
    <updated>2019-07-29T13:49:41.166Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><h1 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h1><p>优先级队列还是一个队列，队列的最大特性仍是先进先出，不过在优先级队列中，数据的出对顺序不是按照先进先出，而是按照优先级来，优先级最高的最先出队。<br>最大优先级队列，无论入队顺序如何，都是当前最大的元素优先出队。<br>最小优先级队列，无论入队顺序如何，都是当前最小的元素优先出队。</p><h2 id="如何实现优先队列"><a href="#如何实现优先队列" class="headerlink" title="如何实现优先队列"></a>如何实现优先队列</h2><p>如何实现一个优先级队列？方法有很对，但是用堆来实现是最直接、最高效的。这是因为，堆和优先级队列非常相似，一个堆就可以看作一个优先级队列。很多时候，它们只是概念上的区分而已。<br>往优先级队列中插入一个元素，就相当于往堆中插入一个元素；从优先级队列中去除优先级最高的元素，就相当于取出堆顶元素。</p><p>优先级队应用场景非常多，比如，哈夫曼编码、图的最短路径、最小生成树算法等等。</p><p>下面是两个应用优先级队列的例子。（选自极客时间-王争-数据结构与算法之美）</p><h3 id="合并有序小文件"><a href="#合并有序小文件" class="headerlink" title="合并有序小文件"></a>合并有序小文件</h3><p>假设我们有100个小文件，每个文件的大小时100MB，每个文件中存储的都是有序的字符串。我们希望将这些100个小文件合并成一个有序的大文件。这里就会用到 <strong>优先级队列</strong>。</p><p>整体思路有点像归并排序中的合并函数。我们从这100个文件中，各取第一个字符，放入数组中，然后比较大小，把最小的那个字符串放入合并后的大文件中，并从数组中删除。</p><p>假设，最小的字符串来自于13.txt这个小文件，我们就再从这个小文件取下一个字符串，放到数组中，重新比较大小，并且选择最小的放入合并后的大文件，将它从数组中删除。以此类推，知道所有的文件中的数据都放大文件为止。</p><p>这里我们用到数组这种数据结构，来存储从小文件中取出来的字符串。每次从数组中取最小字符串，都需要循环遍历整个数组，这种做法是低效的。</p><p>这里就可一个用到优先级队列，也就是说堆。我们将小文件中取出来的字符串放入到小顶堆中，把堆顶的元素，也就是优先级队列队首的元素，就是最小的字符串。讲这个字符串放入到大文件中，并将其从堆中删除，然后再从小文件中去除下一个字符串，放入到堆中。循环这个过程就可以把100个小文件中的数据依次入到大文件中。</p><p>删除堆顶数据和往堆中插入数据的时间复杂度都是O(logn)，n表示堆中的数据个数，这里就是100，比原来的数组存储的方式高效多了。</p><h3 id="高性能定时器"><a href="#高性能定时器" class="headerlink" title="高性能定时器"></a>高性能定时器</h3><p>假设有一个定时器，定时器中维护了很多定时任务，每个任务都设定了一个要触发指向的时间点。定时器美国一个很小的单位时间（比如1秒），就扫描一边任务，看是否有任务到达设定的执行时间，如果到达就拿出来执行。</p><p>但是这样每过1秒就扫描一遍任务列表的做法比较低效，主要原因有两点：第一，任务的约定执行时间离当前时间可能还有很久，这样前面很多次扫描其实都是徒劳的；第二，每次都要扫描整个任务列表，如果任务列表很大的话，势必会比较耗时。</p><p>针对这些问题，就可以用优先级队列来解决。我们按照任务设定的执行时间，将这些任务存储在优先级队列中，队列首部(也就是小顶堆的堆顶)存储的是最先执行的任务。</p><p>这样，定时器就不需要每隔1秒就扫描一遍任务列表了。拿队首任务的执行时间点，与当前时间点相减，得到一个时间间隔T。</p><p>这个时间间隔T就是，从当前时间开始，需要等待多久，才会有第一个任务需要被执行。这样，定时器就可以设定在T秒之后，再来执行任务。从当前时间点到(T-1)秒时间里，定时器都不需要做任何事情。</p><p>当T秒时间过后，定时器取优先级队列中投队首的任务执行。然后再计算新的队首任务的执行时间点与当前时间点的差值，把这个值设置为定时器执行I行啊一个任务需要等待的时间。</p><p>这样，定时器既不用间隔1秒就轮询一次，也不用遍历整个任务列表，性能就提高了。</p><h2 id="优先级队列的实现"><a href="#优先级队列的实现" class="headerlink" title="优先级队列的实现"></a>优先级队列的实现</h2><p>优先队列主要有入队、出队和扩容操作组成：</p><ul><li>入队，需要进行上浮操作</li><li>出队，需要进行下沉操作</li><li>上浮操作，用于插入的叶子节点（数组最后的位置），将其移到正确的位置</li><li>下沉操作，用于删除队头元素，并且将最后一个元素放到队头并调整堆的形状</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 最大优先队列，无论入队的顺序如何，都是当前最大的元素优先出队；最小队列，无论入队的顺序如何，都是当前最小的元素优先出队。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: rhsphere</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>: 2019-07-08 09:34 by jdk 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PriorityQueue</span> </span>&#123;</span><br><span class="line"><span class="comment">//使用最大堆来实现最大优先队列，入队就是堆的插入，出队就是堆的删除</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] arr;  <span class="comment">//存储元素的数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;   <span class="comment">//队列中元素的个数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">32</span>];  <span class="comment">//队列初始长度为32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入队</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enQueue</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line"><span class="comment">//队列长度超出范围，扩容</span></span><br><span class="line"><span class="keyword">if</span>(size &gt;= arr.length) &#123;</span><br><span class="line">resize();</span><br><span class="line">&#125;</span><br><span class="line">arr[size++] = key;</span><br><span class="line">upAdjust();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出队</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deQueue</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (size &lt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"the queue is empty"</span>);</span><br><span class="line"><span class="comment">//获取堆顶元素</span></span><br><span class="line"><span class="keyword">int</span> head = arr[<span class="number">0</span>];</span><br><span class="line"><span class="comment">//让最后一个元素移到堆顶</span></span><br><span class="line">arr[<span class="number">0</span>] = arr[--size];</span><br><span class="line">downAdjust();</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//上浮操作，用于插入的叶子节点，将其移到正确的位置</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span>  <span class="title">upAdjust</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> childIndex = size - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> parentIndex = childIndex / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> tmp = arr[childIndex];</span><br><span class="line"><span class="keyword">while</span> (childIndex &gt; <span class="number">0</span> &amp;&amp; tmp &gt; arr[parentIndex]) &#123;</span><br><span class="line">arr[childIndex] = arr[parentIndex];</span><br><span class="line">childIndex = parentIndex;</span><br><span class="line">parentIndex = (parentIndex - <span class="number">1</span>) / <span class="number">2</span>; <span class="comment">//这里需要减一吗</span></span><br><span class="line">&#125;</span><br><span class="line">arr[childIndex] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下沉操作，用于删除队头元素，并且将最后一个元素放到队头并调整堆的形状</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">downAdjust</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> parentIndex = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//tmp用于保存父节点的值，用于最后的赋值</span></span><br><span class="line"><span class="keyword">int</span> tmp = arr[parentIndex];</span><br><span class="line"><span class="keyword">int</span> childIndex = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (childIndex &lt; size) &#123;</span><br><span class="line"><span class="comment">//如果有有孩子且右孩子大于左孩子的值，则定位到右孩子</span></span><br><span class="line"><span class="keyword">if</span> (childIndex + <span class="number">1</span> &lt; size &amp;&amp; arr[childIndex + <span class="number">1</span>] &gt; arr[childIndex])</span><br><span class="line">childIndex++;</span><br><span class="line"><span class="comment">//如果父节点大于左右孩子最大的值，直接跳出</span></span><br><span class="line"><span class="keyword">if</span> (tmp &gt;= arr[childIndex])</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="comment">//较大子节点单向赋值给父节点即可</span></span><br><span class="line">arr[parentIndex] = arr[childIndex];</span><br><span class="line">parentIndex = childIndex;</span><br><span class="line">childIndex = <span class="number">2</span> * childIndex + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">arr[parentIndex] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//扩容</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> newSize = <span class="keyword">this</span>.size * <span class="number">2</span>;</span><br><span class="line"><span class="keyword">this</span>.arr = Arrays.copyOf(<span class="keyword">this</span>.arr, newSize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        PriorityQueue pq = <span class="keyword">new</span> PriorityQueue();</span><br><span class="line">        pq.enQueue(<span class="number">1</span>);</span><br><span class="line">        pq.enQueue(<span class="number">3</span>);</span><br><span class="line">        pq.enQueue(<span class="number">5</span>);</span><br><span class="line">        pq.enQueue(<span class="number">10</span>);</span><br><span class="line">        pq.enQueue(<span class="number">2</span>);</span><br><span class="line">        pq.enQueue(<span class="number">7</span>);</span><br><span class="line">        System.out.println(<span class="string">"出队元素："</span> + pq.deQueue());</span><br><span class="line">        System.out.println(<span class="string">"出队元素："</span> + pq.deQueue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>优先队列是一种特殊的队列，优先级高的数据先出队，而不再像普通的队列那样，先进先出。<br>实际上，堆就可以看作优先级队列，只是称谓不一样。</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Heap" scheme="https://www.blogs.rhsphere.com/categories/Heap/"/>
    
    
      <category term="PriorityQueue" scheme="https://www.blogs.rhsphere.com/tags/PriorityQueue/"/>
    
  </entry>
  
  <entry>
    <title>树的遍历</title>
    <link href="https://www.blogs.rhsphere.com/2019/07/04/traversal-treenode.html"/>
    <id>https://www.blogs.rhsphere.com/2019/07/04/traversal-treenode.html</id>
    <published>2019-07-04T03:35:11.000Z</published>
    <updated>2019-07-10T12:29:36.834Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><h1 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h1><p>二叉树的遍历操作复杂度，跟节点的个数n成正比，也就是说二叉树遍历的时间复杂度是O(n)。</p><ul><li>前序遍历是指，对于树中的任意节点来说，先打印这个节点，然后再打印它的左子树，最后打印它的右子树。</li><li>中序遍历是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它本身，最后打印它的右子树。</li><li>后序遍历是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它的右子树，最后打印这个节点本身。</li></ul><p>二叉树本身是递归定义的，相应的遍历很自然就成为一种递归问题。</p><p><strong>写递归代码的关键，就是看能不能写出递推公式，而写递推公式的关键就是，如果解决问题A，就假设子问题B、C已经解决，然后再来看如何利用B、C来解决A。所以可以把前、中、后序遍历的递推公式都写出来。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前序遍历的递推公式：</span></span><br><span class="line">preorder(r) = print r -&gt; preorder(r.left) -&gt; preorder(r.right)</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历的递推公式：</span></span><br><span class="line">inorder(r) = inorder(r.left) -&gt; print r -&gt; inorder(r.right)</span><br><span class="line"></span><br><span class="line"><span class="comment">//后序遍历的递推公式：</span></span><br><span class="line">postorder(r) = postorder(r.left) -&gt; postorder(r.right) -&gt; print r</span><br></pre></td></tr></table></figure><p>递归遍历操作的关键点是递归体和递归出口：</p><ul><li>递归出口是二叉树的空子树或叶节点，此时为空操作，递归不继续进行，只能回退；</li><li>递归体是对二叉树根节点或左、右子树进行相应处理。</li></ul><p>基于递归的遍历算法易于编写，操作简单，但可读性差，系统需要维护相应的工作栈，效率不是很高。</p><p>递归转化为非递归的基本思想是如何实现原本是系统完成的递归工作栈，为此，可以仿照递归执行过程中工作栈状态变化而得到。</p><p>对二叉树进行前序、中序和后序遍历时都开始于根节点或结束于根节点，经由路线也相同。彼此差别在于对节点访问时机的选择不同。三种遍历方式都是沿着左子树不断深入下去，当到达二叉树左下节点而无法往下深入时，就向上逐一返回，行进到最近深入时曾遇到节点的右子树，然后进行同样的深入和返回，直到最终从根节点的右子树返回到根节点。<br>这样，遍历时返回顺序与深入节点顺序恰好相反，因此可以在实现二叉树遍历过程中，使用一个工作栈来保存当前深入到的节点信息，以供后面返回需要时使用。</p><p>树的节点的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="中序遍历-inorder-traversal"><a href="#中序遍历-inorder-traversal" class="headerlink" title="中序遍历(inorder traversal)"></a>中序遍历(inorder traversal)</h2><h3 id="递归遍历"><a href="#递归遍历" class="headerlink" title="递归遍历"></a>递归遍历</h3><p>二叉树分为根节点、左子树和右子树，分别表示为 +、1、2。<br>遍历顺序为： 1+2  可以递增顺序显示BST中所有节点。</p><ul><li>中序遍历访问左子二叉树</li><li>访问根节点</li><li>中序遍历访问右子二叉树</li></ul><figure class="highlight java"><figcaption><span>中序遍历递归方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    inorder(root);      </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    inorder(root.left);  <span class="comment">// 递归遍历左子树</span></span><br><span class="line">    System.out.print(root.val + <span class="string">" "</span>);  <span class="comment">// 递归遍历根节点</span></span><br><span class="line">    inorder(root.right);  <span class="comment">// 递归遍历右子树 1+2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="非递归遍历"><a href="#非递归遍历" class="headerlink" title="非递归遍历"></a>非递归遍历</h3><p>中序遍历的黄金口诀：当前节点(current=root)不为空，压栈，当前节点向左移动；当前节点为空，从栈中弹出一个元素，并打印该节点，当前节点向右移动；</p><figure class="highlight java"><figcaption><span>中序遍历非递归方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    inorder(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    java.util.Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> java.util.Stack&lt;&gt;();</span><br><span class="line">    TreeNode current = root;</span><br><span class="line">    <span class="keyword">while</span> (!stack.empty() || current != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (current != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(current);</span><br><span class="line">            current = current.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;            </span><br><span class="line">            TreeNode node = stack.pop();</span><br><span class="line">            System.out.print(node.val + <span class="string">" "</span>);</span><br><span class="line">            current = node.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="前序遍历-preorder-traversal"><a href="#前序遍历-preorder-traversal" class="headerlink" title="前序遍历(preorder traversal)"></a>前序遍历(preorder traversal)</h2><h3 id="递归遍历-1"><a href="#递归遍历-1" class="headerlink" title="递归遍历"></a>递归遍历</h3><p>+12  深度优先遍历法(depth-first traversal)与前序遍历法相同。</p><ul><li>访问根节点</li><li>前序遍历访问左子二叉树</li><li>前序遍历访问右子二叉树</li></ul><figure class="highlight java"><figcaption><span>preorder递归遍历</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preorder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    preorder(root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">preorder</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    System.out.println(root.val + <span class="string">" "</span>);  <span class="comment">// 递归遍历根节点</span></span><br><span class="line">    preorder(root.left);  <span class="comment">// 递归遍历左子树</span></span><br><span class="line">    preorder(root.right);  <span class="comment">// 递归遍历右子树 +12</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="非递归遍历-1"><a href="#非递归遍历-1" class="headerlink" title="非递归遍历"></a>非递归遍历</h3><p>根节点入栈，栈不为空，则循环：出栈并打印节点值，右孩子节点进栈，左孩子节点进栈。</p><figure class="highlight java"><figcaption><span>前序非递归遍历</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preorder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    preorder(root);</span><br><span class="line">&#125;    </span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">preorder</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!stack.empty()) &#123;</span><br><span class="line">        TreeNode node = stack.pop();</span><br><span class="line">        System.out.print(node.val + <span class="string">" "</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Push the right child onto the stack </span></span><br><span class="line">        <span class="comment">// first so the left is processed first</span></span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="后序遍历-postorder-traversal"><a href="#后序遍历-postorder-traversal" class="headerlink" title="后序遍历(postorder traversal)"></a>后序遍历(postorder traversal)</h2><h3 id="递归遍历-2"><a href="#递归遍历-2" class="headerlink" title="递归遍历"></a>递归遍历</h3><p>1 2 + </p><ul><li>后序遍历访问左子二叉树</li><li>后序遍历访问右子二叉树</li><li>访问根节点</li></ul><figure class="highlight java"><figcaption><span>postorder递归遍历</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postorder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    postorder(root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">postorder</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    postorder(root.left);  <span class="comment">// 递归遍历左子树</span></span><br><span class="line">    postorder(root.right);  <span class="comment">// 递归遍历右子树</span></span><br><span class="line">    System.out.println(root.val + <span class="string">" "</span>);  <span class="comment">// 递归遍历根节点 12+</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="非递归遍历-2"><a href="#非递归遍历-2" class="headerlink" title="非递归遍历"></a>非递归遍历</h3><p>需要两个栈，一个栈用来模拟后续遍历顺序，另一个栈用来存储后续遍历打印顺序。</p><p>根节点入栈1，栈1不为空则循环：栈1出栈，将出栈元素存到栈2，出栈节点左孩子节点进栈，右孩子节点进栈； 打印栈2的元素</p><figure class="highlight java"><figcaption><span>后序非递归遍历</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postorder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    postorder(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">postorder</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create two stacks</span></span><br><span class="line">    Stack&lt;TreeNode&gt; stack1 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    Stack&lt;TreeNode&gt; stack2 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// push root to stack1</span></span><br><span class="line">    stack1.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!stack1.empty()) &#123;</span><br><span class="line">        <span class="comment">// Pop node from stack1 and push onto stack2</span></span><br><span class="line">        TreeNode node = stack1.pop();</span><br><span class="line">        stack2.push(node);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="keyword">null</span>)</span><br><span class="line">            stack1.push(node.left);</span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="keyword">null</span>)</span><br><span class="line">            stack1.push(node.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Display vals in stack2</span></span><br><span class="line">    <span class="keyword">while</span> (!stack2.empty()) &#123;</span><br><span class="line">        System.out.print(stack2.pop().val + <span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="广度优先遍历-breadth-first-traversal"><a href="#广度优先遍历-breadth-first-traversal" class="headerlink" title="广度优先遍历(breadth-first traversal)"></a>广度优先遍历(breadth-first traversal)</h2><p>根节点先入队，然后队列不空，取出对头元素，如果左孩子存在就入队列，否则什么也不做，右孩子同理。知道队列为空，则表示树层次遍历结束。树的层次遍历，其实也是广度优先的遍历算法。</p><figure class="highlight java"><figcaption><span>广度优先遍历</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">breadthFirstTraversal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Queue Deque Linkedlist</span></span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();  </span><br><span class="line"></span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        TreeNode current = queue.element();</span><br><span class="line">        <span class="keyword">if</span> (current.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.add(current.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (current.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.add(current.right);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(queue.remove().val + <span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Tree" scheme="https://www.blogs.rhsphere.com/categories/Tree/"/>
    
    
      <category term="tree" scheme="https://www.blogs.rhsphere.com/tags/tree/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer(26) 树的子结构</title>
    <link href="https://www.blogs.rhsphere.com/2019/07/02/substructure-in-tree.html"/>
    <id>https://www.blogs.rhsphere.com/2019/07/02/substructure-in-tree.html</id>
    <published>2019-07-02T04:23:41.000Z</published>
    <updated>2019-07-02T05:41:53.314Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><h2 id="树的子结构"><a href="#树的子结构" class="headerlink" title="树的子结构"></a>树的子结构</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入两棵二叉树A和B，判断B是不是A的子结构。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>先对A树进行遍历，找到与B树的根节点值相同的节点R；</li><li>判断A树中以R为根节点的子树是否包含B树一样的结构。</li></ol><h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><ol><li>功能测试（A和B为普通二叉树；B是或者不是A的子结构）</li><li>特殊测试（任意一个或者两个数的根节点为null；左斜、右斜树）</li></ol><h2 id="java代码"><a href="#java代码" class="headerlink" title="java代码"></a>java代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">**</span><br><span class="line"> * <span class="meta">@description</span>: 剑指Offer26 树的子结构</span><br><span class="line"> * <span class="meta">@author</span>: rhsphere</span><br><span class="line"> * <span class="meta">@since</span>: <span class="number">2019</span>-<span class="number">07</span>-<span class="number">02</span> <span class="number">12</span>:<span class="number">19</span> by jdk <span class="number">1.8</span></span><br><span class="line"> */</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubstructureInTree</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line">TreeNode left;</span><br><span class="line">TreeNode right;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.val = val;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//主程序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasSubTree</span><span class="params">(TreeNode root1, TreeNode root2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root1 == <span class="keyword">null</span> || root2 == <span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">//        boolean result=false;</span></span><br><span class="line"><span class="comment">//        if(equal(root1.val, root2.val)) &#123;</span></span><br><span class="line"><span class="comment">//          result = doesTree1HasTree2(root1, root2);</span></span><br><span class="line"><span class="comment">//          if(!result)</span></span><br><span class="line"><span class="comment">//              result=hasSubtree(root1.left, root2)</span></span><br><span class="line"><span class="comment">//              ||hasSubtree(root1.right, root2);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        return result;</span></span><br><span class="line">        <span class="comment">//上面几行可以直接写成：</span></span><br><span class="line"><span class="keyword">return</span> doesTree1HasTree2(root1, root2) || hasSubtree(root1.left, root2)</span><br><span class="line">|| hasSubtree(root1.right, root2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断root节点开始的子树中各个节点是否相同</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doesTree1HasTree2</span><span class="params">(TreeNode root1, TreeNode root2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">if</span> (root1 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">return</span> equal(root1.val, root2.val) &amp;&amp; doesTree1HasTree2(root1.left, root2.left)</span><br><span class="line">&amp;&amp; doesTree1HasTree2(root1.right, root2.right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断两个浮点数是否相同</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">equal</span><span class="params">(<span class="keyword">double</span> num1, <span class="keyword">double</span> num2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (Math.abs(num1 - num2) &lt; <span class="number">0.00000001</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>本题是对二叉树遍历的扩展，利用递归比较简洁方便；</li><li>浮点数判等方法，不能直接用 “==” 判断。</li></ol><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="剑指Offer" scheme="https://www.blogs.rhsphere.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="Recursive" scheme="https://www.blogs.rhsphere.com/tags/Recursive/"/>
    
      <category term="Tree" scheme="https://www.blogs.rhsphere.com/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer(25) 合并两个有序链表</title>
    <link href="https://www.blogs.rhsphere.com/2019/06/30/merge-sorted-linkedlist.html"/>
    <id>https://www.blogs.rhsphere.com/2019/06/30/merge-sorted-linkedlist.html</id>
    <published>2019-06-30T09:25:47.000Z</published>
    <updated>2019-07-02T04:15:09.475Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><h2 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a>合并两个有序链表</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入两个递增排序的链表，合并这两个链表并使新链表中的结点仍然是按照递增排序的。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><strong>递归实现：</strong> 合并过程中，每次都是从两个链表中找出较小的一个来链接，因此可以采用递归来实现：当任意一个链表为null时，直接连接另一个链表即可；其余情况只需要在两个链表中找出一个较小的节点进行连接，该节点的next值继续通过递归函数来链接。</p><p><strong>非递归实现：</strong> 参考<a href="https://blogs.rhsphere.com/leetcode/2019/05/27/21.html" target="_blank" rel="noopener">leetcode 21. Merge Two Sorted Lists</a>  进行分类讨论即可。</p><h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><ol><li>功能测试（两个链表有多个或一个节点；节点值相同、不同）</li><li>特殊测试（任意一个或者两个链表的头结点为null）</li></ol><h2 id="java代码"><a href="#java代码" class="headerlink" title="java代码"></a>java代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 剑指offer25</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: rhsphere</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>: 2019-07-02 10:25 by jdk 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSortedLists</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line">ListNode next;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ListNode</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.val = val;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">merge</span><span class="params">(ListNode la, ListNode lb)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (la == <span class="keyword">null</span>) <span class="keyword">return</span> lb;</span><br><span class="line"><span class="keyword">if</span> (lb == <span class="keyword">null</span>) <span class="keyword">return</span> la;</span><br><span class="line"><span class="keyword">if</span> (la.val &lt; lb.val) &#123;</span><br><span class="line">la.next = merge(la.next, lb);</span><br><span class="line"><span class="keyword">return</span> la;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">lb.next = merge(la, lb.next);</span><br><span class="line"><span class="keyword">return</span> lb;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//非递归</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeSortedList</span><span class="params">(ListNode la, ListNode lb)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (la == <span class="keyword">null</span>) <span class="keyword">return</span> lb;</span><br><span class="line"><span class="keyword">if</span> (lb == <span class="keyword">null</span>) <span class="keyword">return</span> la;</span><br><span class="line">ListNode p = la, q = lb, head;</span><br><span class="line"><span class="keyword">if</span> (p.val &lt; q.val) &#123;</span><br><span class="line">head = p;</span><br><span class="line">p = p.next;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">head = q;</span><br><span class="line">q = q.next;</span><br><span class="line">&#125;</span><br><span class="line">ListNode r = head;</span><br><span class="line"><span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; q != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (p.val &lt; q.val) &#123;</span><br><span class="line">r.next = p;</span><br><span class="line">p = p.next;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">r.next = q;</span><br><span class="line">q = q.next;</span><br><span class="line">&#125;</span><br><span class="line">r = r.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">r.next = p;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">r.next = q;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>对于递归实现方法，得到链表中值叫次奥的头结点并把它连接到已经合并的链表之后，两个链表剩余的节点依然是排序的，因此合并的步骤和之前的步骤是一样的。这就是典型的递归过程，我们可以定义递归函数完成这一合并过程。</li></ol><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="剑指Offer" scheme="https://www.blogs.rhsphere.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="LinkedList" scheme="https://www.blogs.rhsphere.com/tags/LinkedList/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer(24) 反转链表</title>
    <link href="https://www.blogs.rhsphere.com/2019/06/30/reverse-linkedlist.html"/>
    <id>https://www.blogs.rhsphere.com/2019/06/30/reverse-linkedlist.html</id>
    <published>2019-06-30T09:25:30.000Z</published>
    <updated>2019-07-01T03:33:09.731Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><h2 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>　定义一个函数，输入一个链表的头结点，反转该链表并输出反转后链表的头结点。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>参考 <a href="https://blogs.rhsphere.com/leetcode/2019/05/27/206.html" target="_blank" rel="noopener">leetcode 206. Reverse Linked List</a></p><h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><ol><li>功能测试（链表有多个或一个节点）</li><li>特殊测试（头结点为null）</li></ol><h2 id="java代码"><a href="#java代码" class="headerlink" title="java代码"></a>java代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 剑指Offer24</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: rhsphere</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>: 2019-07-01 10:48 by jdk 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReverseList</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        ListNode next = <span class="keyword">null</span>;</span><br><span class="line">        ListNode(<span class="keyword">int</span> val) &#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//迭代</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">       ListNode reverse = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">           ListNode second = head.next;</span><br><span class="line">           head.next = reverse;</span><br><span class="line">           reverse = head;</span><br><span class="line">           head = second;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> reverse;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseListRecursively</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode res = reverseListRecursively(head.next);</span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="剑指Offer" scheme="https://www.blogs.rhsphere.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="LinkedList" scheme="https://www.blogs.rhsphere.com/tags/LinkedList/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer(23) 链表中环的入口节点</title>
    <link href="https://www.blogs.rhsphere.com/2019/06/30/entry-node-in-linkedlist.html"/>
    <id>https://www.blogs.rhsphere.com/2019/06/30/entry-node-in-linkedlist.html</id>
    <published>2019-06-30T09:25:04.000Z</published>
    <updated>2019-07-01T02:21:34.517Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><h2 id="链表中环的入口节点"><a href="#链表中环的入口节点" class="headerlink" title="链表中环的入口节点"></a>链表中环的入口节点</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>一个链表中包含环，如何找出环的入口结点？</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>确定链表是否有环：通过两个不同速度的指针确定，当两个指针指向同一个结点时，该结点为环中的一个结点。</li><li>确定环中结点的数目n：指针走一圈，边走边计数</li><li>找到环的入口：从头结点开始，通过两个相差为n的指针来得到（即寻找链表中倒数第n个结点）</li></ol><p>本题和 <a href="https://blogs.rhsphere.com/leetcode/2019/05/27/141.html" target="_blank" rel="noopener"> leetcode 141. Linked List Cycle 1</a> 及 <a href="https://blogs.rhsphere.com/leetcode/2019/05/27/142.html" target="_blank" rel="noopener">  leetcode 142. Linked List Cycle 2</a>相同</p><h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><ol><li>功能测试 （链表包含与不包含环；链表有多个或一个节点）</li><li>特殊测试（头结点为null）</li></ol><h2 id="java代码"><a href="#java代码" class="headerlink" title="java代码"></a>java代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 剑指Offer23</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: rhsphere</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>: 2019-06-30 23:34 by jdk 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EntryNodeOfLoop</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        ListNode next = <span class="keyword">null</span>;</span><br><span class="line">        ListNode(<span class="keyword">int</span> val) &#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//确定链表中是否有环，采用快慢指针</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">meetingNode</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="keyword">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            <span class="keyword">if</span> (fast != <span class="keyword">null</span>)</span><br><span class="line">                fast = fast.next;</span><br><span class="line">            <span class="keyword">if</span> (slow != <span class="keyword">null</span> &amp;&amp; slow == fast)</span><br><span class="line">                <span class="keyword">return</span> slow;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算环中入口节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">entryNodeOfLoop</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode meetingNode = meetingNode(head);</span><br><span class="line">        <span class="keyword">if</span> (meetingNode == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//计算环中节点的数目</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        ListNode fast = meetingNode.next;</span><br><span class="line">        <span class="keyword">while</span> (fast != meetingNode) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//先移动p，次数为count</span></span><br><span class="line">        fast = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= count; i++) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="剑指Offer" scheme="https://www.blogs.rhsphere.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="LinkedList" scheme="https://www.blogs.rhsphere.com/tags/LinkedList/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer(22) 链表中倒数第k个节点</title>
    <link href="https://www.blogs.rhsphere.com/2019/06/30/kth-listnode-from-end.html"/>
    <id>https://www.blogs.rhsphere.com/2019/06/30/kth-listnode-from-end.html</id>
    <published>2019-06-30T09:24:16.000Z</published>
    <updated>2019-06-30T14:35:48.479Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><h2 id="链表中倒数第k个节点"><a href="#链表中倒数第k个节点" class="headerlink" title="链表中倒数第k个节点"></a>链表中倒数第k个节点</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入一个链表，输出该链表中倒数第k个结点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾结点是倒数第1个结点。例如一个链表有6个结点，从头结点开始它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个结点是值为4的结点。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>本题和 <a href="https://blogs.rhsphere.com/leetcode/2019/05/27/19.html" target="_blank" rel="noopener">leetcode 19. Remove Nth Node From End of List</a> 是同一道题，和书中是同一个思路：设置两个指针，第一个指针先遍历k-1步；从第k步开始，第二个指针指向头结点，两个节点同时往后遍历，当第一个指针到达最后一个节点时，第二个指针指向的正好是倒数第k个节点。</p><h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><ol><li>功能测试（第k个节点分别在链表的中间、头结点和尾节点）</li><li>特殊测试（头结点为null、k超出范围）</li></ol><h2 id="java代码"><a href="#java代码" class="headerlink" title="java代码"></a>java代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KthNodeFromEnd</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line">ListNode next = <span class="keyword">null</span>;</span><br><span class="line">ListNode(<span class="keyword">int</span> val) &#123;</span><br><span class="line"><span class="keyword">this</span>.val = val;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法1：利用栈</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">findKthToTail</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="keyword">null</span> || k &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">int</span> numOfList = <span class="number">1</span>;</span><br><span class="line">Stack&lt;ListNode&gt; st = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">st.push(head);</span><br><span class="line">ListNode node = head.next;</span><br><span class="line"><span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">numOfList++;</span><br><span class="line">st.push(node);</span><br><span class="line">node = node.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (k &gt; numOfList) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++)</span><br><span class="line">node = st.pop();</span><br><span class="line"><span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//方法2：利用两个相距为k-1的指针</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">findKthToTail2</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="keyword">null</span> || k &lt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">ListNode fast = head;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; k; i++) &#123;</span><br><span class="line">fast = fast.next;</span><br><span class="line"><span class="keyword">if</span> (fast == <span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">ListNode slow = head;</span><br><span class="line"><span class="keyword">while</span> (fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">fast = fast.next;</span><br><span class="line">slow = slow.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>注意代码的鲁棒性，开始思考前都需要注意特殊输入测试；</li><li>一个指针遍历链表无法解决问题时，可以考虑使用两个指针来遍历链表：两个指针先后遍历（即该题目）、或者两个指针遍历速度不同（如：求链表中的中间结点，可以令一个指针一次走一步，另一个指针一次走两步来实现）</li></ol><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="剑指Offer" scheme="https://www.blogs.rhsphere.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="LinkedList" scheme="https://www.blogs.rhsphere.com/tags/LinkedList/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer(21) 调整数组顺序使奇数位于偶数前面</title>
    <link href="https://www.blogs.rhsphere.com/2019/06/30/reorder-array.html"/>
    <id>https://www.blogs.rhsphere.com/2019/06/30/reorder-array.html</id>
    <published>2019-06-30T01:34:57.000Z</published>
    <updated>2019-06-30T06:56:34.268Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><h2 id="调整数组顺序使奇数位于偶数前面"><a href="#调整数组顺序使奇数位于偶数前面" class="headerlink" title="调整数组顺序使奇数位于偶数前面"></a>调整数组顺序使奇数位于偶数前面</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>对于任意一个整数数组，设置一个left指针，从前往后走，如果遇到奇数则指针后移，遇到偶数时，指针停止；设置一个right指针，从前往后走，遇到偶数时指针前移，遇到奇数是，可以喝前面的指针所指的偶数进行调换。</p><h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><ol><li>功能测试（数组中奇偶交替出现、数组中先奇后偶、先偶后奇）</li><li>特殊测试（null、空数组、一个数据的数组）</li></ol><h2 id="java代码"><a href="#java代码" class="headerlink" title="java代码"></a>java代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReorderArray</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reorderArray</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> right = arr.length - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> tmp;</span><br><span class="line"><span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line"><span class="keyword">while</span> (left &lt; right &amp;&amp; (arr[left] &amp; <span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">left++;</span><br><span class="line"><span class="keyword">while</span> (left &lt; right &amp;&amp; (arr[right] &amp; <span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">right--;</span><br><span class="line">tmp = arr[left];</span><br><span class="line">arr[left] = arr[right];</span><br><span class="line">arr[right] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="附加要求"><a href="#附加要求" class="headerlink" title="附加要求"></a>附加要求</h2><p>如果题目附加要求：保证调整后的数组中，奇数和奇数之间，偶数和偶数之间的相对位置不变。<br>此时用上面的方法无法实现该功能，可以采用类似于“直接插入排序”的方法：从头开始遍历，遇到奇数时，将该奇数插入到该奇数前面的偶数之前。（如：从头开始遍历246183，遇到奇数1时，将1插入到246之前，变为：124683；该插入的实质是：奇数前面的所有偶数往后移一位，空出的位置放入该奇数）</p><h3 id="java代码-1"><a href="#java代码-1" class="headerlink" title="java代码"></a>java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reorderArray1</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tmp, j;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> ((arr[i] &amp; <span class="number">1</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">j = i;</span><br><span class="line">tmp = arr[i];</span><br><span class="line"><span class="keyword">while</span> ((j &gt; <span class="number">0</span>) &amp;&amp; (arr[j - <span class="number">1</span>] &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">arr[j] = arr[j - <span class="number">1</span>];</span><br><span class="line">j--;</span><br><span class="line">&#125;</span><br><span class="line">arr[j] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="剑指Offer" scheme="https://www.blogs.rhsphere.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="Array" scheme="https://www.blogs.rhsphere.com/tags/Array/"/>
    
      <category term="Two Pointers" scheme="https://www.blogs.rhsphere.com/tags/Two-Pointers/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer(20) 表示数值的字符串</title>
    <link href="https://www.blogs.rhsphere.com/2019/06/29/numberic-strings.html"/>
    <id>https://www.blogs.rhsphere.com/2019/06/29/numberic-strings.html</id>
    <published>2019-06-29T14:36:23.000Z</published>
    <updated>2019-06-30T01:34:07.047Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><h2 id="表示数值的字符串"><a href="#表示数值的字符串" class="headerlink" title="表示数值的字符串"></a>表示数值的字符串</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串“+100”、“5e2”、“-123”、“3.1416”及“-1E-16”都表示数值，但“12e”、“1a3.14”、“1.2.3”、“+-5”及“12e+5.4”都不是。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>具体思路参考剑指offer，需要将数字总结出规律，（A.B E/e A），按顺序进行判断，（A代表有符号整数，B代表无符号整数）</p><p>另一种思路：借助几个flag从头到尾遍历，leetcode 65. Valid Number</p><h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><ol><li>功能测试（正负数、含整数与不含整数部分、含小数与不含、含与不含指数部分；不匹配情况）</li><li>特殊测试（null、空字符串）</li></ol><h2 id="java代码"><a href="#java代码" class="headerlink" title="java代码"></a>java代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumericStrings</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNumeric</span><span class="params">(<span class="keyword">char</span>[] str)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (str == <span class="keyword">null</span> || str.length == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">int</span>[] index = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];</span><br><span class="line">index[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">boolean</span> isNumeric;</span><br><span class="line">isNumeric = isInteger(str, index);</span><br><span class="line"><span class="keyword">if</span> (index[<span class="number">0</span>] &lt; str.lengrh &amp;&amp; (str[index[<span class="number">0</span>]] == <span class="string">'.'</span>)) &#123;</span><br><span class="line">index[<span class="number">0</span>]++;</span><br><span class="line">isNumeric = isUnsignedInteger(str, index) || isNumeric;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (index[<span class="number">0</span>] &lt; str.length &amp;&amp; (str[index[<span class="number">0</span>]] == <span class="string">'e'</span> || str[index[<span class="number">0</span>]] == <span class="string">'E'</span>)) &#123;</span><br><span class="line">index[<span class="number">0</span>]++;</span><br><span class="line">isNumeric = isInteger(str, index) &amp;&amp; isNumeric;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (isNumeric &amp;&amp; index[<span class="number">0</span>] == str.length)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isInteger</span><span class="params">(<span class="keyword">char</span>[] str, <span class="keyword">int</span>[] index)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (index[<span class="number">0</span>] &lt; str.length &amp;&amp; (str[index[<span class="number">0</span>]] == <span class="string">'+'</span> || str[index[<span class="number">0</span>]] == <span class="string">'-'</span>))</span><br><span class="line">index[<span class="number">0</span>]++;</span><br><span class="line"><span class="keyword">return</span> isUnsignedInteger(str, index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isUnsignedInteger</span><span class="params">(<span class="keyword">char</span>[] str, <span class="keyword">int</span>[] index)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> start = index[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">while</span> (index[<span class="number">0</span>] &lt; str.length &amp;&amp; (str[index[<span class="number">0</span>]] - <span class="string">'0'</span> &lt;= <span class="number">9</span> &amp;&amp; str[index[<span class="number">0</span>]] - <span class="string">'0'</span> &gt;= <span class="number">0</span>))</span><br><span class="line">index[<span class="number">0</span>]++;</span><br><span class="line"><span class="keyword">if</span> (index[<span class="number">0</span>] &gt; start)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>对字符串进行依次判断时，定义一个boolean变量，每判断一部分就进行更新，最终改变量即为判断结果，不需要进行循环判断。</li><li>if (isNumeric &amp;&amp; index[0] == str.length) 判断index是否到达结尾处了。</li><li>isNumeric = isUnsignedInteger(str, index) || isNumeric; 顺序不能反了，否则当isNumeric为true时，不会判断后半部分，index就不会走向’e’，从而导致错误。</li></ol><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="剑指Offer" scheme="https://www.blogs.rhsphere.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="String" scheme="https://www.blogs.rhsphere.com/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer(19) 正则表达式匹配</title>
    <link href="https://www.blogs.rhsphere.com/2019/06/23/regular-expression.html"/>
    <id>https://www.blogs.rhsphere.com/2019/06/23/regular-expression.html</id>
    <published>2019-06-23T06:57:00.000Z</published>
    <updated>2019-06-23T07:30:37.521Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><h2 id="正则表达式匹配"><a href="#正则表达式匹配" class="headerlink" title="正则表达式匹配"></a>正则表达式匹配</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>实现一个函数用来匹配包含’.’和 ‘*‘ 的正则表达式。模式中的字符’.’表示任意一个字符，而 ‘*‘ 表示塔前面的字符可以出现忍一次（含0次）。在本题中，匹配是指字符穿的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab*ac*a”匹配，但与”aa.a”和”ab*a”均不匹配。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><pre><code>使用函数matchCore(char[] str, int indexOfStr, char[] pat, int indexOfPat)来实现每一步的比较（递归）。</code></pre><ol><li>当模式中第二个字符不为”*“时：若当前字符相等，则字符串和模式串都前后移一个字符，继续调用函数进行比较；若不相等，则返回false。</li><li>当模式中第二个字符为”*“时：若当前字符不相等，则模式后移两个字符，继续比较；若当前字符相等，则有三种情况：<ol><li>字符串位置不变，模式后移两个字符，继续比较；</li><li>字符串后移一个字符，模式后移两个字符，继续比较；</li><li>字符串后移一个字符，模式字符位置不变，继续比较。<br>以上三种情况使用”||”进行并列比较。</li></ol></li></ol><h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><ol><li>功能测试（模式中包含普通字符、 “.”、””; 匹配情况；不匹配情况）</li><li>特殊测试 （null、空字符串）</li></ol><h2 id="java代码"><a href="#java代码" class="headerlink" title="java代码"></a>java代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 实现一个函数用来匹配包含‘，’和‘*’的正则表达式。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: rhsphere</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>: 2019-06-23 08:52 by jdk 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegularExpression</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(<span class="keyword">char</span>[] str, <span class="keyword">char</span>[] pat)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="keyword">null</span> || pat == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> matchCore(str, <span class="number">0</span>, pat, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matchCore</span><span class="params">(<span class="keyword">char</span>[] str, <span class="keyword">int</span> indexOfStr, <span class="keyword">char</span>[] pat, <span class="keyword">int</span> indexOfPat)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (indexOfStr == str.length &amp;&amp; indexOfPat == pat.length)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (indexOfStr &lt; str.length &amp;&amp; indexOfPat == pat.length)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (indexOfPat + <span class="number">1</span> &lt; pat.length &amp;&amp; pat[indexOfPat + <span class="number">1</span>] == <span class="string">'*'</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((indexOfStr &lt; str.length &amp;&amp; pat[indexOfPat] == <span class="string">'.'</span>) </span><br><span class="line">            || (indexOfStr &lt; str.length &amp;&amp; pat[indexOfPat] == str[indexOfStr])) &#123;</span><br><span class="line">                <span class="keyword">return</span> matchCore(str, indexOfStr, pat, indexOfPat + <span class="number">2</span>)</span><br><span class="line">                        || matchCore(str, indexOfStr + <span class="number">1</span>, pat, indexOfPat)</span><br><span class="line">                        || matchCore(str, indexOfStr + <span class="number">1</span>, pat, indexOfPat + <span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> matchCore(str, indexOfStr, pat, indexOfPat + <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (indexOfStr &lt; str.length &amp;&amp; (pat[indexOfPat] == str[indexOfStr] </span><br><span class="line">        || pat[indexOfPat] == <span class="string">'.'</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> matchCore(str, indexOfStr + <span class="number">1</span>, pat, indexOfPat + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ==========测试代码=========</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(String testName, <span class="keyword">char</span>[] str, <span class="keyword">char</span>[] pattern, <span class="keyword">boolean</span> expected)</span> </span>&#123;</span><br><span class="line">        System.out.print(testName + <span class="string">":"</span>);</span><br><span class="line">        <span class="keyword">if</span> (match(str, pattern) == expected)</span><br><span class="line">            System.out.println(<span class="string">"passed!"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            System.out.println(<span class="string">"failed!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] str = &#123;&#125;;</span><br><span class="line">        <span class="keyword">char</span>[] pattern = &#123; <span class="string">'.'</span> &#125;;</span><br><span class="line">        test(<span class="string">"test1"</span>, str, pattern, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] str = &#123;&#125;;</span><br><span class="line">        <span class="keyword">char</span>[] pattern = &#123; <span class="string">'.'</span>, <span class="string">'*'</span> &#125;;</span><br><span class="line">        test(<span class="string">"test2"</span>, str, pattern, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] str = &#123; <span class="string">'a'</span> &#125;;</span><br><span class="line">        <span class="keyword">char</span>[] pattern = &#123; <span class="string">'.'</span>, <span class="string">'*'</span> &#125;;</span><br><span class="line">        test(<span class="string">"test3"</span>, str, pattern, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] str = &#123;&#125;;</span><br><span class="line">        <span class="keyword">char</span>[] pattern = &#123;&#125;;</span><br><span class="line">        test(<span class="string">"test4"</span>, str, pattern, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] str = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">char</span>[] pattern = <span class="keyword">null</span>;</span><br><span class="line">        test(<span class="string">"test5"</span>, str, pattern, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] str = &#123; <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'b'</span> &#125;;</span><br><span class="line">        <span class="keyword">char</span>[] pattern = &#123; <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'b'</span>, <span class="string">'*'</span>, <span class="string">'b'</span> &#125;;</span><br><span class="line">        test(<span class="string">"test6"</span>, str, pattern, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] str = &#123; <span class="string">'a'</span> &#125;;</span><br><span class="line">        <span class="keyword">char</span>[] pattern = &#123; <span class="string">'a'</span>, <span class="string">'a'</span>, <span class="string">'*'</span> &#125;;</span><br><span class="line">        test(<span class="string">"test7"</span>, str, pattern, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RegularExpression demo = <span class="keyword">new</span> RegularExpression();</span><br><span class="line">        demo.test1();</span><br><span class="line">        demo.test2();</span><br><span class="line">        demo.test3();</span><br><span class="line">        demo.test4();</span><br><span class="line">        demo.test5();</span><br><span class="line">        demo.test6();</span><br><span class="line">        demo.test7();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>涉及到数组的情况下，一定要时刻注意数组越界的问题！</li><li>对于每一步都是采用相同判断方法的题目，可以采用递归函数来实现</li><li>思维一定要全面，把握住关键矛盾，将每种情况考虑清楚。例如这道题，关键就在于第二个字符是否为“*”，确定关键问题后，分析清楚每一种情况即可</li><li>代码第29行的 indexOfStr &lt; str.length 一定要记得加，否则可能会出现重复执行第32行的情况。</li></ol><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="剑指Offer" scheme="https://www.blogs.rhsphere.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="String" scheme="https://www.blogs.rhsphere.com/tags/String/"/>
    
      <category term="RegExp" scheme="https://www.blogs.rhsphere.com/tags/RegExp/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer(18) 删除链表中的节点</title>
    <link href="https://www.blogs.rhsphere.com/2019/06/22/delete-nodes-in-linkedlist.html"/>
    <id>https://www.blogs.rhsphere.com/2019/06/22/delete-nodes-in-linkedlist.html</id>
    <published>2019-06-22T03:19:00.000Z</published>
    <updated>2019-06-23T00:50:58.054Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><h1 id="在O-1-时间内删除链表结点"><a href="#在O-1-时间内删除链表结点" class="headerlink" title="在O(1)时间内删除链表结点"></a>在O(1)时间内删除链表结点</h1><h2 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h2><p>在给定单向链表的头指针和一个节点指针，定义一个函数在O(1)时间内删除该节点。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><strong>本题缺陷，要求O(1)时间删除，相当于隐藏了一个假设：待删除的节点的确在链表中。</strong></p><p>在单向链表中，节点没有指向前一个节点的指针，所以只好从链表的链表的头结点开始顺序查找。这样的时间复杂度为O(n)，要在O(1)的时间删除节点，可以这样实现：<br>    将待删除节点的next节点 j 的值赋值给 i ，再把 i 的指针指向 j 的下一个节点，最后删除 j ，效果等同于删除 j 。</p><p>全面考虑其他情况：</p><ol><li>待删除节点i为尾节点是，无下一个节点，只能从头开始遍历到尾节点；</li><li>链表中只有一个节点时（即是头结点，又是尾节点），必须把头结点也设置为null；</li></ol><h2 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h2><ol><li><p>功能测试 （多个节点链表，删除头结点、中间节点和尾节点；单个节点链表）</p></li><li><p>特殊测试 （头结点或者删除节点为null）</p></li></ol><h2 id="java代码"><a href="#java代码" class="headerlink" title="java代码"></a>java代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 给定单向链表的头结点和一个节点指针，定义一个函数在O(1)时间删除该节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: rhsphere</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>: 2019-06-22 15:49 by jdk 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注:本题存在缺陷，要求O(1)时间，则无法确定待删除节点的确在表中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeleteNodeInList</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line">ListNode next;</span><br><span class="line">ListNode(<span class="keyword">int</span> val, ListNode next) &#123;</span><br><span class="line"><span class="keyword">this</span>.val = val;</span><br><span class="line"><span class="keyword">this</span>.next = next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteNode</span><span class="params">(ListNode head, ListNode pToBeDeleted)</span> </span>&#123;</span><br><span class="line">ListNode p = pToBeDeleted;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="keyword">null</span> || p == <span class="keyword">null</span>) </span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line"><span class="keyword">if</span> (p.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">ListNode q = p.next;</span><br><span class="line">p.val = q.val;</span><br><span class="line">p.next = q.next;</span><br><span class="line">q = <span class="keyword">null</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (head == p) &#123;</span><br><span class="line">p = <span class="keyword">null</span>;</span><br><span class="line">head = <span class="keyword">null</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">ListNode pre = head;</span><br><span class="line"><span class="keyword">while</span> (pre.next != p &amp;&amp; pre != <span class="keyword">null</span>) &#123;</span><br><span class="line">pre = pre.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (pre == <span class="keyword">null</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">"无法找到待删除节点"</span>)；</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line">pre.next = <span class="keyword">null</span>;</span><br><span class="line">p = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//=========测试代码==========</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(ListNode head,ListNode PToBeDelete)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"============"</span>);</span><br><span class="line">        System.out.print(<span class="string">"The original list is: "</span>);</span><br><span class="line">        ListNode curr=head;</span><br><span class="line">        <span class="keyword">if</span>(curr!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span>(curr.next!=<span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.print(curr.val+<span class="string">","</span>);</span><br><span class="line">                curr=curr.next;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(curr.val);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        System.out.print(<span class="string">"The node to be deleted is: "</span>);</span><br><span class="line">        <span class="keyword">if</span>(PToBeDelete!=<span class="keyword">null</span>)</span><br><span class="line">            System.out.println(PToBeDelete.val);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            System.out.println();</span><br><span class="line">         </span><br><span class="line">        curr=deleteNode(head, PToBeDelete);    </span><br><span class="line">        System.out.print(<span class="string">"The result list is: "</span>);</span><br><span class="line">        <span class="keyword">if</span>(curr!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span>(curr.next!=<span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.print(curr.val+<span class="string">","</span>);</span><br><span class="line">                curr=curr.next;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(curr.val);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"============"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 链表含多个结点，删除头结点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ListNode p4=<span class="keyword">new</span> ListNode(<span class="number">4</span>, <span class="keyword">null</span>);</span><br><span class="line">        ListNode p3=<span class="keyword">new</span> ListNode(<span class="number">3</span>, p4);</span><br><span class="line">        ListNode p2=<span class="keyword">new</span> ListNode(<span class="number">2</span>, p3);</span><br><span class="line">        ListNode p1=<span class="keyword">new</span> ListNode(<span class="number">1</span>, p2);</span><br><span class="line">        test(p1, p1);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 链表含多个结点，删除中间结点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ListNode p4=<span class="keyword">new</span> ListNode(<span class="number">4</span>, <span class="keyword">null</span>);</span><br><span class="line">        ListNode p3=<span class="keyword">new</span> ListNode(<span class="number">3</span>, p4);</span><br><span class="line">        ListNode p2=<span class="keyword">new</span> ListNode(<span class="number">2</span>, p3);</span><br><span class="line">        ListNode p1=<span class="keyword">new</span> ListNode(<span class="number">1</span>, p2);</span><br><span class="line">        test(p1, p3);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 链表含多个结点，删除尾结点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ListNode p4=<span class="keyword">new</span> ListNode(<span class="number">4</span>, <span class="keyword">null</span>);</span><br><span class="line">        ListNode p3=<span class="keyword">new</span> ListNode(<span class="number">3</span>, p4);</span><br><span class="line">        ListNode p2=<span class="keyword">new</span> ListNode(<span class="number">2</span>, p3);</span><br><span class="line">        ListNode p1=<span class="keyword">new</span> ListNode(<span class="number">1</span>, p2);</span><br><span class="line">        test(p1, p4);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 链表含一个结点，删除结点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ListNode p4=<span class="keyword">new</span> ListNode(<span class="number">4</span>, <span class="keyword">null</span>);</span><br><span class="line">        test(p4, p4);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 链表为空</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        test(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">         </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DeleteNodeInList demo = <span class="keyword">new</span> DeleteNodeInList();</span><br><span class="line">        demo.test1();</span><br><span class="line">        demo.test2();</span><br><span class="line">        demo.test3();</span><br><span class="line">        demo.test4();</span><br><span class="line">        demo.test5();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>链表中删除节点的方法中，虽然直接令 head=null, 但是在主函数中的head还是不变的，因此要令删除节点的返回值为LinkNode，将返回值赋值给主函数中的head，这样才能实现真正的删除。</li><li>另一种情况可以令删除函数返回值为void，只是需要定义一个头结点head（1中的head相当于第一个节点），这个头结点中不存任何数据，仅仅起到执政的作用，第一个节点是头结点的下一个节点，通过对head.next操作，能够实现真正的删除。</li><li>和链表有关的特殊情况：头结点、尾节点，链表仅有一个节点，null等。</li></ol><h1 id="删除链表中的重复节点"><a href="#删除链表中的重复节点" class="headerlink" title="删除链表中的重复节点"></a>删除链表中的重复节点</h1><h2 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h2><p>在一个排序的链表中，如何删除重复的节点？</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>设置一个 pre ，用于记录当前节点的前一个节点，再设置一个布尔变量 needDelete ，如果说当前节点和后一结点的值相同（记该值为dupVal)，needDelete赋值为真。<br>当 needDelete 为真时，通过寻魂往后找到第一个不为 dupVal 的节点，把该节点设置为当前节点，并赋值给 pre.next, 即相当于完成了删除操作；而当 needDelete 为假时，把当前节点和 pre 往后移一位即可。</p><h2 id="测试用例-1"><a href="#测试用例-1" class="headerlink" title="测试用例"></a>测试用例</h2><ol><li>功能测试（重复的节点位于链表的头部、中间、尾部；链表中无重复节点）</li><li>特殊输入测试（头结点为null、所有节点都重复）</li></ol><h2 id="java代码-1"><a href="#java代码-1" class="headerlink" title="java代码"></a>java代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 在一个排序链表中删除重复的节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: rhsphere</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>: 2019-06-23 08:37 by jdk 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeleteDuplicatedNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        ListNode next = <span class="keyword">null</span>;</span><br><span class="line">        ListNode(<span class="keyword">int</span> val, ListNode next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplication</span><span class="params">(ListNode pHead)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pHead == <span class="keyword">null</span> || pHead.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 空节点或者仅一个节点</span></span><br><span class="line">            <span class="keyword">return</span> pHead;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">        ListNode cur = pHead;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> needDelete = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (cur.next != <span class="keyword">null</span> &amp;&amp; cur.val == cur.next.val) &#123;</span><br><span class="line">                needDelete = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!needDelete) &#123; <span class="comment">// 当前节点不重复</span></span><br><span class="line">                pre = cur;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> dupValue = cur.val;</span><br><span class="line">                ListNode toBeDel = cur;</span><br><span class="line">                <span class="keyword">while</span> (toBeDel != <span class="keyword">null</span> &amp;&amp; toBeDel.val == dupValue) &#123;</span><br><span class="line">                    <span class="comment">// 这里删除在那还是不涉及前一节点操作，其实主要是找出后面第一个不重复节点</span></span><br><span class="line">                    toBeDel = toBeDel.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (pre == <span class="keyword">null</span>) &#123; <span class="comment">//说明删除的节点是头结点</span></span><br><span class="line">                    pHead = toBeDel;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    pre.next = toBeDel;</span><br><span class="line">                &#125;</span><br><span class="line">                cur = toBeDel;  <span class="comment">//这个节点还是可能出现重复，所以不能 =next</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pHead;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//========测试代码======</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(ListNode pHead)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"-----------"</span>);</span><br><span class="line">        System.out.print(<span class="string">"The original list is: "</span>);</span><br><span class="line">        ListNode curr=pHead;</span><br><span class="line">        <span class="keyword">if</span>(curr!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span>(curr.next!=<span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.print(curr.val+<span class="string">","</span>);</span><br><span class="line">                curr=curr.next;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(curr.val);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        pHead=deleteDuplication(pHead);</span><br><span class="line">        System.out.print(<span class="string">"The result list is: "</span>);</span><br><span class="line">        curr=pHead;</span><br><span class="line">        <span class="keyword">if</span>(curr!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span>(curr.next!=<span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.print(curr.val+<span class="string">","</span>);</span><br><span class="line">                curr=curr.next;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(curr.val);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"-----------"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重复结点位于链表头部</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ListNode p4=<span class="keyword">new</span> ListNode(<span class="number">3</span>, <span class="keyword">null</span>);</span><br><span class="line">        ListNode p3=<span class="keyword">new</span> ListNode(<span class="number">2</span>, p4);</span><br><span class="line">        ListNode p2=<span class="keyword">new</span> ListNode(<span class="number">1</span>, p3);</span><br><span class="line">        ListNode p1=<span class="keyword">new</span> ListNode(<span class="number">1</span>, p2);</span><br><span class="line">        test(p1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重复结点位于链表尾部</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ListNode p4=<span class="keyword">new</span> ListNode(<span class="number">3</span>, <span class="keyword">null</span>);</span><br><span class="line">        ListNode p3=<span class="keyword">new</span> ListNode(<span class="number">3</span>, p4);</span><br><span class="line">        ListNode p2=<span class="keyword">new</span> ListNode(<span class="number">2</span>, p3);</span><br><span class="line">        ListNode p1=<span class="keyword">new</span> ListNode(<span class="number">1</span>, p2);</span><br><span class="line">        test(p1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重复结点位于链表中部</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ListNode p4=<span class="keyword">new</span> ListNode(<span class="number">3</span>, <span class="keyword">null</span>);</span><br><span class="line">        ListNode p3=<span class="keyword">new</span> ListNode(<span class="number">2</span>, p4);</span><br><span class="line">        ListNode p2=<span class="keyword">new</span> ListNode(<span class="number">2</span>, p3);</span><br><span class="line">        ListNode p1=<span class="keyword">new</span> ListNode(<span class="number">1</span>, p2);</span><br><span class="line">        test(p1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连续出现重复结点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ListNode p6=<span class="keyword">new</span> ListNode(<span class="number">3</span>, <span class="keyword">null</span>);</span><br><span class="line">        ListNode p5=<span class="keyword">new</span> ListNode(<span class="number">3</span>, p6);</span><br><span class="line">        ListNode p4=<span class="keyword">new</span> ListNode(<span class="number">2</span>, p5);</span><br><span class="line">        ListNode p3=<span class="keyword">new</span> ListNode(<span class="number">2</span>, p4);</span><br><span class="line">        ListNode p2=<span class="keyword">new</span> ListNode(<span class="number">1</span>, p3);</span><br><span class="line">        ListNode p1=<span class="keyword">new</span> ListNode(<span class="number">1</span>, p2);</span><br><span class="line">        test(p1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 多个重复结点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ListNode p6=<span class="keyword">new</span> ListNode(<span class="number">3</span>, <span class="keyword">null</span>);</span><br><span class="line">        ListNode p5=<span class="keyword">new</span> ListNode(<span class="number">3</span>, p6);</span><br><span class="line">        ListNode p4=<span class="keyword">new</span> ListNode(<span class="number">3</span>, p5);</span><br><span class="line">        ListNode p3=<span class="keyword">new</span> ListNode(<span class="number">2</span>, p4);</span><br><span class="line">        ListNode p2=<span class="keyword">new</span> ListNode(<span class="number">1</span>, p3);</span><br><span class="line">        ListNode p1=<span class="keyword">new</span> ListNode(<span class="number">1</span>, p2);</span><br><span class="line">        test(p1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 无重复结点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ListNode p6=<span class="keyword">new</span> ListNode(<span class="number">6</span>, <span class="keyword">null</span>);</span><br><span class="line">        ListNode p5=<span class="keyword">new</span> ListNode(<span class="number">5</span>, p6);</span><br><span class="line">        ListNode p4=<span class="keyword">new</span> ListNode(<span class="number">4</span>, p5);</span><br><span class="line">        ListNode p3=<span class="keyword">new</span> ListNode(<span class="number">3</span>, p4);</span><br><span class="line">        ListNode p2=<span class="keyword">new</span> ListNode(<span class="number">2</span>, p3);</span><br><span class="line">        ListNode p1=<span class="keyword">new</span> ListNode(<span class="number">1</span>, p2);</span><br><span class="line">        test(p1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 单个结点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ListNode p1=<span class="keyword">new</span> ListNode(<span class="number">6</span>, <span class="keyword">null</span>);</span><br><span class="line">        test(p1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test8</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ListNode p1=<span class="keyword">null</span>;</span><br><span class="line">        test(p1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DeleteDuplicatedNode demo= <span class="keyword">new</span> DeleteDuplicatedNode();</span><br><span class="line">        demo.test1();</span><br><span class="line">        demo.test2();</span><br><span class="line">        demo.test3();</span><br><span class="line">        demo.test4();</span><br><span class="line">        demo.test5();</span><br><span class="line">        demo.test6();</span><br><span class="line">        demo.test7();</span><br><span class="line">        demo.test8();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ol><li>删除多个节点时，只需要把重复节点前一个节点的next指向重复节点的后一个节点；</li><li>不要把重复节点一个一个删除，先定义一个布尔变量确定当前节点是否重复，然后按1 中的方法删除即可。</li></ol><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="剑指Offer" scheme="https://www.blogs.rhsphere.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="Linked List" scheme="https://www.blogs.rhsphere.com/tags/Linked-List/"/>
    
      <category term="HQ Code" scheme="https://www.blogs.rhsphere.com/tags/HQ-Code/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer(17) 打印从1到最大的n位数</title>
    <link href="https://www.blogs.rhsphere.com/2019/06/19/print-1-to-n-digits.html"/>
    <id>https://www.blogs.rhsphere.com/2019/06/19/print-1-to-n-digits.html</id>
    <published>2019-06-19T12:49:27.000Z</published>
    <updated>2019-06-22T03:08:58.693Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><h2 id="打印1到最大的n位数-需复习"><a href="#打印1到最大的n位数-需复习" class="headerlink" title="打印1到最大的n位数(需复习)"></a>打印1到最大的n位数(需复习)</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入数字n，按顺序打印出从1最大的n位十进制数。比如输入1，则打印出1、2、3一直到最大的3位数即999</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><strong>陷阱</strong>：n过大时是大数问题，不能简单用int或者long数据输出，需要采用字符串或者数组表达大数。</p><p><strong>解决方法</strong>：通过字符数组char[]来进行输出数字。</p><p><strong>方法一</strong>：</p><ol><li><p>在字符串表达的数字上模拟加法；</p></li><li><p>把字符串表达的数字打印出来。</p></li></ol><p><strong>方法二</strong>：</p><ol><li><p>采用递归将每一位都从0到9排列出来；</p></li><li><p>把字符串表达的数字打印出来。</p></li></ol><h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><p>功能测试（输入1、2、3）<br>特殊测试（输入0、-1）</p><h2 id="int与char类型之间的相互转换"><a href="#int与char类型之间的相互转换" class="headerlink" title="int与char类型之间的相互转换"></a>int与char类型之间的相互转换</h2><ol><li>int类型转char类型，将数字加一个’0’，并<strong>强制类型转换成char即可</strong>、</li><li>char类型转int类型，将字符减去一个‘0’</li></ol><figure class="highlight java"><figcaption><span>char和int之间的类型转换</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//int类型转char类型</span></span><br><span class="line"><span class="keyword">int</span> number = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">char</span> cNumber = (<span class="keyword">char</span>)(number + <span class="string">'0'</span>);</span><br><span class="line">System.out.pritnln(<span class="string">"Number "</span> + number + <span class="string">"to char is:"</span> + cNumber);</span><br><span class="line"></span><br><span class="line"><span class="comment">//char类型装int类型</span></span><br><span class="line"><span class="keyword">char</span> ch = <span class="string">'3'</span>;</span><br><span class="line"><span class="keyword">int</span> number2 = ch - <span class="string">'0'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="java代码"><a href="#java代码" class="headerlink" title="java代码"></a>java代码</h2><h3 id="非递归法"><a href="#非递归法" class="headerlink" title="非递归法"></a>非递归法</h3><p>每次加一并打印这个数，直到最大的n位数并终止递增</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 面试题17：输入数字n，按顺序打印出从1最大的n位十进制数。比如输入3，则打印出1、2、3一直到最大的3位数即999。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: rhsphere</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>: 2019-06-13 22:18 by jdk 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Print1ToMaxOfNDigit</span> </span>&#123;</span><br><span class="line"><span class="comment">// 方法一</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 采取模拟加一的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print1ToMaxOfNDigits</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt;= <span class="number">0</span>) </span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">char</span>[] number = <span class="keyword">new</span> <span class="keyword">char</span>[n];</span><br><span class="line"><span class="comment">//不能用foreach对number赋值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; number.length; k++) &#123;</span><br><span class="line">number[k] = <span class="string">'0'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (!increment(number)) &#123;</span><br><span class="line">printCharNumber(number);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对字符串进行加一操作，number达到最大值后返回true</span></span><br><span class="line"><span class="comment">     * 最低位加1；所以如果所有位超过10，则进位</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">increment</span><span class="params">(<span class="keyword">char</span>[] number)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> nTakeOver = <span class="number">0</span>; <span class="comment">//代表进位</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = number.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="keyword">int</span> nSum = (number[i] - <span class="string">' 0'</span>) + nTakeOver; <span class="comment">//当前位置数字</span></span><br><span class="line"><span class="comment">// number[i] - '0' 是把char转成int，nTakeOver代表进位</span></span><br><span class="line"><span class="keyword">if</span> (i == number.length - <span class="number">1</span>)</span><br><span class="line">nSum++;</span><br><span class="line"><span class="keyword">if</span> (nSum &gt;= <span class="number">10</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">nTakeOver = <span class="number">1</span>;</span><br><span class="line">nSum -= <span class="number">10</span>;</span><br><span class="line">number[i] = (<span class="keyword">char</span>) (nSum + <span class="string">'0'</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">number[i] = (<span class="keyword">char</span>) (nSum + <span class="string">'0'</span>);</span><br><span class="line"><span class="keyword">break</span>; <span class="comment">//高位不变，可以直接跳出循环</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印字符数组形成的数字</span></span><br><span class="line"><span class="comment">     * 书中方法：利用布尔变量isBeginning0来从第一个非零字符打印</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printCharNumber</span><span class="params">(<span class="keyword">char</span>[] number)</span> </span>&#123;</span><br><span class="line"><span class="keyword">boolean</span> isBeginning0 = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (isBeginning0 &amp;&amp; (number[i] - <span class="string">'0'</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">isBeginning0 = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!isBeginning0) &#123;</span><br><span class="line">System.out.print(number[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印字符数组形成的数字</span></span><br><span class="line"><span class="comment">     * 自己的方法：找出第一个非零字符位置，往后进行打印</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printCharNumber2</span><span class="params">(<span class="keyword">char</span>[] number)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> beginner = number.length; <span class="comment">//不写成number.llength - 1，以防写出0</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> ((number[i] - <span class="string">'0'</span>) != <span class="number">0</span>)&#123;</span><br><span class="line">beginner = i;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = beginner; i &lt;= number.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">System.out.print(number[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (beginner != number.length)</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="递归方法"><a href="#递归方法" class="headerlink" title="递归方法"></a>递归方法</h3><p>如果在数字前面补0.就会发现n位所有十进制其实就是n个从0到9的全排列。也就是说，我们把数字的每一位都从0到9排列一遍，就得到了所有的十进制数。<br>只是在打印的时候，排在前面的0不打印出来。<br>全排列用递归很容易表达，数字的每一位都可能是0~9中的一个数，然后设置下一位。<br>递归终止条件是我们已经设置了数字的最后一位。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Print1ToMaxOfNDigit</span> </span>&#123;</span><br><span class="line"><span class="comment">//方法二</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*采用递归算法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print1ToMaxOfNDigits</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">char</span>[] number = <span class="keyword">new</span> <span class="keyword">char</span>[n];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; number.length; k++)</span><br><span class="line">number[k] = <span class="string">'0'</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; i++) </span><br><span class="line">makeNumber(n, number, i, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//生成数字</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">makeNumber</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">char</span>[] number, <span class="keyword">int</span> nNumber, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (index == number.length - <span class="number">1</span>) &#123;</span><br><span class="line">number[index] = (<span class="keyword">char</span>)(nNumber + <span class="string">'0'</span>);</span><br><span class="line">printCharNumber(number);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">number[index] = (<span class="keyword">char</span>)(nNumber + <span class="string">'0'</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;=<span class="number">9</span>; i++) &#123;</span><br><span class="line">makeNumber(n, number, i, index + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printCharNumber</span><span class="params">(<span class="keyword">char</span>[] number)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> beginner = number.length;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= number.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> ((number[i] - <span class="string">'0'</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">beginner = i;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = beginner; i &lt;= number.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">System.out.print(number[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (beginner != number.length)</span><br><span class="line">System.out.pritnln();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="清晰、简洁版本的java代码"><a href="#清晰、简洁版本的java代码" class="headerlink" title="清晰、简洁版本的java代码"></a>清晰、简洁版本的java代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Print1ToMaxOfNDigit</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print1ToMaxOfNDigits</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">char</span>[] digit = <span class="keyword">new</span> <span class="keyword">char</span>[n];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) </span><br><span class="line">digit[i] = <span class="string">'0'</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="keyword">while</span> (digit[i] != <span class="string">'9'</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line">digit[m]++;</span><br><span class="line"><span class="keyword">while</span> (m &lt; n-<span class="number">1</span> &amp;&amp; digit[m] &gt; <span class="string">'9'</span>) &#123;</span><br><span class="line">digit[m] = <span class="string">'0'</span>;</span><br><span class="line">digit[m+<span class="number">1</span>]++;</span><br><span class="line">m++;</span><br><span class="line">&#125;</span><br><span class="line">printDigits(digit);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printDigits</span><span class="params">(<span class="keyword">char</span>[] digit)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> m = digit.length - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (digit[m] == <span class="string">'0'</span>)</span><br><span class="line">m--;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = m; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">System.out.print(digit[i]);</span><br><span class="line">Sytem.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>打印字符串镖师的数组，从第一个非零数字打印。</li><li>关注大数问题</li></ol><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="剑指Offer" scheme="https://www.blogs.rhsphere.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="HQ Code" scheme="https://www.blogs.rhsphere.com/tags/HQ-Code/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer(16) 数值的整数次方</title>
    <link href="https://www.blogs.rhsphere.com/2019/06/14/perfect-power.html"/>
    <id>https://www.blogs.rhsphere.com/2019/06/14/perfect-power.html</id>
    <published>2019-06-14T01:43:48.000Z</published>
    <updated>2019-06-17T02:07:54.333Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><h2 id="数值的整数次方"><a href="#数值的整数次方" class="headerlink" title="数值的整数次方"></a>数值的整数次方</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>本章开始将关注代码的质量，关注功能测试、边界测试和负面（错误测试），写出完整的代码。<br>实现double Power(double base, int exponent)，求base的exponent次方，不得使用库函数，同时不需要考虑大数问题。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这道题很容易实现，但是需要注意以下陷阱：1）0的负数次方不存在；2）0的0次方没有数学意义；3）要考虑exponent为负数的情况。所以可以对exponent进行分类讨论，再对base是否为0进行讨论。</p><h2 id="java代码"><a href="#java代码" class="headerlink" title="java代码"></a>java代码</h2><h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 面试题16：数值的整数次方</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: rhsphere</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>: 2019-06-13 22:16 by jdk 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Power</span> </span>&#123;</span><br><span class="line"><span class="keyword">boolean</span> isInvalid = <span class="keyword">false</span>;  <span class="comment">//全局变量标记是否出错</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">isValid = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">double</span> result;  </span><br><span class="line"><span class="keyword">if</span> (exponent &gt; <span class="number">0</span>) &#123;</span><br><span class="line">result = powerCore(base, exponent);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (exponent &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (base == <span class="number">0</span>) &#123;</span><br><span class="line">isInvalid = <span class="keyword">true</span>;  <span class="comment">//0的负数次方不存在</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> = <span class="number">1</span> / powerCore(base, -exponent);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">//这里0的0次方输出为1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">powerCore</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (exponent == <span class="number">1</span>) </span><br><span class="line"><span class="keyword">return</span> base;</span><br><span class="line"><span class="keyword">if</span> (exponent == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 递归调用本身</span></span><br><span class="line"><span class="keyword">double</span> result = powerCore(base, expoennt &gt;&gt; <span class="number">1</span>);</span><br><span class="line">result *= result;</span><br><span class="line"><span class="keyword">if</span> ((exponent &amp; <span class="number">0x1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">//最后一次运算的exponent为奇数，需要再乘一次base</span></span><br><span class="line">result *= base;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ========测试代码========</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(String testName, <span class="keyword">double</span> base, <span class="keyword">int</span> exponent, <span class="keyword">double</span> expected, <span class="keyword">boolean</span> expectedFlag)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (testName != <span class="keyword">null</span>)</span><br><span class="line">            System.out.print(testName + <span class="string">":"</span>);</span><br><span class="line">        <span class="keyword">if</span> (power(base, exponent) == expected &amp;&amp; IsInvalid == expectedFlag) &#123;</span><br><span class="line">            System.out.println(<span class="string">"passed."</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"failed."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        test(<span class="string">"test1"</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        test(<span class="string">"test2"</span>, <span class="number">0</span>, -<span class="number">6</span>, <span class="number">0</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        test(<span class="string">"test3"</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        test(<span class="string">"test4"</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">64</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        test(<span class="string">"test5"</span>, <span class="number">2</span>, -<span class="number">3</span>, <span class="number">0.125</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        test(<span class="string">"test6"</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        test(<span class="string">"test7"</span>, -<span class="number">2</span>, <span class="number">6</span>, <span class="number">64</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Power demo = <span class="keyword">new</span> Power();</span><br><span class="line">        demo.test1();</span><br><span class="line">        demo.test2();</span><br><span class="line">        demo.test3();</span><br><span class="line">        demo.test4();</span><br><span class="line">        demo.test5();</span><br><span class="line">        demo.test6();</span><br><span class="line">        demo.test7();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="非递归实现"><a href="#非递归实现" class="headerlink" title="非递归实现"></a>非递归实现</h3><p>上面的powerCore()方法可改写成如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">powerCore</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line"><span class="keyword">double</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (exponent != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> ((exponent &amp; <span class="number">0x1</span>) == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> *= base;</span><br><span class="line">exponent &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">base *= base; <span class="comment">//指数右移一位，则底数翻倍</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>double 类型变量在被赋值为0时，是可以用等号判等的</li><li>做乘方的地推公式要掌握，用递推公式能够更加简洁；</li><li>使用位与运算符代替求余运算符%判断奇偶数，有较高的效率：if ((exponent &amp; 0x1) == 1)</li><li>非递归实现乘方，其本质是根据指数与2的倍数关系来对底数进行操作的</li></ol><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="剑指Offer" scheme="https://www.blogs.rhsphere.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="Power" scheme="https://www.blogs.rhsphere.com/tags/Power/"/>
    
      <category term="HQ Code" scheme="https://www.blogs.rhsphere.com/tags/HQ-Code/"/>
    
  </entry>
  
  <entry>
    <title>Sort(排序)</title>
    <link href="https://www.blogs.rhsphere.com/2019/06/01/sort-sum-up.html"/>
    <id>https://www.blogs.rhsphere.com/2019/06/01/sort-sum-up.html</id>
    <published>2019-06-01T13:17:19.000Z</published>
    <updated>2019-06-01T13:26:54.017Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><h2 id="Sort-排序"><a href="#Sort-排序" class="headerlink" title="Sort(排序)"></a>Sort(排序)</h2><p><a href="https://blogs.rhsphere.com/leetcode/2019/04/01/selection-sort.html" target="_blank" rel="noopener">01. Selection Sort（选择排序实现）</a></p><p><a href="https://blogs.rhsphere.com/leetcode/2019/04/01/insertion-sort.html" target="_blank" rel="noopener">02. Insertion Sort（插入排序实现）</a></p><p><a href="https://blogs.rhsphere.com/leetcode/2019/04/01/shell-sort.html" target="_blank" rel="noopener">03. Shell Sort（希尔排序实现）</a></p><p><a href="https://blogs.rhsphere.com/leetcode/2019/04/01/bubble-sort.html" target="_blank" rel="noopener">04. Bubble Sort（冒泡排序实现）</a></p><p><a href="https://blogs.rhsphere.com/leetcode/2019/04/01/cock-tail-sort.html" target="_blank" rel="noopener">05.  Cocktail Sort（鸡尾酒排序）</a></p><p><a href="https://blogs.rhsphere.com/leetcode/2019/04/01/merge-sort.html" target="_blank" rel="noopener">06. Merge Sort（归并排序实现）</a></p><p><a href="https://blogs.rhsphere.com/leetcode/2019/04/01/quick-sort.html" target="_blank" rel="noopener">07. Quick Sort（快速排序实现）</a></p><p><a href="https://blogs.rhsphere.com/leetcode/2019/04/01/count-sort.html" target="_blank" rel="noopener">08. Count Sort（计数排序）</a></p><p><a href="https://blogs.rhsphere.com/leetcode/2019/04/01/bucket-sort.html" target="_blank" rel="noopener">09. Bucket Sort（桶排序）</a></p><p><a href="https://blogs.rhsphere.com/leetcode/2019/04/01/heapsort-easy.html" target="_blank" rel="noopener">10. Heap Sort （堆排序(非泛型)）</a></p><p><a href="https://blogs.rhsphere.com/leetcode/2019/04/01/external-sort.html" target="_blank" rel="noopener">11. Sort Large File （外部排序）</a></p><p><a href="https://blogs.rhsphere.com/leetcode/2019/03/14/heap-sort.html" target="_blank" rel="noopener">12. Heap Sort （堆排序(泛型)）</a></p><p><a href="https://blogs.rhsphere.com/leetcode/2019/04/10/sort-summary.html" target="_blank" rel="noopener">Summary of Sorting Algos（排序总结）</a></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Sum-up" scheme="https://www.blogs.rhsphere.com/categories/Sum-up/"/>
    
    
      <category term="Sum-up" scheme="https://www.blogs.rhsphere.com/tags/Sum-up/"/>
    
      <category term="Sort" scheme="https://www.blogs.rhsphere.com/tags/Sort/"/>
    
  </entry>
  
  <entry>
    <title>Queue(队列)</title>
    <link href="https://www.blogs.rhsphere.com/2019/06/01/queue-sum-up.html"/>
    <id>https://www.blogs.rhsphere.com/2019/06/01/queue-sum-up.html</id>
    <published>2019-06-01T12:44:17.000Z</published>
    <updated>2019-06-01T13:16:39.341Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><h2 id="Queue-队列"><a href="#Queue-队列" class="headerlink" title="Queue(队列)"></a>Queue(队列)</h2><p>Last Modified: 2019/5/30 20:36 by dp</p><p><a href="https://blogs.rhsphere.com/leetcode/2019/05/31/array-linked-circular-queue.html" target="_blank" rel="noopener">01. Implement Queue by Array（用数组实现队列）</a></p><p><a href="https://blogs.rhsphere.com/leetcode/2019/05/31/array-linked-circular-queue.html" target="_blank" rel="noopener">02. Implement Queue by LinkedList（用链表实现队列）</a></p><p><a href="">03. Implement Queue using Stacks（用栈实现队列）</a></p><p><a href="https://blogs.rhsphere.com/leetcode/2019/05/31/array-linked-circular-queue.html" target="_blank" rel="noopener">04. Implement Circular Queue using Array（用数组实现循环队列）</a></p><p><a href="https://blogs.rhsphere.com/leetcode/2019/05/31/641.html" target="_blank" rel="noopener">05. Design Circular Deque（设计一个双端队列）</a></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Sum-up" scheme="https://www.blogs.rhsphere.com/categories/Sum-up/"/>
    
    
      <category term="Queue" scheme="https://www.blogs.rhsphere.com/tags/Queue/"/>
    
      <category term="Sum-up" scheme="https://www.blogs.rhsphere.com/tags/Sum-up/"/>
    
  </entry>
  
  <entry>
    <title>641. Design Circular Deque</title>
    <link href="https://www.blogs.rhsphere.com/2019/05/31/641.html"/>
    <id>https://www.blogs.rhsphere.com/2019/05/31/641.html</id>
    <published>2019-05-31T02:20:04.000Z</published>
    <updated>2019-05-31T03:09:40.732Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><h2 id="设计一个双端队列"><a href="#设计一个双端队列" class="headerlink" title="设计一个双端队列"></a>设计一个双端队列</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>设计实现双端队列。<br>你的实现需要支持以下操作：</p><p>MyCircularDeque(k)：构造函数,双端队列的大小为k。<br>insertFront()：将一个元素添加到双端队列头部。 如果操作成功返回 true。<br>insertLast()：将一个元素添加到双端队列尾部。如果操作成功返回 true。<br>deleteFront()：从双端队列头部删除一个元素。 如果操作成功返回 true。<br>deleteLast()：从双端队列尾部删除一个元素。如果操作成功返回 true。<br>getFront()：从双端队列头部获得一个元素。如果双端队列为空，返回 -1。<br>getRear()：获得双端队列的最后一个元素。 如果双端队列为空，返回 -1。<br>isEmpty()：检查双端队列是否为空。<br>isFull()：检查双端队列是否满了。<br>示例：</p><p>MyCircularDeque circularDeque = new MycircularDeque(3); // 设置容量大小为3<br>circularDeque.insertLast(1);                    // 返回 true<br>circularDeque.insertLast(2);                    // 返回 true<br>circularDeque.insertFront(3);                    // 返回 true<br>circularDeque.insertFront(4);                    // 已经满了，返回 false<br>circularDeque.getRear();                  // 返回 2<br>circularDeque.isFull();                        // 返回 true<br>circularDeque.deleteLast();                    // 返回 true<br>circularDeque.insertFront(4);                    // 返回 true<br>circularDeque.getFront();                // 返回 4</p><p>提示：</p><p>所有值的范围为 [1, 1000]<br>操作次数的范围为 [1, 1000]<br>请不要使用内置的双端队列库。</p><h3 id="java代码"><a href="#java代码" class="headerlink" title="java代码"></a>java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 使用链表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: rhsphere</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>: 2019-05-31 10:25 by jdk 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCircularDeque</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        Node next;</span><br><span class="line">        Node prev;</span><br><span class="line">        Node(<span class="keyword">int</span> val) &#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Node head, tail;</span><br><span class="line">    <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. Set the size of the deque to be k. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyCircularDeque</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        head = <span class="keyword">new</span> Node(-<span class="number">1</span>);</span><br><span class="line">        tail = <span class="keyword">new</span> Node(-<span class="number">1</span>);</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.prev = head;</span><br><span class="line">        capacity = k;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Adds an item at the front of Deque. Return true if the operation is successful. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">insertFront</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == capacity)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Node node = <span class="keyword">new</span> Node(value);</span><br><span class="line">        node.next = head.next;</span><br><span class="line">        head.next.prev = node;</span><br><span class="line">        head.next = node;</span><br><span class="line">        node.prev = head;</span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Adds an item at the rear of Deque. Return true if the operation is successful. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">insertLast</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == capacity)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Node node = <span class="keyword">new</span> Node(value);</span><br><span class="line">        tail.prev.next = node;</span><br><span class="line">        node.prev = tail.prev;</span><br><span class="line">        node.next = tail;</span><br><span class="line">        tail.prev = node;</span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Deletes an item from the front of Deque. Return true if the operation is successful. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">deleteFront</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        head.next.next.prev = head;</span><br><span class="line">        head.next = head.next.next;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Deletes an item from the rear of Deque. Return true if the operation is successful. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">deleteLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        tail.prev.prev.next = tail;</span><br><span class="line">        tail.prev = tail.prev.prev;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the front item from the deque. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getFront</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> head.next.val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the last item from the deque. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tail.prev.val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Checks whether the circular deque is empty or not. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Checks whether the circular deque is full or not. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size == capacity;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyCircularDeque object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyCircularDeque obj = new MyCircularDeque(k);</span></span><br><span class="line"><span class="comment"> * boolean param_1 = obj.insertFront(value);</span></span><br><span class="line"><span class="comment"> * boolean param_2 = obj.insertLast(value);</span></span><br><span class="line"><span class="comment"> * boolean param_3 = obj.deleteFront();</span></span><br><span class="line"><span class="comment"> * boolean param_4 = obj.deleteLast();</span></span><br><span class="line"><span class="comment"> * int param_5 = obj.getFront();</span></span><br><span class="line"><span class="comment"> * int param_6 = obj.getRear();</span></span><br><span class="line"><span class="comment"> * boolean param_7 = obj.isEmpty();</span></span><br><span class="line"><span class="comment"> * boolean param_8 = obj.isFull();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Queue" scheme="https://www.blogs.rhsphere.com/categories/Queue/"/>
    
    
      <category term="Queue" scheme="https://www.blogs.rhsphere.com/tags/Queue/"/>
    
      <category term="Circular Queue" scheme="https://www.blogs.rhsphere.com/tags/Circular-Queue/"/>
    
  </entry>
  
  <entry>
    <title>Array &amp;&amp; Linked &amp;&amp; Circular Queue</title>
    <link href="https://www.blogs.rhsphere.com/2019/05/31/array-linked-circular-queue.html"/>
    <id>https://www.blogs.rhsphere.com/2019/05/31/array-linked-circular-queue.html</id>
    <published>2019-05-30T23:51:06.000Z</published>
    <updated>2019-05-31T02:17:53.493Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>队列跟栈一样，也是操作受限的线性表结构。 队列最基本的操作也是两个：<strong>入队enqueue()，放一个数据到队列尾部；</strong>出队dequeue()，从队列头部取一个元素。**</p><p>队列的应用非常广泛，特别是一些具有某些额外特性的队列，比如循环队列、阻塞队列、并发队列。他们在很多偏底层系统、框架、中间件的开发中，骑着关键性的作用。比如高性能队列Disruptor、Linux环形缓存，都用到了循环并发队列；Java concurrent并发包利用ArrayBlockingQueue来实现公平锁等。</p><p>实际的项目，不可能从零实现一个队列，甚至都不会直接用到。而具有特殊特性的队列应用却比较广泛，比如阻塞队列和并发队列。</p><p><strong>阻塞队列</strong>其实就是在队列基础上增加了阻塞操作。简单来说，就是在队列为空的时候，从队头取数据会被阻塞。因为此时还没有数据可取，直到队列中有了数据才能返回；如果队列已经满了，那么插入数据的操作就会被阻塞，知道队列中有空闲位置后再插入数据，然后再返回。</p><p>线程安全的队列叫做 <strong>并发队列</strong>，对简单直接的实现方式就是直接在enqueue()、dequeue()方法上加锁，但是锁粒度大并发度会比较低，同一时刻仅允许一个存或者取操所。实际上，基于数组的循环队列，利用CAS原子操作，可以实现非常高效的并发队列。</p><p>这也是循环队列比链式队列应用更加广泛的原因。</p><h3 id="线程池队列的策略"><a href="#线程池队列的策略" class="headerlink" title="线程池队列的策略"></a>线程池队列的策略</h3><p>线程池没有空闲线程时，新的任务请求线程资源是，线程池该如何处理?这种处理策略又是如何实现的呢？</p><p>一半有两种处理策略。第一种是非阻塞的处理方式，直接拒绝任务请求；另一种是阻塞的处理方式，将请求排队，等到有空闲线程时，去除排队的请求继续处理。</p><p>基于链表的实现方式，可以实现一个支持无限排队的无界队列，但是可能会导致过多的请求队列等待，请求处理的相应时间过长。所以，针对响应时间比较敏感的系统，基于链表实现的无限排队的线程池是不合适的。</p><p>而基于数组实现的有界队列，队列的大小有限，所以线程池中排队的请求超过队列大小时，接下来的请求就会被拒绝，这种方式对响应时间敏感的系统来说，就像对更加合理。</p><p>分布式应用中的消息队列，也是一种队列结构。<br>考虑使用CAS实现无锁队列，在入队前，获取tail位置，入队是比较tail是否发生变化，如果否，则允许入队，反之，本次入队失败，出队则是获取head位置，进行cas。</p><h2 id="顺序队列"><a href="#顺序队列" class="headerlink" title="顺序队列"></a>顺序队列</h2><p>对于队列，需要两个指针：一个是head指针，指向对头；一个是tail指针，指向队尾。随着不停地进行入队、出队操作，head和tail都会持续往后移动。当tail移动到最右边，即使数组中还有空闲空间，也无法继续往队列中添加数据了。<br>一种方法是，对于入队enqueue()，进行判断队列末尾是否有空间，然后将数据整体搬移一次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">enqueue</span><span class="params">(String item)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (tail == n) &#123;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = head; i &lt; tail; i++) &#123;</span><br><span class="line">items[i - head] = items[i];</span><br><span class="line">&#125;</span><br><span class="line">tail -= head;</span><br><span class="line">head = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">items[tail] = item;</span><br><span class="line">tail++;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="顺序队列实现"><a href="#顺序队列实现" class="headerlink" title="顺序队列实现"></a>顺序队列实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 用数组实现的动态扩容顺序队列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: rhsphere</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>: 2019-05-30 20:53 by jdk 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> E[] q;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> head;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> tail;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayQueu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">q = (E[]) <span class="keyword">new</span> Object[<span class="number">2</span>];</span><br><span class="line">n = <span class="number">0</span>;</span><br><span class="line">head = <span class="number">0</span>;</span><br><span class="line">tail = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> n == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line"><span class="keyword">assert</span> capacity &gt; <span class="number">0</span>;</span><br><span class="line">E[] tmp = (E[]) <span class="keyword">new</span> Object[capacity];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">tmp[i] = q[(head + i) % q.length];</span><br><span class="line">q = tmp;</span><br><span class="line">head = <span class="number">0</span>;</span><br><span class="line">tail = n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n == q.length) </span><br><span class="line">resize(<span class="number">2</span> * q.length);</span><br><span class="line">q[tail++] = e;</span><br><span class="line"><span class="keyword">if</span> (tail == q.length)</span><br><span class="line">tail = <span class="number">0</span>;</span><br><span class="line">n++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException(<span class="string">"Queue underflow"</span>);</span><br><span class="line">&#125;</span><br><span class="line">E e = q[head];</span><br><span class="line">q[head] = <span class="keyword">null</span>;</span><br><span class="line">n--;</span><br><span class="line">head++;</span><br><span class="line"><span class="keyword">if</span> (head == q.length)</span><br><span class="line">head = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (n &gt; <span class="number">0</span> &amp;&amp; n == q.length / <span class="number">4</span>)</span><br><span class="line">resize(q.length / <span class="number">2</span>);</span><br><span class="line"><span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (isEmpty())</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException(<span class="string">"Queue underflow"</span>);</span><br><span class="line"><span class="keyword">return</span> q[head];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ArrayIterator();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> i &lt; n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!hasNext())</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line"></span><br><span class="line">E e = q[(i + head) % q.length];</span><br><span class="line">i++;</span><br><span class="line"><span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链式队列"><a href="#链式队列" class="headerlink" title="链式队列"></a>链式队列</h2><p>基于链表的实现，同样需要两个指针：head指针和tail指针。分别指向链表的第一个节点和最后一个节点。入队时，tail.next = newNode, tail = tail.next; 出队时，head = head.next;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 链式队列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: rhsphere</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>: 2019-05-30 22:11 by jdk 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">pubilc <span class="class"><span class="keyword">class</span> <span class="title">LinkedQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> Node&lt;E&gt; head;</span><br><span class="line"><span class="keyword">private</span> Node&lt;E&gt; tail;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> E e;</span><br><span class="line"><span class="keyword">private</span> Node&lt;E&gt; next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">head = <span class="keyword">null</span>;</span><br><span class="line">tail = <span class="keyword">null</span>;</span><br><span class="line">n = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> head == <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (isEmpty())</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException(<span class="string">"Queue underfolw"</span>);</span><br><span class="line"><span class="keyword">return</span> head.e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">Node&lt;E&gt; oldtail = tail;</span><br><span class="line">tail = <span class="keyword">new</span> Node&lt;E&gt;();</span><br><span class="line">tail.e = e;</span><br><span class="line">tail.next = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">head = tail;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">oldtail.next = tail;</span><br><span class="line">&#125;</span><br><span class="line">n++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException(<span class="string">"Queue underflow"</span>);</span><br><span class="line">&#125;</span><br><span class="line">E e = head.e;</span><br><span class="line">head = head.next;</span><br><span class="line">n--;</span><br><span class="line"><span class="keyword">if</span> (isEmpty())</span><br><span class="line">tail = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">pulbic String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="keyword">for</span> (E e : <span class="keyword">this</span>) &#123;</span><br><span class="line">sb.append(e);</span><br><span class="line">sb.append(<span class="string">' '</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ListIterator&lt;E&gt;(head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> Node&lt;E&gt; cur;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ListIterator</span><span class="params">(Node&lt;E&gt; head)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.cur = head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> cur != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!hasNext())</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">E e = cur.e;</span><br><span class="line">cur = cur.next;</span><br><span class="line"><span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h2><p>在用数组实现队列的时候，在tail=n时，会有数据搬移，这样入队操作性能就会受到影响。</p><p>循环队列最关键的是，确定好队空和队满的判定条件。 </p><p>对于数组实现的非循环队列中，队满的判断条件是tail == n，队空的判断条件时head == tail。<br>针对循环队列，队空的判断条件是head == tail。但是队满的判断条件是 <strong> （tail + 1) % n == head </strong>。</p><p>队满时tail指向的位置实际上是没有存储数据的，所有，循环队列会浪费一个数组空间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 循环队列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: rhsphere</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>: 2019-05-30 22:42 by jdk 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CircularQueue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> E[] q;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> head = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> tail = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CircularQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">q = (E[]) <span class="keyword">new</span> Object[capacity];</span><br><span class="line">n = capacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">enqueue</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> ((tail + <span class="number">1</span>) % n == head)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">q[tail] = e;</span><br><span class="line">tail = (tail + <span class="number">1</span>) % n;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">dequeu</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (head == tail)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">E res = q[head];</span><br><span class="line">head = (head + <span class="number">1</span>) % n;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试LinkedQueue和ArrayQueue"><a href="#测试LinkedQueue和ArrayQueue" class="headerlink" title="测试LinkedQueue和ArrayQueue"></a>测试LinkedQueue和ArrayQueue</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 测试顺序队列和链式队列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: rhsphere</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>: 2019-05-30 22:02 by jdk 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestQueue</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"==========测试ArrayQueue==============="</span>);</span><br><span class="line">        ArrayQueue&lt;String&gt; arrayQueue = <span class="keyword">new</span> ArrayQueue&lt;&gt;();</span><br><span class="line">        arrayQueue.enqueue(<span class="string">"Hello, "</span>);</span><br><span class="line">        arrayQueue.enqueue(<span class="string">"world! "</span>);</span><br><span class="line">        arrayQueue.enqueue(<span class="string">"You, "</span>);</span><br><span class="line">        arrayQueue.enqueue(<span class="string">"there."</span>);</span><br><span class="line">        <span class="keyword">for</span> (String s : arrayQueue)</span><br><span class="line">            System.out.print(s);</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!arrayQueue.isEmpty()) &#123;</span><br><span class="line">            System.out.print(arrayQueue.dequeue());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"\n("</span> + arrayQueue.size() + <span class="string">" left on array queue) "</span>);</span><br><span class="line">        System.out.println(<span class="string">"=========结束测试============"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"==========测试LinkedQueue=============="</span>);</span><br><span class="line">       LinkedQueue&lt;Integer&gt; linkedQueue = <span class="keyword">new</span> LinkedQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">       linkedQueue.enqueue(<span class="number">1</span>);</span><br><span class="line">       linkedQueue.enqueue(<span class="number">3</span>);</span><br><span class="line">       linkedQueue.enqueue(<span class="number">5</span>);</span><br><span class="line">       linkedQueue.enqueue(<span class="number">7</span>);</span><br><span class="line">       linkedQueue.enqueue(<span class="number">9</span>);</span><br><span class="line">        <span class="keyword">for</span> (Integer i : linkedQueue)</span><br><span class="line">            System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!linkedQueue.isEmpty()) &#123;</span><br><span class="line">            System.out.print(linkedQueue.dequeue() + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"\n("</span> + linkedQueue.size() + <span class="string">" left on linked queue) "</span>);</span><br><span class="line">        System.out.println(<span class="string">"=========结束测试============"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Sum-up" scheme="https://www.blogs.rhsphere.com/categories/Sum-up/"/>
    
    
      <category term="Queue" scheme="https://www.blogs.rhsphere.com/tags/Queue/"/>
    
      <category term="ArrayQueue" scheme="https://www.blogs.rhsphere.com/tags/ArrayQueue/"/>
    
      <category term="LinkedQueue" scheme="https://www.blogs.rhsphere.com/tags/LinkedQueue/"/>
    
      <category term="CircularQueue" scheme="https://www.blogs.rhsphere.com/tags/CircularQueue/"/>
    
  </entry>
  
  <entry>
    <title>Stack(栈)</title>
    <link href="https://www.blogs.rhsphere.com/2019/05/30/stack-sum-up.html"/>
    <id>https://www.blogs.rhsphere.com/2019/05/30/stack-sum-up.html</id>
    <published>2019-05-30T12:35:04.000Z</published>
    <updated>2019-05-30T12:43:58.514Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><h2 id="Stack-栈"><a href="#Stack-栈" class="headerlink" title="Stack(栈)"></a>Stack(栈)</h2><p>Last Modified: 2019/5/30 20:36 by dp<br><a href="https://blogs.rhsphere.com/leetcode/2019/05/28/linked-and-array-stack.html" target="_blank" rel="noopener">01. Implement Stack by Array（数组实现栈）</a></p><p><a href="https://blogs.rhsphere.com/leetcode/2019/05/28/linked-and-array-stack.html" target="_blank" rel="noopener">02. Implement Stack by LinkedList（链表实现栈）</a></p><p><a href="https://blogs.rhsphere.com/leetcode/2019/05/29/sample-browser.html" target="_blank" rel="noopener">03. Implement Sample Browser by Stack（用栈模拟浏览器）</a></p><p><a href="https://blogs.rhsphere.com/leetcode/2019/05/29/20.html" target="_blank" rel="noopener">04. Valid Parentheses（有效的括号）</a></p><p><a href="https://blogs.rhsphere.com/leetcode/2019/05/30/32.html" target="_blank" rel="noopener">05. Longest Valid Parentheses（最长有效括号）</a></p><p><a href="https://blogs.rhsphere.com/leetcode/2019/05/30/150.html" target="_blank" rel="noopener">06. Evaluate Reverse Polish Notatio（逆波兰表达式求值）</a></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Sum-up" scheme="https://www.blogs.rhsphere.com/categories/Sum-up/"/>
    
    
      <category term="Stack" scheme="https://www.blogs.rhsphere.com/tags/Stack/"/>
    
      <category term="Sum-up" scheme="https://www.blogs.rhsphere.com/tags/Sum-up/"/>
    
  </entry>
  
  <entry>
    <title>150. Evalute Reverse Polish Notatio</title>
    <link href="https://www.blogs.rhsphere.com/2019/05/30/150.html"/>
    <id>https://www.blogs.rhsphere.com/2019/05/30/150.html</id>
    <published>2019-05-30T11:38:54.000Z</published>
    <updated>2019-05-30T12:32:18.118Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><h2 id="逆波兰表达式求值"><a href="#逆波兰表达式求值" class="headerlink" title="逆波兰表达式求值"></a>逆波兰表达式求值</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>根据<a href="https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F/128437" target="_blank" rel="noopener">逆波兰表示法</a>，求表达式的值。</p><p>有效的运算符包括 +, -, *, / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。</p><p>说明：</p><p>整数除法只保留整数部分。 给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。 示例 1：</p><p>输入: [“2”, “1”, “+”, “3”, “<em>“]<br>输出: 9<br>解释: ((2 + 1) </em> 3) = 9<br>示例 2：</p><p>输入: [“4”, “13”, “5”, “/“, “+”]<br>输出: 6<br>解释: (4 + (13 / 5)) = 6<br>示例 3：</p><p>输入: [“10”, “6”, “9”, “3”, “+”, “-11”, “<em>“, “/“, “</em>“, “17”, “+”, “5”, “+”]<br>输出: 22<br>解释:<br>  ((10 <em> (6 / ((9 + 3) </em> -11))) + 17) + 5<br>= ((10 <em> (6 / (12 </em> -11))) + 17) + 5<br>= ((10 <em> (6 / -132)) + 17) + 5<br>= ((10 </em> 0) + 17) + 5<br>= (0 + 17) + 5<br>= 17 + 5<br>= 22</p><h3 id="java代码"><a href="#java代码" class="headerlink" title="java代码"></a>java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: rhsphere</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>: 2019-05-30 19:52 by jdk 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EvaluateReversePolishNotation</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">evalRPN</span><span class="params">(String[] tokens)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (tokens.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tokens.length; i++) &#123;</span><br><span class="line">String s = tokens[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (s.equals(<span class="string">"+"</span>) || s.equals(<span class="string">"-"</span>) || s.equals(<span class="string">"/"</span>) || s.equals(<span class="string">"*"</span>)) &#123;</span><br><span class="line"><span class="keyword">int</span> b = stack.pop();</span><br><span class="line"><span class="keyword">int</span> a = stack.pop();</span><br><span class="line"><span class="keyword">switch</span>(s) &#123;</span><br><span class="line"> <span class="keyword">case</span> <span class="string">"+"</span>: stack.push(a+b);<span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">"-"</span>: stack.push(a-b);<span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">"*"</span>: stack.push(a*b);<span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">"/"</span>: stack.push(a/b);<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">satck.push(Integer.valueOf(s));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> stack.pop();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Medium" scheme="https://www.blogs.rhsphere.com/categories/Medium/"/>
    
    
      <category term="Stack" scheme="https://www.blogs.rhsphere.com/tags/Stack/"/>
    
  </entry>
  
  <entry>
    <title>32. Longest Valid Parentheses</title>
    <link href="https://www.blogs.rhsphere.com/2019/05/30/32.html"/>
    <id>https://www.blogs.rhsphere.com/2019/05/30/32.html</id>
    <published>2019-05-30T10:44:28.000Z</published>
    <updated>2019-05-30T11:37:42.311Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><h2 id="最长有效括号"><a href="#最长有效括号" class="headerlink" title="最长有效括号"></a>最长有效括号</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个只包含 ‘(‘ 和 ‘)’ 的字符串，找出最长的包含有效括号的子串的长度。</p><p>示例 1:</p><p>输入: “(()”<br>输出: 2<br>解释: 最长有效括号子串为 “()”<br>示例 2:</p><p>输入: “)()())”<br>输出: 4<br>解释: 最长有效括号子串为 “()()”</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>使用栈，本题用了栈的三个操作。</p><p>要记住，<strong>字符串等价于字符数组</strong>，字符串的每个字符都是可以等价于字符数组，所以可以利用数组的性质。</p><h3 id="java代码"><a href="#java代码" class="headerlink" title="java代码"></a>java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">**</span><br><span class="line"> * <span class="meta">@description</span>:</span><br><span class="line"> * <span class="meta">@author</span>: rhsphere</span><br><span class="line"> * <span class="meta">@since</span>: <span class="number">2019</span>-<span class="number">05</span>-<span class="number">30</span> <span class="number">18</span>:<span class="number">47</span> by jdk <span class="number">1.8</span></span><br><span class="line"> */</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongestValidParentheses</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">stack.push(-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (s.charAt(i) == <span class="string">'('</span>) &#123;</span><br><span class="line">stack.push(i);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (!stack.isEmpty()) &#123;</span><br><span class="line">stack.pop();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">stack.push(i);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">max = Math.max(max, i - stack.peek());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">"())((())"</span>;</span><br><span class="line">        <span class="keyword">int</span> len = longestValidParentheses(s);</span><br><span class="line">        System.out.println(len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>写完代码读一下，检查一下错误，这次有两处错误，1）s.charAt(i) == ‘()’<br>2）max = Math.max(max, i - peek());</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Hard" scheme="https://www.blogs.rhsphere.com/categories/Hard/"/>
    
    
      <category term="Stack" scheme="https://www.blogs.rhsphere.com/tags/Stack/"/>
    
      <category term="String" scheme="https://www.blogs.rhsphere.com/tags/String/"/>
    
      <category term="Dynamic Programming" scheme="https://www.blogs.rhsphere.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>leetcode排序</title>
    <link href="https://www.blogs.rhsphere.com/2019/05/29/leetcode-asc.html"/>
    <id>https://www.blogs.rhsphere.com/2019/05/29/leetcode-asc.html</id>
    <published>2019-05-29T02:15:36.000Z</published>
    <updated>2019-05-30T12:46:47.955Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><h2 id="leetcode刷过的题"><a href="#leetcode刷过的题" class="headerlink" title="leetcode刷过的题"></a>leetcode刷过的题</h2><table><thead><tr><th style="text-align:center">#</th><th style="text-align:center">Title(跳转到网站)</th><th style="text-align:center">Difficulty(刷过的)</th></tr></thead><tbody><tr><td style="text-align:center">0001</td><td style="text-align:center"><a href="https://leetcode.com/problems/two-sum/" target="_blank" rel="noopener">Two Sum</a></td><td style="text-align:center"><a href="https://blogs.rhsphere.com/leetcode/2019/05/25/1.html" target="_blank" rel="noopener">Easy</a></td></tr><tr><td style="text-align:center">0002</td><td style="text-align:center"><a href="https://leetcode.com/problems/add-two-numbers/" target="_blank" rel="noopener">Add Two Numbers</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0003</td><td style="text-align:center"><a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">Longest Substring Without Repeating Characters</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0004</td><td style="text-align:center"><a href="https://leetcode.com/problems/median-of-two-sorted-arrays/" target="_blank" rel="noopener">Median of Two Sorted Arrays</a></td><td style="text-align:center">Hard</td></tr><tr><td style="text-align:center">0005</td><td style="text-align:center"><a href="https://leetcode.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">Longest Palindromic Substring</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0006</td><td style="text-align:center"><a href="https://leetcode.com/problems/zigzag-conversion/" target="_blank" rel="noopener">ZigZag Conversion</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0007</td><td style="text-align:center"><a href="https://leetcode.com/problems/reverse-integer/" target="_blank" rel="noopener">Reverse Integer</a></td><td style="text-align:center">Easy</td></tr><tr><td style="text-align:center">0008</td><td style="text-align:center"><a href="https://leetcode.com/problems/string-to-integer-atoi/" target="_blank" rel="noopener">String to Integer (atoi)</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0009</td><td style="text-align:center"><a href="https://leetcode.com/problems/palindrome-number/" target="_blank" rel="noopener">Palindrome Number</a></td><td style="text-align:center">Easy</td></tr><tr><td style="text-align:center">0010</td><td style="text-align:center"><a href="https://leetcode.com/problems/regular-expression-matching" target="_blank" rel="noopener">Regular Expression Matching</a></td><td style="text-align:center">Hard</td></tr><tr><td style="text-align:center">0011</td><td style="text-align:center"><a href="https://leetcode.com/problems/queue-reconstruction-by-height/" target="_blank" rel="noopener">Container With Most Water</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0012</td><td style="text-align:center"><a href="https://leetcode.com/problems/integer-to-roman" target="_blank" rel="noopener">Integer to Roman</a></td><td style="text-align:center"><a href="./Java/leetcode/Solution12.java">Medium</a></td></tr><tr><td style="text-align:center">0013</td><td style="text-align:center"><a href="https://leetcode.com/problems/roman-to-integer/" target="_blank" rel="noopener">Roman to Integer</a></td><td style="text-align:center">Easy</td></tr><tr><td style="text-align:center">0014</td><td style="text-align:center"><a href="https://leetcode.com/problems/longest-common-prefix/" target="_blank" rel="noopener">Longest Common Prefix</a></td><td style="text-align:center">Easy</td></tr><tr><td style="text-align:center">0015</td><td style="text-align:center"><a href="https://leetcode.com/problems/3sum/" target="_blank" rel="noopener">3Sum</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0016</td><td style="text-align:center"><a href="https://leetcode.com/problems/3Sum-Closest/" target="_blank" rel="noopener">3Sum Closest</a></td><td style="text-align:center"><a href="./Java/leetcode/Solution22.java">Medium</a></td></tr><tr><td style="text-align:center">0017</td><td style="text-align:center"><a href="https://leetcode.com/problems/letter-combinations-of-a-phone-number/" target="_blank" rel="noopener">Letter Combinations of a Phone Number</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0018</td><td style="text-align:center"><a href="https://leetcode.com/problems/4sum/" target="_blank" rel="noopener">4Sum</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0019</td><td style="text-align:center"><a href="https://leetcode.com/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="noopener">Remove Nth Node From End of List</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0020</td><td style="text-align:center"><a href="https://leetcode.com/problems/valid-parentheses/" target="_blank" rel="noopener">Valid Parentheses</a></td><td style="text-align:center"><a href="https://blogs.rhsphere.com/leetcode/2019/05/29/20.html" target="_blank" rel="noopener">Easy</a></td></tr><tr><td style="text-align:center">0021</td><td style="text-align:center"><a href="https://leetcode.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">Merge Two Sorted Lists</a></td><td style="text-align:center">Easy</td></tr><tr><td style="text-align:center">0022</td><td style="text-align:center"><a href="https://leetcode.com/problems/generate-parentheses/" target="_blank" rel="noopener">Generate Parentheses</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0023</td><td style="text-align:center"><a href="https://leetcode.com/problems/merge-k-sorted-lists/" target="_blank" rel="noopener">Merge k Sorted Lists</a></td><td style="text-align:center">Hard</td></tr><tr><td style="text-align:center">0024</td><td style="text-align:center"><a href="https://leetcode.com/problems/swap-nodes-in-pairs/" target="_blank" rel="noopener">Swap Nodes in Pairs</a></td><td style="text-align:center"><a href="./Java/leetcode/Solution24.java">Medium</a></td></tr><tr><td style="text-align:center">0026</td><td style="text-align:center"><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-array/" target="_blank" rel="noopener">Remove Duplicates from Sorted Array</a></td><td style="text-align:center">Easy</td></tr><tr><td style="text-align:center">0027</td><td style="text-align:center"><a href="https://leetcode.com/problems/remove-element/" target="_blank" rel="noopener">Remove Element</a></td><td style="text-align:center">Easy</td></tr><tr><td style="text-align:center">0028</td><td style="text-align:center"><a href="https://leetcode.com/problems/implement-strstr/" target="_blank" rel="noopener">Implement strStr()</a></td><td style="text-align:center">Easy</td></tr><tr><td style="text-align:center">0029</td><td style="text-align:center"><a href="https://leetcode.com/problems/divide-two-integers/" target="_blank" rel="noopener">Divide Two Integers</a></td><td style="text-align:center"><a href="./Java/leetcode/Solution29.java">Medium</a></td></tr><tr><td style="text-align:center">0030</td><td style="text-align:center"><a href="https://leetcode.com/problems/substring-with-concatenation-of-all-words/" target="_blank" rel="noopener">Substring with Concatenation of All Words</a></td><td style="text-align:center">Hard</td></tr><tr><td style="text-align:center">0031</td><td style="text-align:center"><a href="https://leetcode.com/problems/next-permutation/" target="_blank" rel="noopener">Next Permutation</a></td><td style="text-align:center"><a href="./Java/leetcode/Solution31.java">Medium</a></td></tr><tr><td style="text-align:center">0032</td><td style="text-align:center"><a href="https://leetcode.com/problems/longest-valid-parentheses/" target="_blank" rel="noopener">Longest Valid Parentheses</a></td><td style="text-align:center">Hard</td></tr><tr><td style="text-align:center">0033</td><td style="text-align:center"><a href="https://leetcode.com/problems/search-in-rotated-sorted-array/" target="_blank" rel="noopener">Search in Rotated Sorted Array</a></td><td style="text-align:center"><a href="./Java/leetcode/Solution33">Medium</a></td></tr><tr><td style="text-align:center">0034</td><td style="text-align:center"><a href="https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/" target="_blank" rel="noopener">Find First and Last Position of Element in Sorted Array</a></td><td style="text-align:center"><a href="./Java/leetcode/Solution34.java">Medium</a></td></tr><tr><td style="text-align:center">0035</td><td style="text-align:center"><a href="https://leetcode.com/problems/search-insert-position/" target="_blank" rel="noopener">Search Insert Position</a></td><td style="text-align:center">Easy</td></tr><tr><td style="text-align:center">0036</td><td style="text-align:center"><a href="https://leetcode.com/problems/valid-sudoku/" target="_blank" rel="noopener">Valid Sudoku</a></td><td style="text-align:center"><a href="./Java/leetcode/Solution36.java">Medium</a></td></tr><tr><td style="text-align:center">0037</td><td style="text-align:center"><a href="https://leetcode.com/problems/sudoku-solver/" target="_blank" rel="noopener">Sudoku Solver</a></td><td style="text-align:center">Hard</td></tr><tr><td style="text-align:center">0038</td><td style="text-align:center"><a href="https://leetcode.com/problems/count-and-say/" target="_blank" rel="noopener">Count and Say</a></td><td style="text-align:center">Easy</td></tr><tr><td style="text-align:center">0039</td><td style="text-align:center"><a href="https://leetcode.com/problems/combination-sum/" target="_blank" rel="noopener">Combination Sum</a></td><td style="text-align:center"><a href="./Java/leetcode/Solution39.java">Medium</a></td></tr><tr><td style="text-align:center">0040</td><td style="text-align:center"><a href="https://leetcode.com/problems/combination-sum-ii/" target="_blank" rel="noopener">Combination Sum II</a></td><td style="text-align:center"><a href="./Java/leetcode/Solution40.java">Medium</a></td></tr><tr><td style="text-align:center">0041</td><td style="text-align:center"><a href="https://leetcode.com/problems/first-missing-positive/" target="_blank" rel="noopener">First Missing Positive</a></td><td style="text-align:center">Hard</td></tr><tr><td style="text-align:center">0042</td><td style="text-align:center"><a href="https://leetcode.com/problems/trapping-rain-water/" target="_blank" rel="noopener">Trapping Rain Water</a></td><td style="text-align:center">Hard</td></tr><tr><td style="text-align:center">0043</td><td style="text-align:center"><a href="https://leetcode.com/problems/multiply-strings/" target="_blank" rel="noopener">Multiply Strings</a></td><td style="text-align:center"><a href="./Java/leetcode/Solution43.java">Medium</a></td></tr><tr><td style="text-align:center">0044</td><td style="text-align:center"><a href="https://leetcode.com/problems/wildcard-matching/" target="_blank" rel="noopener">Wildcard Matching</a></td><td style="text-align:center">Hard</td></tr><tr><td style="text-align:center">0045</td><td style="text-align:center"><a href="https://leetcode.com/problems/jump-game-ii/" target="_blank" rel="noopener">Jump Game II</a></td><td style="text-align:center">Hard</td></tr><tr><td style="text-align:center">0046</td><td style="text-align:center"><a href="https://leetcode.com/problems/permutations/" target="_blank" rel="noopener">Permutations</a></td><td style="text-align:center"><a href="./Java/leetcode/Solution46.java">Medium</a></td></tr><tr><td style="text-align:center">0047</td><td style="text-align:center"><a href="https://leetcode.com/problems/permutations-ii/" target="_blank" rel="noopener">Permutations II</a></td><td style="text-align:center"><a href="./Java/leetcode/Solution47.java">Medium</a></td></tr><tr><td style="text-align:center">0048</td><td style="text-align:center"><a href="https://leetcode.com/problems/rotate-image/" target="_blank" rel="noopener">Rotate Image</a></td><td style="text-align:center"><a href="./Java/leetcode/Solution48.java">Medium</a></td></tr><tr><td style="text-align:center">0049</td><td style="text-align:center"><a href="https://leetcode.com/problems/group-anagrams/" target="_blank" rel="noopener">Group Anagrams</a></td><td style="text-align:center"><a href="./Java/leetcode/Solution49.java">Medium</a></td></tr><tr><td style="text-align:center">0050</td><td style="text-align:center"><a href="https://leetcode.com/problems/powx-n/" target="_blank" rel="noopener">Pow(x, n)</a></td><td style="text-align:center"><a href="./Java/leetcode/Solution50.java">Medium</a></td></tr><tr><td style="text-align:center">0051</td><td style="text-align:center"><a href="https://leetcode.com/problems/n-queens/" target="_blank" rel="noopener">N-Queens</a></td><td style="text-align:center">Hard</td></tr><tr><td style="text-align:center">0052</td><td style="text-align:center"><a href="https://leetcode.com/problems/n-queens-ii/" target="_blank" rel="noopener">N-Queens II</a></td><td style="text-align:center">Hard</td></tr><tr><td style="text-align:center">0053</td><td style="text-align:center"><a href="https://leetcode.com/problems/maximum-subarray/" target="_blank" rel="noopener">Maximum Subarray</a></td><td style="text-align:center">Easy</td></tr><tr><td style="text-align:center">0054</td><td style="text-align:center"><a href="https://leetcode.com/problems/spiral-matrix/" target="_blank" rel="noopener">Spiral Matrix</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0055</td><td style="text-align:center"><a href="https://leetcode.com/problems/jump-game/" target="_blank" rel="noopener">Jump Game</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0056</td><td style="text-align:center"><a href="https://leetcode.com/problems/merge-intervals/" target="_blank" rel="noopener">Merge Intervals</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0057</td><td style="text-align:center"><a href="https://leetcode.com/problems/insert-interval/" target="_blank" rel="noopener">Insert Interval</a></td><td style="text-align:center">Hard</td></tr><tr><td style="text-align:center">0058</td><td style="text-align:center"><a href="https://leetcode.com/problems/length-of-last-word/" target="_blank" rel="noopener">Length of Last Word</a></td><td style="text-align:center">Easy</td></tr><tr><td style="text-align:center">0059</td><td style="text-align:center"><a href="https://leetcode.com/problem/spiral-matrix-ii/" target="_blank" rel="noopener">Spiral Matrix II</a></td><td style="text-align:center">Hard</td></tr><tr><td style="text-align:center">0060</td><td style="text-align:center"><a href="https://leetcode.com/problems/permutation-sequence/" target="_blank" rel="noopener">Permutation Sequence</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0061</td><td style="text-align:center"><a href="https://leetcode.com/problems/rotate-list/" target="_blank" rel="noopener">Rotate List</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0062</td><td style="text-align:center"><a href="https://leetcode.com/problems/unique-paths/" target="_blank" rel="noopener">Unique Paths</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0063</td><td style="text-align:center"><a href="https://leetcode.com/problems/unique-paths-ii/" target="_blank" rel="noopener">Unique Paths II</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0064</td><td style="text-align:center"><a href="https://leetcode.com/problems/minimum-path-sum/" target="_blank" rel="noopener">Minimum Path Sum</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0065</td><td style="text-align:center"><a href="https://leetcode.com/problems/valid-number/" target="_blank" rel="noopener">Valid Number</a></td><td style="text-align:center">Hard</td></tr><tr><td style="text-align:center">0066</td><td style="text-align:center"><a href="https://leetcode.com/problems/plus-one/" target="_blank" rel="noopener">Plus One</a></td><td style="text-align:center">Easy</td></tr><tr><td style="text-align:center">0068</td><td style="text-align:center"><a href="https://leetcode.com/problems/text-justification/" target="_blank" rel="noopener">Text Justification</a></td><td style="text-align:center">Hard</td></tr><tr><td style="text-align:center">0069</td><td style="text-align:center"><a href="https://leetcode.com/problems/sqrtx/" target="_blank" rel="noopener">Sqrt(x)</a></td><td style="text-align:center">Easy</td></tr><tr><td style="text-align:center">0070</td><td style="text-align:center"><a href="https://leetcode.com/problems/climbing-stairs/" target="_blank" rel="noopener">Climbing Stairs</a></td><td style="text-align:center">Easy</td></tr><tr><td style="text-align:center">0071</td><td style="text-align:center"><a href="https://leetcode.com/problems/simplify-path/" target="_blank" rel="noopener">Simplify Path</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0072</td><td style="text-align:center"><a href="https://leetcode.com/problems/edit-distance/" target="_blank" rel="noopener">Edit Distance</a></td><td style="text-align:center">Hard</td></tr><tr><td style="text-align:center">0073</td><td style="text-align:center"><a href="https://leetcode.com/problems/set-matrix-zeroes/" target="_blank" rel="noopener">Set Matrix Zeroes</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0074</td><td style="text-align:center"><a href="https://leetcode.com/problems/search-a-2d-matrix/" target="_blank" rel="noopener">Search a 2D Matrix</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0075</td><td style="text-align:center"><a href="https://leetcode.com/problems/sort-colors/" target="_blank" rel="noopener">Sort Colors</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0076</td><td style="text-align:center"><a href="https://leetcode.com/problems/minimum-window-substring/" target="_blank" rel="noopener">Minimum Window Substring</a></td><td style="text-align:center">Easy</td></tr><tr><td style="text-align:center">0077</td><td style="text-align:center"><a href="https://leetcode.com/problems/combinations/" target="_blank" rel="noopener">Combinations</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0078</td><td style="text-align:center"><a href="https://leetcode.com/problems/subsets/" target="_blank" rel="noopener">Subsets</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0079</td><td style="text-align:center"><a href="https://leetcode.com/problems/word-search/" target="_blank" rel="noopener">Word Search</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0080</td><td style="text-align:center"><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/" target="_blank" rel="noopener">Remove Duplicates from Sorted Array II</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0081</td><td style="text-align:center"><a href="https://leetcode.com/problems/search-in-rotated-sorted-array-ii/" target="_blank" rel="noopener">Search in Rotated Sorted Array II</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0082</td><td style="text-align:center"><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/" target="_blank" rel="noopener">Remove Duplicates from Sorted List II</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0083</td><td style="text-align:center"><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-list/" target="_blank" rel="noopener">Remove Duplicates from Sorted List</a></td><td style="text-align:center">Easy</td></tr><tr><td style="text-align:center">0084</td><td style="text-align:center"><a href="https://leetcode.com/problems/largest-rectangle-in-histogram/" target="_blank" rel="noopener">Largest Rectangle in Histogram</a></td><td style="text-align:center">Hard</td></tr><tr><td style="text-align:center">0085</td><td style="text-align:center"><a href="https://leetcode.com/problems/maximal-rectangle/" target="_blank" rel="noopener">Maximal Rectangle</a></td><td style="text-align:center">Hard</td></tr><tr><td style="text-align:center">0086</td><td style="text-align:center"><a href="https://leetcode.com/problems/partition-list/" target="_blank" rel="noopener">Partition List</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0087</td><td style="text-align:center"><a href="https://leetcode.com/problems/scramble-string/" target="_blank" rel="noopener">Scramble String</a></td><td style="text-align:center">Hard</td></tr><tr><td style="text-align:center">0088</td><td style="text-align:center"><a href="https://leetcode.com/problems/merge-sorted-array/" target="_blank" rel="noopener">Merge Sorted Array</a></td><td style="text-align:center">Easy</td></tr><tr><td style="text-align:center">0089</td><td style="text-align:center"><a href="https://leetcode.com/problems/gray-code/" target="_blank" rel="noopener">Gray Code</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0090</td><td style="text-align:center"><a href="https://leetcode.com/problems/subsets-ii/" target="_blank" rel="noopener">Subsets II</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0091</td><td style="text-align:center"><a href="https://leetcode.com/problems/decode-ways/" target="_blank" rel="noopener">Decode Ways</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0092</td><td style="text-align:center"><a href="https://leetcode.com/problems/reverse-linked-list-ii/" target="_blank" rel="noopener">Reverse Linked List II</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0093</td><td style="text-align:center"><a href="https://leetcode.com/problems/restore-ip-addresses/" target="_blank" rel="noopener">Restore IP Addresses</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0094</td><td style="text-align:center"><a href="https://leetcode.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">Binary Tree Inorder Traversal</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0095</td><td style="text-align:center"><a href="https://leetcode.com/problems/unique-binary-search-trees-ii/" target="_blank" rel="noopener">Unique Binary Search Trees II</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0096</td><td style="text-align:center"><a href="https://leetcode.com/problems/unique-binary-search-trees/" target="_blank" rel="noopener">Unique Binary Search Trees</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0097</td><td style="text-align:center"><a href="https://leetcode.com/problems/interleaving-string/" target="_blank" rel="noopener">Interleaving String</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0098</td><td style="text-align:center"><a href="https://leetcode.com/problems/validate-binary-search-tree/" target="_blank" rel="noopener">Validate Binary Search Tree</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0099</td><td style="text-align:center"><a href="https://leetcode.com/problems/recover-binary-search-tree/" target="_blank" rel="noopener">Recover Binary Search Tree</a></td><td style="text-align:center">Hard</td></tr><tr><td style="text-align:center">0100</td><td style="text-align:center"><a href="https://leetcode.com/problems/same-tree/" target="_blank" rel="noopener">Same Tree</a></td><td style="text-align:center">Easy</td></tr><tr><td style="text-align:center">0101</td><td style="text-align:center"><a href="https://leetcode.com/problems/symmetric-tree/" target="_blank" rel="noopener">Symmetric Tree</a></td><td style="text-align:center">Easy</td></tr><tr><td style="text-align:center">0102</td><td style="text-align:center"><a href="https://leetcode.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">Binary Tree Level Order Traversal</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0103</td><td style="text-align:center"><a href="https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/" target="_blank" rel="noopener">Binary Tree Zigzag Level Order Traversal</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0104</td><td style="text-align:center"><a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">Maximum Depth of Binary Tree</a></td><td style="text-align:center">Easy</td></tr><tr><td style="text-align:center">0105</td><td style="text-align:center"><a href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" target="_blank" rel="noopener">Construct Binary Tree from Preorder and Inorder Traversal</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0106</td><td style="text-align:center"><a href="https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/" target="_blank" rel="noopener">Construct Binary Tree from Inorder and Postorder Traversal</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0107</td><td style="text-align:center"><a href="https://leetcode.com/problems/binary-tree-level-order-traversal-ii/" target="_blank" rel="noopener">Binary Tree Level Order Traversal II</a></td><td style="text-align:center">Easy</td></tr><tr><td style="text-align:center">0108</td><td style="text-align:center"><a href="https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/" target="_blank" rel="noopener">Convert Sorted Array to Binary Search Tree</a></td><td style="text-align:center">Easy</td></tr><tr><td style="text-align:center">0109</td><td style="text-align:center"><a href="https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/" target="_blank" rel="noopener">Convert Sorted List to Binary Search Tree</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0110</td><td style="text-align:center"><a href="https://leetcode.com/problems/balanced-binary-tree/" target="_blank" rel="noopener">Balanced Binary Tree</a></td><td style="text-align:center">Easy</td></tr><tr><td style="text-align:center">0111</td><td style="text-align:center"><a href="https://leetcode.com/problems/minimum-depth-of-binary-tree/" target="_blank" rel="noopener">Minimum Depth of Binary Tree</a></td><td style="text-align:center">Easy</td></tr><tr><td style="text-align:center">0112</td><td style="text-align:center"><a href="https://leetcode.com/problems/path-sum/" target="_blank" rel="noopener">Path Sum</a></td><td style="text-align:center">Easy</td></tr><tr><td style="text-align:center">0113</td><td style="text-align:center"><a href="https://leetcode.com/problems/path-sum-ii/" target="_blank" rel="noopener">Path Sum II</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0114</td><td style="text-align:center"><a href="https://leetcode.com/problems/flatten-binary-tree-to-linked-list/" target="_blank" rel="noopener">Flatten Binary Tree to Linked List</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0115</td><td style="text-align:center"><a href="https://leetcode.com/problems/distinct-subsequences/" target="_blank" rel="noopener">Distinct Subsequences</a></td><td style="text-align:center">Hard</td></tr><tr><td style="text-align:center">0116</td><td style="text-align:center"><a href="https://leetcode.com/problems/populating-next-right-pointers-in-each-node/" target="_blank" rel="noopener">Populating Next Right Pointers in Each Node</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0117</td><td style="text-align:center"><a href="https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/" target="_blank" rel="noopener">Populating Next Right Pointers in Each Node II</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0118</td><td style="text-align:center"><a href="https://leetcode.com/problems/pascals-triangle/" target="_blank" rel="noopener">Pascal’s Triangle</a></td><td style="text-align:center">Easy</td></tr><tr><td style="text-align:center">0119</td><td style="text-align:center"><a href="https://leetcode.com/problems/pascals-triangle-ii/" target="_blank" rel="noopener">Pascal’s Triangle II</a></td><td style="text-align:center">Easy</td></tr><tr><td style="text-align:center">0120</td><td style="text-align:center"><a href="https://leetcode.com/problems/triangle/" target="_blank" rel="noopener">Triangle</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0121</td><td style="text-align:center"><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">Best Time to Buy and Sell Stock</a></td><td style="text-align:center">Easy</td></tr><tr><td style="text-align:center">0122</td><td style="text-align:center"><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="noopener">Best Time to Buy and Sell Stock II</a></td><td style="text-align:center">Easy</td></tr><tr><td style="text-align:center">0123</td><td style="text-align:center"><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/" target="_blank" rel="noopener">Best Time to Buy and Sell Stock III</a></td><td style="text-align:center">Hard</td></tr><tr><td style="text-align:center">0124</td><td style="text-align:center"><a href="https://leetcode.com/problems/binary-tree-maximum-path-sum/" target="_blank" rel="noopener">Binary Tree Maximum Path Sum</a></td><td style="text-align:center">Hard</td></tr><tr><td style="text-align:center">0125</td><td style="text-align:center"><a href="https://leetcode.com/problems/valid-palindrome/" target="_blank" rel="noopener">Valid Palindrome</a></td><td style="text-align:center">Easy</td></tr><tr><td style="text-align:center">0126</td><td style="text-align:center"><a href="https://leetcode.com/problems/word-ladder-ii/" target="_blank" rel="noopener">Word Ladder II</a></td><td style="text-align:center">Hard</td></tr><tr><td style="text-align:center">0127</td><td style="text-align:center"><a href="https://leetcode.com/problems/word-ladder/" target="_blank" rel="noopener">Word Ladder</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0128</td><td style="text-align:center"><a href="https://leetcode.com/problems/longest-consecutive-sequence/" target="_blank" rel="noopener">Longest Consecutive Sequence</a></td><td style="text-align:center">Hard</td></tr><tr><td style="text-align:center">0129</td><td style="text-align:center"><a href="https://leetcode.com/problems/sum-root-to-leaf-numbers/" target="_blank" rel="noopener">Sum Root to Leaf Numbers</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0130</td><td style="text-align:center"><a href="https://leetcode.com/problems/surrounded-regions/" target="_blank" rel="noopener">Surrounded Regions</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0131</td><td style="text-align:center"><a href="https://leetcode.com/problems/palindrome-partitioning/" target="_blank" rel="noopener">Palindrome Partitioning</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0132</td><td style="text-align:center"><a href="https://leetcode.com/problems/palindrome-partitioning-ii/" target="_blank" rel="noopener">Palindrome Partitioning II</a></td><td style="text-align:center">Hard</td></tr><tr><td style="text-align:center">0133</td><td style="text-align:center"><a href="https://leetcode.com/problems/clone-graph/" target="_blank" rel="noopener">Clone Graph</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0134</td><td style="text-align:center"><a href="https://leetcode.com/problems/gas-station/" target="_blank" rel="noopener">Gas Station</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0135</td><td style="text-align:center"><a href="https://leetcode.com/problems/gas-station/" target="_blank" rel="noopener">Candy</a></td><td style="text-align:center">Hard</td></tr><tr><td style="text-align:center">0136</td><td style="text-align:center"><a href="https://leetcode.com/problems/single-number/" target="_blank" rel="noopener">Single Number</a></td><td style="text-align:center">Easy</td></tr><tr><td style="text-align:center">0137</td><td style="text-align:center"><a href="https://leetcode.com/problems/single-number-ii/" target="_blank" rel="noopener">Single Number II</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0138</td><td style="text-align:center"><a href="https://leetcode.com/problems/copy-list-with-random-pointer/" target="_blank" rel="noopener">Copy List with Random Pointer</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0139</td><td style="text-align:center"><a href="https://leetcode.com/problems/word-break/" target="_blank" rel="noopener">Word Break</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0140</td><td style="text-align:center"><a href="https://leetcode.com/problems/word-break-ii/" target="_blank" rel="noopener">Word Break II</a></td><td style="text-align:center">Hard</td></tr><tr><td style="text-align:center">0141</td><td style="text-align:center"><a href="https://leetcode.com/problems/linked-list-cycle/" target="_blank" rel="noopener">Linked List Cycle</a></td><td style="text-align:center">Easy</td></tr><tr><td style="text-align:center">0142</td><td style="text-align:center"><a href="https://leetcode.com/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">Linked List Cycle II</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0143</td><td style="text-align:center"><a href="https://leetcode.com/problems/reorder-list/" target="_blank" rel="noopener">Reorder-List</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0144</td><td style="text-align:center"><a href="https://leetcode.com/problems/binary-tree-preorder-traversal/" target="_blank" rel="noopener">Binary Tree Preorder Traversal</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0145</td><td style="text-align:center"><a href="https://leetcode.com/problems/binary-tree-postorder-traversal/" target="_blank" rel="noopener">Binary Tree Postorder Traversal</a></td><td style="text-align:center">Hard</td></tr><tr><td style="text-align:center">0146</td><td style="text-align:center"><a href="https://leetcode.com/problems/lru-cache/" target="_blank" rel="noopener">LRU Cache</a></td><td style="text-align:center">Hard</td></tr><tr><td style="text-align:center">0147</td><td style="text-align:center"><a href="https://leetcode.com/problems/insertion-sort-list/" target="_blank" rel="noopener">Insertion Sort List</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0148</td><td style="text-align:center"><a href="https://leetcode.com/problems/sort-list/" target="_blank" rel="noopener">Sort List</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0149</td><td style="text-align:center"><a href="https://leetcode.com/problems/max-points-on-a-line/" target="_blank" rel="noopener">Max Points on a Line</a></td><td style="text-align:center">Hard</td></tr><tr><td style="text-align:center">0150</td><td style="text-align:center"><a href="https://leetcode.com/problems/evaluate-reverse-polish-notation/" target="_blank" rel="noopener">Evaluate Reverse Polish Notation</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0151</td><td style="text-align:center"><a href="https://leetcode.com/problems/evaluate-reverse-polish-notation/" target="_blank" rel="noopener">Reverse Words in a String</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0152</td><td style="text-align:center"><a href="https://leetcode.com/problems/evaluate-reverse-polish-notation/" target="_blank" rel="noopener">Maximum Product Subarray</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0153</td><td style="text-align:center"><a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/" target="_blank" rel="noopener">Find Minimum in Rotated Sorted Array</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0154</td><td style="text-align:center"><a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/" target="_blank" rel="noopener">Find Minimum in Rotated Sorted Array II</a></td><td style="text-align:center">Hard</td></tr><tr><td style="text-align:center">0155</td><td style="text-align:center"><a href="https://leetcode.com/problems/min-stack/" target="_blank" rel="noopener">Min Stack</a></td><td style="text-align:center">Easy</td></tr><tr><td style="text-align:center">0160</td><td style="text-align:center"><a href="https://leetcode.com/problems/intersection-of-two-linked-lists/" target="_blank" rel="noopener">Intersection of Two Linked Lists</a></td><td style="text-align:center">Easy</td></tr><tr><td style="text-align:center">0162</td><td style="text-align:center"><a href="https://leetcode.com/problems/find-peak-element/" target="_blank" rel="noopener">Find Peak Element</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0165</td><td style="text-align:center"><a href="https://leetcode.com/problems/compare-version-numbers/" target="_blank" rel="noopener">Compare Version Numbers</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0166</td><td style="text-align:center"><a href="https://leetcode.com/problems/fraction-to-recurring-decimal/" target="_blank" rel="noopener">Fraction to Recurring Decimal</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0167</td><td style="text-align:center"><a href="https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/" target="_blank" rel="noopener">Two Sum II - Input array is sorted</a></td><td style="text-align:center">Easy</td></tr><tr><td style="text-align:center">0168</td><td style="text-align:center"><a href="https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/" target="_blank" rel="noopener">Excel Sheet Column Title</a></td><td style="text-align:center">Easy</td></tr><tr><td style="text-align:center">0169</td><td style="text-align:center"><a href="https://leetcode.com/problems/majority-element/" target="_blank" rel="noopener">Majority Element</a></td><td style="text-align:center">Easy</td></tr><tr><td style="text-align:center">0171</td><td style="text-align:center"><a href="https://leetcode.com/problems/excel-sheet-column-number/" target="_blank" rel="noopener">Excel Sheet Column Number</a></td><td style="text-align:center">Easy</td></tr><tr><td style="text-align:center">0172</td><td style="text-align:center"><a href="https://leetcode.com/problems/factorial-trailing-zeroes/" target="_blank" rel="noopener">Factorial Trailing Zeroes</a></td><td style="text-align:center">Easy</td></tr><tr><td style="text-align:center">0173</td><td style="text-align:center"><a href="https://leetcode.com/problems/binary-search-tree-iterator/" target="_blank" rel="noopener">Binary Search Tree Iterator</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0174</td><td style="text-align:center"><a href="https://leetcode.com/problems/dungeon-game/" target="_blank" rel="noopener">Dungeon Game</a></td><td style="text-align:center">Hard</td></tr><tr><td style="text-align:center">0187</td><td style="text-align:center"><a href="https://leetcode.com/problems/repeated-dna-sequences/" target="_blank" rel="noopener">Repeated-DNA-Sequences</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0188</td><td style="text-align:center"><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/" target="_blank" rel="noopener">Best Time to Buy and Sell Stock IV</a></td><td style="text-align:center">Hard</td></tr><tr><td style="text-align:center">0189</td><td style="text-align:center"><a href="https://leetcode.com/problems/rotate-array/" target="_blank" rel="noopener">Rotate Array</a></td><td style="text-align:center">Easy</td></tr><tr><td style="text-align:center">0190</td><td style="text-align:center"><a href="https://leetcode.com/problems/reverse-bits/" target="_blank" rel="noopener">Reverse Bits</a></td><td style="text-align:center">Easy</td></tr><tr><td style="text-align:center">0191</td><td style="text-align:center"><a href="https://leetcode.com/problems/number-of-1-bits/" target="_blank" rel="noopener">Number of 1 Bits</a></td><td style="text-align:center">Easy</td></tr><tr><td style="text-align:center">0198</td><td style="text-align:center"><a href="https://leetcode.com/problems/house-robber/" target="_blank" rel="noopener">House Robber</a></td><td style="text-align:center">Easy</td></tr><tr><td style="text-align:center">0199</td><td style="text-align:center"><a href="https://leetcode.com/problems/binary-tree-right-side-view/" target="_blank" rel="noopener">Binary Tree Right Side View</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0200</td><td style="text-align:center"><a href="https://leetcode.com/problems/number-of-islands/" target="_blank" rel="noopener">Number of Islands</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0201</td><td style="text-align:center"><a href="https://leetcode.com/problems/bitwise-and-of-numbers-range/" target="_blank" rel="noopener">Bitwise AND of Numbers Range</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0202</td><td style="text-align:center"><a href="https://leetcode.com/problems/happy-number/" target="_blank" rel="noopener">Happy Number</a></td><td style="text-align:center">Easy</td></tr><tr><td style="text-align:center">0203</td><td style="text-align:center"><a href="https://leetcode.com/problems/remove-linked-list-elements/" target="_blank" rel="noopener">Remove Linked List Elements</a></td><td style="text-align:center">Easy</td></tr><tr><td style="text-align:center">0204</td><td style="text-align:center"><a href="https://leetcode.com/problems/remove-linked-list-elements/" target="_blank" rel="noopener">Count Primes</a></td><td style="text-align:center">Easy</td></tr><tr><td style="text-align:center">0205</td><td style="text-align:center"><a href="https://leetcode.com/problems/isomorphic-strings/" target="_blank" rel="noopener">Isomorphic Strings</a></td><td style="text-align:center">Easy</td></tr><tr><td style="text-align:center">0206</td><td style="text-align:center"><a href="https://leetcode.com/problems/reverse-linked-list/" target="_blank" rel="noopener">Reverse Linked List</a></td><td style="text-align:center">Easy</td></tr><tr><td style="text-align:center">0208</td><td style="text-align:center"><a href="https://leetcode.com/problems/implement-trie-prefix-tree/" target="_blank" rel="noopener">Implement Trie (Prefix Tree)</a></td><td style="text-align:center">Easy</td></tr><tr><td style="text-align:center">0209</td><td style="text-align:center"><a href="https://leetcode.com/problems/minimum-size-subarray-sum/" target="_blank" rel="noopener">Minimum Size Subarray Sum</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0211</td><td style="text-align:center"><a href="https://leetcode.com/problems/add-and-search-word-data-structure-design/" target="_blank" rel="noopener">Add and Search Word - Data structure design</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0213</td><td style="text-align:center"><a href="https://leetcode.com/problems/house-robber-ii/" target="_blank" rel="noopener">House Robber II</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0215</td><td style="text-align:center"><a href="https://leetcode.com/problems/kth-largest-element-in-an-array/" target="_blank" rel="noopener">Kth Largest Element in an Array</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0216</td><td style="text-align:center"><a href="https://leetcode.com/problems/combination-sum-iii/" target="_blank" rel="noopener">Combination Sum III</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0217</td><td style="text-align:center"><a href="https://leetcode.com/problems/contains-duplicate/" target="_blank" rel="noopener">Contains Duplicate</a></td><td style="text-align:center">Easy</td></tr><tr><td style="text-align:center">0219</td><td style="text-align:center"><a href="https://leetcode.com/problems/contains-duplicate-ii/" target="_blank" rel="noopener">Contains Duplicate II</a></td><td style="text-align:center">Easy</td></tr><tr><td style="text-align:center">0222</td><td style="text-align:center"><a href="https://leetcode.com/problems/count-complete-tree-nodes/" target="_blank" rel="noopener">Count Complete Tree Nodes</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0226</td><td style="text-align:center"><a href="https://leetcode.com/problems/invert-binary-tree/" target="_blank" rel="noopener">Invert Binary Tree</a></td><td style="text-align:center">Easy</td></tr><tr><td style="text-align:center">0228</td><td style="text-align:center"><a href="https://leetcode.com/problems/summary-ranges/" target="_blank" rel="noopener">Summary Ranges</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0229</td><td style="text-align:center"><a href="https://leetcode.com/problems/majority-element-ii/" target="_blank" rel="noopener">Majority Element II</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0230</td><td style="text-align:center"><a href="https://leetcode.com/problems/kth-smallest-element-in-a-bst/" target="_blank" rel="noopener">Kth Smallest Element in a BST</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0234</td><td style="text-align:center"><a href="https://leetcode.com/problems/palindrome-linked-list/" target="_blank" rel="noopener">Palindrome Linked List</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0235</td><td style="text-align:center"><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/" target="_blank" rel="noopener">Lowest Common Ancestor of a Binary Search Tree</a></td><td style="text-align:center">Easy</td></tr><tr><td style="text-align:center">0236</td><td style="text-align:center"><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/" target="_blank" rel="noopener">Lowest Common Ancestor of a Binary Tree</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0237</td><td style="text-align:center"><a href="https://leetcode.com/problems/delete-node-in-a-linked-list/" target="_blank" rel="noopener">Delete Node in a Linked List</a></td><td style="text-align:center">Easy</td></tr><tr><td style="text-align:center">0238</td><td style="text-align:center"><a href="https://leetcode.com/problems/product-of-array-except-self/" target="_blank" rel="noopener">Product of Array Except Self</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0239</td><td style="text-align:center"><a href="https://leetcode.com/problems/sliding-window-maximum/" target="_blank" rel="noopener">Sliding Window Maximum</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0241</td><td style="text-align:center"><a href="https://leetcode.com/problems/different-ways-to-add-parentheses/" target="_blank" rel="noopener">Different Ways to Add Parentheses</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0242</td><td style="text-align:center"><a href="https://leetcode.com/problems/valid-anagram/" target="_blank" rel="noopener">Valid Anagram</a></td><td style="text-align:center">Easy</td></tr><tr><td style="text-align:center">0242</td><td style="text-align:center"><a href="https://leetcode.com/problems/binary-tree-paths/" target="_blank" rel="noopener">Binary Tree Paths</a></td><td style="text-align:center">Easy</td></tr><tr><td style="text-align:center">0260</td><td style="text-align:center"><a href="https://leetcode.com/problems/single-number-iii/" target="_blank" rel="noopener">Single Number III</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0268</td><td style="text-align:center"><a href="https://leetcode.com/problems/missing-number/" target="_blank" rel="noopener">Missing Number</a></td><td style="text-align:center">Easy</td></tr><tr><td style="text-align:center">0279</td><td style="text-align:center"><a href="https://leetcode.com/problems/perfect-squares/" target="_blank" rel="noopener">Perfect Squares</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0283</td><td style="text-align:center"><a href="https://leetcode.com/problems/move-zeroes/" target="_blank" rel="noopener">Move Zeroes</a></td><td style="text-align:center">Easy</td></tr><tr><td style="text-align:center">0287</td><td style="text-align:center"><a href="https://leetcode.com/problems/find-the-duplicate-number/" target="_blank" rel="noopener">Find the Duplicate Number</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0289</td><td style="text-align:center"><a href="https://leetcode.com/problems/game-of-life/" target="_blank" rel="noopener">Game of Life</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0290</td><td style="text-align:center"><a href="https://leetcode.com/problems/word-pattern/" target="_blank" rel="noopener">Word Pattern</a></td><td style="text-align:center">Easy</td></tr><tr><td style="text-align:center">0300</td><td style="text-align:center"><a href="https://leetcode.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">Longest Increasing Subsequence</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0303</td><td style="text-align:center"><a href="https://leetcode.com/problems/range-sum-query-immutable/" target="_blank" rel="noopener">Range Sum Query - Immutable</a></td><td style="text-align:center">Easy</td></tr><tr><td style="text-align:center">0307</td><td style="text-align:center"><a href="https://leetcode.com/problems/range-sum-query-mutable/" target="_blank" rel="noopener">Range Sum Query - Mutable</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0309</td><td style="text-align:center"><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/" target="_blank" rel="noopener">Best Time to Buy and Sell Stock with Cooldown</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0322</td><td style="text-align:center"><a href="https://leetcode.com/problems/coin-change/" target="_blank" rel="noopener">Coin-Change</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0325</td><td style="text-align:center"><a href="https://leetcode.com/problems/maximum-size-subarray-sum-equals-k/" target="_blank" rel="noopener">Maximum Size Subarray Sum Equals k</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0328</td><td style="text-align:center"><a href="https://leetcode.com/problems/odd-even-linked-list/" target="_blank" rel="noopener">Odd Even Linked List</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0337</td><td style="text-align:center"><a href="https://leetcode.com/problems/house-robber-iii/" target="_blank" rel="noopener">House Robber III</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0341</td><td style="text-align:center"><a href="https://leetcode.com/problems/flatten-nested-list-iterator/" target="_blank" rel="noopener">Flatten Nested List Iterator</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0343</td><td style="text-align:center"><a href="https://leetcode.com/problems/integer-break/" target="_blank" rel="noopener">Integer Break</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0344</td><td style="text-align:center"><a href="https://leetcode.com/problems/reverse-string/" target="_blank" rel="noopener">Reverse String</a></td><td style="text-align:center">Easy</td></tr><tr><td style="text-align:center">0345</td><td style="text-align:center"><a href="https://leetcode.com/problems/reverse-vowels-of-a-string/" target="_blank" rel="noopener">Reverse Vowels of a String</a></td><td style="text-align:center">Easy</td></tr><tr><td style="text-align:center">0347</td><td style="text-align:center"><a href="https://leetcode.com/problems/top-k-frequent-elements/" target="_blank" rel="noopener">Top K Frequent Elements</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0349</td><td style="text-align:center"><a href="https://leetcode.com/problems/intersection-of-two-arrays/" target="_blank" rel="noopener">Intersection of Two Arrays</a></td><td style="text-align:center">Easy</td></tr><tr><td style="text-align:center">0350</td><td style="text-align:center"><a href="https://leetcode.com/problems/intersection-of-two-arrays-ii/" target="_blank" rel="noopener">Intersection of Two Arrays II</a></td><td style="text-align:center">Easy</td></tr><tr><td style="text-align:center">0377</td><td style="text-align:center"><a href="https://leetcode.com/problems/combination-sum-iv/" target="_blank" rel="noopener">Combination Sum IV</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0389</td><td style="text-align:center"><a href="https://leetcode.com/problems/find-the-difference/" target="_blank" rel="noopener">Find the Difference</a></td><td style="text-align:center">Easy</td></tr><tr><td style="text-align:center">0392</td><td style="text-align:center"><a href="https://leetcode.com/problems/is-subsequence/" target="_blank" rel="noopener">Is Subsequence</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0401</td><td style="text-align:center"><a href="https://leetcode.com/problems/binary-watch/" target="_blank" rel="noopener">Binary Watch</a></td><td style="text-align:center">Easy</td></tr><tr><td style="text-align:center">0404</td><td style="text-align:center"><a href="https://leetcode.com/problems/sum-of-left-leaves/" target="_blank" rel="noopener">Sum of Left Leaves</a></td><td style="text-align:center">Easy</td></tr><tr><td style="text-align:center">0416</td><td style="text-align:center"><a href="https://leetcode.com/problems/partition-equal-subset-sum/" target="_blank" rel="noopener">Partition Equal Subset Sum</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0435</td><td style="text-align:center"><a href="https://leetcode.com/problems/non-overlapping-intervals/" target="_blank" rel="noopener">Non-overlapping Intervals</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0437</td><td style="text-align:center"><a href="https://leetcode.com/problems/path-sum-iii/" target="_blank" rel="noopener">Path Sum III</a></td><td style="text-align:center">Easy</td></tr><tr><td style="text-align:center">0438</td><td style="text-align:center"><a href="https://leetcode.com/problems/find-all-anagrams-in-a-string/" target="_blank" rel="noopener">Find All Anagrams in a String</a></td><td style="text-align:center">Easy</td></tr><tr><td style="text-align:center">0445</td><td style="text-align:center"><a href="https://leetcode.com/problems/add-two-numbers-ii/" target="_blank" rel="noopener">Add Two Numbers II</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0447</td><td style="text-align:center"><a href="https://leetcode.com/problems/number-of-boomerangs/" target="_blank" rel="noopener">Number of Boomerangs</a></td><td style="text-align:center">Easy</td></tr><tr><td style="text-align:center">0450</td><td style="text-align:center"><a href="https://leetcode.com/problems/delete-node-in-a-bst/" target="_blank" rel="noopener">Delete Node in a BST</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0451</td><td style="text-align:center"><a href="https://leetcode.com/problems/sort-characters-by-frequency/" target="_blank" rel="noopener">Sort Characters By Frequency</a></td><td style="text-align:center">Easy</td></tr><tr><td style="text-align:center">0454</td><td style="text-align:center"><a href="https://leetcode.com/problems/4sum-ii/" target="_blank" rel="noopener">4Sum II</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0455</td><td style="text-align:center"><a href="https://leetcode.com/problems/assign-cookies/" target="_blank" rel="noopener">Assign Cookies</a></td><td style="text-align:center">Easy</td></tr><tr><td style="text-align:center">0474</td><td style="text-align:center"><a href="https://leetcode.com/problems/ones-and-zeroes/" target="_blank" rel="noopener">Ones and Zeroes</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0494</td><td style="text-align:center"><a href="https://leetcode.com/problems/target-sum/" target="_blank" rel="noopener">Target Sum</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0496</td><td style="text-align:center"><a href="https://leetcode.com/problems/next-greater-element-i/" target="_blank" rel="noopener">Next Greater Element I</a></td><td style="text-align:center">Easy</td></tr><tr><td style="text-align:center">0503</td><td style="text-align:center"><a href="https://leetcode.com/problems/next-greater-element-i/" target="_blank" rel="noopener">Next Greater Element II</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0525</td><td style="text-align:center"><a href="https://leetcode.com/problems/contiguous-array/" target="_blank" rel="noopener">Contiguous Array</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0560</td><td style="text-align:center"><a href="https://leetcode.com/problems/subarray-sum-equals-k/" target="_blank" rel="noopener">Subarray Sum Equals K</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0704</td><td style="text-align:center"><a href="https://leetcode.com/problems/binary-search/" target="_blank" rel="noopener">Binary Search</a></td><td style="text-align:center"><a href="./Java/leetcode/Solution704.java">Easy</a></td></tr><tr><td style="text-align:center">0705</td><td style="text-align:center"><a href="https://leetcode.com/problems/design-hashset/" target="_blank" rel="noopener">Design HashSet</a></td><td style="text-align:center"><a href="./Java/leetcode/Solution705.java">Easy</a></td></tr><tr><td style="text-align:center">0739</td><td style="text-align:center"><a href="https://leetcode.com/problems/daily-temperatures/" target="_blank" rel="noopener">Daily Temperatures</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0852</td><td style="text-align:center"><a href="https://leetcode.com/problems/peak-index-in-a-mountain-array/" target="_blank" rel="noopener">Peak Index in a Mountain Array</a></td><td style="text-align:center">Easy</td></tr><tr><td style="text-align:center">0901</td><td style="text-align:center"><a href="https://leetcode.com/problems/online-stock-span/" target="_blank" rel="noopener">Online-Stock-Span</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0907</td><td style="text-align:center"><a href="https://leetcode.com/problems/sum-of-subarray-minimums/" target="_blank" rel="noopener">Sum-of-Subarray-Minimums</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0917</td><td style="text-align:center"><a href="https://leetcode.com/problems/reverse-only-letters/" target="_blank" rel="noopener">Reverse Only Letters</a></td><td style="text-align:center">Easy</td></tr><tr><td style="text-align:center">0918</td><td style="text-align:center"><a href="https://leetcode.com/problems/maximum-sum-circular-subarray/" target="_blank" rel="noopener">Maximum Sum Circular Subarray</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0919</td><td style="text-align:center"><a href="https://leetcode.com/problems/complete-binary-tree-inserter/" target="_blank" rel="noopener">Complete Binary Tree Inserter</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0920</td><td style="text-align:center"><a href="https://leetcode.com/problems/number-of-music-playlists/" target="_blank" rel="noopener">Number of Music Playlists</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0921</td><td style="text-align:center"><a href="https://leetcode.com/problems/minimum-add-to-make-parentheses-valid/" target="_blank" rel="noopener">Minimum Add to Make Parentheses Valid</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0922</td><td style="text-align:center"><a href="https://leetcode.com/problems/sort-array-by-parity-ii/" target="_blank" rel="noopener">Sort Array By Parity II</a></td><td style="text-align:center">Easy</td></tr><tr><td style="text-align:center">0923</td><td style="text-align:center"><a href="https://leetcode.com/problems/3sum-with-multiplicity/" target="_blank" rel="noopener">3Sum With Multiplicity</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0925</td><td style="text-align:center"><a href="https://leetcode.com/problems/long-pressed-name/" target="_blank" rel="noopener">Long Pressed Name</a></td><td style="text-align:center">Easy</td></tr><tr><td style="text-align:center">0926</td><td style="text-align:center"><a href="https://leetcode.com/problems/flip-string-to-monotone-increasing/" target="_blank" rel="noopener">Flip String to Monotone Increasing</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0927</td><td style="text-align:center"><a href="https://leetcode.com/problems/three-equal-parts/" target="_blank" rel="noopener">Three Equal Parts</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0929</td><td style="text-align:center"><a href="https://leetcode.com/problems/unique-email-addresses/" target="_blank" rel="noopener">Unique Email Addresses</a></td><td style="text-align:center">Easy</td></tr><tr><td style="text-align:center">0930</td><td style="text-align:center"><a href="https://leetcode.com/problems/binary-subarrays-with-sum/" target="_blank" rel="noopener">Binary Subarrays With Sum</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0931</td><td style="text-align:center"><a href="https://leetcode.com/problems/minimum-falling-path-sum/" target="_blank" rel="noopener">Minimum Falling Path Sum</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0932</td><td style="text-align:center"><a href="https://leetcode.com/problems/minimum-falling-path-sum/" target="_blank" rel="noopener">Beautiful Array</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0933</td><td style="text-align:center"><a href="https://leetcode.com/problems/number-of-recent-calls/" target="_blank" rel="noopener">Number of Recent Calls</a></td><td style="text-align:center">Easy</td></tr><tr><td style="text-align:center">0934</td><td style="text-align:center"><a href="https://leetcode.com/problems/shortest-bridge/" target="_blank" rel="noopener">Shortest Bridge</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0935</td><td style="text-align:center"><a href="https://leetcode.com/problems/knight-dialer/" target="_blank" rel="noopener">Knight Dialer</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0936</td><td style="text-align:center"><a href="https://leetcode.com/problems/stamping-the-sequence/" target="_blank" rel="noopener">Stamping The Sequence</a></td><td style="text-align:center">Hard</td></tr><tr><td style="text-align:center">0937</td><td style="text-align:center"><a href="https://leetcode.com/problems/reorder-log-files/" target="_blank" rel="noopener">Reorder Log Files</a></td><td style="text-align:center">Easy</td></tr><tr><td style="text-align:center">0938</td><td style="text-align:center"><a href="https://leetcode.com/problems/range-sum-of-bst/" target="_blank" rel="noopener">Range Sum of BST</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0939</td><td style="text-align:center"><a href="https://leetcode.com/problems/minimum-area-rectangle/" target="_blank" rel="noopener">Minimum Area Rectangle</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0940</td><td style="text-align:center"><a href="https://leetcode.com/problems/distinct-subsequences-ii/" target="_blank" rel="noopener">Distinct Subsequences II</a></td><td style="text-align:center">Hard</td></tr><tr><td style="text-align:center">0941</td><td style="text-align:center"><a href="https://leetcode.com/problems/valid-mountain-array/" target="_blank" rel="noopener">Valid Mountain Array</a></td><td style="text-align:center">Easy</td></tr><tr><td style="text-align:center">0942</td><td style="text-align:center"><a href="https://leetcode.com/problems/di-string-match/" target="_blank" rel="noopener">DI String Match</a></td><td style="text-align:center">Easy</td></tr><tr><td style="text-align:center">0943</td><td style="text-align:center"><a href="https://leetcode.com/problems/find-the-shortest-superstring/" target="_blank" rel="noopener">Find the Shortest Superstring</a></td><td style="text-align:center">Hard</td></tr><tr><td style="text-align:center">0944</td><td style="text-align:center"><a href="https://leetcode.com/problems/delete-columns-to-make-sorted/" target="_blank" rel="noopener">Delete Columns to Make Sorted</a></td><td style="text-align:center">Easy</td></tr><tr><td style="text-align:center">0945</td><td style="text-align:center"><a href="https://leetcode.com/problems/minimum-increment-to-make-array-unique/" target="_blank" rel="noopener">Minimum Increment to Make Array Unique</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0946</td><td style="text-align:center"><a href="https://leetcode.com/problems/validate-stack-sequences/" target="_blank" rel="noopener">Validate Stack Sequences</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0947</td><td style="text-align:center"><a href="https://leetcode.com/problems/validate-stack-sequences/https://leetcode.com/problems/most-stones-removed-with-same-row-or-column/" target="_blank" rel="noopener">Most Stones Removed with Same Row or Column</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0948</td><td style="text-align:center"><a href="https://leetcode.com/problems/bag-of-tokens/" target="_blank" rel="noopener">Bag of Tokens</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0949</td><td style="text-align:center"><a href="https://leetcode.com/problems/largest-time-for-given-digits/" target="_blank" rel="noopener">Largest Time for Given Digits</a></td><td style="text-align:center">Easy</td></tr><tr><td style="text-align:center">0950</td><td style="text-align:center"><a href="https://leetcode.com/problems/reveal-cards-in-increasing-order/" target="_blank" rel="noopener">Reveal Cards In Increasing Order</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0951</td><td style="text-align:center"><a href="https://leetcode.com/problems/flip-equivalent-binary-trees/" target="_blank" rel="noopener">Flip Equivalent Binary Trees</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0953</td><td style="text-align:center"><a href="https://leetcode.com/problems/verifying-an-alien-dictionary/" target="_blank" rel="noopener">Verifying an Alien Dictionary</a></td><td style="text-align:center">Easy</td></tr><tr><td style="text-align:center">0954</td><td style="text-align:center"><a href="https://leetcode.com/problems/array-of-doubled-pairs/" target="_blank" rel="noopener">Array of Doubled Pairs</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0955</td><td style="text-align:center"><a href="https://leetcode.com/problems/delete-columns-to-make-sorted-ii/" target="_blank" rel="noopener">Delete Columns to Make Sorted II</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0956</td><td style="text-align:center"><a href="https://leetcode.com/problems/tallest-billboard/" target="_blank" rel="noopener">Tallest Billboard</a></td><td style="text-align:center">Hard</td></tr><tr><td style="text-align:center">0957</td><td style="text-align:center"><a href="https://leetcode.com/problems/prison-cells-after-n-days/" target="_blank" rel="noopener">Prison Cells After N Days</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0958</td><td style="text-align:center"><a href="https://leetcode.com/problems/check-completeness-of-a-binary-tree/" target="_blank" rel="noopener">Check Completeness of a Binary Tree</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0959</td><td style="text-align:center"><a href="https://leetcode.com/problems/regions-cut-by-slashes/" target="_blank" rel="noopener">Regions Cut By Slashes</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0960</td><td style="text-align:center"><a href="https://leetcode.com/problems/delete-columns-to-make-sorted-iii/" target="_blank" rel="noopener">Delete Columns to Make Sorted III</a></td><td style="text-align:center">Hard</td></tr><tr><td style="text-align:center">0961</td><td style="text-align:center"><a href="https://leetcode.com/problems/n-repeated-element-in-size-2n-array/" target="_blank" rel="noopener">N-Repeated Element in Size 2N Array</a></td><td style="text-align:center">Easy</td></tr><tr><td style="text-align:center">0962</td><td style="text-align:center"><a href="https://leetcode.com/problems/maximum-width-ramp/" target="_blank" rel="noopener">Maximum Width Ramp</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0963</td><td style="text-align:center"><a href="https://leetcode.com/problems/minimum-area-rectangle-ii/" target="_blank" rel="noopener">Minimum Area Rectangle II</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0965</td><td style="text-align:center"><a href="https://leetcode.com/problems/univalued-binary-tree/" target="_blank" rel="noopener">Univalued Binary Tree</a></td><td style="text-align:center">Easy</td></tr><tr><td style="text-align:center">0966</td><td style="text-align:center"><a href="https://leetcode.com/problems/vowel-spellchecker/" target="_blank" rel="noopener">Vowel Spellchecker</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0967</td><td style="text-align:center"><a href="https://leetcode.com/problems/numbers-with-same-consecutive-differences/" target="_blank" rel="noopener">Numbers With Same Consecutive Differences</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0969</td><td style="text-align:center"><a href="https://leetcode.com/problems/pancake-sorting/" target="_blank" rel="noopener">Pancake Sorting</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0970</td><td style="text-align:center"><a href="https://leetcode.com/problems/powerful-integers/" target="_blank" rel="noopener">Powerful Integers</a></td><td style="text-align:center">Easy</td></tr><tr><td style="text-align:center">0971</td><td style="text-align:center"><a href="https://leetcode.com/problems/flip-binary-tree-to-match-preorder-traversal/" target="_blank" rel="noopener">Flip Binary Tree To Match Preorder Traversal</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0972</td><td style="text-align:center"><a href="https://leetcode.com/problems/equal-rational-numbers/" target="_blank" rel="noopener">Equal Rational Numbers</a></td><td style="text-align:center">Hard</td></tr><tr><td style="text-align:center">0973</td><td style="text-align:center"><a href="https://leetcode.com/problems/k-closest-points-to-origin/" target="_blank" rel="noopener">K Closest Points to Origin</a></td><td style="text-align:center">Easy</td></tr><tr><td style="text-align:center">0974</td><td style="text-align:center"><a href="https://leetcode.com/problems/equal-rational-numbers/" target="_blank" rel="noopener">Subarray Sums Divisible by K</a></td><td style="text-align:center">Medium</td></tr><tr><td style="text-align:center">0975</td><td style="text-align:center"><a href="https://leetcode.com/problems/odd-even-jump/" target="_blank" rel="noopener">Odd Even Jump</a></td><td style="text-align:center">Hard</td></tr><tr><td style="text-align:center">0976</td><td style="text-align:center"><a href="https://leetcode.com/problems/largest-perimeter-triangle/" target="_blank" rel="noopener">Largest Perimeter Triangle</a></td><td style="text-align:center">Easy</td></tr><tr><td style="text-align:center">0977</td><td style="text-align:center"><a href="https://leetcode.com/problems/squares-of-a-sorted-array/" target="_blank" rel="noopener">Squares of a Sorted Array</a></td><td style="text-align:center">Easy</td></tr></tbody></table><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://www.blogs.rhsphere.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://www.blogs.rhsphere.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>20. Valid Parentheses</title>
    <link href="https://www.blogs.rhsphere.com/2019/05/29/20.html"/>
    <id>https://www.blogs.rhsphere.com/2019/05/29/20.html</id>
    <published>2019-05-29T01:16:30.000Z</published>
    <updated>2019-05-29T01:56:48.802Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><h2 id="有效的括号"><a href="#有效的括号" class="headerlink" title="有效的括号"></a>有效的括号</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</p><p>有效字符串需满足：</p><p>左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 注意空字符串可被认为是有效字符串。</p><p>示例 1:</p><p>输入: “()”<br>输出: true<br>示例 2:</p><p>输入: “()[]{}”<br>输出: true<br>示例 3:</p><p>输入: “(]”<br>输出: false<br>示例 4:</p><p>输入: “([)]”<br>输出: false<br>示例 5:</p><p>输入: “{[]}”<br>输出: true</p><h3 id="java代码"><a href="#java代码" class="headerlink" title="java代码"></a>java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 有效括号</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: rhsphere</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>: 2019-05-29 09:16 by jdk 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ValidParentheses</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> Map&lt;Character, Character&gt; map = <span class="keyword">new</span> HahsMap&lt;&gt;();</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">map.put(<span class="string">'('</span>, <span class="string">')'</span>);</span><br><span class="line">map.put(<span class="string">'['</span>, <span class="string">']'</span>);</span><br><span class="line">map.put(<span class="string">'&#123;'</span>, <span class="string">'&#125;'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.lengt(); i++) &#123;</span><br><span class="line"><span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line"><span class="keyword">if</span> (map.containsKey(c)) &#123;</span><br><span class="line">stack.push(map.get(c));</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (map.containsValue(c)) &#123;</span><br><span class="line"><span class="keyword">if</span> (stack.isEmpty() || stack.pop() != c) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">"()[]&#123;&#125;"</span>;</span><br><span class="line">        <span class="keyword">boolean</span> b = isValid(s);</span><br><span class="line">        System.out.println(b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Easy" scheme="https://www.blogs.rhsphere.com/categories/Easy/"/>
    
    
      <category term="Stack" scheme="https://www.blogs.rhsphere.com/tags/Stack/"/>
    
      <category term="String" scheme="https://www.blogs.rhsphere.com/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>SampleBrowser</title>
    <link href="https://www.blogs.rhsphere.com/2019/05/29/sample-browser.html"/>
    <id>https://www.blogs.rhsphere.com/2019/05/29/sample-browser.html</id>
    <published>2019-05-29T00:03:21.000Z</published>
    <updated>2019-05-29T01:15:32.367Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><h2 id="模拟实现浏览器的前进、后退功能"><a href="#模拟实现浏览器的前进、后退功能" class="headerlink" title="模拟实现浏览器的前进、后退功能"></a>模拟实现浏览器的前进、后退功能</h2><p>浏览器的前进、后退功能。<br>每次一次访问完一串页面a-b-c后，点击浏览器的后退按钮，就可以查看之前浏览过的页面b和a。当你后退到页面a，点击前进按钮，就可以重新查看页面b和c。但是，如果你后退到页面b后，点击了新的页面d，那就无法再通过前进、头腿功能查看页面c了。</p><p>现在来实现这个功能，使用链式栈，用backStack、currentPage、forwardStack来存储这些页面。</p><h3 id="java代码"><a href="#java代码" class="headerlink" title="java代码"></a>java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line">**</span><br><span class="line"> * <span class="meta">@description</span>: 使用前后栈实现浏览器的前进后退</span><br><span class="line"> * <span class="meta">@author</span>: rhsphere</span><br><span class="line"> * <span class="meta">@since</span>: <span class="number">2019</span>-<span class="number">05</span>-<span class="number">28</span> <span class="number">19</span>:<span class="number">55</span> by jdk <span class="number">1.8</span></span><br><span class="line"> */</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleBrowser</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">SampleBrowser browser = <span class="keyword">new</span> SampleBrowser();</span><br><span class="line">        browser.open(<span class="string">"http://www.baidu.com"</span>);</span><br><span class="line">        browser.open(<span class="string">"http://news.baidu.com/"</span>);</span><br><span class="line">        browser.open(<span class="string">"http://news.baidu.com/end"</span>);</span><br><span class="line">        browser.goBack();</span><br><span class="line">        browser.goBack();</span><br><span class="line">        browser.goForward();</span><br><span class="line">        browser.open(<span class="string">"http://www.qq.com"</span>);</span><br><span class="line">        browser.goForward();</span><br><span class="line">        browser.goBack();</span><br><span class="line">        browser.goForward();</span><br><span class="line">        browser.goBack();</span><br><span class="line">        browser.goBack();</span><br><span class="line">        browser.goBack();</span><br><span class="line">        browser.goBack();</span><br><span class="line">        browser.checkCurrentPage();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String currentPage;</span><br><span class="line"><span class="keyword">private</span> LinkedListBasedStack backStack;</span><br><span class="line"><span class="keyword">private</span> LinkedListBasedStack forwardStack;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SampleBrowser</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.bakcStack = <span class="keyword">new</span> LinkedListBasedStack();</span><br><span class="line"><span class="keyword">this</span>.forwardStack = <span class="keyword">new</span> LinkedListBasedStack();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.currentPage != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.backStack.push(<span class="keyword">this</span>.currentPage);</span><br><span class="line"><span class="keyword">this</span>.forwardStack.clear();</span><br><span class="line">&#125;</span><br><span class="line">showUrl(url, <span class="string">"Open"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canGoBack</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.backStack.size() &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canGOForward</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.forwardStack.size() &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">goBack</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.canGoBack()) &#123;</span><br><span class="line"><span class="keyword">this</span>.forwardStack.push(<span class="keyword">this</span>.currentPage);</span><br><span class="line">String backUrl = <span class="keyword">this</span>.backStack.pop();</span><br><span class="line">showUrl(backUrl, <span class="string">"Back"</span>);</span><br><span class="line"><span class="keyword">return</span> backUrl;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"* Cannot go back, no pages behind."</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">goForward</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.canGoForward()) &#123;</span><br><span class="line"><span class="keyword">this</span>.backStack.push(<span class="keyword">this</span>.currentPage);</span><br><span class="line">String forwardUrl = <span class="keyword">this</span>.forwardStack.pop();</span><br><span class="line">showUrl(forwardUrl, <span class="string">"FOrward"</span>);</span><br><span class="line"><span class="keyword">return</span> forwardUrl;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"** Cannot go forward, no pages ahead."</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showUrl</span><span class="params">(String url, String prefix)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.currentPage = url;</span><br><span class="line">System.out.println(prefix + <span class="string">" page == "</span> + url);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkCurrentPage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"current Page is: "</span> + <span class="keyword">this</span>.currentPage);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 基于链表的栈</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListBasedStack</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"><span class="keyword">private</span> Node top;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> Node <span class="title">createNode</span><span class="params">(String data, Node next)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Node(data, next);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.top = top;</span><br><span class="line"><span class="keyword">this</span>.size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">Node node = createNode(data, <span class="keyword">this</span>.top);</span><br><span class="line"><span class="keyword">this</span>.top = top;</span><br><span class="line"><span class="keyword">this</span>.size++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Node popNode = <span class="keyword">this</span>.top;</span><br><span class="line"><span class="keyword">if</span> (popNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">"Stack is empty"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.top = popNode.next;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.size &gt; ) </span><br><span class="line"><span class="keyword">this</span>.size--;</span><br><span class="line"><span class="keyword">return</span> popNode.data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getTopData</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.top == <span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.top.data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Print stack:"</span>);</span><br><span class="line">Node cur = <span class="keyword">this</span>.top;</span><br><span class="line"><span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">String data = cur.getData();</span><br><span class="line">Sustem.out.println(data + <span class="string">"\t"</span>);</span><br><span class="line">cur = cur.next;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> String data;</span><br><span class="line"><span class="keyword">private</span> Node next;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>(datam <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(String data, Node next)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.data= data;</span><br><span class="line"><span class="keyword">this</span>.next = next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.data = data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNext</span><span class="params">(Node next)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.next = next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">getNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Stack" scheme="https://www.blogs.rhsphere.com/categories/Stack/"/>
    
    
      <category term="Stack" scheme="https://www.blogs.rhsphere.com/tags/Stack/"/>
    
      <category term="SampleBrowser" scheme="https://www.blogs.rhsphere.com/tags/SampleBrowser/"/>
    
  </entry>
  
  <entry>
    <title>LinkedStack &amp;&amp; ArrayStack</title>
    <link href="https://www.blogs.rhsphere.com/2019/05/28/linked-and-array-stack.html"/>
    <id>https://www.blogs.rhsphere.com/2019/05/28/linked-and-array-stack.html</id>
    <published>2019-05-28T11:08:37.000Z</published>
    <updated>2019-05-29T00:36:14.791Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p><strong>当某个数据集合致设计在一端插入和删除数据，并且满足后进先出、先进后出的特性，我们就应该首选“栈”这种数据结构。</strong></p><p>栈主要包括两个操作，入栈和出栈，在栈顶插入一个数据和从栈顶删除一个数据。</p><p>栈既可以用数组来实现，也可以用链表来实现。用数组实现的栈，就做顺序栈，用链表实现的栈，叫链式栈。</p><p>不管是顺序栈还是链式栈，我们存储数据只需要一个大小为n的数组就够了。在入栈和出栈过程中，只需要一两个临时变量存储空间，所以空间复杂度是O(1)。</p><p><strong>注意，这里存储数据需要一个大小为n的数组，并不是说空间复杂度就是O(n)。因为这个空间是必须的，无法省掉。所以我们说空间复杂度的时候，是指除了原本的数据存储空间外，算法运行还需要额外的存储空间。</strong></p><p>栈的一些应用：</p><ol><li><strong>栈在函数调用中的应用</strong></li><li><strong>栈在表达式求值中的应用</strong></li><li><strong>栈在括号匹配中的应用</strong></li></ol><p>关于用函数调用栈来保存临时变量，为什么函数调用要用“栈”来保存变量呢？用其他数据结构不行吗？</p><p><strong>解答：</strong> 其实，不一定非要栈来保存临时变量，只不过如果这个函数调用符合后进先出的特性，用栈这种数据结构来实现，是最顺理成章的选择。</p><p>从调用函数进入被调用函数，对于数据来说，变化的是什么？是作用域。所以根本上，只要能保证每进入一个新的函数，都是一个新的作用域就可以。而要实现这个，用栈就非常方便。在进入被调用函数的时候，分配一段栈空间给这个函数的变量，在函数结束的时候，将栈顶复位，正好回到调用函数的作用域内。</p><h2 id="数组实现顺序栈"><a href="#数组实现顺序栈" class="headerlink" title="数组实现顺序栈"></a>数组实现顺序栈</h2><p>支持动态扩容的顺序栈，底层依赖一个支持动态扩容的数组就可以了。当栈满了，就申请一个更大的数组，将原来的数据搬移到新数组中。</p><p>实际上，支持动态扩容的顺序栈，平时开发并不常用到。<br>出栈的时间复杂度是O(1)，那入栈操作的 <strong>均摊时间复杂度是O(1)</strong>。 关于分析，参考<a href="https://time.geekbang.org/column/article/41222" target="_blank" rel="noopener">极客时间08|栈</a></p><h3 id="数组实现栈的代码"><a href="#数组实现栈的代码" class="headerlink" title="数组实现栈的代码"></a>数组实现栈的代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 数组实现栈，使用支持动态调整数组大小的泛型数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: rhsphere</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>: 2019-05-28 16:43 by jdk 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayStack</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> E[] arr;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayStack</span><span class="params">()</span></span>&#123;</span><br><span class="line">        arr = (E[]) <span class="keyword">new</span> Object[<span class="number">2</span>];</span><br><span class="line">        n = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> capacity &gt;= <span class="number">0</span>;</span><br><span class="line">        E[] tmp = (E[]) <span class="keyword">new</span> Object[capacity];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            tmp[i] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        arr = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == arr.length)</span><br><span class="line">            resize(<span class="number">2</span> * arr.length);</span><br><span class="line">        arr[n++] = e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException(<span class="string">"Stack underflow"</span>);</span><br><span class="line"></span><br><span class="line">        E e = arr[n - <span class="number">1</span>];</span><br><span class="line">        arr[n - <span class="number">1</span>] = <span class="keyword">null</span>;</span><br><span class="line">        n--;</span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">0</span> &amp;&amp; n == arr.length / <span class="number">4</span>)</span><br><span class="line">            resize(arr.length / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException(<span class="string">"Stack underflow"</span>);</span><br><span class="line">        <span class="keyword">return</span> arr[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayIterator();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里写ArrayIterator&lt;E&gt; 会报错是为什么？？？</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ArrayIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            i = n - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> i &gt;= <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!hasNext())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">            <span class="keyword">return</span> arr[i--];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链表实现链式栈"><a href="#链表实现链式栈" class="headerlink" title="链表实现链式栈"></a>链表实现链式栈</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>用链表结点存储栈顶top节点，存储链表长度</li><li>实现isEmpty()方法、size()方法</li><li>push()用增加的节点作为头节点</li></ol><h3 id="链表实现栈的代码"><a href="#链表实现栈的代码" class="headerlink" title="链表实现栈的代码"></a>链表实现栈的代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 实现链表栈，使用泛型的单链表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: rhsphere</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>: 2019-05-28 15:57 by jdk 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedStack</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//栈顶节点top和栈的大小</span></span><br><span class="line">    <span class="keyword">private</span> Node&lt;E&gt; top;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//内部静态类，因为不用接触类的任何实例对象和方法</span></span><br><span class="line">    <span class="comment">//外部类可以访问内部类的private/protected变量，就像访问自己的private/protected变量一样.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> E e;</span><br><span class="line">        <span class="keyword">private</span> Node&lt;E&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//构造一个空的stack</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        top = <span class="keyword">null</span>;</span><br><span class="line">        n = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断栈顶结点是不是null</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> top == <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加一个元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  e 待添加的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        Node&lt;E&gt; oldTop = top;</span><br><span class="line">        top = <span class="keyword">new</span> Node&lt;E&gt;();</span><br><span class="line">        top.e = e;</span><br><span class="line">        top.next = oldTop;</span><br><span class="line">        n++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除并返回最近添加的元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 最近添加的元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NoSuchElementException 如果栈为空</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException(<span class="string">"LinkedStack underflow"</span>);</span><br><span class="line">        E e = top.e;</span><br><span class="line">        top = top.next;</span><br><span class="line">        n--;</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回但不移除最近添加的栈顶元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 最近添加的元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NoSuchElementException 如果栈为空</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException(<span class="string">"LinkedStack underflow"</span>);</span><br><span class="line">        <span class="keyword">return</span> top.e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//foreach的写法是因为LinkedStack的对象实现了Iterable接口</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (E e : <span class="keyword">this</span>) &#123;</span><br><span class="line">            sb.append(e);</span><br><span class="line">            sb.append(<span class="string">' '</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回一个以LIFO顺序遍历栈元素的迭代器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 一个以LIFO顺序遍历栈元素的迭代器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ListIterator&lt;E&gt;(top);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Node&lt;E&gt; cur;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ListIterator</span><span class="params">(Node&lt;E&gt; top)</span> </span>&#123;</span><br><span class="line">            cur = top;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> cur != <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!hasNext())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException(<span class="string">"LinkedStack underflow"</span>);</span><br><span class="line">            E e = cur.e;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="顺序和链式栈测试代码"><a href="#顺序和链式栈测试代码" class="headerlink" title="顺序和链式栈测试代码"></a>顺序和链式栈测试代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: rhsphere</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>: 2019-05-28 16:28 by jdk 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStack</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"==========测试ArrayStack=========="</span>);</span><br><span class="line"></span><br><span class="line">        LinkedStack&lt;String&gt; stack = <span class="keyword">new</span> LinkedStack&lt;String&gt;();</span><br><span class="line">        stack.push(<span class="string">"! "</span>);</span><br><span class="line">        stack.push(<span class="string">"world"</span>);</span><br><span class="line">        stack.push(<span class="string">", "</span>);</span><br><span class="line">        stack.push(<span class="string">"Hello"</span>);</span><br><span class="line">        stack.push(<span class="string">"Hi. "</span>);</span><br><span class="line">        System.out.println(<span class="string">"栈顶元素是："</span> + stack.peek());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用foreach遍历栈元素</span></span><br><span class="line">        <span class="keyword">for</span>(String s : stack)</span><br><span class="line">            System.out.print(s);</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            System.out.print(stack.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"\n(now "</span> + stack.size() + <span class="string">" left on linked stack)"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"==========测试ArrayStack=========="</span>);</span><br><span class="line">        ArrayStack&lt;String&gt; arrStack = <span class="keyword">new</span> ArrayStack&lt;String&gt;();</span><br><span class="line">        arrStack.push(<span class="string">"! "</span>);</span><br><span class="line">        arrStack.push(<span class="string">"world"</span>);</span><br><span class="line">        arrStack.push(<span class="string">", "</span>);</span><br><span class="line">        arrStack.push(<span class="string">"Goodbye"</span>);</span><br><span class="line">        arrStack.push(<span class="string">"woo. "</span>);</span><br><span class="line">        System.out.println(<span class="string">"栈顶元素是："</span> + arrStack.peek());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用foreach遍历栈元素</span></span><br><span class="line">        <span class="keyword">for</span>(String s : arrStack)</span><br><span class="line">            System.out.print(s);</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!arrStack.isEmpty()) &#123;</span><br><span class="line">            System.out.print(arrStack.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"\n(now "</span> + arrStack.size() + <span class="string">" left on  array stack)"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Sum-up" scheme="https://www.blogs.rhsphere.com/categories/Sum-up/"/>
    
    
      <category term="Stack" scheme="https://www.blogs.rhsphere.com/tags/Stack/"/>
    
      <category term="LinkedStack" scheme="https://www.blogs.rhsphere.com/tags/LinkedStack/"/>
    
      <category term="ArrayStack" scheme="https://www.blogs.rhsphere.com/tags/ArrayStack/"/>
    
  </entry>
  
  <entry>
    <title>LinkedList(链表)</title>
    <link href="https://www.blogs.rhsphere.com/2019/05/28/linkedlist-sum-up.html"/>
    <id>https://www.blogs.rhsphere.com/2019/05/28/linkedlist-sum-up.html</id>
    <published>2019-05-28T01:17:27.000Z</published>
    <updated>2019-05-28T01:24:40.267Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><h2 id="LinkedList-链表"><a href="#LinkedList-链表" class="headerlink" title="LinkedList(链表)"></a>LinkedList(链表)</h2><p>Last Modified: 2019/5/28 09:24 by dp</p><p><a href="https://blogs.rhsphere.com/leetcode/2019/05/27/206.html" target="_blank" rel="noopener">01. Reverse Linked List（反转链表）</a></p><p><a href="https://blogs.rhsphere.com/leetcode/2019/05/27/141.html" target="_blank" rel="noopener">02. Linked List Cycley Ⅰ（检测链表是否有环Ⅰ）</a></p><p><a href="https://blogs.rhsphere.com/leetcode/2019/05/27/142.html" target="_blank" rel="noopener">03. Linked List Cycley Ⅱ（检测链表是否有环Ⅱ）</a></p><p><a href="https://blogs.rhsphere.com/leetcode/2019/05/27/21.html" target="_blank" rel="noopener">04. Merge Two Sorted Lists（合并两个有序链表）</a></p><p><a href="https://blogs.rhsphere.com/leetcode/2019/05/27/25.html" target="_blank" rel="noopener">05. Reverse Nodes in k-Group（以 k 为一组反转链表）</a></p><p><a href="https://blogs.rhsphere.com/leetcode/2019/05/27/19.html" target="_blank" rel="noopener">06. Remove Nth Node From End of List（删除链表的倒数第N个节点）</a></p><p><a href="https://blogs.rhsphere.com/leetcode/2019/05/28/876.html" target="_blank" rel="noopener">07. Middle of the Linked List（链表的中间节点）</a></p><p><a href="https://blogs.rhsphere.com/leetcode/2019/05/28/23.html" target="_blank" rel="noopener">08. Merge k Sorted Lists（合并 k 个排序链表）</a></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Sum-up" scheme="https://www.blogs.rhsphere.com/categories/Sum-up/"/>
    
    
      <category term="Linked List" scheme="https://www.blogs.rhsphere.com/tags/Linked-List/"/>
    
      <category term="Sum-up" scheme="https://www.blogs.rhsphere.com/tags/Sum-up/"/>
    
  </entry>
  
  <entry>
    <title>23. Merge k Sorted Lists</title>
    <link href="https://www.blogs.rhsphere.com/2019/05/28/23.html"/>
    <id>https://www.blogs.rhsphere.com/2019/05/28/23.html</id>
    <published>2019-05-28T00:26:23.000Z</published>
    <updated>2019-05-28T01:14:48.886Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><h2 id="合并-k-个排序链表"><a href="#合并-k-个排序链表" class="headerlink" title="合并 k 个排序链表"></a>合并 k 个排序链表</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。</p><p>示例:</p><p>输入:<br>[<br>  1-&gt;4-&gt;5,<br>  1-&gt;3-&gt;4,<br>  2-&gt;6<br>]<br>输出: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6 </p><h3 id="java代码"><a href="#java代码" class="headerlink" title="java代码"></a>java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 采用merge算法，一次合并两个</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: rhsphere</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>: 2019-05-28 08:32 by jdk 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeKLists</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> mergeKLists(lists, <span class="number">0</span>, list.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] listNodes, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (start &gt; end)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (start == end)</span><br><span class="line"><span class="keyword">return</span> listNodes[start];</span><br><span class="line">mid = start + ((end - start) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">ListNode p = mergeKLists(listNodes, start, mid);</span><br><span class="line">ListNode q = mergeKLists(listNodes, mid + <span class="number">1</span>, end);</span><br><span class="line">ListNode res = merge(p, q);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">merge</span><span class="params">(ListNode p, ListNode q)</span> </span>&#123;</span><br><span class="line">ListNode head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">ListNode r = head;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (p == <span class="keyword">null</span> &amp;&amp; q == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(p != <span class="keyword">null</span> &amp;&amp; (q == <span class="keyword">null</span> || p.val &lt;= q.val)) &#123;</span><br><span class="line">r.next = p;</span><br><span class="line">p = p.next;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (p == <span class="keyword">null</span> || q.val &lt; p.val) &#123;</span><br><span class="line">r.next = q;</span><br><span class="line">q = q.next;</span><br><span class="line">&#125;</span><br><span class="line">r = r.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> head.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>  <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        ListNode next;</span><br><span class="line">        ListNode(<span class="keyword">int</span> val) &#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>失误的地方</p><ol><li>else if(p != null &amp;&amp; (q == null || p.val &lt;= q.val)) 条件中少了判等， 写成了p.val &lt; q.val。</li><li>mergeKLists(ListNode[] listNodes, int start, int end) start和end的形参类型写成了ListNode</li><li>这题就是归并排序的衍生，理解归并排序，就能理解这里面的递归调用。</li></ol><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Hard" scheme="https://www.blogs.rhsphere.com/categories/Hard/"/>
    
    
      <category term="Linked List" scheme="https://www.blogs.rhsphere.com/tags/Linked-List/"/>
    
      <category term="Divide and Conquer" scheme="https://www.blogs.rhsphere.com/tags/Divide-and-Conquer/"/>
    
      <category term="Heap" scheme="https://www.blogs.rhsphere.com/tags/Heap/"/>
    
      <category term="MergeSort" scheme="https://www.blogs.rhsphere.com/tags/MergeSort/"/>
    
  </entry>
  
  <entry>
    <title>876. Middle of the Linked List</title>
    <link href="https://www.blogs.rhsphere.com/2019/05/28/876.html"/>
    <id>https://www.blogs.rhsphere.com/2019/05/28/876.html</id>
    <published>2019-05-28T00:01:22.000Z</published>
    <updated>2019-05-28T00:25:17.510Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><h2 id="链表的中间节点"><a href="#链表的中间节点" class="headerlink" title="链表的中间节点"></a>链表的中间节点</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个带有头结点 head 的非空单链表，返回链表的中间结点。</p><p>如果有两个中间结点，则返回第二个中间结点。</p><p>示例 1：</p><p>输入：[1,2,3,4,5]<br>输出：此列表中的结点 3 (序列化形式：[3,4,5])<br>返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。<br>注意，我们返回了一个 ListNode 类型的对象 ans，这样：<br>ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, 以及 ans.next.next.next = NULL.<br>示例 2：</p><p>输入：[1,2,3,4,5,6]<br>输出：此列表中的结点 4 (序列化形式：[4,5,6])<br>由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。</p><p>提示：</p><p>给定链表的结点数介于 1 和 100 之间。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>头结点误导人</p><p>快慢指针： 1.慢指针一次走一步，快指针一次走2步，快指针走到末端，慢指针正好指向中间结点； 2.这里分两种情况：</p><p>快指针的next为null，慢指针正好指向中间结点，链表结点数为偶数；<br>快指针为null，慢指针正好指向第二个中间结点，链表结点数为奇数；</p><h3 id="java代码"><a href="#java代码" class="headerlink" title="java代码"></a>java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 快慢指针，找到链表的中间节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: rhsphere</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>: 2019-05-28 08:02 by jdk 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MiddleNode</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">middleNode</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果没有头结点</span></span><br><span class="line">        <span class="comment">//if (head == null) return head;</span></span><br><span class="line"></span><br><span class="line">        ListNode fast = head, slow = head;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//while (fast.next != null &amp;&amp; fast.next.next != null) &#123;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        ListNode next;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ListNode</span><span class="params">(<span class="keyword">int</span> val, ListNode next)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Easy" scheme="https://www.blogs.rhsphere.com/categories/Easy/"/>
    
    
      <category term="Linked List" scheme="https://www.blogs.rhsphere.com/tags/Linked-List/"/>
    
      <category term="Two Pointers" scheme="https://www.blogs.rhsphere.com/tags/Two-Pointers/"/>
    
  </entry>
  
  <entry>
    <title>19. Remove Nth Node From End of List</title>
    <link href="https://www.blogs.rhsphere.com/2019/05/27/19.html"/>
    <id>https://www.blogs.rhsphere.com/2019/05/27/19.html</id>
    <published>2019-05-27T12:43:36.000Z</published>
    <updated>2019-05-27T23:59:20.323Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><h2 id="删除链表的倒数第N个节点"><a href="#删除链表的倒数第N个节点" class="headerlink" title="删除链表的倒数第N个节点"></a>删除链表的倒数第N个节点</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。</p><p>示例：</p><p>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.</p><p>当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.<br>说明：</p><p>给定的 n 保证是有效的。</p><p>进阶：</p><p>你能尝试使用一趟扫描实现吗？</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>使用fast指针先远离头结点 n-1 的位置，然后slow指针和fast再同时移动到链表尾部，此时slow指针的位置就是倒数第n个节点，提前保存slow的prev节点，然后prev.next = prev.next.next即可完成任务。</p><p>注意：</p><ol><li>链表为空的情况；</li><li>链表只有一个元素的情况</li></ol><h3 id="java代码"><a href="#java代码" class="headerlink" title="java代码"></a>java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: rhsphere</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>: 2019-05-27 20:45 by jdk 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoveNthFromEnd</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">ListNode fast = head;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; i &lt; n) &#123;</span><br><span class="line">fast = fast.next;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//链表为空</span></span><br><span class="line"><span class="keyword">if</span> (fast == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">ListNode slow = head, prev = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">fast = fast.next;</span><br><span class="line">prev = slow;</span><br><span class="line">slow = slow.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//链表只有一个元素</span></span><br><span class="line"><span class="keyword">if</span> (prev == <span class="keyword">null</span>) head = head.next;</span><br><span class="line"><span class="keyword">else</span> prev.next = prev.next.next;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        ListNode next;</span><br><span class="line"></span><br><span class="line">        ListNode(<span class="keyword">int</span> val, ListNode next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Medium" scheme="https://www.blogs.rhsphere.com/categories/Medium/"/>
    
    
      <category term="Linked List" scheme="https://www.blogs.rhsphere.com/tags/Linked-List/"/>
    
      <category term="Two Pointers" scheme="https://www.blogs.rhsphere.com/tags/Two-Pointers/"/>
    
  </entry>
  
  <entry>
    <title>25. Reverse Nodes in k-Group</title>
    <link href="https://www.blogs.rhsphere.com/2019/05/27/25.html"/>
    <id>https://www.blogs.rhsphere.com/2019/05/27/25.html</id>
    <published>2019-05-27T12:06:25.000Z</published>
    <updated>2019-05-27T12:41:42.476Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><h2 id="k-个一组翻转链表"><a href="#k-个一组翻转链表" class="headerlink" title="k 个一组翻转链表"></a>k 个一组翻转链表</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给出一个链表，每 k 个节点一组进行翻转，并返回翻转后的链表。</p><p>k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么将最后剩余节点保持原有顺序。</p><p>示例 :</p><p>给定这个链表：1-&gt;2-&gt;3-&gt;4-&gt;5</p><p>当 k = 2 时，应当返回: 2-&gt;1-&gt;4-&gt;3-&gt;5</p><p>当 k = 3 时，应当返回: 3-&gt;2-&gt;1-&gt;4-&gt;5<br>说明 :</p><p>你的算法只能使用常数的额外空间。 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 </p><h3 id="java代码"><a href="#java代码" class="headerlink" title="java代码"></a>java代码</h3><p>思路见注释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: rhsphere</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>: 2019-05-27 20:10 by jdk 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReverseKGroup</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseKGroup</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//计数器</span></span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//当前组头结点</span></span><br><span class="line">        ListNode r = head;</span><br><span class="line">        <span class="comment">//遍历剩余链表,用计数器记录,每当链表还满足长度&gt;=k,则终止操作</span></span><br><span class="line">        <span class="keyword">while</span> (r != <span class="keyword">null</span> &amp;&amp; length != k) &#123;</span><br><span class="line">            r = r.next;</span><br><span class="line">            length++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果长度 == k,说明当前剩余链表长度&gt;=k,还可以再分组</span></span><br><span class="line">        <span class="keyword">if</span> (length == k) &#123;</span><br><span class="line">            <span class="comment">//对于剩余链表调用自身函数再进行分组,直至剩余长度不足k为止</span></span><br><span class="line">            <span class="comment">//用tail 接受此组的下一组反转完成之后的新头结点</span></span><br><span class="line">            ListNode pre = reverseKGroup(r, k);</span><br><span class="line">            <span class="comment">//对于此组的节点进行指向反转</span></span><br><span class="line">            <span class="keyword">while</span> (k-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                ListNode next = head.next;</span><br><span class="line">                head.next = pre;</span><br><span class="line">                pre = head;</span><br><span class="line">                head = next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//值得注意的是:当上述的while循环结束的时候,head 指向的已经是下一组的原头结点了,所以</span></span><br><span class="line">            <span class="comment">//不要直接返回head</span></span><br><span class="line">            <span class="comment">//应该返回head 的上一个元素 ,如上面用pre记录了.</span></span><br><span class="line">            <span class="keyword">return</span> pre;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果长度不满足k,则剩余链表不需要进行任何操作,直接返回剩余链表的头结点即可.</span></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        ListNode next;</span><br><span class="line"></span><br><span class="line">        ListNode(<span class="keyword">int</span> val, ListNode next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>while(k– &gt; 0)的循环体内就是 反转链表的代码，这里reverse节点是下一组链表的头结点。</li></ol><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Hard" scheme="https://www.blogs.rhsphere.com/categories/Hard/"/>
    
    
      <category term="Linked List" scheme="https://www.blogs.rhsphere.com/tags/Linked-List/"/>
    
  </entry>
  
  <entry>
    <title>21. Merge Two Sorted Lists</title>
    <link href="https://www.blogs.rhsphere.com/2019/05/27/21.html"/>
    <id>https://www.blogs.rhsphere.com/2019/05/27/21.html</id>
    <published>2019-05-27T11:21:04.000Z</published>
    <updated>2019-05-27T12:05:05.434Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><h2 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a>合并两个有序链表</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p><p>示例：</p><p>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br>输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p><h3 id="java代码"><a href="#java代码" class="headerlink" title="java代码"></a>java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">**</span><br><span class="line"> * <span class="meta">@description</span>: 合并两个有序链表</span><br><span class="line"> * <span class="meta">@author</span>: rhsphere</span><br><span class="line"> * <span class="meta">@since</span>: <span class="number">2019</span>-<span class="number">05</span>-<span class="number">27</span> <span class="number">19</span>:<span class="number">41</span> by jdk <span class="number">1.8</span></span><br><span class="line"> */</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSortedLists</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">mergeSortedLists</span><span class="params">(ListNode la, ListNode lb)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (la == <span class="keyword">null</span>) <span class="keyword">return</span> lb;</span><br><span class="line"><span class="keyword">if</span> (lb == <span class="keyword">null</span>) <span class="keyword">return</span> la;</span><br><span class="line"></span><br><span class="line">ListNode p = la, q = lb, head;</span><br><span class="line"><span class="keyword">if</span> (p.val &lt; q.val) &#123;</span><br><span class="line">head = p;</span><br><span class="line">p = p.next;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">head = q;</span><br><span class="line">q = q.next;</span><br><span class="line">&#125;</span><br><span class="line">ListNode r = head;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; q != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (p.val &lt; q.val) &#123;</span><br><span class="line">r.next = p;</span><br><span class="line">p = p.next;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">r.next = q;</span><br><span class="line">q = q.next;</span><br><span class="line">&#125;</span><br><span class="line">r = r.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">r.next = p;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">r.next = q;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        ListNode next;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ListNode</span><span class="params">(<span class="keyword">int</span> val, ListNode next)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>脑袋要清楚知道指针是如何移动的！</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Easy" scheme="https://www.blogs.rhsphere.com/categories/Easy/"/>
    
    
      <category term="Linked List" scheme="https://www.blogs.rhsphere.com/tags/Linked-List/"/>
    
  </entry>
  
  <entry>
    <title>141. Linked List Cycle 1</title>
    <link href="https://www.blogs.rhsphere.com/2019/05/27/141.html"/>
    <id>https://www.blogs.rhsphere.com/2019/05/27/141.html</id>
    <published>2019-05-27T09:58:55.000Z</published>
    <updated>2019-05-27T10:40:50.938Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><h2 id="环形链表Ⅰ"><a href="#环形链表Ⅰ" class="headerlink" title="环形链表Ⅰ"></a>环形链表Ⅰ</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个链表，判断链表中是否有环。</p><p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p><p>示例 1：<br>输入：head = [3,2,0,-4], pos = 1<br>输出：true<br>解释：链表中有一个环，其尾部连接到第二个节点。</p><p>示例 2：<br>输入：head = [1,2], pos = 0<br>输出：true<br>解释：链表中有一个环，其尾部连接到第一个节点。</p><p>示例 3：<br>输入：head = [1], pos = -1<br>输出：false<br>解释：链表中没有环。</p><p>进阶：<br>你能用 O(1)（即，常量）内存解决此问题吗？</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>如果链表中没有环，则fast指针最终将到达终点，返回false；</li><li>对于环形链表，fast和slow指针是两个围绕跑道的跑者。 快速跑步者最终会遇到慢跑者。 为什么？ 考虑这种情况（将其命名为情形A） ： 快速跑步者仅仅是慢跑者的一步。 在下一次迭代中，它们分别增加一步和两步并相互会合。</li></ol><p>例如，我们还没有考虑过快速跑步者落后慢跑者两到三步的情况。 这很简单，因为在下一次或下次的下一次迭代中，这种情况将简化为上面的情形A。</p><p>证明方法采用了，归纳法。</p><h3 id="java代码"><a href="#java代码" class="headerlink" title="java代码"></a>java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: rhsphere</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>: 2019-05-27 18:06 by jdk 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HasCycle</span> </span>&#123; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">ListNode fast = head.next;</span><br><span class="line">ListNode slow = head;</span><br><span class="line"><span class="comment">// while (fast != null &amp;&amp; slow != null) &#123;</span></span><br><span class="line"><span class="comment">// 错误示范</span></span><br><span class="line"><span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">fast = fast.next.next;</span><br><span class="line">slow = slow.next;</span><br><span class="line"><span class="keyword">if</span> (fast == slow) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line">ListNode next;</span><br><span class="line"></span><br><span class="line">ListNode(<span class="keyword">int</span> val, ListNode next) &#123;</span><br><span class="line"><span class="keyword">this</span>.val = val;</span><br><span class="line"><span class="keyword">this</span>.next = next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ListNode head = <span class="keyword">new</span> ListNode(<span class="number">3</span>, <span class="keyword">null</span>);</span><br><span class="line">        ListNode second = <span class="keyword">new</span> ListNode(<span class="number">2</span>, <span class="keyword">null</span>);</span><br><span class="line">        ListNode third = <span class="keyword">new</span> ListNode(<span class="number">0</span>, <span class="keyword">null</span>);</span><br><span class="line">        ListNode fourth = <span class="keyword">new</span> ListNode(-<span class="number">4</span>, <span class="keyword">null</span>);</span><br><span class="line">        head.next = second;</span><br><span class="line">        second.next = third;</span><br><span class="line">        third.next = fourth;</span><br><span class="line">        fourth.next = second;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> hasCycle = hasCycle(head);</span><br><span class="line">        System.out.println(hasCycle);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>错误示范  while (fast != null &amp;&amp; slow != null) {</li></ol><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Easy" scheme="https://www.blogs.rhsphere.com/categories/Easy/"/>
    
    
      <category term="Linked List" scheme="https://www.blogs.rhsphere.com/tags/Linked-List/"/>
    
      <category term="Two Pointers" scheme="https://www.blogs.rhsphere.com/tags/Two-Pointers/"/>
    
  </entry>
  
  <entry>
    <title>142. Linked List Cycle 2</title>
    <link href="https://www.blogs.rhsphere.com/2019/05/27/142.html"/>
    <id>https://www.blogs.rhsphere.com/2019/05/27/142.html</id>
    <published>2019-05-27T09:58:10.000Z</published>
    <updated>2019-05-27T11:19:26.419Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><h2 id="环形链表Ⅱ"><a href="#环形链表Ⅱ" class="headerlink" title="环形链表Ⅱ"></a>环形链表Ⅱ</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个链表，判断链表中是否有环。</p><p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。<br>说明：不允许修改给定的链表。</p><p>示例 1：</p><p>输入：head = [3,2,0,-4], pos = 1<br>输出：tail connects to node index 1<br>解释：链表中有一个环，其尾部连接到第二个节点。</p><p>示例 2：</p><p>输入：head = [1,2], pos = 0<br>输出：tail connects to node index 0<br>解释：链表中有一个环，其尾部连接到第一个节点。</p><p>示例 3：</p><p>输入：head = [1], pos = -1<br>输出：no cycle<br>解释：链表中没有环。</p><p>进阶：<br>你能用 O(1)（即，常量）内存解决此问题吗？</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>分两个步骤，首先通过快慢指针的方法判断链表是否有环；接下来如果有环，则寻找入环的第一个节点。</p><p>具体的方法为，首先假定链表起点到入环的第一个节点A的长度为a【未知】，到快慢指针相遇的节点B的长度为（a + b）【这个长度是已知的】。</p><p>现在我们想知道a的值，注意到快指针 fast 始终是慢指针 slow 走过长度的2倍，所以慢指针 slow 从B继续走（a + b）又能回到B点，如果只走a个长度就能回到节点A。</p><p>但是a的值是不知道的，解决思路是曲线救国，注意到起点到A的长度是a，那么可以用一个从起点开始的新指针head和从节点B开始的慢指针slow同步走，相遇的地方必然是入环的第一个节点A。</p><p>画个图就一目了然了~</p><h3 id="java代码"><a href="#java代码" class="headerlink" title="java代码"></a>java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 链表有环，返回节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: rhsphere</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>: 2019-05-27 18:58 by jdk 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DetectCycle</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="keyword">if</span> (fast == slow) &#123;</span><br><span class="line">                <span class="keyword">while</span> (head != fast) &#123;</span><br><span class="line">                    fast = fast.next;</span><br><span class="line">                    head = head.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> head;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        ListNode next;</span><br><span class="line"></span><br><span class="line">        ListNode(<span class="keyword">int</span> val, ListNode next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Medium" scheme="https://www.blogs.rhsphere.com/categories/Medium/"/>
    
    
      <category term="Linked List" scheme="https://www.blogs.rhsphere.com/tags/Linked-List/"/>
    
      <category term="Two Pointers" scheme="https://www.blogs.rhsphere.com/tags/Two-Pointers/"/>
    
  </entry>
  
  <entry>
    <title>206. Reverse Linked List</title>
    <link href="https://www.blogs.rhsphere.com/2019/05/27/206.html"/>
    <id>https://www.blogs.rhsphere.com/2019/05/27/206.html</id>
    <published>2019-05-27T08:34:16.000Z</published>
    <updated>2019-05-27T09:07:39.691Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><h2 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>反转一个单链表。</p><p>示例:</p><p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL<br>进阶: 你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>有很多种写法：<br>1）迭代方式的解答<br>为了完成这个任务，需要记录链表中三个连续的节点：reverse、head、second。在每一轮迭代中，从原始链表中提取节点head并将它插入到逆链表的开头。我们需要一直保持head指向原链表中所有剩余节点的首节点，second指向原链表中所有剩余节点的第二个节点，reverse指向结果链表中的首节点。</p><p>2）假设链表有N个节点，首先递归颠倒最后N-1个节点，然后小心地将原链表的首节点插入到结果链表的末端。</p><h3 id="java代码"><a href="#java代码" class="headerlink" title="java代码"></a>java代码</h3><p>迭代和递归写法，见代码注释。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 反转一个链表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: rhsphere</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>: 2019-05-27 16:32 by jdk 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReverseLinkedList</span> </span>&#123;</span><br><span class="line"><span class="comment">//迭代解法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">ListNode reverse = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">ListNode second = head.next;</span><br><span class="line">head.next = reverse;</span><br><span class="line">reverse = head;</span><br><span class="line">head = second;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> reverse;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归解法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">reverseRecursive</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line"><span class="keyword">if</span> (head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">ListNode second = head.next;</span><br><span class="line">ListNode res = reverseRecursive(second);</span><br><span class="line">second.next = head;</span><br><span class="line">head.next = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> val;</span><br><span class="line"><span class="keyword">private</span> ListNode next;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ListNode</span><span class="params">(<span class="keyword">int</span> val, ListNode next)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.val = val;</span><br><span class="line"><span class="keyword">this</span>.next = next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getData</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> val;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>编写和链表相关的代码时，必须要小心处理异常情况（链表为空或是只有一个或两个节点）和边界情况（处理首尾节点）。这些情况通常更加需，要画图等手段来看清楚指针变化。</li></ol><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Easy" scheme="https://www.blogs.rhsphere.com/categories/Easy/"/>
    
    
      <category term="Linked List" scheme="https://www.blogs.rhsphere.com/tags/Linked-List/"/>
    
  </entry>
  
  <entry>
    <title>Array&amp;&amp;GenericArray</title>
    <link href="https://www.blogs.rhsphere.com/2019/05/27/array-and-genericarray.html"/>
    <id>https://www.blogs.rhsphere.com/2019/05/27/array-and-genericarray.html</id>
    <published>2019-05-27T03:02:51.000Z</published>
    <updated>2019-05-27T03:06:21.065Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><p>自己实现动态数组：</p><ol><li>实现一个大小固定的有序数组，支持动态增删改操作</li><li>实现一个支持动态扩容的泛型数组</li><li><h2 id="大小固定的有序数组，支持动态增删改操作"><a href="#大小固定的有序数组，支持动态增删改操作" class="headerlink" title="大小固定的有序数组，支持动态增删改操作"></a>大小固定的有序数组，支持动态增删改操作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 实现一个大小国定的有序数组，支持动态增删改操作。</span></span><br><span class="line"><span class="comment"> * 1)数组的插入、删除、按照下标随机访问操作；</span></span><br><span class="line"><span class="comment"> * 2）数组中的数据是int类型的。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: rhsphere</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>: 2019-05-27 10:21 by jdk 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义整型数据data保存数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> data[];</span><br><span class="line">    <span class="comment">//定义数组长度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="comment">//定义实际中的个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造方法，定义数组大小</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Array</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = <span class="keyword">new</span> <span class="keyword">int</span>[capacity];</span><br><span class="line">        <span class="keyword">this</span>.n = capacity;</span><br><span class="line">        <span class="keyword">this</span>.count = <span class="number">0</span>; <span class="comment">//初始化后没有存数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据索引找到数据中的元素并返回</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= count)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> data[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//插入元素，尾部插入</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 数组空间已满</span></span><br><span class="line">        <span class="keyword">if</span> (count == n) &#123;</span><br><span class="line">            System.out.println(<span class="string">"没有可插入的位置"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果count还没满，那么就可以插入数据到数组中</span></span><br><span class="line">        <span class="comment">// 位置不合法</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; count) &#123;</span><br><span class="line">            System.out.println(<span class="string">"位置不合法"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//位置合法</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = count; i &gt; index; --i) &#123;</span><br><span class="line">            data[i] = data[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        data[index] = value;</span><br><span class="line">        ++count;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据索引，删除数组中元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= count)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//从删除位置开始，将后面的元素向前移动一位</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index + <span class="number">1</span>; i &lt; count; i++) &#123;</span><br><span class="line">            data[i - <span class="number">1</span>] = data[i];</span><br><span class="line">        &#125;</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            System.out.print(data[i] + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Array arr = <span class="keyword">new</span> Array(<span class="number">5</span>);</span><br><span class="line">        arr.printAll();</span><br><span class="line">        arr.insert(<span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">        arr.insert(<span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">        arr.insert(<span class="number">1</span>, <span class="number">5</span>);</span><br><span class="line">        arr.insert(<span class="number">3</span>, <span class="number">9</span>);</span><br><span class="line">        arr.insert(<span class="number">3</span>, <span class="number">10</span>);</span><br><span class="line">        arr.printAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="支持动态扩容的泛型数组"><a href="#支持动态扩容的泛型数组" class="headerlink" title="支持动态扩容的泛型数组"></a>支持动态扩容的泛型数组</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 实现一个支持动态扩容的泛型数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: rhsphere</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>: 2019-05-27 10:43 by jdk 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericArray</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T[] data;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据传入容量，构造Array</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GenericArray</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        data = (T[]) <span class="keyword">new</span> Object[capacity];</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无参构造方法，默认数组容量为10</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GenericArray</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取数组容量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCapacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前元素个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断数组是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改 index 位置的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, T e)</span> </span>&#123;</span><br><span class="line">        checkIndex(index);</span><br><span class="line">        data[index] = e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取对应 index 位置的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        checkIndex(index);</span><br><span class="line">        <span class="keyword">return</span> data[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查看数组是否包含元素e</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(T e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (data[i].equals(e)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取对应元素的下标, 未找到，返回 -1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(T e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (data[i].equals(e)) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 index 位置，插入元素e, 时间复杂度 O(m+n)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, T e)</span> </span>&#123;</span><br><span class="line">        checkIndex(index);</span><br><span class="line">        <span class="comment">// 如果当前元素个数等于数组容量，则将数组扩容为原来的2倍</span></span><br><span class="line">        <span class="keyword">if</span> (size == data.length) &#123;</span><br><span class="line">            resize(<span class="number">2</span> * data.length);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt;= index; i--) &#123;</span><br><span class="line">            data[i + <span class="number">1</span>] = data[i];</span><br><span class="line">        &#125;</span><br><span class="line">        data[index] = e;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向数组头插入元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(T e)</span> </span>&#123;</span><br><span class="line">        add(<span class="number">0</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向数组尾插入元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(T e)</span> </span>&#123;</span><br><span class="line">        add(size, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除 index 位置的元素，并返回</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        checkIndexForRemove(index);</span><br><span class="line"></span><br><span class="line">        T ret = data[index];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index + <span class="number">1</span>; i &lt; size; i++) &#123;</span><br><span class="line">            data[i - <span class="number">1</span>] = data[i];</span><br><span class="line">        &#125;</span><br><span class="line">        size --;</span><br><span class="line">        data[size] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 缩容</span></span><br><span class="line">        <span class="keyword">if</span> (size == data.length / <span class="number">4</span> &amp;&amp; data.length / <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">            resize(data.length / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除第一个元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">removeFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> remove(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除末尾元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">removeLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> remove(size - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从数组中删除指定元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeElement</span><span class="params">(T e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = find(e);</span><br><span class="line">        <span class="keyword">if</span> (index != -<span class="number">1</span>) &#123;</span><br><span class="line">            remove(index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        builder.append(String.format(<span class="string">"Array size = %d, capacity = %d \n"</span>, size, data.length));</span><br><span class="line">        builder.append(<span class="string">'['</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            builder.append(data[i]);</span><br><span class="line">            <span class="keyword">if</span> (i != size - <span class="number">1</span>) &#123;</span><br><span class="line">                builder.append(<span class="string">", "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        builder.append(<span class="string">']'</span>);</span><br><span class="line">        <span class="keyword">return</span> builder.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扩容方法，时间复杂度 O(n)</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        T[] newData = (T[]) <span class="keyword">new</span> Object[capacity];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            newData[i] = data[i];</span><br><span class="line">        &#125;</span><br><span class="line">        data = newData;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Add failed! Require index &gt;=0 and index &lt;= size."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkIndexForRemove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"remove failed! Require index &gt;=0 and index &lt; size."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Sum-up" scheme="https://www.blogs.rhsphere.com/categories/Sum-up/"/>
    
    
      <category term="Array" scheme="https://www.blogs.rhsphere.com/tags/Array/"/>
    
      <category term="GenericArray" scheme="https://www.blogs.rhsphere.com/tags/GenericArray/"/>
    
  </entry>
  
  <entry>
    <title>Array(数组)</title>
    <link href="https://www.blogs.rhsphere.com/2019/05/27/arrays-in-leetcode.html"/>
    <id>https://www.blogs.rhsphere.com/2019/05/27/arrays-in-leetcode.html</id>
    <published>2019-05-27T01:55:57.000Z</published>
    <updated>2019-05-27T03:10:27.157Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><h2 id="Array-数组"><a href="#Array-数组" class="headerlink" title="Array(数组)"></a>Array(数组)</h2><p>Last Modified: 2019/5/27 11:09 by dp</p><p><a href="https://blogs.rhsphere.com/leetcode/2019/05/25/1.html" target="_blank" rel="noopener">01. Two Sum（两数之和）</a></p><p><a href="https://blogs.rhsphere.com/leetcode/2019/05/25/15.html" target="_blank" rel="noopener">02. Three Sum（三数之和）</a></p><p><a href="https://blogs.rhsphere.com/leetcode/2019/05/25/169.html" target="_blank" rel="noopener">03. Majority Element（在数组中出现次数超过一半的数）</a></p><p><a href="https://blogs.rhsphere.com/leetcode/2019/05/25/412.html" target="_blank" rel="noopener">04. FizzBuzz（3 和 5 的倍数）</a></p><p><a href="https://blogs.rhsphere.com/leetcode/2019/05/25/88.html" target="_blank" rel="noopener">05. Merge Sorted Array（合并两个有序数组）</a></p><p><a href="https://blogs.rhsphere.com/leetcode/2019/05/25/41.html" target="_blank" rel="noopener">06. First Missing Positive（寻找缺失的最小正数）</a></p><p><a href="https://blogs.rhsphere.com/leetcode/2019/05/27/215.html" target="_blank" rel="noopener">07. Kth Largest Element in an Array（查找第K大的数）</a></p><p><a href="https://blogs.rhsphere.com/leetcode/2019/05/27/136.html" target="_blank" rel="noopener">08. Single Number（数组中只出现一次的数）</a></p><p><a href="https://blogs.rhsphere.com/leetcode/2019/05/27/442.html" target="_blank" rel="noopener">09. Find All Duplicates in an Array（数组中重复的数字）</a></p><p><a href="https://blogs.rhsphere.com/leetcode/2019/05/27/array-and-genericarray.html" target="_blank" rel="noopener">10. 实现动态数组（泛型）</a></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Sum-up" scheme="https://www.blogs.rhsphere.com/categories/Sum-up/"/>
    
    
      <category term="Array" scheme="https://www.blogs.rhsphere.com/tags/Array/"/>
    
      <category term="Sum-up" scheme="https://www.blogs.rhsphere.com/tags/Sum-up/"/>
    
  </entry>
  
  <entry>
    <title>442. Find All Duplicates in an Array</title>
    <link href="https://www.blogs.rhsphere.com/2019/05/27/442.html"/>
    <id>https://www.blogs.rhsphere.com/2019/05/27/442.html</id>
    <published>2019-05-27T01:24:30.000Z</published>
    <updated>2019-05-27T01:59:33.001Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><h2 id="数组中重复的数据"><a href="#数组中重复的数据" class="headerlink" title="数组中重复的数据"></a>数组中重复的数据</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个整数数组 a，其中1 ≤ a[i] ≤ n （n为数组长度）, 其中有些元素出现两次而其他元素出现一次。</p><p>找到所有出现两次的元素。</p><p>你可以不用到任何额外空间并在O(n)时间复杂度内解决这个问题吗？</p><p>示例：</p><p>输入:<br>[4,3,2,7,8,2,3,1]</p><p>输出:<br>[2,3]</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>元素的值在不超过数组的长度，我们遍历数组，将元素值映射的下标改为负数，当遇到负数时，说明该元素下标映射的值已经出现过了。</li><li>和<a href="https://blogs.rhsphere.com/leetcode/2019/05/25/41.html" target="_blank" rel="noopener">41. First Missing Positive</a>中取负值的思路差不多，但是方法略有不同，<strong>所以不要死记硬背！</strong></li></ol><h3 id="java代码"><a href="#java代码" class="headerlink" title="java代码"></a>java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 元素的值在不超过数组的长度，遍历数组将元素映射的下标改成负数，当遇到负数时，说明该元素下标映射的值已经出现过了</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: rhsphere</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>: 2019-05-27 09:30 by jdk 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FindAllDuplicates</span> </span>&#123; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">findDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nums.length &lt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> list;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> v = Math.abs(nums[i]);</span><br><span class="line"><span class="keyword">if</span> (nums[v - <span class="number">1</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">nums[v - <span class="number">1</span>] *= -<span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">list.add(Math.nums[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        List&lt;Integer&gt; list = findDuplicates(arr);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Medium" scheme="https://www.blogs.rhsphere.com/categories/Medium/"/>
    
    
      <category term="Array" scheme="https://www.blogs.rhsphere.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>136. Single Number</title>
    <link href="https://www.blogs.rhsphere.com/2019/05/27/136.html"/>
    <id>https://www.blogs.rhsphere.com/2019/05/27/136.html</id>
    <published>2019-05-27T01:01:56.000Z</published>
    <updated>2019-05-27T01:23:15.575Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><h2 id="数组中只出现一次的数"><a href="#数组中只出现一次的数" class="headerlink" title="数组中只出现一次的数"></a>数组中只出现一次的数</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><p>说明：</p><p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p><p>示例 1:</p><p>输入: [2,2,1]<br>输出: 1<br>示例 2:</p><p>输入: [4,1,2,1,2]<br>输出: 4</p><h3 id="java代码"><a href="#java代码" class="headerlink" title="java代码"></a>java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 异或操作最秀的用法了</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: rhsphere</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>: 2019-05-27 09:06 by jdk 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleNumber</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">for (int i : nums)</span></span><br><span class="line"><span class="comment">ans ^= i;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) </span><br><span class="line">ans ^= nusm[i];</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> a = singleNumber(arr);</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>由于题目原因，用异或太简单了，但是foreach比正常for循环执行速度要慢很多</li></ol><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Easy" scheme="https://www.blogs.rhsphere.com/categories/Easy/"/>
    
    
      <category term="Hash Table" scheme="https://www.blogs.rhsphere.com/tags/Hash-Table/"/>
    
      <category term="Bit Manipulation" scheme="https://www.blogs.rhsphere.com/tags/Bit-Manipulation/"/>
    
  </entry>
  
  <entry>
    <title>215. Kth Largest Element in an Array</title>
    <link href="https://www.blogs.rhsphere.com/2019/05/27/215.html"/>
    <id>https://www.blogs.rhsphere.com/2019/05/27/215.html</id>
    <published>2019-05-27T00:49:21.000Z</published>
    <updated>2019-05-27T02:00:02.680Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><h2 id="数组中的第K个最大元素"><a href="#数组中的第K个最大元素" class="headerlink" title="数组中的第K个最大元素"></a>数组中的第K个最大元素</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p><p>示例 1:</p><p>输入: [3,2,1,5,6,4] 和 k = 2<br>输出: 5<br>示例 2:</p><p>输入: [3,2,3,1,2,4,5,5,6] 和 k = 4<br>输出: 4<br>说明:</p><p>你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。</p><h3 id="java代码"><a href="#java代码" class="headerlink" title="java代码"></a>java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 用快排的思想，partition函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: rhsphere</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>: 2019-05-26 10:49 by jdk 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KthLarget</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> end = nums.length - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> index = nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line"><span class="keyword">int</span> pivotIndex = partition(nums, start, end);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pivotIndex &lt; index) &#123;</span><br><span class="line">start = pivotIndex + <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pivotIndex &gt; index) &#123;</span><br><span class="line">end = startIndex - <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> nums[pivotIndex];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> nums[start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> pivot = nums[start];</span><br><span class="line"><span class="keyword">int</span> mark = start;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = start + <span class="number">1</span>; i &lt;= end; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (nums[i] &lt; pivot) &#123;</span><br><span class="line">mark++;</span><br><span class="line"><span class="keyword">int</span> tmp = nums[i];</span><br><span class="line">nums[i] = nums[mark];</span><br><span class="line">nums[mark] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">nums[start] = nums[mark];</span><br><span class="line">nums[mark] = pivot;</span><br><span class="line"><span class="keyword">return</span> mark;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> a = findKthLargest(arr, <span class="number">2</span>);</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>应用了快排中partition的函数，参看<a href="https://blogs.rhsphere.com/leetcode/2019/04/01/quick-sort.html" target="_blank" rel="noopener">partition函数的单边循环法</a></li><li>这种方法在提交时，运行时间效果不是很好，不知道有什么可以改进的地方吗?</li><li>partition单边循环时，可以用一个数组（4 7 6 5 3 2 8 1）演示一下就知道怎么写了</li></ol><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Medium" scheme="https://www.blogs.rhsphere.com/categories/Medium/"/>
    
    
      <category term="Divide and Conquer" scheme="https://www.blogs.rhsphere.com/tags/Divide-and-Conquer/"/>
    
      <category term="Heap" scheme="https://www.blogs.rhsphere.com/tags/Heap/"/>
    
      <category term="Quick Sort" scheme="https://www.blogs.rhsphere.com/tags/Quick-Sort/"/>
    
  </entry>
  
  <entry>
    <title>41. First Missing Positive</title>
    <link href="https://www.blogs.rhsphere.com/2019/05/25/41.html"/>
    <id>https://www.blogs.rhsphere.com/2019/05/25/41.html</id>
    <published>2019-05-25T14:05:55.000Z</published>
    <updated>2019-05-27T01:47:53.202Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><h2 id="缺失的第一个正数"><a href="#缺失的第一个正数" class="headerlink" title="缺失的第一个正数"></a>缺失的第一个正数</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个未排序的整数数组，找出其中没有出现的最小的正整数。</p><p>示例 1:</p><p>输入: [3,4,-1,1]<br>输出: 2<br>示例 3:</p><p>输入: [7,8,9,11,12]<br>输出: 1<br>说明:</p><p>你的算法的时间复杂度应为O(n)，并且只能使用常数级别的空间。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><strong>整个的思路就是把nums[i]存储的数放到，下标为nums[i]的位置，处理小于等于0和大于数组长度的nums[i]，交换nums[i]到下标nums[i]是做一下取负值处理，离开的位置i不做处理，把整个数组处理一遍后，遍历数组找到第一个正数所对应的位置，就是第一个缺失的正数。</strong></p><ol><li>和剑指offer中3. 数组中重复中的数字差不多，数组存储的数（长度范围内）放在对应下标的位置，离开的位置保持不变，如果没有人填回来说明这个位置空缺，这是只要遍历一次数组，找到第一个空缺的位置就是第一个缺失的正数。</li><li>缺失的位置巧妙的用数组的0、1来辅助，先判断是否有1，如果有1那这个位置就可以拿出来放  数组中存储的不在长度范围内的数，把这些数置为1，</li><li>如果说这个数离开现在的位置，到nums[i]的位置（比如数组长度6， i = 3, nums[i] = 4, nums[i]去填到i = 4的位置），把这个数变成负数，所以这种方法，最后统计有多少正数，还能统计在数组范围内缺失多少正数。</li></ol><h3 id="java代码"><a href="#java代码" class="headerlink" title="java代码"></a>java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FindMissingPositive</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findMissingPositive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"><span class="comment">//1. 判断1是否存在</span></span><br><span class="line"><span class="keyword">int</span> n = nums.length;</span><br><span class="line"><span class="keyword">boolean</span> isOneExists = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : nums) &#123;</span><br><span class="line"><span class="comment">// foreach语句出错，错成nums[i] == 1</span></span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">1</span>)</span><br><span class="line">isOneExists = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!isOneExists) </span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"> <span class="comment">// n == 2判断出错</span></span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">1</span>) </span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"><span class="comment">//2. 因为上面判断出1存在的（否则程序结束了），所以可以借用数组下标为1的位置，</span></span><br><span class="line">        <span class="comment">// 存放不在数组长度范围内的数（小于0和大于数组长度的），将值设置为1，等下在搬移时</span></span><br><span class="line">        <span class="comment">//会一直搬移到下标为1的位置进行覆盖</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (nums[i] &lt;= <span class="number">0</span> || nums[i] &gt; n)</span><br><span class="line">nums[i] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 把数组长度内的数都给置为负值，</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> v = Math.abs(nums[i]);</span><br><span class="line"><span class="keyword">if</span> (v == n) &#123;</span><br><span class="line"><span class="comment">//避免越界，而且0位置不是正数</span></span><br><span class="line">nums[<span class="number">0</span>] = -<span class="number">1</span> * Math.abs(nums[<span class="number">0</span>]);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//由于这个位置v可能会反复访问，所以要加绝对值再取负值</span></span><br><span class="line">nums[v] = -<span class="number">1</span> * Math.abs(nums[v]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//4. 从下标为1的位置遍历</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//若执行到此步，上面的for循环，说明n-1的位置都是在的，</span></span><br><span class="line"><span class="keyword">if</span> (nums[<span class="number">0</span>] &gt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line"><span class="keyword">return</span> n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] nums = &#123;<span class="number">3</span>,<span class="number">4</span>,-<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> a = firstMissingPositive(nums);</span><br><span class="line">        System.out.println(a);</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>O(2n)的意思是遍历两遍！！！</li><li>本题思路借鉴了剑指Offer3. 重复的数字，请复习</li><li><strong>犯了两个错误</strong>1. // foreach语句出错，错成nums[i] == 1 2. // n == 2判断出错</li><li>可以看本题的思路</li></ol><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Hard" scheme="https://www.blogs.rhsphere.com/categories/Hard/"/>
    
    
      <category term="Array" scheme="https://www.blogs.rhsphere.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>88. Merge Sorted Array</title>
    <link href="https://www.blogs.rhsphere.com/2019/05/25/88.html"/>
    <id>https://www.blogs.rhsphere.com/2019/05/25/88.html</id>
    <published>2019-05-25T13:28:29.000Z</published>
    <updated>2019-05-25T14:01:23.974Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><h2 id="合并两个有序数组"><a href="#合并两个有序数组" class="headerlink" title="合并两个有序数组"></a>合并两个有序数组</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。</p><p>说明:</p><p>初始化 nums1 和 nums2 的元素数量分别为 m 和 n。<br>你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。<br>示例:</p><p>输入:<br>nums1 = [1,2,3,0,0,0], m = 3<br>nums2 = [2,5,6],       n = 3</p><p>输出: [1,2,2,3,5,6]</p><h3 id="java实现"><a href="#java实现" class="headerlink" title="java实现"></a>java实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 合并两个有序数组，考虑在归并排序中的merge函数，需要额外的空间，</span></span><br><span class="line"><span class="comment"> *本题目中，限制了数组的长度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: rhsphere</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>: 2019-05-25 21:30 by jdk 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSorted</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> index = n + m - <span class="number">1</span>;</span><br><span class="line">m--;</span><br><span class="line">n--;</span><br><span class="line"><span class="keyword">while</span> (m &gt;= <span class="number">0</span> || n &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (n == -<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (m &lt; <span class="number">0</span>) &#123;</span><br><span class="line">nums1[index--] = nums2[n--];</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums1[m] &gt; nums1[n]) &#123;</span><br><span class="line">nums1[index--] = nums1[m--];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">nums1[index--] = nums2[n--];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] nums2 = &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">3</span>, n = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">        merge(nums1, m, nums2, n);</span><br><span class="line">        System.out.println(Arrays.toString(nums1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>善用断点调试，看清流程怎么走的</li><li>合并两个有序数组，虽然没有额外的控件，但是nums1数组的长度题目中是大于等于 m+n的，和归并排序中的merge函数是完全不一样的，归并排序中用了O(n)的空间，来存储合并后的数组</li><li>对于 i– 的合理利用</li></ol><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Easy" scheme="https://www.blogs.rhsphere.com/categories/Easy/"/>
    
    
      <category term="Array" scheme="https://www.blogs.rhsphere.com/tags/Array/"/>
    
      <category term="Two Pointers" scheme="https://www.blogs.rhsphere.com/tags/Two-Pointers/"/>
    
  </entry>
  
  <entry>
    <title>412. Fizz Buzz</title>
    <link href="https://www.blogs.rhsphere.com/2019/05/25/412.html"/>
    <id>https://www.blogs.rhsphere.com/2019/05/25/412.html</id>
    <published>2019-05-25T12:45:57.000Z</published>
    <updated>2019-05-25T13:18:27.669Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><h2 id="3和5的倍数"><a href="#3和5的倍数" class="headerlink" title="3和5的倍数"></a>3和5的倍数</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>写一个程序，输出从 1 到 n 数字的字符串表示。</p><p>如果 n 是3的倍数，输出“Fizz”；</p><p>如果 n 是5的倍数，输出“Buzz”；</p><p>3.如果 n 同时是3和5的倍数，输出 “FizzBuzz”。</p><p>示例：</p><p>n = 15,</p><p>返回:<br>[<br>    “1”,<br>    “2”,<br>    “Fizz”,<br>    “4”,<br>    “Buzz”,<br>    “Fizz”,<br>    “7”,<br>    “8”,<br>    “Fizz”,<br>    “Buzz”,<br>    “11”,<br>    “Fizz”,<br>    “13”,<br>    “14”,<br>    “FizzBuzz”<br>]</p><h3 id="java实现"><a href="#java实现" class="headerlink" title="java实现"></a>java实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 比较简单，分别判断3和5的倍数标志</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: rhsphere</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>: 2019-05-25 20:51 by jdk 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FizzBuzz</span> </span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public List&lt;String&gt; fizzBuzz(int n) &#123;</span></span><br><span class="line"><span class="comment">List&lt;String&gt; list = new ArrayList&lt;&gt;();</span></span><br><span class="line"><span class="comment">if (n &lt;= 0) </span></span><br><span class="line"><span class="comment">return list;</span></span><br><span class="line"><span class="comment">int i = 0;</span></span><br><span class="line"><span class="comment">while (i &lt;= n) &#123;</span></span><br><span class="line"><span class="comment">String out = "";</span></span><br><span class="line"><span class="comment">boolean t = false, f = false;</span></span><br><span class="line"><span class="comment">if (i % 3 == 0) t = true;</span></span><br><span class="line"><span class="comment">if (i % 5 == 0) f = true;</span></span><br><span class="line"><span class="comment">if (t &amp; f) &#123;</span></span><br><span class="line"><span class="comment">out = "FizzBuzz";</span></span><br><span class="line"><span class="comment">&#125; else if (t) &#123;</span></span><br><span class="line"><span class="comment">out = "Fizz";</span></span><br><span class="line"><span class="comment">&#125; else if (f) &#123;</span></span><br><span class="line"><span class="comment">out = "Buzz";</span></span><br><span class="line"><span class="comment">&#125; else &#123;</span></span><br><span class="line"><span class="comment">out = Integer.toString(i);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">list.add(out);</span></span><br><span class="line"><span class="comment">i++;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">return list;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">fizzBuzz</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">list.add(isMultiple(i));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">isMultiple</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n % <span class="number">3</span> == <span class="number">0</span> &amp;&amp; n % <span class="number">5</span> != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Fizz"</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (n % <span class="number">3</span> != <span class="number">0</span> &amp;&amp; n % <span class="number">5</span> == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Buzz"</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (n % <span class="number">15</span> == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"FizzBuzz"</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> String.valueOf(n);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>几个方法 String.valueOf(int n)、 Integer.toString(int n)、 list.add()</li><li>注释的方法也有可取之处，比如 <strong> t &amp; f </strong></li></ol><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Easy" scheme="https://www.blogs.rhsphere.com/categories/Easy/"/>
    
    
      <category term="Array" scheme="https://www.blogs.rhsphere.com/tags/Array/"/>
    
      <category term="String" scheme="https://www.blogs.rhsphere.com/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>169. Majority Element</title>
    <link href="https://www.blogs.rhsphere.com/2019/05/25/169.html"/>
    <id>https://www.blogs.rhsphere.com/2019/05/25/169.html</id>
    <published>2019-05-25T12:15:22.000Z</published>
    <updated>2019-05-25T12:43:40.002Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><h2 id="求众数"><a href="#求众数" class="headerlink" title="求众数"></a>求众数</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。</p><p>你可以假设数组是非空的，并且给定的数组总是存在众数。</p><p>示例 1:</p><p>输入: [3,2,3]<br>输出: 3<br>示例 2:</p><p>输入: [2,2,1,1,1,2,2]<br>输出: 2</p><h3 id="java代码"><a href="#java代码" class="headerlink" title="java代码"></a>java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">**</span><br><span class="line"> * <span class="meta">@description</span>: leetcode上说明, 一定是具有众数存在的，则可以计算出一个初始值 count,从数组的下标<span class="number">1</span>开始，</span><br><span class="line"> * 如果与下一个数组下标的数字不相等，则count-- 当count 为<span class="number">0</span> 就切换为下一个比较的数字</span><br><span class="line"> * <span class="meta">@author</span>: rhsphere</span><br><span class="line"> * <span class="meta">@since</span>: <span class="number">2019</span>-<span class="number">05</span>-<span class="number">25</span> <span class="number">20</span>:<span class="number">19</span> by jdk <span class="number">1.8</span></span><br><span class="line"> */</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MajorityElement</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> maj = nums[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; nums.length) &#123;</span><br><span class="line"><span class="keyword">if</span> (nums[i] == maj) count++;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">count--;</span><br><span class="line"><span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">maj = nums[i];</span><br><span class="line">count = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> maj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*另一种写法</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">public static int majorityElement(int[] nums) &#123;</span></span><br><span class="line"><span class="comment">int maj = nums[0];</span></span><br><span class="line"><span class="comment">int count = 1;</span></span><br><span class="line"><span class="comment">for (int i = 1; i &lt; nums.length; i++) &#123;</span></span><br><span class="line"><span class="comment">if (nums[i] == maj) &#123;</span></span><br><span class="line"><span class="comment">count++;</span></span><br><span class="line"><span class="comment">&#125; else &#123;</span></span><br><span class="line"><span class="comment">count--;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">if (count == 0) &#123;</span></span><br><span class="line"><span class="comment">maj = nums[i + 1];</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">return maj;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(Sting[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] test1 = &#123;<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> a = majorityElement(test1);</span><br><span class="line">        System.out.println(a);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li><p>O(n) time and O(n) space</p></li><li><p>O(n) time and O(1) space 使用 major 变量记录众数，count 记录遇到 major +1，非 major -1，最终 count 会大于0，major 即代表众数。</p></li></ol><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Easy" scheme="https://www.blogs.rhsphere.com/categories/Easy/"/>
    
    
      <category term="Array" scheme="https://www.blogs.rhsphere.com/tags/Array/"/>
    
      <category term="Bit Manipulation" scheme="https://www.blogs.rhsphere.com/tags/Bit-Manipulation/"/>
    
      <category term="Divide and Conquer" scheme="https://www.blogs.rhsphere.com/tags/Divide-and-Conquer/"/>
    
  </entry>
  
  <entry>
    <title>15. Three Sum</title>
    <link href="https://www.blogs.rhsphere.com/2019/05/25/15.html"/>
    <id>https://www.blogs.rhsphere.com/2019/05/25/15.html</id>
    <published>2019-05-25T10:42:33.000Z</published>
    <updated>2019-05-25T11:58:58.844Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><h2 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0？找出所有满足条件且不重复的三元组。</p><p>注意：答案中不可以包含重复的三元组。</p><p>例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，</p><p>满足要求的三元组集合为： [ [-1, 0, 1], [-1, -1, 2] ]</p><h3 id="java代码"><a href="#java代码" class="headerlink" title="java代码"></a>java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 先排序，然后有两个指针 head 和 tail。 要计算的第一个数一定是负数,所以只要后两个数相加等于0-第一个数即可。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: rhsphere</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>: 2019-05-25 18:57 by jdk 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreeSum</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">Arrays.sort(nums);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line"><span class="comment">//如果上一次匹配成功了在nums[i-1]，相同的nums[i]显然会重复</span></span><br><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] = nums[i - <span class="number">1</span>]) </span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//双指针的做法谨记</span></span><br><span class="line"><span class="keyword">int</span> head = i + <span class="number">1</span>, tail = nums.length - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> val = <span class="number">0</span> - nums[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (head &lt; tail) &#123;</span><br><span class="line"><span class="keyword">if</span> (nums[head] + nums[tail] == val) &#123;</span><br><span class="line">List&lt;Integer&gt; list = Arrays.asList(nums[i], nums[head], nums[tail]);</span><br><span class="line">res.add(list);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (head &lt; tail &amp;&amp; nums[tail] = nums[tail - <span class="number">1</span>])</span><br><span class="line">tail--;</span><br><span class="line"><span class="keyword">while</span> (head &lt; tail &amp;&amp; nums[head] = nums[head + <span class="number">1</span>])</span><br><span class="line">head++;</span><br><span class="line">tail--;</span><br><span class="line">head++;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[head] + nums[tail] &gt; val) &#123;</span><br><span class="line">tail--;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">head++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> nums = &#123;-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">4</span>&#125;;</span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; list = threeSum(nums);</span><br><span class="line">System.out.println(list);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>排序后再进行规约成两数之和</li><li>记住几个函数 Arrays.asList()、 Arrays.sort()、 list.add()、 List res = new ArrayList() (接口和抽象类不能实例化)</li><li>去重的考虑，有三处做了去重</li><li><strong>双指针的方法</strong></li></ol><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Medium" scheme="https://www.blogs.rhsphere.com/categories/Medium/"/>
    
    
      <category term="Array" scheme="https://www.blogs.rhsphere.com/tags/Array/"/>
    
      <category term="Two Pointers" scheme="https://www.blogs.rhsphere.com/tags/Two-Pointers/"/>
    
  </entry>
  
  <entry>
    <title>01. Two Sum</title>
    <link href="https://www.blogs.rhsphere.com/2019/05/25/1.html"/>
    <id>https://www.blogs.rhsphere.com/2019/05/25/1.html</id>
    <published>2019-05-25T08:45:10.000Z</published>
    <updated>2019-05-25T10:41:10.977Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><h2 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h2><p>给定一个整数数组nums和一个目标值target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。</p><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoSum</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> key = target - nums[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (map.contains(key))</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;map.get(key), i&#125;;</span><br><span class="line"></span><br><span class="line">map.put(nums[i], i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"No two sum solution"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Easy" scheme="https://www.blogs.rhsphere.com/categories/Easy/"/>
    
    
      <category term="Hash Table" scheme="https://www.blogs.rhsphere.com/tags/Hash-Table/"/>
    
      <category term="Array" scheme="https://www.blogs.rhsphere.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>动态代理</title>
    <link href="https://www.blogs.rhsphere.com/2019/04/24/dynamic-proxy.html"/>
    <id>https://www.blogs.rhsphere.com/2019/04/24/dynamic-proxy.html</id>
    <published>2019-04-24T11:45:57.000Z</published>
    <updated>2019-04-24T14:00:39.879Z</updated>
    
    <content type="html"><![CDATA[<p class="description">JDK动态代理涉及java.lang.reflect包中的两个类，Proxy和InvocationHandler。Proxy利用InvocationHandler动态创建一个符合某一接口的实例，生成目标类的代理对象。InvocationHandler可以实现接口定义横切逻辑，并通过反射机制调用目标类的代码，动态地将横切逻辑和业务逻辑编织在一起。</p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><h2 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h2><p>下面的代码来自于 精通Spring 4.x企业应用开发实战 P224</p><h3 id="业务逻辑横切代码"><a href="#业务逻辑横切代码" class="headerlink" title="业务逻辑横切代码"></a>业务逻辑横切代码</h3><p>业务逻辑实现类的代码，省去ForumService接口类和PerformanceMonitor的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForumServiceImpl</span> <span class="keyword">implements</span> <span class="title">ForumService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeTopic</span><span class="params">(<span class="keyword">int</span> topicId)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 横切逻辑</span></span><br><span class="line">        <span class="comment">// PerformanceMonitor.begin();  </span></span><br><span class="line">        System.out.println(<span class="string">"模拟删除Topic记录"</span> + topicId);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.currentThread().sleep(<span class="number">20</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// PerformanceMonitor.end()</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeForum</span><span class="params">(<span class="keyword">int</span> forumId)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// PerformanceMonitor.begin();</span></span><br><span class="line">        System.out.println(<span class="string">"模拟删除Topic记录"</span> + forumId);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.currentThread().sleep(<span class="number">20</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// PerformanceMonitor.end();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="横切逻辑"><a href="#横切逻辑" class="headerlink" title="横切逻辑"></a>横切逻辑</h3><p>将业务类中性能监视横切代码移除后，放置到InvocationHandler中，代码如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PerformanceHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PerformanceHandler</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, </span></span></span><br><span class="line"><span class="function"><span class="params">        Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// 横切逻辑代码定义在PerformanceMonitor中</span></span><br><span class="line">        PerformanceMonitor.begin(target.getClass().getName() + <span class="string">"."</span> + method.getName());</span><br><span class="line">        <span class="comment">// 使用反射方法调用业务类的目标方法</span></span><br><span class="line">        Object obj = method.invoke(target, args);</span><br><span class="line">        <span class="comment">// 横切逻辑</span></span><br><span class="line">        PerformanceMonitor.end();</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>invoke(Object proxy, Method method, Object[] args)方法，其中，proxy是最终生成的代理实例，一般不会用到；method是被代理目标实例的某个具体方法，通过它可以发起目标实例方法的反射调用；args是被代理实例某个方法的入参，在方法反射时调用。<br>其次，在构造参数里通过target传入希望被代理的目标对象，在接口方法invoke(Object proxy, Method method, Object[] args)里，将目标实例传递给method.invoke()方法，并调用目标实例的方法。</p><p>下面通过Proxy结合PerformanceHandler创建ForumService接口的代理实例。</p><h3 id="创建代理实例"><a href="#创建代理实例" class="headerlink" title="创建代理实例"></a>创建代理实例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForumServiceTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">proxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//  希望被代理的目标业务类</span></span><br><span class="line">        ForumService target = <span class="keyword">new</span> ForumServiceImpl();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  将目标业务类和横切代码编织到一起</span></span><br><span class="line">        PerformanceHandler handler = <span class="keyword">new</span> PerformanceHandler(target);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  根据编织了目标业务类逻辑和性能监视横切逻辑的</span></span><br><span class="line">        <span class="comment">//  InvocationHandler实例创建代理实例</span></span><br><span class="line">        ForumService proxy = (ForumService) Proxy.newProxyInstance(</span><br><span class="line">            target.getClass().getClassLoader(),</span><br><span class="line">            target.getClass().getInterface(),</span><br><span class="line">            handler);</span><br><span class="line">        <span class="comment">//  调用代理实例</span></span><br><span class="line">        proxy.removeForum(<span class="number">10</span>);</span><br><span class="line">        proxy.removeTopic(<span class="number">1024</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Proxy.newProxyInstance() 方法的第一个入参为类加载器；第二个入参为创建代理实例所需实现的一组接口；第三个入参是整合了业务逻辑和横切逻辑的编织器对象。</p><h2 id="JDK动态代理另一种简洁写法"><a href="#JDK动态代理另一种简洁写法" class="headerlink" title="JDK动态代理另一种简洁写法"></a>JDK动态代理另一种简洁写法</h2><p>以下代码来自于 Java EE 互联网轻量级框架整合开发</p><h3 id="接口类和实现类的定义"><a href="#接口类和实现类的定义" class="headerlink" title="接口类和实现类的定义"></a>接口类和实现类的定义</h3><p>在动态代理中必须使用接口，CGLib不需要。<br>下面的代码分别是简单的接口和被代理类的定义。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceImpl</span> <span class="keyword">implements</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello world"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动态代理绑定和代理逻辑实现"><a href="#动态代理绑定和代理逻辑实现" class="headerlink" title="动态代理绑定和代理逻辑实现"></a>动态代理绑定和代理逻辑实现</h3><p>要实现动态代理要两个步骤，首先，建立起代理对象和被代理对象的关系（将目标业务类和横切代码编织到一起），然后实现代理逻辑。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkProxyExample</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object target = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">bind</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">            target.getClass().getClassLoader(),</span><br><span class="line">            target.getClass().gerInterfaces(),</span><br><span class="line">            <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, </span></span></span><br><span class="line"><span class="function"><span class="params">        Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"before..."</span>);</span><br><span class="line"></span><br><span class="line">        Object obj = method.invoke(target, args);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"after..."</span>);</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="测试动态代理类"><a href="#测试动态代理类" class="headerlink" title="测试动态代理类"></a>测试动态代理类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkProxyExampleTest</span> </span>&#123;</span><br><span class="line">    JdkProxyExample jdk = <span class="keyword">new</span> JdkProxyExample();</span><br><span class="line"></span><br><span class="line">    Service proxy = (Service) jdk.bind(<span class="keyword">new</span> ServiceImpl());</span><br><span class="line"></span><br><span class="line">    proxy.sayHello();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>bind方法同时完成了两步。</p><h2 id="CGLib动态代理"><a href="#CGLib动态代理" class="headerlink" title="CGLib动态代理"></a>CGLib动态代理</h2><p>使用JDK创建代理有一个限制，即只能为接口创建代理。Proxy的接口方法中newProxyInstance(ClassLoader loder, Class[] interfaces, InvocationHandler hander)，第二个入参就是需要代理实例实现的接口列表。<br>假如对一个简单业务表的操作也需要创建5个类（领域对象、DAO接口、DAO实现类、Service接口和Service实现类）吗？<br>对于没有通过接口定义业务方法的类，可以使用CGLib动态创建代理实例。</p><p>CGLib采用底层的字节码技术，可以为一个类创建子类，在子类中采用方法拦截的技术拦截父类方法的调用并顺势织入横切逻辑。</p><p>值得一提的是，由于CGLib采用动态创建子类的方式生成代理对象，所以不能对目标类中的final或private方法进行代理。</p><h3 id="CglibProxy"><a href="#CglibProxy" class="headerlink" title="CglibProxy"></a>CglibProxy</h3><p>下面代码可以创建，为任何类织入性能监视横切逻辑代理对象的代理创建器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibProxy</span> <span class="title">implemets</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 增强类对象</span></span><br><span class="line">    <span class="keyword">private</span> Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(Class cls)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 设置需要创建子类的类</span></span><br><span class="line">        enhancer.setSuperClass(cls);</span><br><span class="line">        <span class="comment">/* 定义代理逻辑对象为当前对象，要求当前对象实现</span></span><br><span class="line"><span class="comment">        * MethodInterceptor方法</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过字节码技术动态创建子类实例</span></span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *代理逻辑方法，拦截父类所有方法的调用</span></span><br><span class="line"><span class="comment">    * obj 目标类的实例</span></span><br><span class="line"><span class="comment">    * method 目标类方法的反射对象</span></span><br><span class="line"><span class="comment">    * args 方法的动态入参</span></span><br><span class="line"><span class="comment">    * proxy 代理类实例</span></span><br><span class="line"><span class="comment">    * result 代理逻辑方法返回</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Objcet obj, Method method, Object[] args,</span></span></span><br><span class="line"><span class="function"><span class="params">        MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        PerformanceMonitor.begin(obj.getClass().getName() + <span class="string">"."</span> + method.getName());</span><br><span class="line">        <span class="comment">// CGLib反射调用父类中的方法</span></span><br><span class="line">        Objcet result = proxy.invokeSuper(obj, args);</span><br><span class="line">        PerformanceMonitor.end();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用户可以通过getProxy(Class cla)方法动态创建一个动态代理类。</p><h3 id="Cglib测试代码"><a href="#Cglib测试代码" class="headerlink" title="Cglib测试代码"></a>Cglib测试代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> org.testg.annotations.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForumServiceTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">proxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CglibProxy proxy = <span class="keyword">new</span> CglibProxy();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  通过动态生成子类的方式创建代理类</span></span><br><span class="line">        ForumServiceImpl forumService = (ForumServiceImpl) </span><br><span class="line">        proxy.getProxy(ForumServiceImpl.class);</span><br><span class="line"></span><br><span class="line">        forumService.removeForum(<span class="number">10</span>);</span><br><span class="line">        forumService.removeTopic(<span class="number">1024</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><h3 id="拦截器接口"><a href="#拦截器接口" class="headerlink" title="拦截器接口"></a>拦截器接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">before</span><span class="params">(Object proxy, Object target, Method method, Objcet[] args)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">around</span><span class="params">(Object proxy, Object target, Method method, Objcet[] args)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">after</span><span class="params">(Object proxy, Object target, Method method, Objcet[] args)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Interceptor实现类"><a href="#Interceptor实现类" class="headerlink" title="Interceptor实现类"></a>Interceptor实现类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">before</span><span class="params">(Object proxy, Object target, Method method, Objcet[] args)</span> </span>&#123;</span><br><span class="line">        System.err.println(<span class="string">"反射方法前逻辑"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">(Object proxy, Object target, Method method, Objcet[] args)</span> </span>&#123;</span><br><span class="line">        System.err.println(<span class="string">"反射方法后逻辑"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">around</span><span class="params">(Object proxy, Object target, Method method, Objcet[] args)</span> </span>&#123;</span><br><span class="line">        System.err.println(<span class="string">"取代了目标实例的方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在JDK动态代理中使用拦截器"><a href="#在JDK动态代理中使用拦截器" class="headerlink" title="在JDK动态代理中使用拦截器"></a>在JDK动态代理中使用拦截器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterceptorJdkProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 目标实例</span></span><br><span class="line">    <span class="keyword">private</span> Objcet target;</span><br><span class="line">    <span class="comment">// 拦截器全限定名</span></span><br><span class="line">    <span class="keyword">private</span> String interceptorClass = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InterceptorJdkProxy</span><span class="params">(Objcet target, String interceptorClass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">        <span class="keyword">this</span>.interceptorClass = interceptorClass;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">bind</span><span class="params">(Object target, String interceptorClass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">            target.getClass().getClassLoader(),</span><br><span class="line">            target.getClass().getInterfaces(),</span><br><span class="line">            <span class="keyword">new</span> InterceptorJdkProxy(target, interceptorClass));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, </span></span></span><br><span class="line"><span class="function"><span class="params">        Object[] args)</span>  <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (interceptorClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> method.invoke(target, args);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Object result = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        Interceptor inceptor = (Interceptor) </span><br><span class="line">            Class.forName(interceptorClass).newInstance();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (interceptor.before(proxy, target, method, args)) &#123;</span><br><span class="line">            result = method.invoke(target, args);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            inceptor.around(proxy, target, method, args);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        interceptor.after(proxy, target, method, args);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;JDK动态代理涉及java.lang.reflect包中的两个类，Proxy和InvocationHandler。Proxy利用InvocationHandler动态创建一个符合某一接口的实例，生成目标类的代理对象。InvocationHandler可以实现接口定义横切逻辑，并通过反射机制调用目标类的代码，动态地将横切逻辑和业务逻辑编织在一起。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://&quot; alt=&quot;&quot; style=&quot;width:100%&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="动态代理" scheme="https://www.blogs.rhsphere.com/categories/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    
    
      <category term="动态代理" scheme="https://www.blogs.rhsphere.com/tags/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer(15) 二进制中1的个数</title>
    <link href="https://www.blogs.rhsphere.com/2019/04/21/number-of-1-in-binary.html"/>
    <id>https://www.blogs.rhsphere.com/2019/04/21/number-of-1-in-binary.html</id>
    <published>2019-04-20T16:42:23.000Z</published>
    <updated>2019-05-25T07:28:06.546Z</updated>
    
    <content type="html"><![CDATA[<p class="description">用机器语言编写程序，经常需要直接处理二进制数值，并在位级别上执行操作。位操作可以解决各种各样的问题。有的问题会明确要求用位操作来解决，而在其他的情况下，位操作也是优化代码的实用技巧。写代码要熟悉位操作，同时也要熟悉位操作的手工运算。写好代码后一定要进行充分测试，也可以边写代码边测试。</p><a id="more"></a><h2 id="位操作手工运算"><a href="#位操作手工运算" class="headerlink" title="位操作手工运算"></a>位操作手工运算</h2><p>其实二进制的位运算不是很难掌握，因为位运算总共只有7种运算：与、或、非(取反)、异或、左移位、带符号位右移位和无符号位右移位。<br>位操作符仅适用于整数类型（byte、short、int和long）。位操作涉及的字符将转换为整数。所有的位操作符可以构成位赋值操作符，如 &amp;=， |=， ~=， ^=， &lt;&lt;=， &gt;&gt;=， &gt;&gt;&gt;=。</p><p>对于复杂一点的位操作，可以使用若干技巧来解决。假定操作数的位宽为4。<br>（1）0110 + 0110<br>相当于 0110 * 2，也就是将0110左移1位。</p><p>（2）0100 <em> 0011<br>0100相当于4，上面就等于 4 </em> 0011，也就是2^2，于是将0011左移2位得到1100。<br>**一个数与2^n相乘，相当于将这个数左移n位。</p><p>（3）1101 ^ (~1101)<br>逐比特分解这个操作。一个比特与对它去烦的数值做异或操作，结果总是1。因此 x ^ (~x)的结果是一串1。</p><p>（4）1011 &amp; (~0 &lt;&lt; 2)<br>类似 x &amp; (~0 &lt;&lt; n)的操作会将x最右边的n位清零。 <strong> ~0的值是一串1（0在内存中为0x00000000，故取反后为一串1）</strong>，将它左移n位后的结果为一串1后面跟n个0。将这个数与x进行“位与”操作，相当于将x最右边的n位清零。</p><h2 id="位操作原理与技巧"><a href="#位操作原理与技巧" class="headerlink" title="位操作原理与技巧"></a>位操作原理与技巧</h2><p>处理位操作问题时，理解下面的原理会有很大帮助。下面的示例中，“1s”和“0s”分别表示一串1和一串0。<br><strong>异或</strong><br>x ^ 0s = x    x ^ 1s = ~x    x ^ x = 0<br><strong>与</strong><br>x &amp; 0s = 0    x &amp; 1s = x     x &amp; x = x<br><strong>或</strong><br>x | 0s = x    x | 1s = 1s    x | x = x</p><p>要理解这些表达式的含义，需要记住 <strong>所有操作都是按位进行的，某一位的运算结果不会影响其余位。</strong></p><p>清零取数要用与，某位置一可用或<br>若要取反和交换，轻轻松松用异或</p><h2 id="常见位操作"><a href="#常见位操作" class="headerlink" title="常见位操作"></a>常见位操作</h2><p>常见操作有：获取、设置、清除及更新位数据<br>以下这些位操作很重要，不过不要死记硬背，否则会滋生一些难以觉察的错误，相反，要吃透这些操作方法，学会举一反三，灵活处理问题。</p><h3 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h3><p>该方法将1左移i位，接着，对这个值与num执行“位与”操作，从而将i位之外的所有位清零。最后，检查该结果是否为零。不为零说明i位为1，否则，i位为0。<br><strong> n &amp; (1 &lt;&lt; (k - 1)) 第k位置为1</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">getBit</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((num &amp; (<span class="number">1</span> &lt;&lt; i)) != <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="置位"><a href="#置位" class="headerlink" title="置位"></a>置位</h3><p>将1左移i位，然后对这个值和num执行“位或”操作，这样只会改变i位的数据。该掩码i位除外的位均为零，孤儿不会影响num的其余位。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setBit</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num | (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="清零"><a href="#清零" class="headerlink" title="清零"></a>清零</h3><p>将给定操作数n的第k位清零，可以用表达式 n &amp; ~(1 &lt;&lt; (k-1))</p><p>将掩码和num执行位与操作，这样只会清零num的i位，其余位保持不变。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">clearBit</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mask = ~(<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">    <span class="keyword">return</span> num &amp; mask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>将num最高位至i位（含）清零的做法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">clearBitsMSBthroughI</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mask = (<span class="number">1</span> &lt;&lt; i) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> num &amp; mask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>将i位至0位（含）清零的做法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">clearBitsIthrough0</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mask = ~((<span class="number">1</span> &lt;&lt; (i + <span class="number">1</span>)) - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> num &amp; mask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p>这个方法将setBit与clearBit合二为一。首先，用诸如11101111的掩码将num的第i位清零。接着，将带写入值val左移i位，得到一个i位为val但其余位都为0的数。最后，对之前去的的两个结果执行“位或”操作<br>，val为1则将num的i位更新为1，否则该位仍为0。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">updateBit</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span> i, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mask = ~(<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">    <span class="keyword">return</span> (num &amp; mask) | (val &lt;&lt; i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="n-amp-n-1-0-的含义"><a href="#n-amp-n-1-0-的含义" class="headerlink" title="(n &amp; (n - 1) == 0) 的含义"></a>(n &amp; (n - 1) == 0) 的含义</h2><p><strong> （A &amp; B） == 0 的含义 </strong><br>意思是，A和B二进制表示的同一位置绝不会同时为1。<br>因此，如果n &amp; (n - 1) == 0，则 n 和 n-1 就不会有共同的1。</p><p>表达式 (n &amp; (n - 1) == 0) 是用来检查n是否为2的某次方（或者检查n是否为0）。</p><h2 id="二进制中1的个数"><a href="#二进制中1的个数" class="headerlink" title="二进制中1的个数"></a>二进制中1的个数</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>请实现一个函数，输入一个整数，输出该数二进制表示中1的个数。例如把9表示成二进制是1001，有2位是1。因此如果输入9，该函数输出2。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>遇到与二进制有关的题目，应该想到位运算(与、或、异或、左移、右移)。</p><p>方法一：“位与”有一个性质：通过与对应位上为1，其余位为0的数进行与运算，可以判断某一整数指定位上的值是否为1。<br>这道题中，先把整数n与1做与运算，判断最低位是否为1；接着把1左移一位，与n做与运算，可以判断次低位是否为1……反复左移，即可对每一个位置都进行判断，从而可以获得1的个数。这种方法需要循环判断32次。</p><p><strong>方法二（better）：</strong><br>如果一个整数不为0，把这个整数减1，那么原来处在整数最右边的1就会变为0，原来在1后面的所有的0都会变成1。其余所有位将不会受到影响。<br>再把原来的整数和减去1之后的结果做与运算，从原来整数最右边一个1那一位开始所有位都会变成0。因此，把一个整数减1，再和原来的整数做与运算，会把该整数最右边的1变成0。<br>这种方法，整数中有几个1，就只需要循环判断几次。</p><h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><p>1.正数（包括边界值1、0x7FFFFFFF）<br>2.负数（包括边界值0x80000000、0xFFFFFFFF）<br>3.0</p><h2 id="java代码"><a href="#java代码" class="headerlink" title="java代码"></a>java代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumberOf1InBinary</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberOf1_Solution1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (flag != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((flag &amp; n) != <span class="number">0</span>)</span><br><span class="line">                count++;</span><br><span class="line">            flag &lt;&lt;= <span class="number">1</span>;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberOf1_Solution2</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            n = n &amp; (n - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><strong>注意：负数右移还是负数！</strong>即如果对n=0x8000 0000右移，最高位的1是不会变的。如果这道题目通过令n=n&gt;&gt;1来计算n中1的个数，该数最终会变成0xFFFF FFFF而陷入死循环！</li><li><p>把一个整数减1，再和原来的整数做与运算，会把该整数最右边的1变成0。这种方法一定要牢牢记住，很多情况下都可能用到，例如：</p><ul><li>一句话判断一个整数是否为2的整数次方；</li><li>对两个整数m和n，计算需要改变m二进制表示中的几位才能得到n。</li></ul></li><li><p>与数字操作有关的题目，测试时注意边界值的问题。对于32位数字，其正数的边界值为1、0x7FFFFFFF，负数的边界值为0x80000000、0xFFFFFFFF。</p></li><li>(flag &amp; n！=0)，而非(flag &amp; n == 1)； 也就不能写成count += (flag &amp; 1)。</li><li>if语句中，不能写为if(flag &amp; n != 0) ，而要写成 if((flag &amp; n) != 0)，需要加上括号</li></ol><h2 id="扩展题"><a href="#扩展题" class="headerlink" title="扩展题"></a>扩展题</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>编写一个函数，确定需要改变几个位，才能将整数A转成整数B。<br>这道题可以分两步解决：第一步求这两个数的异或；第二步统计异或结果中1的位数。</p><p>只要输出a^b有几个位为1即可。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bitSwapRequired</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> c = a ^ b; c != <span class="number">0</span>; c &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        count += c &amp; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的代码的做法是不断对c执行移位操作，然后检查最低有效位，但是其实可以不断翻转最低有效位，计算要多少次才会变成0。操作c = c &amp; (c - 1)会清楚c的最低有效位。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bitSwapRequired</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> c = a ^ b; c != <span class="number">0</span>; c = c &amp; (c - <span class="number">1</span>)) </span><br><span class="line">        count++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;用机器语言编写程序，经常需要直接处理二进制数值，并在位级别上执行操作。位操作可以解决各种各样的问题。有的问题会明确要求用位操作来解决，而在其他的情况下，位操作也是优化代码的实用技巧。写代码要熟悉位操作，同时也要熟悉位操作的手工运算。写好代码后一定要进行充分测试，也可以边写代码边测试。&lt;/p&gt;
    
    </summary>
    
      <category term="剑指Offer" scheme="https://www.blogs.rhsphere.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="bit" scheme="https://www.blogs.rhsphere.com/tags/bit/"/>
    
      <category term="bit manipulation" scheme="https://www.blogs.rhsphere.com/tags/bit-manipulation/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer(14) 剪绳子</title>
    <link href="https://www.blogs.rhsphere.com/2019/04/21/cut-rope.html"/>
    <id>https://www.blogs.rhsphere.com/2019/04/21/cut-rope.html</id>
    <published>2019-04-20T16:41:44.000Z</published>
    <updated>2019-10-10T12:55:37.274Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><h1 id="剪绳子"><a href="#剪绳子" class="headerlink" title="剪绳子"></a>剪绳子</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一根长度为n绳子，请把绳子剪成m段（m、n都是整数，n&gt;1并且m≥1）。<br>每段的绳子的长度记为k[0]、k[1]、……、k[m]。k[0]·k[1]·…·k[m]可能的最大乘积是多少？例如当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到最大的乘积18。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>本题采用动态规划或者贪婪算法可以实现。一开始没有思路时，可以从简单的情况开始想，试着算以下比较短的绳子是如何剪的。<br>当n=1时，最大乘积只能为0；</p><p>当n=2时，最大乘积只能为1；</p><p>当n=3时，最大乘积只能为2；</p><p>当n=4时，可以分为如下几种情况:1·1·1·1，1·2·1，1·3，2·2，最大乘积为4；</p><p>往下推时，发现n≥4时，可以把问题变成几个小问题，即：如果把长度n绳子的最大乘积记为f(n)，则有：f(n)=max(f(i) · f(n - 1))，0 &lt; i &lt; n。<br>所以思路就很容易出来了：自底向上，先算小的问题，再算大的问题，大的问题通过寻找小问题的最优组合得到。</p><p>贪婪算法依赖于数学证明，当绳子大于5时，尽量多地剪出长度为3的绳子是最优解。</p><h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><ol><li>功能测试（长度大于5）</li><li>边界测试（长度1,2,3,4）</li></ol><h2 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CuttingRope</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ======动态规划======</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProductAfterCutting_solution1</span><span class="params">(<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (length &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (length == <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (length == <span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span>[] product = <span class="keyword">new</span> <span class="keyword">int</span>[length + <span class="number">1</span>]; <span class="comment">// 用于存放最大乘积值</span></span><br><span class="line">        <span class="comment">// 下面几个不是乘积，因为其本身长度比乘积大</span></span><br><span class="line">        product[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        product[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        product[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        product[<span class="number">3</span>] = <span class="number">3</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 开始从下到上计算长度为i绳子的最大乘积值product[i]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">4</span>; i &lt;= length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 算不同子长度的乘积，找出最大的乘积</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i / <span class="number">2</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (max &lt; product[j] * product[i - j])</span><br><span class="line">                    max = product[j] * product[i - j];</span><br><span class="line">            &#125;</span><br><span class="line">            product[i] = max;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> product[length];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    / =======贪婪算法========</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProductAfterCutting_solution2</span><span class="params">(<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (length &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (length == <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (length == <span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> timesOf3 = length / <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> timesOf2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (length - timesOf3 * <span class="number">3</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            timesOf3--;</span><br><span class="line">            <span class="comment">// timesOf2=2;  //错误！</span></span><br><span class="line">        &#125;</span><br><span class="line">        timesOf2 = (length - timesOf3 * <span class="number">3</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) (Math.pow(<span class="number">3</span>, timesOf3) * Math.pow(<span class="number">2</span>, timesOf2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><p>最优解问题，经常使用动态规划法，关键要刻画最优解的结构特征（本题的f(n)），从下往上计算最优解的值，没有思路时，从简单情况先算一下。</p></li><li><p>动态规划法中，子问题的最优解一般存放于一个数组中。</p></li><li><p>本题贪婪规划的代码中，timeOf2别忘记等于1的情况。</p></li></ol><p>复习时补充：</p><ol><li><p>动态规划法可以直接令 f(n)=max{f(n-2)<em>2,f(n-3)</em>3} 就可以了。</p></li><li><p>贪婪算法，核心部分可改为</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> timesOf3 = n / <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (n % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)(Math.pow(<span class="number">3</span>, timesOf3));</span><br><span class="line"><span class="keyword">if</span> (n % <span class="number">3</span> == <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)(Math.pow(<span class="number">3</span>, timesOf3 - <span class="number">1</span>) *４)；</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">int</span>)(Math.pow(<span class="number">3</span>, timesOf3) * <span class="number">2</span>);</span><br></pre></td></tr></table></figure><ol start="3"><li>int[] product = new int[length + 1]; // 用于存放最大乘积值<br>备忘录的长度不是length - 1<hr></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="剑指Offer" scheme="https://www.blogs.rhsphere.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="Dynamic Programming" scheme="https://www.blogs.rhsphere.com/tags/Dynamic-Programming/"/>
    
      <category term="recursive" scheme="https://www.blogs.rhsphere.com/tags/recursive/"/>
    
      <category term="greedy" scheme="https://www.blogs.rhsphere.com/tags/greedy/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer(13) 机器人的运动范围</title>
    <link href="https://www.blogs.rhsphere.com/2019/04/19/robot-move.html"/>
    <id>https://www.blogs.rhsphere.com/2019/04/19/robot-move.html</id>
    <published>2019-04-19T00:43:37.000Z</published>
    <updated>2019-10-10T12:26:11.832Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><h1 id="机器人的移动范围"><a href="#机器人的移动范围" class="headerlink" title="机器人的移动范围"></a>机器人的移动范围</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>地上有一个m行n列的方格。一个机器人从坐标(0, 0)的格子开始移动，它每一次可以向左、右、上、下移动一格，但不能进入行坐标和列坐标的数位之和大于k的格子。<br>例如，当k为18时，机器人能够进入方格(35, 37)，因为3+5+3+7=18。但它不能进入方格(35, 38)，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>与<a href="https://blogs.rhsphere.com/leetcode/2019/04/18/string-path-in-matrix.html" target="_blank" rel="noopener">剑指offer(12) 矩阵中的路径</a>类似，也采用回溯法，先判断机器人能否进入(i,j)，再判断周围4个格子。<br>不同的是，这题返回的是int值。</p><p>递归回溯本质上是一种枚举法，可以看成蛮力法的升级版。回溯法用于多个步骤，每个步骤都有多个选项的问题：若当前步骤满足条件，给定一个标记，当发现之后的步骤不满足条件时，去除标记。</p><h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><ol><li>功能测试（多行多列矩阵，k为正数）</li><li>边界值测试（矩阵只有一行或一列；k=0）</li><li>特殊输入测试（k为负数）</li></ol><h2 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h2><p>已验证代码正确性，测试部分去除。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RobotMove</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (rows &lt;= <span class="number">0</span> || cols &lt;= <span class="number">0</span> || threshold &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span>[] isVisited = <span class="keyword">new</span> <span class="keyword">boolean</span>[rows * cols];</span><br><span class="line">        <span class="keyword">int</span> count = movingCountCore(threshold, rows, cols, <span class="number">0</span>, <span class="number">0</span>, isVisited);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">movingCountCore</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">boolean</span>[] isVisited)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (row &lt; <span class="number">0</span> || col &lt; <span class="number">0</span> || row &gt;= rows || col &gt;= cols || isVisited[row * cols + col]</span><br><span class="line">                || cal(row) + cal(col) &gt; threshold)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        isVisited[row * cols + col] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + movingCountCore(threshold, rows, cols, row - <span class="number">1</span>, col, isVisited)</span><br><span class="line">                + movingCountCore(threshold, rows, cols, row + <span class="number">1</span>, col, isVisited)</span><br><span class="line">                + movingCountCore(threshold, rows, cols, row, col - <span class="number">1</span>, isVisited)</span><br><span class="line">                + movingCountCore(threshold, rows, cols, row, col + <span class="number">1</span>, isVisited);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sum += num % <span class="number">10</span>;</span><br><span class="line">            num /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>计算数位之和时，要注意数字不一定是十位数，可能是百位、千位甚至更多，所以cal()函数别写成计算十位数的方法了。</li><li>row &gt;= rows || col &gt;= cols  这里的等号。</li><li>return 0; 而不是 return false;</li></ol><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="剑指Offer" scheme="https://www.blogs.rhsphere.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="Backtracking" scheme="https://www.blogs.rhsphere.com/tags/Backtracking/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer(12) 矩阵中的路径</title>
    <link href="https://www.blogs.rhsphere.com/2019/04/18/string-path-in-matrix.html"/>
    <id>https://www.blogs.rhsphere.com/2019/04/18/string-path-in-matrix.html</id>
    <published>2019-04-18T01:23:17.000Z</published>
    <updated>2019-10-10T12:00:21.220Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><h1 id="矩阵中的路径"><a href="#矩阵中的路径" class="headerlink" title="矩阵中的路径"></a>矩阵中的路径</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。<br>路径可以从矩阵中任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。<br>例如在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用下划线标出）。但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。<br> A B T G<br> C F C S<br> J D E H</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>首先对整个矩阵遍历，找到第一个字符，然后向上下左右查找下一个字符，由于每个字符都是相同的判断方法（先判断当前字符是否相等，再向四周查找），因此采用 <strong>递归回溯</strong>。<br>由于字符查找过后不能重复进入，所有还要定义一个字符矩阵相同大小的 <strong>布尔值矩阵</strong>，进入过的格子标记为true。如果不满足的情况下，需要进行 <strong>回溯</strong>，此时，要将当前位置的布尔值标记回false。<br>（<strong>所谓的回溯无非就是对使用过的字符进行标记和对处理后的字符去标记</strong>）</p><p>递归回溯本质上是一种枚举法，可以看成蛮力法的升级版。回溯法用于多个步骤，内个步骤都有多个选项的问题：若当前步骤满足条件，给定一个标记，当发现之后的步骤不满足条件时，去除标记。</p><h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><ol><li>功能测试（多行多列矩阵中存在或者不存在路径）</li><li>边界值测试（矩阵只有一行；矩阵与路径的所有字符都相同）</li><li>特殊输入测试（null）</li></ol><h2 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringPathInMatrix</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPath</span><span class="params">(<span class="keyword">char</span>[] matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">char</span>[] str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || rows &lt; <span class="number">1</span> || cols &lt; <span class="number">1</span> || str == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span>[] isVisited = <span class="keyword">new</span> <span class="keyword">boolean</span>[rows * cols];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">boolean</span> v : isVisited) &#123;</span><br><span class="line">            v = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> pathLength = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; rows; row++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; cols; col++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (hasPathCore(matrix, rows, cols, row, col, str, pathLength, isVisited))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">hasPathCore</span><span class="params">(<span class="keyword">char</span>[] matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">char</span>[] str, <span class="keyword">int</span> pathLength,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span>[] isVisited)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (row &lt; <span class="number">0</span> || col &lt; <span class="number">0</span> || row &gt;= rows || col &gt;= cols || isVisited[row * cols + col] == <span class="keyword">true</span></span><br><span class="line">                || str[pathLength] != matrix[row * cols + col])</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pathLength == str.length - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">boolean</span> hasPath = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        isVisited[row * cols + col] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        hasPath = hasPathCore(matrix, rows, cols, row - <span class="number">1</span>, col, str, pathLength + <span class="number">1</span>, isVisited)</span><br><span class="line">                || hasPathCore(matrix, rows, cols, row + <span class="number">1</span>, col, str, pathLength + <span class="number">1</span>, isVisited)</span><br><span class="line">                || hasPathCore(matrix, rows, cols, row, col - <span class="number">1</span>, str, pathLength + <span class="number">1</span>, isVisited)</span><br><span class="line">                || hasPathCore(matrix, rows, cols, row, col + <span class="number">1</span>, str, pathLength + <span class="number">1</span>, isVisited);</span><br><span class="line">        <span class="keyword">if</span> (!hasPath) &#123;</span><br><span class="line">            isVisited[row * cols + col] = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hasPath;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><strong>回溯法用于多个步骤，每个步骤都有多个选项的问题：若当前步骤满足条件，给定一个标记，当发现之后的步骤不满足条件时，去除标记。</strong></li><li>字符串转化为以为字符数组，使用toCharArray()方法。</li><li>二维数组下标在一维数组中的计算： row · cols + col。</li></ol><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="剑指Offer" scheme="https://www.blogs.rhsphere.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="Backtracking" scheme="https://www.blogs.rhsphere.com/tags/Backtracking/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer(11) 旋转数组中的最小数字</title>
    <link href="https://www.blogs.rhsphere.com/2019/04/16/min-number-in-rotate-array.html"/>
    <id>https://www.blogs.rhsphere.com/2019/04/16/min-number-in-rotate-array.html</id>
    <published>2019-04-16T14:15:13.000Z</published>
    <updated>2019-10-10T11:23:36.814Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><h1 id="查找和排序"><a href="#查找和排序" class="headerlink" title="查找和排序"></a>查找和排序</h1><p>tips:</p><p>在面试时，如果面试官要求实现一个排序算法，那么一定要问清楚这个排序应用的环境是什么、有哪些约束条件。</p><p>数组在一定程度上是排序的，很容易分析出：可以采用二分法来寻找最小数字。</p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。<br>输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。<br>例如数组 {3, 4, 5, 1, 2} 为 {1, 2, 3, 4, 5} 的一个旋转，该数组的最小值为1。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>数组在一定程度上是排序的，很容易分析出：可以采用二分法来寻找最小数字。</p><p>但是这里面有一些陷阱：</p><ol><li><p>递增排序数组的本身是自己的旋转，则最小数字是第一个数字</p></li><li><p><strong>中间数字</strong> 与 <strong>首尾数字</strong> 大小相等，如 {1, 0, 1, 1, 1, 1} 和 {1, 1, 1, 1, 0, 1}，无法采用二分法，只能顺序查找。</p></li></ol><h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><ol><li>功能测试（正常旋转数组，中间有或者无重复数字）</li><li>边界值测试（升序数组，1个数字的数组）</li><li>特殊输入测试（null，空数组）</li></ol><h2 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinNumberInRotateArray</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> high = arr.length - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> mid = low + (high - low) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 升序数组</span></span><br><span class="line"><span class="keyword">if</span> (arr[low] &lt; arr[high])</span><br><span class="line"><span class="keyword">return</span> arr[low];</span><br><span class="line"><span class="comment">// 中间数字与首尾数字相等</span></span><br><span class="line"><span class="keyword">if</span> (arr[mid] == arr[high] &amp;&amp; arr[mid] == arr[low]) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= high; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr[i] &lt; arr[i - <span class="number">1</span>])</span><br><span class="line"><span class="keyword">return</span> arr[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> arr[low];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 正常情况</span></span><br><span class="line"><span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line"><span class="keyword">if</span> (high - low == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">mid = (low + high) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (arr[mid] &lt;= arr[high]) &#123;</span><br><span class="line">high = mid;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">low = mid;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> arr[high];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是测试代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinNumberInRotateArray</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] array = <span class="keyword">null</span>;</span><br><span class="line">System.out.println(<span class="string">"test1:"</span> + minNumberInRotateArray(array));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] array = &#123;&#125;;</span><br><span class="line">System.out.println(<span class="string">"test2:"</span> + minNumberInRotateArray(array));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] array = &#123; <span class="number">1</span> &#125;;</span><br><span class="line">System.out.println(<span class="string">"test3:"</span> + minNumberInRotateArray(array));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] array = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;;</span><br><span class="line">System.out.println(<span class="string">"test4:"</span> + minNumberInRotateArray(array));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] array = &#123; <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span> &#125;;</span><br><span class="line">System.out.println(<span class="string">"test5:"</span> + minNumberInRotateArray(array));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] array = &#123; <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span> &#125;;</span><br><span class="line">System.out.println(<span class="string">"test6:"</span> + minNumberInRotateArray(array));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] array = &#123; <span class="number">6</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;;</span><br><span class="line">System.out.println(<span class="string">"test7:"</span> + minNumberInRotateArray(array));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">MinNumberInRotateArray demo = <span class="keyword">new</span> MinNumberInRotateArray();</span><br><span class="line">demo.test1();</span><br><span class="line">demo.test2();</span><br><span class="line">demo.test3();</span><br><span class="line">demo.test4();</span><br><span class="line">demo.test5();</span><br><span class="line">demo.test6();</span><br><span class="line">demo.test7();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="牛客网优秀代码"><a href="#牛客网优秀代码" class="headerlink" title="牛客网优秀代码"></a>牛客网优秀代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minNuberInRotateArray</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> high = arr.length - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = low + (high - low) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (arr[mid] &gt; arr[high]) &#123;</span><br><span class="line">low = mid + <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] == arr[high]) &#123;</span><br><span class="line">high = high - <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">high = mid;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> arr[low];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="这段代码的细节："><a href="#这段代码的细节：" class="headerlink" title="这段代码的细节："></a>这段代码的细节：</h3><ol><li>使用low = mid + 1，而不是low = mid，最终会使得low = high（左右指针重合）而跳出循环。</li><li>使用high = mid，而不是high = mid - 1，因为mid有可能就是最小值点，不能减1。</li><li>升序数组的情况可以直接在循环中一起搞定，不用单独列出来判断。</li></ol><p>不好的地方：</p><ol><li><p>该程序在array[mid] = array[high]时直接顺序查找。但其实这还有可能可以用二分法的，除非还满足array[mid] = array[low]，才只能使用顺序查找。<br>所以可以先排除掉必须顺序查找的情况（类似自己上面的程序，提前判断掉），之后就可以直接删除else if(array[mid] == array[high]){high = high - 1;这两行了。</p></li><li><p>缺少null的判断。</p></li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>题目中给定的特殊条件一定要去关注，往往就是解法的题眼，尤其是接触到一个新的概念时，要能快速理解并考虑全面。</li><li>要注意一些特例，如递增数组的本身是自己的旋转、相同数字数组。</li><li>如果数组一定程度上是排序的，可以考虑使用二分法来解题。对于数组的方法（如二分法等），可以用low、high、mid或者left、right、mid来表示左右指针，也即数组下标。</li></ol><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="剑指Offer" scheme="https://www.blogs.rhsphere.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="BinarySearch" scheme="https://www.blogs.rhsphere.com/tags/BinarySearch/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer(10) 斐波那契数列及青蛙跳台阶问题</title>
    <link href="https://www.blogs.rhsphere.com/2019/04/16/fibonacci.html"/>
    <id>https://www.blogs.rhsphere.com/2019/04/16/fibonacci.html</id>
    <published>2019-04-16T06:46:10.000Z</published>
    <updated>2019-10-08T15:36:02.798Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><h1 id="递归和循环"><a href="#递归和循环" class="headerlink" title="递归和循环"></a>递归和循环</h1><p>如果我们需要重复地多次计算相同的问题，则通常可以选择用递归或循环两种不同的方法。 递归就是把问题层层分解，直到程序出口处。而循环则是通过设置计算的初始值及终止条件，在一个范围内重复运算。</p><p>递归虽然有简洁的优点，但它同时也有显著的缺点。递归由于是函数调用自身，而函数调用是有时间和空间的消耗的：每一次函数调用，都需要在内存栈中分配空间以保存参数、返回地址及临时变量，而且往栈里压入数据和弹出数据都需要时间。<br>另外，递归中有可能很多计算都是重复的，从而对性能带来很大的负面影响。递归的本质是把一个问题分解成两个或者多个小问题。如果多个小问题存在相互重叠的部分，就存在重复的计算。</p><p>通常应用动态规划解决问题时，我们都是用递归的思路分析问题，但由于递归分解的子问题中存在大量的重复，因此我们总是用自上而下的循环来实现代码。</p><p>除了效率，递归还有可能引起更严重的问题：调用栈溢出。每一次函数调用在内存栈中分配空间，而每个进程的栈的容量是有限的。当递归调用层级太多时，就会超出栈的容量，从而导致调用栈溢出。</p><h1 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>如果直接写递归函数，由于会出现很多重复计算，效率非常底，不采用。</p><p>要避免重复计算，采用从下往上计算，可以把计算过了的保存起来，下次要计算时就不必重复计算了：先由f(0)和f(1)计算f(2)，再由f(1)和f(2)计算f(3)……以此类推就行了，计算第n个时，只要保存第n-1和第n-2项就可以了。</p><h2 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h2><ol><li>功能测试（3，5，8等）</li><li>边界值测试（0，1，2等）</li><li>性能测试（50，100等）</li><li>特殊（负数）</li></ol><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><p>时间复杂度为O(n)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fibonacci</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">Fib</span><span class="params">(<span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"下标错误，应从0开始！"</span>);</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">long</span> prePre = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">long</span> pre = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">long</span> result = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">result = prePre + pre;</span><br><span class="line">prePre = pre;</span><br><span class="line">pre = result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 附：缩略版（考虑到代码的可读性，其实还是上面的方法比较好）</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">Fib2</span><span class="params">(<span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"下标错误，应从0开始！"</span>);</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">long</span> pre = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">long</span> result = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">result += pre;</span><br><span class="line">pre = result - pre;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Fibonacci demo = <span class="keyword">new</span> Fibonacci();</span><br><span class="line">System.out.println(demo.Fib(<span class="number">0</span>));</span><br><span class="line">System.out.println(demo.Fib(<span class="number">1</span>));</span><br><span class="line">System.out.println(demo.Fib(<span class="number">2</span>));</span><br><span class="line">System.out.println(demo.Fib(<span class="number">8</span>));</span><br><span class="line">System.out.println(demo.Fib(<span class="number">50</span>));</span><br><span class="line">System.out.println(demo.Fib(<span class="number">100</span>));</span><br><span class="line">System.out.println(demo.Fib(-<span class="number">5</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="牛客网提交"><a href="#牛客网提交" class="headerlink" title="牛客网提交"></a>牛客网提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] result = &#123;<span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> result[n];</span><br><span class="line">        <span class="keyword">int</span> fib1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> fib2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> fibN = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;=n; i++) &#123;</span><br><span class="line">            fibN = fib1 + fib2;</span><br><span class="line">            fib1 = fib2;</span><br><span class="line">            fib2 = fibN;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fibN;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="青蛙跳台阶问题"><a href="#青蛙跳台阶问题" class="headerlink" title="青蛙跳台阶问题"></a>青蛙跳台阶问题</h1><h2 id="题目1"><a href="#题目1" class="headerlink" title="题目1"></a>题目1</h2><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p><p>　　将跳法总数记为f(n)，可以知道f(1)=1，f(2)=2。<br>当n&gt;2时，第一次跳1级的话，还有f(n-1)种跳法；第一次跳2级的话，还有f(n-2)种跳法，所以可以推得f(n)=f(n-1)+f(n-2)，即为斐波那契数列。</p><h2 id="题目2"><a href="#题目2" class="headerlink" title="题目2"></a>题目2</h2><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p><p>解法1：</p><p>　　当n=1时，f(1)=1。</p><p>　　当n大于1时，归纳总结可知：跳上n级台阶，第一次跳1级的话，有f(n-1)种方法；第一次跳2级的话，有f(n-2)种方法……第一次跳n-1级的话，有f(1)种方法；直接跳n级的话，有1种方法，所以可以得到如下公式：</p><p>　　f(n) = f(n-1)+f(n-2)+……f(1)+1　　（n≥2）</p><p>　　f(n-1) = f(n-2)+f(n-3)+…..f(1)+1　　（n&gt;2）</p><p>　　由上面两式相减可得，f(n)-f(n-1)=f(n-1)，即f(n) = 2*f(n-1)  (n&gt;2)</p><p>　　最终结合f(1)和f(2)，可以推得：f(n)=2^(n-1)</p><p>解法2：</p><p>　　假设跳到第n级总共需要k次，说明要在中间n-1级台阶中选出任意k-1个台阶，即C(n-1,k-1)种方法。</p><p>　　所以：跳1次就跳上n级台阶，需要C(n-1,0)种方法；跳2次需要C(n-1,1)种方法……跳n次需要C(n-1,n-1)种方法</p><p>　　总共需要跳C(n-1,0)+C(n-1,1)+C(n-1,2)+……C(n-1,n-1)=2^(n-1)种方法。</p><p>解法3：</p><p>　　除了必须到达最后一级台阶，第1级到第n-1级台阶都可以有选择的跳，也就是说对于这n-1个台阶来说，每个台阶都有跳上和不跳上2种情况，所以一共有2^(n-1)种方法。</p><h1 id="矩形覆盖问题"><a href="#矩形覆盖问题" class="headerlink" title="矩形覆盖问题"></a>矩形覆盖问题</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>用n个2 · 1的小矩形无重叠地覆盖一个2 · n的大矩形，总共有多少种方法？</p><p>当n = 1时，有一种方法。</p><p>当n = 2时，有两种方法。</p><p>当n &gt;= 3时，和斐波那契数列类似。第一步竖着放，有f(n-1)种方法；第一步横着放，有f(n-2)种方法。所以f(n)=f(n-1)+f(n-2)。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><p>求n次方时，可以利用递归来降低时间复杂度</p></li><li><p>当遇到涉及n的问题时（类似青蛙跳台阶问题），不要紧张，可以进行归纳分析，特别注意f(n)与f(n-1)、f(n-2)等的关联，从而找出规律，进行合理建模。</p></li><li><p>return (int)Math.pow(2,target-1);</p></li></ol><p>　　1) 转int类型</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="剑指Offer" scheme="https://www.blogs.rhsphere.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="fibonacci" scheme="https://www.blogs.rhsphere.com/tags/fibonacci/"/>
    
  </entry>
  
  <entry>
    <title>二分查找</title>
    <link href="https://www.blogs.rhsphere.com/2019/04/15/binary-search.html"/>
    <id>https://www.blogs.rhsphere.com/2019/04/15/binary-search.html</id>
    <published>2019-04-15T06:44:23.000Z</published>
    <updated>2019-08-02T02:25:36.782Z</updated>
    
    <content type="html"><![CDATA[<p class="description">查找不外乎顺序查找、二分查找、哈希表查找和二叉排序树查找。 二分查找是一个基础的算法，也是面试中常考的一个知识点。二分查找就是将查找的键和子数组的中间键作比较，如果被查找的键小于中间键，就在左子数组继续查找；如果大于中间键，就在右子数组中查找，否则中间键就是要找的元素。</p><a id="more"></a><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>如果题目中要求在排序的数组（或者部分排序的数组）中查找一个数字或者统计某个数字出现的次数，那么都可以尝试用二分查找算法。<br>哈希表和二叉树炸找的重点在于考查对应的数据结构而不是算法。</p><h3 id="二分查找代码"><a href="#二分查找代码" class="headerlink" title="二分查找代码"></a>二分查找代码</h3><p>每次移动left和right指针的时候，需要在mid的基础上+1或者-1， 防止出现死循环， 程序也就能够正确的运行。</p><p>注意：代码中的判断条件必须是while (left &lt;= right)，否则的话判断条件不完整，比如：array[3] = {1, 3, 5};待查找的键为5，此时在(low &lt; high)条件下就会找不到，因为low和high相等时，指向元素5，但是此时条件不成立，没有进入while()中。</p><figure class="highlight java"><figcaption><span>二分查找</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二分查找，找到该值在数组中的下标，否则为-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 这里必须是 &lt;=</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] == key) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &lt; key) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二分查找的变种"><a href="#二分查找的变种" class="headerlink" title="二分查找的变种"></a>二分查找的变种</h2><p>关于二分查找，如果条件稍微变换一下，比如：数组之中的数据可能可以重复，要求返回匹配的数据的最小（或最大）的下标；更近一步， 需要找出数组中第一个大于key的元素（也就是最小的大于key的元素的）下标，等等。 这些，虽然只有一点点的变化，实现的时候确实要更加的细心。</p><p>二分查找的变种和二分查找原理一样，主要就是变换判断条件（也就是边界条件），如果想直接看如何记忆这些变种的窍门，请直接翻到本文最后。下面来看几种二分查找变种的代码：</p><h3 id="查找第一个与key相等的元素"><a href="#查找第一个与key相等的元素" class="headerlink" title="查找第一个与key相等的元素"></a>查找第一个与key相等的元素</h3><p>查找第一个相等的元素，也就是说等于查找key值的元素有好多个，返回这些元素最左边的元素下标。</p><p><strong>当执行到right == left == mid后，此时会执行，if的 if (arr[mid] &gt;= key) 分支，于是right = left - 1，于是跳出while循环，所以最后时 left是 arr[key]最有左边的值，而right正好卡在left左边。</strong></p><figure class="highlight java"><figcaption><span>查找第一个相等的元素</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findFirstEqual</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &gt;= key) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; arr.length &amp;&amp; arr[left] == key) &#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查找最后一个与key相等的元素"><a href="#查找最后一个与key相等的元素" class="headerlink" title="查找最后一个与key相等的元素"></a>查找最后一个与key相等的元素</h3><p>查找最后一个相等的元素，也就是说等于查找key值的元素有好多个，返回这些元素最右边的元素下标。</p><p><strong>根据上面的分析，left == right == mid 的时候，left = mid + 1，于是left卡在了right右边，所以应该返回right值。</strong></p><figure class="highlight java"><figcaption><span>查找最后一个与key相等的元素</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findLastEqual</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = arr.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &lt;= key) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (right &gt;= <span class="number">0</span> &amp;&amp; arr[right] == key) &#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查找最后一个等于或小于key的元素"><a href="#查找最后一个等于或小于key的元素" class="headerlink" title="查找最后一个等于或小于key的元素"></a>查找最后一个等于或小于key的元素</h3><p>查找最后一个等于或小于key的元素，也就是说等于查找key值的元素有好多个，返回这些元素最右边的元素下标；如果没有等于key值的元素，则返回小于key的最右边元素下标。</p><figure class="highlight java"><figcaption><span>查找最后一个等于或小于key的元素</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findLastEqualSmaller</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &gt; key) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查找最后一个小于key的元素"><a href="#查找最后一个小于key的元素" class="headerlink" title="查找最后一个小于key的元素"></a>查找最后一个小于key的元素</h3><p>查找最后一个小于key的元素，也就是说返回小于key的最右边元素下标。</p><figure class="highlight java"><figcaption><span>返回最后一个小于key的元素</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findLastSmaller</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &gt;= key) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查找第一个等于或者大于key的元素"><a href="#查找第一个等于或者大于key的元素" class="headerlink" title="查找第一个等于或者大于key的元素"></a>查找第一个等于或者大于key的元素</h3><p>查找第一个等于或者大于key的元素，也就是说等于查找key值的元素有好多个，返回这些元素最左边的元素下标；如果没有等于key值的元素，则返回大于key的最左边元素下标。</p><figure class="highlight java"><figcaption><span>查找第一个大于等于key的元素</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findFirstEqualLarger</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> rigth = arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &gt;= key) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查找第一个大于key的元素"><a href="#查找第一个大于key的元素" class="headerlink" title="查找第一个大于key的元素"></a>查找第一个大于key的元素</h3><p>查找第一个等于key的元素，也就是说返回大于key的最左边元素下标。</p><figure class="highlight java"><figcaption><span>查找第一个大于key的元素</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findFirstLarger</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &gt; key) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二分查找变种总结"><a href="#二分查找变种总结" class="headerlink" title="二分查找变种总结"></a>二分查找变种总结</h2><figure class="highlight java"><figcaption><span>二分查找核心</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (arr[mid] ? key) &#123;</span><br><span class="line">        <span class="comment">//...right = mid - 1;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//...left = mid + 1;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> xxx;</span><br></pre></td></tr></table></figure><h3 id="首先判断出返回left，还是right"><a href="#首先判断出返回left，还是right" class="headerlink" title="首先判断出返回left，还是right"></a>首先判断出返回left，还是right</h3><p>因为最后跳出 while (left &lt;= right) 循环条件是 right &lt; left 且 right = left - 1。最后right和left一定卡在“边界值”的左右两边，如果比较值是key，查找小于等于（或是小于）key的元素，则边界值就是等于key的所有元素的最左边那个，其实应该返回left。</p><h3 id="判断出比较符号"><a href="#判断出比较符号" class="headerlink" title="判断出比较符号"></a>判断出比较符号</h3><figure class="highlight java"><figcaption><span>二分查找判断符号</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (arr[mid] ? key) &#123;</span><br><span class="line">    <span class="comment">//...right = mid - 1;</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//...left = mid + 1;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是这里的if (array[mid] ? key) 中的判断符号，结合步骤1和给出的条件，如果是查找小于等于key的元素，则知道应该使用判断符号&gt;=，因为是要返回left，所以如果array[mid]等于或者大于key，就应该使用&gt;=，以下是完整代码</p><figure class="highlight java"><figcaption><span>查找小于等于key的元素</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (arr[mid] &gt;= key) &#123;</span><br><span class="line">    right = mid - <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    left = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;查找不外乎顺序查找、二分查找、哈希表查找和二叉排序树查找。 二分查找是一个基础的算法，也是面试中常考的一个知识点。二分查找就是将查找的键和子数组的中间键作比较，如果被查找的键小于中间键，就在左子数组继续查找；如果大于中间键，就在右子数组中查找，否则中间键就是要找的元素。&lt;/p&gt;
    
    </summary>
    
      <category term="Search" scheme="https://www.blogs.rhsphere.com/categories/Search/"/>
    
    
      <category term="BinarySearch" scheme="https://www.blogs.rhsphere.com/tags/BinarySearch/"/>
    
      <category term="search" scheme="https://www.blogs.rhsphere.com/tags/search/"/>
    
  </entry>
  
  <entry>
    <title>排序总结</title>
    <link href="https://www.blogs.rhsphere.com/2019/04/10/sort-summary.html"/>
    <id>https://www.blogs.rhsphere.com/2019/04/10/sort-summary.html</id>
    <published>2019-04-10T01:28:28.000Z</published>
    <updated>2019-06-08T02:17:22.007Z</updated>
    
    <content type="html"><![CDATA[<p class="description">排序算法可以说是一项基本功，解决实际问题中经常遇到，针对实际数据的特点选择合适的排序算法可以使程序获得更高的效率，有时候排序的稳定性还是实际问题中必须考虑的，这篇博客对常见的排序算法进行整理，包括：选择排序、插入排序、希尔排序、冒泡排序、鸡尾酒排序、归并排序、快速排序、堆排序、计数排序、桶排序、基数排序(代码略)。</p><a id="more"></a><h2 id="十大经典排序算法"><a href="#十大经典排序算法" class="headerlink" title="十大经典排序算法"></a>十大经典排序算法</h2><p><img src="https://s2.ax1x.com/2019/03/12/AiBfNd.png" alt="Picture"></p><h2 id="比较和非比较排序"><a href="#比较和非比较排序" class="headerlink" title="比较和非比较排序"></a>比较和非比较排序</h2><h3 id="比较排序"><a href="#比较排序" class="headerlink" title="比较排序"></a>比较排序</h3><p>常见的快速排序、归并排序、堆排序、冒泡排序等排序算法属于比较排序，在排序的最终结果里，元素之间的次序依赖于它们之间的比较。每个数都必须和其他数进行比较，才能确定自己的位置。在冒泡排序之类的排序中，问题规模为n，又因为需要比较n次，所以平均时间复杂度为O(n²)。在归并排序、快速排序之类的排序中，问题规模通过分治法消减为logN次，所以时间复杂度平均O(nlogn)。<br>比较排序的优势是，适用于各种规模的数据，也不在乎数据的分布，都能进行排序。可以说，比较排序适用于一切需要排序的情况。</p><h3 id="非比较排序"><a href="#非比较排序" class="headerlink" title="非比较排序"></a>非比较排序</h3><p>计数排序、基数排序、桶排序则属于非比较排序。因为数据本身包含了定位特征，所有才能不通过比较来确定元素的位置。<br>非比较排序是通过确定每个元素之前，应该有多少个元素来排序。针对数组arr，计算arr之前有多少个元素，则唯一确定了arr在排序后数组中的位置。<br>非比较排序只要确定每个元素之前的已有的元素个数即可，所以一次遍历即可解决。算法时间复杂度O(n)。<br>非比较排序时间复杂度低，但由于非比较排序需要占用空间来确定唯一位置。所以对数据规模和数据分布有一定的要求。</p><h3 id="比较排序时间复杂度证明"><a href="#比较排序时间复杂度证明" class="headerlink" title="比较排序时间复杂度证明"></a>比较排序时间复杂度证明</h3><p>比较排序的时间复杂度通常为O(n²)或者O(nlogn)，比较排序的时间复杂度下界就是O(nlogn)，而非比较排序的时间复杂度可以达到O(n)，但是都需要额外的空间开销。</p><p>比较排序时间复杂度为O(nlogn)的证明：</p><p>a1, a2, a3, ……, an数列的所有排序有n!种，所以满足要求的排序a1’, a2’, a3’, ……, an’（其中a1’&lt;=a2’&lt;=a3’……&lt;=an’）的概率为1/n!。<br>基于输入元素的比较排序，每一次比较的返回不是0就是1，这恰好可以作为决策树的一个决策将一个事件分成两个分支。<br>比如冒泡排序时通过比较a1和a2两个数的大小，可以把序列分成a1, a2, ……, an与a2, a1, ……, an（气泡a2上升一个身位）两种不同的结果，因此比较排序也可以构造决策树。根节点代表原始序列a1, a2, a3, ……, an，所有叶子节点都是这个序列的重排（共有n!个，其中有一个就是我们排序的结果a1’, a2’, a3’, ……, an’）。<br>如果每次比较的结果都是等概率的话（恰好划分为概率空间相等的两个事件），那么二叉树就是高度平衡的，深度至少是log(n!)。</p><p>又因为：</p><ol><li><p>n! &lt; n^n ，两边取对数就得到log(n!) &lt; nlog(n)，所以 log(n!) = O(nlogn)。</p></li><li><p>n! = n(n-1)(n-2)(n-3)…1 &gt; (n/2)^(n/2) 两边取对数得到 log(n!) &gt; (n/2)log(n/2) = Ω(nlogn)，所以 log(n!) = Ω(nlogn)。</p></li></ol><p>因此log(n!)的增长速度与 nlogn 相同，即 log(n!) = Θ(nlogn)，这就是通用排序算法的最低时间复杂度为 O(nlogn) 的依据。</p><h2 id="排序稳定性和复杂度"><a href="#排序稳定性和复杂度" class="headerlink" title="排序稳定性和复杂度"></a>排序稳定性和复杂度</h2><h3 id="不稳定"><a href="#不稳定" class="headerlink" title="不稳定"></a>不稳定</h3><p>选择排序 （Selection Sort）— O(n²)</p><p>希尔排序 （Shell Sort）— O(nlogn)</p><p>快速排序 （Quick Sort）— O(nlogn) 平均时间， O(n²)最坏情况;对于大的、乱序串列一般认为是最快的已知排序。</p><p>堆排序  （Heap Sort）— O(nlogn)</p><p>基数排序 （Radix Sort）— O(n·k); 需要 O(n) 额外存储空间 （K为特征个数）</p><h3 id="稳定"><a href="#稳定" class="headerlink" title="稳定"></a>稳定</h3><p>插入排序 （Insertion Sort）— O(n²)</p><p>冒泡排序 （Bubble Sort） — O(n²)</p><p>归并排序 （Merge Sort）— O(nlogn); 需要 O(n) 额外存储空间</p><p>二叉树排序（Binary Tree Sort） — O(nlogn); 需要 O(n) 额外存储空间</p><p>计数排序  (Counting Sort) — O(n+k); 需要 O(n+k) 额外存储空间，k为序列中 Max-Min+1</p><p>桶排序 （Bucket Sort）— O(n); 需要 O(k) 额外存储空间</p><h2 id="10种排序的原理和实现-基数排序和二叉树排序暂无"><a href="#10种排序的原理和实现-基数排序和二叉树排序暂无" class="headerlink" title="10种排序的原理和实现(基数排序和二叉树排序暂无)"></a>10种排序的原理和实现(基数排序和二叉树排序暂无)</h2><h3 id="选择排序（Selection-Sort）"><a href="#选择排序（Selection-Sort）" class="headerlink" title="选择排序（Selection Sort）"></a><a href="https://blogs.rhsphere.com/leetcode/2019/04/01/selection-sort.html" target="_blank" rel="noopener">选择排序（Selection Sort）</a></h3><p>选择排序的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p><p>遍历数组，遍历到i时，a0, a1, …, ai-1是已经排好序的，然后从i到n选择出最小的，记录下位置，如果不是第i个，则和第i个元素交换。此时第i个元素可能会排到相等元素之后，造成排序的不稳定。</p><h4 id="选择排序实现部分"><a href="#选择排序实现部分" class="headerlink" title="选择排序实现部分"></a>选择排序实现部分</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; = <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> currentMin;</span><br><span class="line">    <span class="keyword">int</span> currentMinIndex;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//  找到最小值和最小值下标位置，在范围arr[i  ... arr.length-1]</span></span><br><span class="line">        currentMin = arr[i];</span><br><span class="line">        currentMinIndex = i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (currentMin &gt; arr[j]) &#123;</span><br><span class="line">                currentMin = arr[j];</span><br><span class="line">                currentMindIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (currentMinIndex != i) &#123;</span><br><span class="line">            arr[currentMinIndex] = arr[i];</span><br><span class="line">            arr[i] = currentMin;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入排序（Insertion-Sort）"><a href="#插入排序（Insertion-Sort）" class="headerlink" title="插入排序（Insertion Sort）"></a><a href="https://blogs.rhsphere.com/leetcode/2019/04/01/insertion-sort.html" target="_blank" rel="noopener">插入排序（Insertion Sort）</a></h3><p>插入排序的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p><p>遍历数组，遍历到i时，a0,a1…ai-1是已经排好序的，取出ai，从ai-1开始向前和每个比较大小，如果小于，则将此位置元素向后移动，继续先前比较，如果不小于，则放到正在比较的元素之后。</p><p>可见相等元素比较是，原来靠后的还是排在后边，所以插入排序是稳定的。<br>当待排序的数据基本有序时，插入排序的效率比较高，只需要进行很少的数据移动。</p><h4 id="插入排序实现部分"><a href="#插入排序实现部分" class="headerlink" title="插入排序实现部分"></a>插入排序实现部分</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 插入arr[i]到已经排好序的子线性表arr[0 ... i-1]中</span></span><br><span class="line">        <span class="keyword">int</span> currentElement = arr[i];</span><br><span class="line">        <span class="keyword">int</span> k;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (k = i - <span class="number">1</span>; k &gt;= <span class="number">0</span> &amp;&amp; arr[k] &gt; currentElement; k--) &#123;</span><br><span class="line">            arr[k+<span class="number">1</span>] = arr[k];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  插入当前元素到arr[k+1]中</span></span><br><span class="line">        arr[k + <span class="number">1</span>] = currentElement;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="希尔排序（Shell-Sort）"><a href="#希尔排序（Shell-Sort）" class="headerlink" title="希尔排序（Shell Sort）"></a><a href="https://blogs.rhsphere.com/leetcode/2019/04/01/shell-sort.html" target="_blank" rel="noopener">希尔排序（Shell Sort）</a></h3><p>希尔排序又叫缩小增量排序，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。</p><p>希尔排序是对插入排序的优化，基于以下两个认识：1.数据量较小时插入排序速度较快，因为n和n²差距很小；2.数据基本有序时插入排序效率很高，因为比较和移动的数据量少。</p><p>因此，希尔排序的基本思想是，将需要排序的序列划分成为若干个较小的子序列，对子序列进行插入排序，通过插入排序能够使得原来序列成为基本有序。这样通过对较小的序列进行插入排序，然后对基本有序的数列进行插入排序，能够提高插入排序算法的效率。</p><p>希尔排序的划分子序列不是像归并排序那种的二分，而是采用的叫做增量的技术，例如有十个元素的数组进行希尔排序，首先选择增量为10/2=5，此时第1个元素和第（1+5）个元素配对成子序列使用插入排序进行排序，第2和（2+5）个元素组成子序列，完成后增量继续减半为2，此时第1个元素、第（1+2）、第（1+4）、第（1+6）、第（1+8）个元素组成子序列进行插入排序。这种增量选择方法的好处是可以使数组整体均匀有序，尽可能的减少比较和移动的次数。<br>二分法中即使前一半数据有序，后一半中如果有比较小的数据，还是会造成大量的比较和移动，因此这种增量的方法和插入排序的配合更佳。</p><p>希尔排序的时间复杂度和增量的选择策略有关，上述增量方法造成希尔排序的不稳定性。</p><h4 id="希尔排序实现部分"><a href="#希尔排序实现部分" class="headerlink" title="希尔排序实现部分"></a>希尔排序实现部分</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] shellSort(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> gap = arr.length / <span class="number">2</span>; gap &gt;= <span class="number">1</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// 对子序列插入排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i;</span><br><span class="line">            <span class="keyword">int</span> currentElement = arr[i];</span><br><span class="line">            <span class="keyword">while</span> (j - gap &gt;= <span class="number">0</span> &amp;&amp; arr[j - gap] &gt; currentElement) &#123;</span><br><span class="line">                arr[j] = arr[j - gap];</span><br><span class="line">                j -= gap;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j] = currentElement;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="冒泡排序（Bubble-Sort）"><a href="#冒泡排序（Bubble-Sort）" class="headerlink" title="冒泡排序（Bubble Sort）"></a><a href="https://blogs.rhsphere.com/leetcode/2019/04/01/bubble-sort.html" target="_blank" rel="noopener">冒泡排序（Bubble Sort）</a></h3><p>冒泡排序，重复地走访要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 </p><p>冒泡排序的名字很形象，实际实现是相邻两节点进行比较，大的向后移一个，经过第一轮两两比较和移动，最大的元素移动到了最后，第二轮次大的位于倒数第二个，依次进行。这是最基本的冒泡排序，还可以进行一些优化。<br>优化一：如果某一轮两两比较中没有任何元素交换，这说明已经都排好序了，算法结束，可以使用一个isSorted做标记，默认为true，如果发生交换则置为false，每轮结束时检测isSorted，如果为false则继续，如果为true则返回。<br>优化二：某一轮结束位置为j，但是这一轮的最后一次交换发生在lastExchangedIndex的位置，则lastExchangedIndex到j之间是排好序的，下一轮的结束点就不必是j–了，而直接到lastExchangedIndex即可。</p><h4 id="优化一实现"><a href="#优化一实现" class="headerlink" title="优化一实现"></a>优化一实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> isSorted = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                tmp = arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = tmp;</span><br><span class="line"></span><br><span class="line">                isSorted = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isSorted) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="优化二实现"><a href="#优化二实现" class="headerlink" title="优化二实现"></a>优化二实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//记录最后一次交换的位置</span></span><br><span class="line">    <span class="keyword">int</span> lastExchangedIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//无序数列的边界，每次比较只需要比到这里为止        </span></span><br><span class="line">    <span class="keyword">int</span> sortBorder = arr.length - <span class="number">1</span>;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="comment">//有序标记，每一轮的初始是true</span></span><br><span class="line">        <span class="keyword">boolean</span> isSorted = <span class="keyword">true</span>;    </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; sortBorder; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                tmp = arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = tmp;</span><br><span class="line">                <span class="comment">//有元素交换，所以不是有序，标记变为false</span></span><br><span class="line">                isSorted = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//把无序数列的边界更新为最后一次交换元素的位置</span></span><br><span class="line">                lastExchangedIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sortBorder = lastExchangedIndex;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isSorted) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="鸡尾酒排序（Cocktail-Sort）"><a href="#鸡尾酒排序（Cocktail-Sort）" class="headerlink" title="鸡尾酒排序（Cocktail Sort）"></a><a href="https://blogs.rhsphere.com/leetcode/2019/04/01/cock-tail-sort.html" target="_blank" rel="noopener">鸡尾酒排序（Cocktail Sort）</a></h3><p>回顾冒泡排序的思想：<br>冒泡排序的每一个元素都可以像一个小气泡一样，根据自身大小，一点一点向着数组的一侧移动。算法的每一轮都是 <strong>从左到右比较元素，进行单向的位置交换</strong>。<br>那么鸡尾酒排序做了怎样的优化呢？<br>鸡尾酒排序的元素比较和交换过程是 <strong>双向的</strong>。 </p><h4 id="鸡尾酒排序代码实现"><a href="#鸡尾酒排序代码实现" class="headerlink" title="鸡尾酒排序代码实现"></a>鸡尾酒排序代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cockTailSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> lastRightExchangedIndex = <span class="number">0</span>;    <span class="comment">//记录右侧最后一次交换的位置</span></span><br><span class="line">    <span class="keyword">int</span> lastLeftExchangedIndex = <span class="number">0</span>;    <span class="comment">//记录左侧最后一次交换的位置 </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//无序数列的右边界，每次比较只需要比到这里为止</span></span><br><span class="line">    <span class="keyword">int</span> rigthSortBorder = arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//无序数列的左边界，每次比较只需要比到这里为止</span></span><br><span class="line">    <span class="keyword">int</span> leftSortBorder = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length / <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> isSorted = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//奇数轮，从左向右比较和交换</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = leftSortBorder; j &lt; rigthSortBorder; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                tmp = arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = tmp;</span><br><span class="line"></span><br><span class="line">                isSorted = <span class="keyword">false</span>;</span><br><span class="line">                lastRightExchangedIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        rigthSortBorder = lastRightExchangedIndex;</span><br><span class="line">        <span class="keyword">if</span> (isSorted) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        isSorted = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//偶数轮，从右向左比较和交换</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = rigthSortBorder; j &gt; leftSortBorder; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                tmp = arr[j];</span><br><span class="line">                arr[j] = arr[j - <span class="number">1</span>];</span><br><span class="line">                arr[j - <span class="number">1</span>] = tmp;</span><br><span class="line"></span><br><span class="line">                isSorted = <span class="keyword">false</span>;</span><br><span class="line">                lastLeftExchangedIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        leftSortBorder = lastLeftExchangedIndex;</span><br><span class="line">        <span class="keyword">if</span> (isSorted) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="归并排序（Merge-Sort）"><a href="#归并排序（Merge-Sort）" class="headerlink" title="归并排序（Merge Sort）"></a><a href="https://blogs.rhsphere.com/leetcode/2019/04/01/merge-sort.html" target="_blank" rel="noopener">归并排序（Merge Sort）</a></h3><p>归并排序是采用分治法（Divide and Conquer）的一个非常典型的应用。<br>将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。</p><p>首先考虑下如何将二个有序数列合并。这个非常简单，只要从比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可。这需要将待排序序列中的所有记录扫描一遍，因此耗费O(n)时间，而由完全二叉树的深度可知，整个归并排序需要进行 logn次，因此，总的时间复杂度为O(nlogn)。</p><p>归并排序在归并过程中需要与原始记录序列同样数量的存储空间存放归并结果，因此空间复杂度为O(n)。<br>归并算法需要两两比较，不存在跳跃，因此归并排序是一种稳定的排序算法。 </p><h4 id="归并排序实现"><a href="#归并排序实现" class="headerlink" title="归并排序实现"></a>归并排序实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//  取中间的数进行拆分</span></span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//  左边的数不断进行拆分</span></span><br><span class="line">        mergeSort(arr, left, mid);</span><br><span class="line">        <span class="comment">//  右边的数不断进行拆分</span></span><br><span class="line">        mergeSort(arr, mid + <span class="number">1</span>, right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 合并</span></span><br><span class="line">        merge(arr, left, mid + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] leftArray = <span class="keyword">new</span> <span class="keyword">int</span>[mid - left];</span><br><span class="line">    <span class="keyword">int</span>[] rightArray = <span class="keyword">new</span> <span class="keyword">int</span>[right - mid + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt; mid; i++) &#123;</span><br><span class="line">        leftArray[i - left] = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = mid; i &lt;= right; i++) &#123;</span><br><span class="line">        rightArray[i - mid] = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> k = left;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; leftArray.length &amp;&amp; j &lt; rightArray.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (leftArray[i] &lt; rightArray[j]) &#123;</span><br><span class="line">            arr[k++] = leftArray[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            arr[k++] = rigthArray[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; leftArray.length) &#123;</span><br><span class="line">        arr[k++] = leftArray[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; rightArray.length) &#123;</span><br><span class="line">        arr[k++] = rigthArray[j++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快速排序（Quick-Sort）"><a href="#快速排序（Quick-Sort）" class="headerlink" title="快速排序（Quick Sort）"></a><a href="https://blogs.rhsphere.com/leetcode/2019/04/01/quick-sort.html" target="_blank" rel="noopener">快速排序（Quick Sort）</a></h3><p>快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。其中，最重要的partition主要有两种方法：<br>A.先把选定为pivot的元素放到最后，然后设定指针low和指针high，low指针左移，high指针右移，当两个指针相撞后停止移动。期间如果符合交换条件，两元素交换。最后把pivot元素放到中间。<br>B.类似冒泡排序的思路，把比pivot大的元素“往下沉”，把比pivot小的元素“往上浮”。<br><strong>快速排序是目前被认为最好的一种内部排序方法。快速排序算法处理的最好情况指每次都是将待排序数列划分为均匀的两部分，通常认为快速排序的平均时间复杂度是O(nlogn)。</strong></p><p><strong>但是，快速排序的最差情况就是基本逆序或者基本有序的情况，那么此时快速排序将蜕化成冒泡排序，其时间复杂度为O(n^2)</strong></p><h4 id="快排实现（挖坑法）"><a href="#快排实现（挖坑法）" class="headerlink" title="快排实现（挖坑法）"></a>快排实现（挖坑法）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//递归结束条件</span></span><br><span class="line">    <span class="keyword">if</span> (startIndex &gt;= endIndex) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 得到基准元素位置</span></span><br><span class="line">    <span class="keyword">int</span> pivotIndex = partition(arr, startIndex, endIndex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用分治法递归数列两部分</span></span><br><span class="line">    quickSort(arr, startIndex, pivotIndex - <span class="number">1</span>);</span><br><span class="line">    quickSort(arr, startIndex + <span class="number">1</span>, endIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 取第一个位置的元素作为基准元素</span></span><br><span class="line">    <span class="keyword">int</span> pivot = arr[startIndex];</span><br><span class="line">    <span class="keyword">int</span> left = startIndex;</span><br><span class="line">    <span class="keyword">int</span> right = endIndex;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 坑的位置，初始等于pivot的位置</span></span><br><span class="line">    <span class="keyword">int</span> index = startIndex;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 大循环左右指针重合或者指针交换时结束</span></span><br><span class="line">    <span class="keyword">while</span> (right &gt;= left) &#123;</span><br><span class="line">        <span class="comment">// right指针从右向左进行比较</span></span><br><span class="line">        <span class="keyword">while</span> (right &gt;= left) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[right] &lt; pivot) &#123;</span><br><span class="line">                arr[left] = arr[right];</span><br><span class="line">                index = right;</span><br><span class="line">                left++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//left指针从左向右进行比较</span></span><br><span class="line">        <span class="keyword">while</span> (right &gt;= left) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[left] &gt; pivot) &#123;</span><br><span class="line">                arr[right] = arr[left];</span><br><span class="line">                index = left;</span><br><span class="line">                right--;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[index] = pivot;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="快排实现（指针交换法）"><a href="#快排实现（指针交换法）" class="headerlink" title="快排实现（指针交换法）"></a>快排实现（指针交换法）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (startIndex &gt;= endIndex) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 得到基准信息</span></span><br><span class="line">    <span class="keyword">int</span> pivotIndex = partition(arr, startIndex, endIndex);</span><br><span class="line">    <span class="comment">//根据基准元素，分成两部分进行递归</span></span><br><span class="line">    quickSort(arr, startIndex, pivotIndex - <span class="number">1</span>);</span><br><span class="line">    quickSort(arr, pivotIndex + <span class="number">1</span>, endIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 取第一个元素作为基准元素</span></span><br><span class="line">    <span class="keyword">int</span> pivot = arr[startIndex];</span><br><span class="line">    <span class="keyword">int</span> left = startIndex;</span><br><span class="line">    <span class="keyword">int</span> right = endIndex;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left != right) &#123;</span><br><span class="line">        <span class="comment">// 控制right指针比较并左移</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; arr[right] &gt; pivot) &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 控制left指针比较并左移</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; arr[left] &lt;= pivot) &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 交换left和right指向的元素</span></span><br><span class="line">        <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = arr[left];</span><br><span class="line">            arr[left] = arr[right];</span><br><span class="line">            arr[right] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// pivot和指针重合交换</span></span><br><span class="line">    <span class="keyword">int</span> tmp = arr[left];</span><br><span class="line">    arr[left] = arr[startIndex];</span><br><span class="line">    arr[startIndex] = tmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="单边循环法"><a href="#单边循环法" class="headerlink" title="单边循环法"></a>单边循环法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (startIndex &gt;= endIndex) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> pivotIndex = partition(arr, startIndex, endIndex);</span><br><span class="line">    quickSort(arr, startIndex, pivotIndex - <span class="number">1</span>);</span><br><span class="line">    quickSort(arr, pivotIndex + <span class="number">1</span>, endIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot = arr[startIndex];</span><br><span class="line">    <span class="keyword">int</span> mark = startIndex;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = startIndex + <span class="number">1</span>; i &lt;= endIndex; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; pivot) &#123;</span><br><span class="line">            mark++;</span><br><span class="line">            <span class="keyword">int</span> tmp = arr[mark];</span><br><span class="line">            arr[mark] = arr[i];</span><br><span class="line">            arr[i] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    arr[startIndex] = arr[mark];</span><br><span class="line">    arr[mark] = pivot;</span><br><span class="line">    <span class="keyword">return</span> mark;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="计数排序（Count-Sort）"><a href="#计数排序（Count-Sort）" class="headerlink" title="计数排序（Count Sort）"></a><a href="https://blogs.rhsphere.com/leetcode/2019/04/01/count-sort.html" target="_blank" rel="noopener">计数排序（Count Sort）</a></h3><p>如果通过比较进行排序，那么复杂度的下界是O(nlogn)，但是如果数据本身有可以利用的特征，可以不通过比较进行排序，就能使时间复杂度降低到O(n)。</p><p>计数排序要求待排序的数组元素都是整数，有很多地方都要求是 0-K 的正整数，其实负整数也可以通过都加一个偏移量解决的。</p><p>计数排序的思想是，考虑待排序数组中的某一个元素a，如果数组中比a小的元素有s个，那么a在最终排好序的数组中的位置将会是s+1，如何知道比a小的元素有多少个，肯定不是通过比较去觉得，而是通过数字本身的属性，即累加数组中最小值到a之间的每个数字出现的次数（未出现则为0），而每个数字出现的次数可以通过扫描一遍数组获得。</p><p>计数排序的步骤：</p><p>1.找出待排序的数组中最大和最小的元素（计数数组C的长度为max-min+1，其中位置0存放min，依次填充到最后一个位置存放max）<br>2.统计数组中每个值为i的元素出现的次数，存入数组C的第i项<br>3.对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）<br>4.反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1（反向填充是为了保证稳定性）</p><p>计数排序适合数据分布集中的排序，如果数据太分散，会造成空间的大量浪费，假设数据为（1,2,3,1000000），这就需要1000000的额外空间，并且有大量的空间浪费和时间浪费。</p><h4 id="计数排序实现"><a href="#计数排序实现" class="headerlink" title="计数排序实现"></a>计数排序实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] countSort(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line">    <span class="comment">// 1. 得到数列的最大值和最小值，并计算出差值d</span></span><br><span class="line">    <span class="keyword">int</span> max = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> min = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; max) &#123;</span><br><span class="line">            max = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; min) &#123;</span><br><span class="line">            min = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> d = max - min;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 创建统计数组并统计对应元素个数</span></span><br><span class="line">    <span class="keyword">int</span>[] countArray = <span class="keyword">new</span> <span class="keyword">int</span>[d + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        countArray[arr[i] - min]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 统计数组做变型，后面的元素等于前面的元素之和</span></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; countArray.length; i++) &#123;</span><br><span class="line">        sum += countArray[i];</span><br><span class="line">        countArray[i] = sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4. 倒序遍历原始数组，从统计数组找到正确位置，输出到结果数组</span></span><br><span class="line">    <span class="keyword">int</span>[] sortedArray = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">//  arr[i]-min找到这个数在countArray中的位置</span></span><br><span class="line">        <span class="keyword">int</span> sumCount = countArray[arr[i] - min];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//得到实际排序后的位置</span></span><br><span class="line">        <span class="keyword">int</span> sortedPos = sumCount - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  向最终结果里存放元素</span></span><br><span class="line">        sortedArray[sortedPos] = arr[i];</span><br><span class="line">        <span class="comment">// 针对重复的元素，先放后面，然后减1，下次循环就会放在前面</span></span><br><span class="line">        countArray[arr[i] - min]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sortedArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="桶排序（Bucket-Sort）"><a href="#桶排序（Bucket-Sort）" class="headerlink" title="桶排序（Bucket Sort）"></a><a href="https://blogs.rhsphere.com/leetcode/2019/04/01/bucket-sort.html" target="_blank" rel="noopener">桶排序（Bucket Sort）</a></h3><p> 假设有一组长度为N的待排关键字序列K[1….n]。首先将这个序列划分成M个的子区间(桶) 。然后基于某种映射函数 ，将待排序列的关键字k映射到第i个桶中(即桶数组B的下标i) ，那么该关键字k就作为B[i]中的元素(每个桶B[i]都是一组大小为N/M的序列)。接着对每个桶B[i]中的所有元素进行比较排序(可以使用快排)。然后依次枚举输出B[0]….B[M]中的全部内容即是一个有序序列。</p><p>桶排序利用函数的映射关系，减少了计划所有的比较操作，是一种Hash的思想，可以用在海量数据处理中。<br>计数排序也可以看作是桶排序的特例，数组关键字范围为N，划分为N个桶。</p><h4 id="桶排序实现"><a href="#桶排序实现" class="headerlink" title="桶排序实现"></a>桶排序实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span>[] bucketSort(<span class="keyword">double</span>[] arr) &#123;</span><br><span class="line">    <span class="comment">// 1. 得到数列的最大值和最小值，并计算出差值d</span></span><br><span class="line">    <span class="keyword">double</span> max = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">double</span> min = arr[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; max) &#123;</span><br><span class="line">            max = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; min) &#123;</span><br><span class="line">            min = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> d = max - min;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 初始化桶</span></span><br><span class="line">    <span class="keyword">int</span> bucketNum = arr.length;</span><br><span class="line"></span><br><span class="line">    ArrayList&lt;LinkedList&lt;Double&gt;&gt; bucketList = <span class="keyword">new</span> ArrayList&lt;&gt;(bucketNum);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketNum; i++) &#123;</span><br><span class="line">        bucketList.add(<span class="keyword">new</span> LinkedList&lt;Double&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 遍历原始数组，将每个元素放入桶中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> num = (<span class="keyword">int</span>) ((arr[i] - min) * (bucketNum - <span class="number">1</span>) / d);</span><br><span class="line">        bucketList.get(num).add(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 对每个桶内部进行排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketList.size(); i++) &#123;</span><br><span class="line">        <span class="comment">// JDK低层采用了归并排序或归并的优化版本</span></span><br><span class="line">        Collections.sort(bucketList.get(i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 输出全部元素</span></span><br><span class="line">    <span class="keyword">double</span>[] sortedArray = <span class="keyword">new</span> <span class="keyword">double</span>[arr.length];</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (LinkedList&lt;Double&gt; list : bucketList) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">double</span> element : list) &#123;</span><br><span class="line">            sortedArray[index] = element;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sortedArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="堆排序（Heap-Sort）"><a href="#堆排序（Heap-Sort）" class="headerlink" title="堆排序（Heap Sort）"></a><a href="https://blogs.rhsphere.com/leetcode/2019/04/01/heapsort-easy.html" target="_blank" rel="noopener">堆排序（Heap Sort）</a></h3><p> 堆排序是把数组看作堆，第i个结点的孩子结点为第2i + 1和2i + 2个结点（不超出数组长度前提下），堆排序的第一步是建堆，然后是取堆顶元素然后调整堆。建堆的过程是自底向上不断调整达成的，这样当调整某个结点时，其左节点和右结点已经是满足条件的，此时如果两个子结点不需要动，则整个子树不需要动，如果调整，则父结点交换到子结点位置，再以此结点继续调整。</p><p>下述代码使用的大顶堆，建立好堆后堆顶元素为最大值，此时取堆顶元素即使堆顶元素和最后一个元素交换，最大的元素处于数组最后，此时调整小了一个长度的堆，然后再取堆顶和倒数第二个元素交换，依次类推，完成数据的非递减排序。</p><p>堆排序的主要时间花在初始建堆期间，建好堆后，堆这种数据结构以及它奇妙的特征，使得找到数列中最大的数字这样的操作只需要O(1)的时间复杂度，维护需要logn的时间复杂度。堆排序不适宜于记录数较少的文件。</p><h4 id="堆排序实现"><a href="#堆排序实现" class="headerlink" title="堆排序实现"></a>堆排序实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//堆排序 arr为待调整的堆</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 把无序数组构建成二叉堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = (arr.length - <span class="number">2</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        downAdjust(arr, i, arr.length);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.循环删除栈顶元素，移到集合尾部，调整堆产生新的栈顶</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">//最后一个元素和第一个元素进行交换</span></span><br><span class="line">        <span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">        arr[i] = arr[<span class="number">0</span>];</span><br><span class="line">        arr[<span class="number">0</span>] = tmp;</span><br><span class="line">        <span class="comment">// 下沉调整最大堆</span></span><br><span class="line">        downAdjust(arr, <span class="number">0</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">downAdjust</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> parentIndex, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = arr[parentIndex];</span><br><span class="line">    <span class="keyword">int</span> childIndex = <span class="number">2</span> * parentIndex + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (childIndex &lt; length) &#123;</span><br><span class="line">        <span class="comment">// 如果有右孩子，且右孩子大于左孩子的值，则定位到右孩子</span></span><br><span class="line">        <span class="keyword">if</span> (childIndex + <span class="number">1</span> &lt; length &amp;&amp; arr[childIndex + <span class="number">1</span>] &gt; arr[childIndex]) &#123;</span><br><span class="line">            childIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果父节点大于任何一个孩子的值，直接跳出</span></span><br><span class="line">        <span class="keyword">if</span> (tmp &gt;= arr[childIndex]) </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//无需真正交换，单向赋值即可</span></span><br><span class="line">        arr[parentIndex] = arr[childIndex];</span><br><span class="line">        parentIndex = childIndex;</span><br><span class="line">        childIndex = <span class="number">2</span> * childIndex + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[parentIndex] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;排序算法可以说是一项基本功，解决实际问题中经常遇到，针对实际数据的特点选择合适的排序算法可以使程序获得更高的效率，有时候排序的稳定性还是实际问题中必须考虑的，这篇博客对常见的排序算法进行整理，包括：选择排序、插入排序、希尔排序、冒泡排序、鸡尾酒排序、归并排序、快速排序、堆排序、计数排序、桶排序、基数排序(代码略)。&lt;/p&gt;
    
    </summary>
    
      <category term="Sorting" scheme="https://www.blogs.rhsphere.com/categories/Sorting/"/>
    
    
      <category term="sort" scheme="https://www.blogs.rhsphere.com/tags/sort/"/>
    
  </entry>
  
  <entry>
    <title>排序(11) 外部排序</title>
    <link href="https://www.blogs.rhsphere.com/2019/04/01/external-sort.html"/>
    <id>https://www.blogs.rhsphere.com/2019/04/01/external-sort.html</id>
    <published>2019-04-01T08:15:38.000Z</published>
    <updated>2019-05-25T07:28:06.551Z</updated>
    
    <content type="html"><![CDATA[<p class="description">前面讨论的排序算法，都假定要排序的所有数据在内存中都同时可用，如数组。要对存储在外部文件中的数据排序，首先要将数据送入内存，然后对它们进行内部排序。然而，如果文件太大，那么文件中的所有数据不能都同时送入内存。在大型外部文件中对数据排序，称为外部排序(external sort)。</p><a id="more"></a><h2 id="创建大文件"><a href="#创建大文件" class="headerlink" title="创建大文件"></a>创建大文件</h2><p>创建一个200万int值存储在一个名为largedata.dat的二进制文件中。使用下面的程序创建：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateLargeFile</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        DataOutputStream output = <span class="keyword">new</span> DataOutputStream(</span><br><span class="line">            <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"largedata.dat"</span>)));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">800004</span>; i++)&#123;</span><br><span class="line">            output.writeInt((<span class="keyword">int</span>)(Math.random() * <span class="number">1000000</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        output.close();</span><br><span class="line"></span><br><span class="line">        DataInputStream input = <span class="keyword">new</span> DataInputStream(</span><br><span class="line">            <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"largedata.dat"</span>)));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.print(input.readInt() + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        input.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="归并排序实现"><a href="#归并排序实现" class="headerlink" title="归并排序实现"></a>归并排序实现</h2><h3 id="实现阶段1"><a href="#实现阶段1" class="headerlink" title="实现阶段1"></a>实现阶段1</h3><p>重复将数据从文件读入数组，并使用内部排序算法堆数组排序，然后将数据从数组输出到一个临时文件中。<br>下面的代码给出了一个方法，它从文件中读取每个数据段，并对分段进行排序，然后将排好序的分段存在一个心文件中。该方法返回分段的个数。</p><figure class="highlight java"><figcaption><span>创建初始的有序分段</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> initializeSegments</span><br><span class="line">    (<span class="keyword">int</span> segmentSize, String originalFile, String f1) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">int</span>[] list =  <span class="keyword">new</span> <span class="keyword">int</span>[segmentSize];</span><br><span class="line">        DataInputStream input = <span class="keyword">new</span> DataInputStream(</span><br><span class="line">                <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(originalFile)));</span><br><span class="line">        DataOutputStream output = <span class="keyword">new</span> DataOutputStream(</span><br><span class="line">                <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(f1)));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> numberOfSegments = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (input.available() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            numberOfSegments++;</span><br><span class="line">            <span class="comment">// 读取一段数据到数组中</span></span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> ( ; input.available() &gt; <span class="number">0</span> &amp;&amp; i &lt; segmentSize; i++) &#123;</span><br><span class="line">                list[i] = input.readInt();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 对数组排序</span></span><br><span class="line">            java.util.Arrays.sort(list, <span class="number">0</span>, i);</span><br><span class="line">            <span class="comment">// 将数组中的数据写入到临时文件中</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                output.writeInt(list[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        input.close();</span><br><span class="line">        output.close();</span><br><span class="line">        <span class="comment">//返回分段个数，除了最后一个分段的元素数可能较少外，其他分段都有</span></span><br><span class="line">        <span class="comment">//MAX_ARRAY_SIZE个元素</span></span><br><span class="line">        <span class="keyword">return</span> numberOfSegments;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>MAX_ARRAY_SIZE，数组的最大尺寸依赖于操作系统分配给JVM的内存大小。<br>假定数组的最大尺寸为100 000个int值，那么在临时文件中就是对每100 000个int值进行的排序。将它们标记为S1，S2，…，Sk，最后一段包含的数值可能会少于100 000个。</p><h3 id="实现阶段2"><a href="#实现阶段2" class="headerlink" title="实现阶段2"></a>实现阶段2</h3><p>将每对有序分段（比如S1，S2，…，Sk）归并到一个大一些的有序分段中，并将新分段存储到新的临时文件中。继续同样的过程直到得到仅仅一个有序分段。<br>每步归并都将两个有序分段归并成一个新分段。新段的元素数目是原来的两倍，因此，每次归并后分段的个数减少一半。<br>如果一个分段太大，它将不能放到内存的数组中。为了实现归并步骤，要将文件f1.dat中的一半数目的分段复制到临时文件f2.dat中。然后，将f1.dat中剩下的收割分段与f2.dat中的首个分段归并到名为f3.dat的临时文件中。<br><strong>复制前半部分的分段</strong><br><figure class="highlight java"><figcaption><span>复制前半部分的分段</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyHalfToF2</span><span class="params">(<span class="keyword">int</span> numberOfSegments, <span class="keyword">int</span> segmentSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                DataInputStream f1, DataOutputStream f2)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (numberOfSegments / <span class="number">2</span>) * segmentSize; i++) &#123;</span><br><span class="line">            f2.writeInt(f1.readInt());</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>归并所有分段</strong><br><figure class="highlight java"><figcaption><span>归并所有分段</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSegments</span><span class="params">(<span class="keyword">int</span> numberOfSegments, </span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> segmentSize, DataInputStream f1, DataInputStream f2, DataOutputStream f3)</span> </span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numberOfSegments; i++) &#123;</span><br><span class="line">            mergeTwoSegments(segmentSize, f1, f2, f3);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (f1.available() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            f3.writeInt(f1.readInt());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p><strong>归并两个阶段</strong><br><figure class="highlight java"><figcaption><span>归并两个阶段</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeTwoSegments</span><span class="params">(<span class="keyword">int</span> segmentSize, DataInputStream f1, </span></span></span><br><span class="line"><span class="function"><span class="params">            DataInputStream f2, DataOutputStream f3)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> intFromF1 = f1.readInt();</span><br><span class="line">        <span class="keyword">int</span> intFromF2 = f2.readInt();</span><br><span class="line">        <span class="keyword">int</span> f1Count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> f2Count = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (intFromF1 &lt; intFromF2) &#123;</span><br><span class="line">                f3.writeInt(intFromF1);</span><br><span class="line">                <span class="keyword">if</span> (f1.available() == <span class="number">0</span> || f1Count++ &gt;= segmentSize) &#123;</span><br><span class="line">                    f3.writeInt(intFromF2);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    intFromF1 = f1.readInt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                f3.writeInt(intFromF2);</span><br><span class="line">                <span class="keyword">if</span> (f2.available() == <span class="number">0</span> || f2Count++ &gt;= segmentSize) &#123;</span><br><span class="line">                    f3.writeInt(intFromF1);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    intFromF2 = f2.readInt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (f1.available() &gt; <span class="number">0</span> &amp;&amp; f1Count++ &lt;segmentSize) &#123;</span><br><span class="line">            f3.writeInt(f1.readInt());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (f2.available() &gt; <span class="number">0</span> &amp;&amp; f2Count++ &lt; segmentSize) &#123;</span><br><span class="line">            f3.writeInt(f2.readInt());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h2 id="结合两个阶段"><a href="#结合两个阶段" class="headerlink" title="结合两个阶段"></a>结合两个阶段</h2><p>完整代码<br><figure class="highlight java"><figcaption><span>外部排序</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> sorting;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SortLargeFile</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = <span class="number">43</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BUFFER_SIZE = <span class="number">100000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        sort(<span class="string">"largedata.dat"</span>, <span class="string">"sortedfile.dat"</span>);</span><br><span class="line">        </span><br><span class="line">        displayFile(<span class="string">"sortedfile.dat"</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(String sourcefile, String targetfile)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> numberOfSegments = initializeSegments(MAX_ARRAY_SIZE, sourcefile, <span class="string">"f1.dat"</span>);        </span><br><span class="line">        merge(numberOfSegments, MAX_ARRAY_SIZE, </span><br><span class="line">                <span class="string">"f1.dat"</span>, <span class="string">"f2.dat"</span>, <span class="string">"f3.dat"</span>, targetfile);        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> initializeSegments</span><br><span class="line">    (<span class="keyword">int</span> segmentSize, String originalFile, String f1) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">int</span>[] list =  <span class="keyword">new</span> <span class="keyword">int</span>[segmentSize];</span><br><span class="line">        DataInputStream input = <span class="keyword">new</span> DataInputStream(</span><br><span class="line">                <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(originalFile)));</span><br><span class="line">        DataOutputStream output = <span class="keyword">new</span> DataOutputStream(</span><br><span class="line">                <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(f1)));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> numberOfSegments = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (input.available() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            numberOfSegments++;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> ( ; input.available() &gt; <span class="number">0</span> &amp;&amp; i &lt; segmentSize; i++) &#123;</span><br><span class="line">                list[i] = input.readInt();</span><br><span class="line">            &#125;</span><br><span class="line">            java.util.Arrays.sort(list, <span class="number">0</span>, i);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                output.writeInt(list[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        input.close();</span><br><span class="line">        output.close();</span><br><span class="line">        <span class="keyword">return</span> numberOfSegments;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> numberOfSegments, <span class="keyword">int</span> segmentSize,</span></span></span><br><span class="line"><span class="function"><span class="params">            String f1, String f2, String f3, String targetfile)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (numberOfSegments &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            mergeOneStep(numberOfSegments, segmentSize, f1, f2, f3);</span><br><span class="line">            merge((numberOfSegments + <span class="number">1</span>) / <span class="number">2</span>, segmentSize * <span class="number">2</span>, f3, f1, f2, targetfile);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            File sortedFile = <span class="keyword">new</span> File(targetfile);</span><br><span class="line">            <span class="keyword">if</span> (sortedFile.exists()) sortedFile.delete();</span><br><span class="line">            <span class="keyword">new</span> File(f1).renameTo(sortedFile);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeOneStep</span><span class="params">(<span class="keyword">int</span> numberOfSegments, <span class="keyword">int</span> segmentSize, </span></span></span><br><span class="line"><span class="function"><span class="params">            String f1, String f2, String f3)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        DataInputStream f1Input = <span class="keyword">new</span> DataInputStream(</span><br><span class="line">                <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(f1), BUFFER_SIZE));</span><br><span class="line">        DataOutputStream f2Output = <span class="keyword">new</span> DataOutputStream(</span><br><span class="line">                <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(f2), BUFFER_SIZE));</span><br><span class="line">        </span><br><span class="line">        copyHalfToF2(numberOfSegments, segmentSize, f1Input, f2Output);</span><br><span class="line">        f2Output.close();</span><br><span class="line">        </span><br><span class="line">        DataInputStream f2Input = <span class="keyword">new</span> DataInputStream(</span><br><span class="line">                <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(f2), BUFFER_SIZE));</span><br><span class="line">        DataOutputStream f3Output = <span class="keyword">new</span> DataOutputStream(</span><br><span class="line">                <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(f3), BUFFER_SIZE));</span><br><span class="line">        </span><br><span class="line">        mergeSegments(numberOfSegments / <span class="number">2</span>, segmentSize, f1Input, f2Input, f3Output);        </span><br><span class="line">        f1Input.close();</span><br><span class="line">        f2Input.close();</span><br><span class="line">        f3Output.close();                </span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyHalfToF2</span><span class="params">(<span class="keyword">int</span> numberOfSegments, <span class="keyword">int</span> segmentSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                DataInputStream f1, DataOutputStream f2)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (numberOfSegments / <span class="number">2</span>) * segmentSize; i++) &#123;</span><br><span class="line">            f2.writeInt(f1.readInt());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSegments</span><span class="params">(<span class="keyword">int</span> numberOfSegments, </span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> segmentSize, DataInputStream f1, DataInputStream f2, DataOutputStream f3)</span> </span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numberOfSegments; i++) &#123;</span><br><span class="line">            mergeTwoSegments(segmentSize, f1, f2, f3);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (f1.available() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            f3.writeInt(f1.readInt());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeTwoSegments</span><span class="params">(<span class="keyword">int</span> segmentSize, DataInputStream f1, </span></span></span><br><span class="line"><span class="function"><span class="params">            DataInputStream f2, DataOutputStream f3)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> intFromF1 = f1.readInt();</span><br><span class="line">        <span class="keyword">int</span> intFromF2 = f2.readInt();</span><br><span class="line">        <span class="keyword">int</span> f1Count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> f2Count = <span class="number">1</span>;        </span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (intFromF1 &lt; intFromF2) &#123;</span><br><span class="line">                f3.writeInt(intFromF1);</span><br><span class="line">                <span class="keyword">if</span> (f1.available() == <span class="number">0</span> || f1Count++ &gt;= segmentSize) &#123;</span><br><span class="line">                    f3.writeInt(intFromF2);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    intFromF1 = f1.readInt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                f3.writeInt(intFromF2);</span><br><span class="line">                <span class="keyword">if</span> (f2.available() == <span class="number">0</span> || f2Count++ &gt;= segmentSize) &#123;</span><br><span class="line">                    f3.writeInt(intFromF1);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    intFromF2 = f2.readInt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (f1.available() &gt; <span class="number">0</span> &amp;&amp; f1Count++ &lt;segmentSize) &#123;</span><br><span class="line">            f3.writeInt(f1.readInt());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (f2.available() &gt; <span class="number">0</span> &amp;&amp; f2Count++ &lt; segmentSize) &#123;</span><br><span class="line">            f3.writeInt(f2.readInt());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">displayFile</span><span class="params">(String filename)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            DataInputStream input = </span><br><span class="line">                    <span class="keyword">new</span> DataInputStream(<span class="keyword">new</span> FileInputStream(filename));</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                System.out.print(input.readInt() + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            input.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="外部排序复杂度"><a href="#外部排序复杂度" class="headerlink" title="外部排序复杂度"></a>外部排序复杂度</h2><p>在外部排序中，主要开销是在IO上。假设n是文件中要排序的元素个数。在阶段1，从原始文件读取元素个数n，然后将它输出给一个临时文件。因此，阶段1的IO复杂度为O(n)。</p><p>对于阶段2，在第一个合并步骤之前，排好序的分段的个数为 n/c，其中c是MAX_ARRAY_SIZE。每一个合并步骤都会使分段的个数减半。因此，在第一次合并步骤之后，分段个数为 n/2c。<br>在第二次合并步骤之后，分段个数为 n/4c。 在第三次合并步骤之后，分段个数为 n/8c。<br>在第log(n/c)次合并步骤之后，分段个数减到1。因此，合并步骤的总数为log(n/c)。</p><p>在每次合并步骤中，从文件f1读取一半数量的分段，然后将它们写入到一个临时文件f2。合并f1中剩余的分段和f2中的分段。每一个合并步骤中IO的次数为O(n)。因为合并步骤的总数是log(n/c)，IO的总数是 O(n) * log(n/c) = O(nlogn)。<br>因此外部排序的复杂度是O(nlogn)</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;前面讨论的排序算法，都假定要排序的所有数据在内存中都同时可用，如数组。要对存储在外部文件中的数据排序，首先要将数据送入内存，然后对它们进行内部排序。然而，如果文件太大，那么文件中的所有数据不能都同时送入内存。在大型外部文件中对数据排序，称为外部排序(external sort)。&lt;/p&gt;
    
    </summary>
    
      <category term="Sorting" scheme="https://www.blogs.rhsphere.com/categories/Sorting/"/>
    
    
      <category term="sort" scheme="https://www.blogs.rhsphere.com/tags/sort/"/>
    
      <category term="ExternalSort" scheme="https://www.blogs.rhsphere.com/tags/ExternalSort/"/>
    
  </entry>
  
  <entry>
    <title>排序(10) 堆排序(非泛型)</title>
    <link href="https://www.blogs.rhsphere.com/2019/04/01/heapsort-easy.html"/>
    <id>https://www.blogs.rhsphere.com/2019/04/01/heapsort-easy.html</id>
    <published>2019-04-01T08:15:18.000Z</published>
    <updated>2019-07-29T13:49:45.706Z</updated>
    
    <content type="html"><![CDATA[<p class="description">堆排序是把数组看作堆，第i个结点的孩子结点为第 2i + 1和 2i + 2个结点（不超出数组长度前提下），堆排序的第一步是建堆，然后是取堆顶元素然后调整堆。建堆的过程是自底向上不断调整达成的，这样当调整某个结点时，其左节点和右结点已经是满足条件的，此时如果两个子结点不需要动，则整个子树不需要动，如果调整，则父结点交换到子结点位置，再以此结点继续调整。</p><a id="more"></a><h2 id="二叉堆回顾"><a href="#二叉堆回顾" class="headerlink" title="二叉堆回顾"></a>二叉堆回顾</h2><h3 id="最大（小）堆"><a href="#最大（小）堆" class="headerlink" title="最大（小）堆"></a>最大（小）堆</h3><p>二叉堆本质上是一种完全二叉树，它分为两个类型：<br>1.最大堆<br>2.最小堆</p><p>完全二叉树定义：如果一棵二叉树的每一层都是满的，或者最后一层可以不填满并且最后一层的叶子都是靠左放置的，这可二叉树是完全的。</p><p>堆排序使用的是二叉堆（binary heap），二叉堆是一棵具有如下属性的二叉树：<br>形状属性：它是一棵完全二叉树。<br>堆属性：<br>什么是最大堆呢？最大堆任何一个父节点的值，都 <strong>大于等于</strong>它左右孩子节点的值。<br>什么是最小堆呢？最小堆任何一个父节点的值，都 <strong>小于等于</strong>它左右孩子节点的值。</p><p>二叉堆的根节点叫做堆顶。</p><p>最大堆和最小堆的特点，决定了在最大堆的堆顶是整个堆中的 <strong>最大元素</strong>；最小堆的堆顶是整个堆中的 <strong>最小元素</strong>。</p><h3 id="堆的三种操作"><a href="#堆的三种操作" class="headerlink" title="堆的三种操作"></a>堆的三种操作</h3><p>对于二叉堆，如下有几种操作：</p><ul><li>插入节点，二叉堆的节点插入，插入位置是完全二叉树的最后一个位置。</li><li></li><li>删除节点，二叉堆的节点删除过程和插入过程正好相反，所删除的是处于堆顶的节点。</li><li></li><li>构建二叉堆，也就是把一个无序的完全二叉树调整为二叉堆。<br>这几种操作都是基于堆的自我调整。</li></ul><h3 id="构建二叉堆"><a href="#构建二叉堆" class="headerlink" title="构建二叉堆"></a>构建二叉堆</h3><p>构建二叉堆，也就是把一个无序的完全二叉树调整为二叉堆，本质上就是让所有非叶子节点依次下沉。</p><h2 id="堆的代码实现"><a href="#堆的代码实现" class="headerlink" title="堆的代码实现"></a>堆的代码实现</h2><p>二叉堆虽然是一颗完全二叉树，但它的存储方式并不是链式存储，而是顺序存储。换句话说，二叉堆的所有节点都存储在数组当中。<br>数组中，在没有左右指针的情况下，如何定位到一个父节点的左孩子和右孩子呢？</p><p>可以依靠数组下标来计算。假设父节点的下标是parent，那么它的左孩子下标就是 2parent+1；它的右孩子下标就是  2parent+2 。</p><figure class="highlight java"><figcaption><span>堆的上浮和下浮调整操作</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapOperator</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 上浮调整 arr为待调整的堆</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">upAdjust</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> childIndex = arr.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> parentIndex = (childIndex - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 用tmp保存插入的叶子节点值，用于最后的赋值</span></span><br><span class="line">        <span class="keyword">int</span> tmp = arr[childIndex];</span><br><span class="line">        <span class="keyword">while</span> (childIndex &gt; <span class="number">0</span> &amp;&amp; tmp &lt; arr[parentIndex]) &#123;</span><br><span class="line">            <span class="comment">// 无须真正交换，单向赋值即可</span></span><br><span class="line">            arr[childIndex] = arr[parentIndex];</span><br><span class="line">            childIndex = parentIndex;</span><br><span class="line">            parentIndex = (parentIndex - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[childIndex] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下沉调整，arr为待调整的堆，parentIndex为要下沉的父节点，length为堆的有效大小</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">downAdjust</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> parentIndex, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = arr[parentIndex];</span><br><span class="line">        <span class="keyword">int</span> childIndex = <span class="number">2</span> * parentIndex + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (childIndex &lt; length) &#123;</span><br><span class="line">            <span class="comment">// 如果有右孩子，且右孩子小于左孩子的值，则定位到右孩子</span></span><br><span class="line">            <span class="comment">//  arr[childIndex + 1] &gt; arr[childIndex]</span></span><br><span class="line">            <span class="keyword">if</span> (childIndex + <span class="number">1</span> &lt; length &amp;&amp; arr[childIndex + <span class="number">1</span>] &lt; arr[childIndex]) &#123;</span><br><span class="line">                childIndex++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果父节点小于任何一个孩子的值，直接跳出</span></span><br><span class="line">            <span class="comment">// if (tmp &gt; arr[childIndex]) </span></span><br><span class="line">            <span class="keyword">if</span> (tmp &lt;= arr[childIndex]) </span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 无需真正交换，单向赋值即可</span></span><br><span class="line">            arr[parentIndex] = arr[childIndex];</span><br><span class="line">            parentIndex = childIndex;</span><br><span class="line">            childIndex = <span class="number">2</span> * childIndex + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[parentIndex] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构建堆 arr为待调整的堆</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildHeap</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 从最后一个叶子节点开始，依次下沉调整</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            downAdjust(arr, i, arr.length - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">0</span> &#125;;</span><br><span class="line">        upAdjust(arr);</span><br><span class="line">        System.out.println(Arrays.toString(array));</span><br><span class="line">        array = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">7</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">6</span> &#125;;</span><br><span class="line">        buildHeap(array);</span><br><span class="line">        System.out.println(Arrays.toString(array));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中有一个优化的点，就是父节点和孩子节点做连续交换时，并不一定要真的交换，只需要先把交换一方的值存入temp变量，做单向覆盖，循环结束后，再把temp的值存入交换后的最终位置。</p><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>我们每一次删除旧堆顶，调整后的新堆顶都是大小仅次于旧堆顶的节点。那么我们只要反复删除堆顶，反复调节二叉堆，所得到的集合就成为了一个有序集合。</p><p>二叉堆和最大堆的特性：</p><ol><li>二叉堆本质上是一种完全二叉树</li><li>最大堆的堆顶是整个堆中的最大元素</li></ol><p>当我们删除一个最大堆的堆顶（并不是完全删除，而是替换到最后面），经过自我调节，第二大的元素就会被交换上来，成为最大堆的新堆顶。</p><p>由此，我们可以归纳出堆排序算法的步骤：</p><ol><li>把无序数组构建成二叉堆。</li><li>循环删除堆顶元素，移到集合尾部，调节堆产生新的堆顶。</li></ol><h2 id="堆排序代码实现"><a href="#堆排序代码实现" class="headerlink" title="堆排序代码实现"></a>堆排序代码实现</h2><figure class="highlight java"><figcaption><span>堆排序实现</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 下沉调整</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr          待调整的堆</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parentIndex  要下沉的父节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> length       堆的有效大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">downAdjust</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> parentIndex, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = arr[parentIndex];</span><br><span class="line">        <span class="keyword">int</span> childIndex = <span class="number">2</span> * parentIndex + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (childIndex &lt; length) &#123;</span><br><span class="line">            <span class="comment">// 如果有右孩子，且右孩子大于左孩子的值，则定位到右孩子</span></span><br><span class="line">            <span class="keyword">if</span> (childIndex + <span class="number">1</span> &lt; length &amp;&amp; arr[childIndex + <span class="number">1</span>] &gt; arr[childIndex]) &#123;</span><br><span class="line">                childIndex++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果父节点大于等于任何一个孩子的值，直接跳出</span></span><br><span class="line">            <span class="keyword">if</span> (tmp &gt;= arr[childIndex]) </span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//无需真正交换，单向赋值即可</span></span><br><span class="line">            arr[parentIndex] = arr[childIndex];</span><br><span class="line">            parentIndex = childIndex;</span><br><span class="line">            childIndex = <span class="number">2</span> * childIndex + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[parentIndex] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//堆排序 arr为待调整的堆</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 把无需数组构建成二叉堆</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length/<span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            downAdjust(arr, i, arr.length);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.循环删除顶端元素，移到数组尾部，调整堆产生新的堆顶</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">//最后一个元素和第一个元素进行交换</span></span><br><span class="line">            <span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">            arr[i] = arr[<span class="number">0</span>];</span><br><span class="line">            arr[<span class="number">0</span>] = tmp;</span><br><span class="line">            <span class="comment">// 下沉调整最大堆</span></span><br><span class="line">            downAdjust(arr, <span class="number">0</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">0</span> &#125;;</span><br><span class="line">        heapSort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="堆排序的时间空间复杂度"><a href="#堆排序的时间空间复杂度" class="headerlink" title="堆排序的时间空间复杂度"></a>堆排序的时间空间复杂度</h2><p>算法复杂度：<br>时间复杂度（平均）： O(nlogn)<br>时间复杂度（最坏）： O(nlogn)<br>时间复杂度（最好）： O(nlogn)</p><p>空间复杂度：  O(1)<br>堆排序是不稳定的排序算法。</p><p>堆排序的空间复杂度毫无疑问是O(1)，因为没有开辟额外的集合空间。</p><p>对于时间复杂度：<br>二叉堆的节点下沉调整（downAdjust 方法）是堆排序算法的基础，这个调节操作本身的时间复杂度是多少呢？<br>假设二叉堆总共有n个元素，那么下沉调整的最坏时间复杂度就等同于二叉堆的高度，也就是O（logn）。</p><p>我们再来回顾一下堆排序算法的步骤：</p><ol><li>把无序数组构建成二叉堆。</li><li>循环删除堆顶元素，移到集合尾部，调节堆产生新的堆顶。</li></ol><p>第一步，把无序数组构建成二叉堆，需要进行n/2次循环。每次循环调用一次 downAdjust 方法，所以第一步的计算规模是  n/2 * logn，时间复杂度 O（nlogn）。</p><p>第二步，需要进行n-1次循环。每次循环调用一次 downAdjust 方法，所以第二步的计算规模是 （n-1） * logn ，时间复杂度 O（nlogn）。</p><p>两个步骤是并列关系，所以整体的时间复杂度同样是 O（nlogn）。</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;堆排序是把数组看作堆，第i个结点的孩子结点为第 2i + 1和 2i + 2个结点（不超出数组长度前提下），堆排序的第一步是建堆，然后是取堆顶元素然后调整堆。建堆的过程是自底向上不断调整达成的，这样当调整某个结点时，其左节点和右结点已经是满足条件的，此时如果两个子结点不需要动，则整个子树不需要动，如果调整，则父结点交换到子结点位置，再以此结点继续调整。&lt;/p&gt;
    
    </summary>
    
      <category term="Sorting" scheme="https://www.blogs.rhsphere.com/categories/Sorting/"/>
    
    
      <category term="HeapSort" scheme="https://www.blogs.rhsphere.com/tags/HeapSort/"/>
    
      <category term="sort" scheme="https://www.blogs.rhsphere.com/tags/sort/"/>
    
  </entry>
  
  <entry>
    <title>排序(9) 桶排序</title>
    <link href="https://www.blogs.rhsphere.com/2019/04/01/bucket-sort.html"/>
    <id>https://www.blogs.rhsphere.com/2019/04/01/bucket-sort.html</id>
    <published>2019-04-01T08:14:41.000Z</published>
    <updated>2019-05-25T07:28:06.553Z</updated>
    
    <content type="html"><![CDATA[<p class="description">假设有一组长度为N的待排关键字序列K[1….n]。首先将这个序列划分成M个的子区间(桶) 。然后基于某种映射函数，将待排序列的关键字k映射到第i个桶中(即桶数组B的下标i)，那么该关键字k就作为B[i]中的元素(每个桶B[i]都是一组大小为N/M的序列)。接着对每个桶B[i]中的所有元素进行比较排序(可以使用快排)。 然后依次枚举输出B[0]….B[M]中的全部内容即是一个有序序列。</p><a id="more"></a><h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><h3 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h3><p>一个长度为20的doule类型数组，取值范围从0到10，要求用最快的速度把这20个double类型元素从小到大进行排序。<br>当数列取值范围过大，或者不是整数时，不能适用计数排序。到那时可以使用桶排序来解决问题。</p><p>桶排序同样是一种线性时间的排序算法，类似于计数排序所创建的统计数组，桶排序需要创若干个 <strong>桶</strong>来协助排序。</p><p>计数排序：<br>计数排序需要根据原始数列的取值范围，创建一个统计数组，用来统计原始数列中每一个可能的整数值所出现的次数。<br>原始数列中的整数值，和统计数组的下标是一一对应的，以数列的最小值作为偏移量，比如原始数列的最小值是90，那么整数对应的统计数组下标就是95-90=5。</p><p>桶排序当中的桶的概念：<br>每一个桶(bucket)代表一个区间范围，里面可以承载一个或多个元素。</p><p>桶排序的第一步，就是创建这些桶，确定每一个桶的区间范围。</p><p>4.5    0.84    3.25    2.18    0.5<br>[0.5, 1.5) [1.5, 2.5) [2.5, 3.5) [3.5, 4.5) [4.5, 4.5]</p><p>具体建立多少个桶，如何确定桶的区间范围，有很多不同的方式。<br>这里创建的桶数量等于原始数列的元素数量，除了最后一个桶只包含数列最大值，前面各个桶的区间按照比例确定。<br>区间跨度 = （最大值-最小值）/ （桶的数量 - 1）</p><p>第二步，遍历原始数列，把元素对号入座放入各个桶中：<br> 0.84    0.5    2.18    3.25     4.5<br>[0.5, 1.5) [1.5, 2.5) [2.5, 3.5) [3.5, 4.5) [4.5, 4.5]</p><p>第三步，每个桶内部的元素分别排序（显然，只有第一个桶需要排序）：</p><p>第四步，遍历所有的桶，输出所有元素：<br>0.5， 0.84， 2.18， 3.25， 4.5</p><p>到此为止，排序结束。</p><h2 id="桶排序代码实现"><a href="#桶排序代码实现" class="headerlink" title="桶排序代码实现"></a>桶排序代码实现</h2><figure class="highlight java"><figcaption><span>桶排序</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BucketSort</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span>[] bucketSort(<span class="keyword">double</span>[] arr) &#123;</span><br><span class="line">        <span class="comment">// 1. 得到数列的最大值和最小值，并计算出差值d</span></span><br><span class="line">        <span class="keyword">double</span> max = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">double</span> min = arr[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; max) &#123;</span><br><span class="line">                max = arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt; min) &#123;</span><br><span class="line">                min = arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span> d = max - min;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 初始化桶</span></span><br><span class="line">        <span class="keyword">int</span> bucketNum = arr.length;</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;LinkedList&lt;Double&gt;&gt; bucketList = <span class="keyword">new</span> ArrayList&lt;&gt;(bucketNum);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketNum; i++) &#123;</span><br><span class="line">            bucketList.add(<span class="keyword">new</span> LinkedList&lt;Double&gt;());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 遍历原始数组，将每个元素放入桶中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> num = (<span class="keyword">int</span>) ((arr[i] - min) * (bucketNum - <span class="number">1</span>) / d);</span><br><span class="line">            bucketList.get(num).add(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 对每个桶内部进行排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketList.size(); i++) &#123;</span><br><span class="line">            <span class="comment">// JDK低层采用了归并排序或归并的优化版本</span></span><br><span class="line">            Collections.sort(bucketList.get(i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 输出全部元素</span></span><br><span class="line">        <span class="keyword">double</span>[] sortedArray = <span class="keyword">new</span> <span class="keyword">double</span>[arr.length];</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (LinkedList&lt;Double&gt; list : bucketList) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">double</span> element : list) &#123;</span><br><span class="line">                sortedArray[index] = element;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sortedArray;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span>[] arr = &#123; <span class="number">4.12</span>, <span class="number">6.421</span>, <span class="number">0.0023</span>, <span class="number">3.0</span>, <span class="number">2.123</span>, <span class="number">8.122</span>, <span class="number">4.12</span>, <span class="number">10.09</span> &#125;;</span><br><span class="line">        <span class="keyword">double</span>[] sortedArr = bucketSort(arr);</span><br><span class="line"></span><br><span class="line">        System.out.println(Arrays.toString(sortedArr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中，所有的桶保存在ArrayList集合当中，每一个桶被定义成一个链表（LinkedList<double>），这样便于在尾部插入元素。</double></p><p>定位元素属于第几个桶，是按照比例来定位：<br>(array[i] - min)  * (bucketNum-1) / d</p><p>同时，代码使用了JDK的集合工具类Collections.sort来为桶内部的元素进行排序。Collections.sort底层采用的是归并排序或Timsort，小伙伴们可以简单地把它们当做是一种时间复杂度 O（nlogn）的排序。</p><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>基数排序</p><p>基数排序也可以看作一种桶排序，不断的使用不同的标准对数据划分到桶中，最终实现有序。基数排序的思想是对数据选择多种基数，对每一种基数依次使用桶排序。</p><p>基数排序的步骤：以整数为例，将整数按十进制位划分，从低位到高位执行以下过程。</p><ol><li><p>从个位开始，根据0~9的值将数据分到10个桶桶，例如12会划分到2号桶中。</p></li><li><p>将0~9的10个桶中的数据顺序放回到数组中。</p></li></ol><p>重复上述过程，一直到最高位。</p><p>上述方法称为LSD（Least significant digital），还可以从高位到低位，称为MSD。</p><h2 id="复杂度及稳定性"><a href="#复杂度及稳定性" class="headerlink" title="复杂度及稳定性"></a>复杂度及稳定性</h2><p>算法复杂度：<br>时间复杂度（平均）： O(n+m+n(logn-logm))<br>时间复杂度（最坏）： O(nlogn)<br>时间复杂度（最好）： O(n)</p><p>空间复杂度：  O(m+n)<br>桶排序也是稳定的排序算法。</p><p>假设原始数列有n个元素，分成m个桶（我们采用分桶方式m=n），平均每个桶的元素个数为 n/m</p><p>下面逐步分析算法复杂度</p><p>第一步，求数列最大最小值，运算量为n。<br>第二步，创建空桶，运算量为m。<br>第三步，遍历原始数列，运算量为n。<br>第四步在每个桶内部做排序，由于使用了O(nlogn)的排序算法，所以运算量为 n/m · log(n/m ) · m。<br>第五步，输出排序数列，运算量为n。</p><p>加起来，总的运算量为3n+m+ n/m · log(n/m ) · m = 3n+m+n(logn-logm)<br>去掉系数，时间复杂度为：<br>O(n+m+n(logn-logm))<br>至于空间复杂度就很明显了：<br>空桶占用的空间 + 数列在桶中占用的空间 = O(m+n)</p><p>桶排序在性能上并非绝对稳定。理想情况下，桶中的元素均匀分布，当n=m时，时间复杂度可以达到O(n)；但是，如果桶内元素的分布极不均匀，极端情况下第一个桶中有n-1个元素，，最后一个桶中有1个元素。此时的时间复杂度将退化成为O(nlogn)，还白白创建了许多空桶。</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;假设有一组长度为N的待排关键字序列K[1….n]。首先将这个序列划分成M个的子区间(桶) 。然后基于某种映射函数，将待排序列的关键字k映射到第i个桶中(即桶数组B的下标i)，那么该关键字k就作为B[i]中的元素(每个桶B[i]都是一组大小为N/M的序列)。接着对每个桶B[i]中的所有元素进行比较排序(可以使用快排)。 然后依次枚举输出B[0]….B[M]中的全部内容即是一个有序序列。&lt;/p&gt;
    
    </summary>
    
      <category term="Sorting" scheme="https://www.blogs.rhsphere.com/categories/Sorting/"/>
    
    
      <category term="sort" scheme="https://www.blogs.rhsphere.com/tags/sort/"/>
    
      <category term="BucketSort" scheme="https://www.blogs.rhsphere.com/tags/BucketSort/"/>
    
  </entry>
  
  <entry>
    <title>排序(8) 计数排序</title>
    <link href="https://www.blogs.rhsphere.com/2019/04/01/count-sort.html"/>
    <id>https://www.blogs.rhsphere.com/2019/04/01/count-sort.html</id>
    <published>2019-04-01T08:14:30.000Z</published>
    <updated>2019-05-25T07:28:06.553Z</updated>
    
    <content type="html"><![CDATA[<p class="description">无论是冒泡排序，还是快速排序等等，都是基于元素之间的比较来进行排序。有一种特殊的算法叫做 <strong>计数排序</strong>，这种排序算法不是基于元素比较，而是利用数组下标来确定元素的正确位置。</p><a id="more"></a><h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><h3 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h3><p>如果通过比较进行排序，那么复杂度的下界是O(nlogn)，但是如果数据本身有可以利用的特征，可以不通过比较进行排序，就能使时间复杂度降低到O(n)。</p><p>计数排序要求待排序的数组元素都是整数，有很多地方都要求是 0-K 的正整数，其实负整数也可以通过都加一个偏移量解决的。</p><p>计数排序的思想是，考虑待排序数组中的某一个元素a，如果数组中比a小的元素有s个，那么a在最终排好序的数组中的位置将会是s+1，如何知道比a小的元素有多少个，肯定不是通过比较去觉得，而是通过数字本身的属性，即累加数组中最小值到a之间的每个数字出现的次数（未出现则为0），而每个数字出现的次数可以通过扫描一遍数组获得。</p><p>计数排序的步骤：</p><p>1.找出待排序的数组中最大和最小的元素（计数数组C的长度为max-min+1，其中位置0存放min，依次填充到最后一个位置存放max）<br>2.统计数组中每个值为i的元素出现的次数，存入数组C的第i项<br>3.对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）<br>4.反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1（反向填充是为了保证稳定性）</p><p>计数排序适合数据分布集中的排序，如果数据太分散，会造成空间的大量浪费，假设数据为（1,2,3,1000000），这就需要1000000的额外空间，并且有大量的空间浪费和时间浪费。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>数组里有20个随机数，取值范围从0到10,要求用最快的速度把这20个整数从小到大进行排序。 </p><p>随机整数的取值范围从0到10，这些整数取值范围为0-10这11个数字。根据这个整数取值范围，建立一个长度为11的数组。数组下标从0到10，元素初始值全为0。</p><p>假定20个随机整数的值如下：<br>9，3，5，4，9，1，2，7，8，1，3，6，5，3，4，0，10，9 ，7，9</p><p>如何给这些无序的随机整数排序呢？<br>非常简单，让我们遍历这个无序的随机数列，每一个整数按照其值对号入座，对应数组下标的元素进行加1操作。<br>最终，数列遍历完毕时，数组的状态如下：</p><table><thead><tr><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th></tr></thead><tbody><tr><td>1</td><td>2</td><td>1</td><td>3</td><td>2</td><td>2</td><td>1</td><td>2</td><td>1</td><td>4</td><td>1</td></tr></tbody></table><p>数组每一个下标位置的值，代表了数列中对应整数出现的次数。<br>有了这个“统计结果”，排序就很简单了。直接遍历数组，输出数组元素的下标值，元素的值是几，就输出几次：<br>0，1，1，2，3，3，3，4，4，5，5，6，7，7，8，9，9，9，9，10<br>显然，这个输出的数列已经是有序的了。</p><p>这就是计数排序的基本过程，它适用于一定范围的整数排序。在取值范围不是很大的情况下，它的性能甚至超过那些O(nlogn)的排序。</p><h2 id="计数排序（初步实现）"><a href="#计数排序（初步实现）" class="headerlink" title="计数排序（初步实现）"></a>计数排序（初步实现）</h2><p>下面代码在一开头补充了一个步骤，就是求得数列的最大整数值max。后面创建的统计数组countArray，长度就是max + 1，以此保证数组的最后一个下标是max。<br>代码如下：<br><figure class="highlight java"><figcaption><span>计数排序初步实现</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountSort</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] countSort(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line">        <span class="comment">// 1. 得到数列的最大值</span></span><br><span class="line">        <span class="keyword">int</span> max = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; arr[<span class="number">0</span>]) &#123;</span><br><span class="line">                max = arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.根据数列最大值确定统计数组的长度</span></span><br><span class="line">        <span class="keyword">int</span>[] countArray = <span class="keyword">new</span> <span class="keyword">int</span>[max + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 3. 遍历数列，填充统计数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            countArray[arr[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4. 遍历统计数组，输出结果</span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] sortedArray = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; countArray.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; countArray[i]; j++) &#123;</span><br><span class="line">                sortedArray[index++] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sortedArray;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = &#123; <span class="number">4</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">10</span> &#125;;</span><br><span class="line">        <span class="keyword">int</span>[] sortedArray = countSort(array);</span><br><span class="line">        System.out.println(Arrays.toString(sortedArray));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="改进点分析"><a href="#改进点分析" class="headerlink" title="改进点分析"></a>改进点分析</h2><h3 id="初始值和偏移量"><a href="#初始值和偏移量" class="headerlink" title="初始值和偏移量"></a>初始值和偏移量</h3><p>上面的初步实现，从功能角度，可以实现整数的排序，但是存在一些问题，只以数列的最大值来决定统计数组的长度，其实并不严谨。比如下面的数列：<br>95，94，91，98，99，90，99，93，91，92</p><p>这个数列的最大值是99，但最小值的整数是90.如果创建长度为100的数组，前面从0到89的空间位置都浪费了。</p><p>解决这个问题，很简单，不再以（输入数列的最大值 + 1）作为统计数组的长度，而是以（数列最大值和最小值的差 + 1）作为统计数组的长度。<br>同时，数列的最小值作为一个偏移量，用于统计数组的对号入座。</p><p>以刚才的数列为例，统计数组的长度为 99-90+1 = 10 偏移量等于数列的最小值90.<br>对于第一个整数95，对应的统计数组下标是 95-90=5</p><h3 id="反向填充"><a href="#反向填充" class="headerlink" title="反向填充"></a>反向填充</h3><p>另外一方面，朴素版的计数排序只是简单地按照统计数组的下标输出了元素值，并没有真正给原始数列进行排序。<br>如果只是单纯的给整数排序，这样没有问题，但是如果放在业务代码里，比如给学生的考试分数排序，遇到相同的分数就会分不清谁是谁。</p><table><thead><tr><th>姓名</th><th>成绩</th></tr></thead><tbody><tr><td>小灰</td><td>90</td></tr><tr><td>大黄</td><td>99</td></tr><tr><td>小红</td><td>95</td></tr><tr><td>小白</td><td>94</td></tr><tr><td>小绿</td><td>95</td></tr></tbody></table><p>给定一个学生的成绩表，要求按成绩从低到高排序，如果成绩相同，则 <strong>遵循原表固有顺序</strong>。<br>那么，当我们填充统计数组以后，我们只知道有两个成绩并列95分的小伙伴，却不知道哪一个是小红，哪一个是小绿：</p><table><thead><tr><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th></tr></thead><tbody><tr><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td><td>2</td><td>0</td><td>0</td><td>0</td><td>1</td></tr></tbody></table><p>变型后：</p><table><thead><tr><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>1</td><td>1</td><td>2</td><td>4</td><td>4</td><td>4</td><td>4</td><td>5</td></tr></tbody></table><p>这是如何变形的呢？统计数组从第二个元素开始，每一个元素都加上前面所有元素之和。<br>为什么要相加呢？</p><p>这样相加的目的，是让统计数组存储的元素值，等于相应整数的最终排序位置。比如下标是9的元素值为5，代表原始数列的整数9，最终的排序是在第5位。</p><p>接下来，我们创建输出数组sortedArray，长度和输入数列一致。然后从后向前遍历输入数列：<br>第一步，我们遍历成绩表最后一行的小绿：<br>小绿是95分，我们找到countArray下标是5的元素，值是4，代表小绿的成绩排名位置在第4位。<br>同时，我们给countArray下标是5的元素值减1，从4变成3,，代表着下次再遇到95分的成绩时，最终排名是第3。</p><p>第二步，我们遍历成绩表倒数第二行的小白：<br>小白是94分，我们找到countArray下标是4的元素，值是2，代表小白的成绩排名位置在第2位。<br>同时，我们给countArray下标是4的元素值减1，从2变成1,，代表着下次再遇到94分的成绩时（实际上已经遇不到了），最终排名是第1。</p><p>第三步，我们遍历成绩表倒数第三行的小红：<br>小红是95分，我们找到countArray下标是5的元素，值是3（最初是4，减1变成了3），代表小红的成绩排名位置在第3位。<br>同时，我们给countArray下标是5的元素值减1，从3变成2,，代表着下次再遇到95分的成绩时（实际上已经遇不到了），最终排名是第2。</p><p>这样一来，同样是95分的小红和小绿就能够清楚地排出顺序了，也正因此，优化版本的计数排序属于稳定排序。</p><h2 id="计数排序代码实现（优化后）"><a href="#计数排序代码实现（优化后）" class="headerlink" title="计数排序代码实现（优化后）"></a>计数排序代码实现（优化后）</h2><p>其中关键的地方有两个：<br>第一，在于理解计算max和min之后，需要使用原数组每一个元素减去min的转换值统计词频，特定情况下能节省存储空间，这样做的另一个好处是可以兼容负数的情况，因为每一个元素减去最小值之后，结果必定是大于等于0；</p><p>第二，在于理解为什么采用词频求和的方式 + 倒序遍历原始数组的方式，能保证排序算法的稳定性。</p><p>这里必须从后向前遍历，只有这样出现重复的元素，才会保持顺序的把最后面的重复元素，永远放在最右边。从而保证排序的稳定性，如果从前向后排序，重复元素的顺序，刚好相反，所以就不是稳定的算法。</p><figure class="highlight java"><figcaption><span>计数排序代码实现（优化后）</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountSort</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] countSort(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line">        <span class="comment">// 1. 得到数列的最大值和最小值，并计算出差值d</span></span><br><span class="line">        <span class="keyword">int</span> max = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> min = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; max) &#123;</span><br><span class="line">                max = arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt; min) &#123;</span><br><span class="line">                min = arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> d = max - min;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 创建统计数组并统计对应元素个数</span></span><br><span class="line">        <span class="keyword">int</span>[] countArray = <span class="keyword">new</span> <span class="keyword">int</span>[d + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            countArray[arr[i] - min]++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 统计数组做变型，后面的元素等于前面的元素之和</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; countArray.length; i++) &#123;</span><br><span class="line">            sum += countArray[i];</span><br><span class="line">            countArray[i] = sum;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 倒序遍历原始数组，从统计数组找到正确位置，输出到结果数组</span></span><br><span class="line">        <span class="keyword">int</span>[] sortedArray = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">/*sortedArray[countArray[arr[i] - min] - 1] = arr[i];</span></span><br><span class="line"><span class="comment">            * countArray[arr[i] - min]--;</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="comment">//  arr[i]-min找到这个数在countArray中的位置</span></span><br><span class="line">            <span class="keyword">int</span> sumCount = countArray[arr[i] - min];</span><br><span class="line"></span><br><span class="line">            <span class="comment">//得到实际排序后的位置</span></span><br><span class="line">            <span class="keyword">int</span> sortedPos = sumCount - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//  向最终结果里存放元素</span></span><br><span class="line">            sortedArray[sortedPos] = arr[i];</span><br><span class="line">            <span class="comment">// 针对重复的元素，先放后面，然后减1，下次循环就会放在前面</span></span><br><span class="line">            countArray[arr[i] - min]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sortedArray;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123; <span class="number">95</span>, <span class="number">94</span>, <span class="number">91</span>, <span class="number">98</span>, <span class="number">99</span>, <span class="number">90</span>, <span class="number">99</span>, <span class="number">93</span>, <span class="number">91</span>, <span class="number">92</span> &#125;;</span><br><span class="line">        <span class="keyword">int</span>[] sortedArray = countSort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(sortedArray));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析及稳定性"><a href="#复杂度分析及稳定性" class="headerlink" title="复杂度分析及稳定性"></a>复杂度分析及稳定性</h2><p>算法复杂度：<br>时间复杂度（平均）： O(n+m)<br>时间复杂度（最坏）： O(n+m)<br>时间复杂度（最好）： O(n+m)</p><p>空间复杂度：  O(m)<br>计数排序是稳定的排序算法。</p><p>如果原始数列的规模是N，最大最小整数的差值是M，计数排序的时间复杂度和空间复杂度。<br>代码第1, 2, 4步都涉及到遍历原数列，运算量都是N，第3步遍历统计数列，运算量是M，所以总体运算量是3N + M，去掉系数，时间复杂度是O(n+m)。</p><p>至于空间复杂度，如果不考虑结果数组，只考虑统计数组 countArray 大小的话，空间复杂度是O(m)。</p><p>计数排序存在它的局限性：</p><ol><li><p>当数列最大值最小值差距过大时，并不使用计数排序。<br>比如给定20个随机整数，范围在0到1亿之间，这时候如果使用计数排序，需要创建长度1亿的数组。不但严重浪费空间，而且时间复杂度也随之升高。</p></li><li><p>当数列元素不是整数，并不适用计数排序。<br>如果数列中的元素都是小数，比如25.213，或是0.00000001这样子，则无法创建对应的统计数组。这样显然无法进行计数排序。</p></li></ol><p>基于这些局限性，另一种线性时间排序算法对此做出了弥补，这种排序算法叫做 <strong>桶排序</strong>。</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;无论是冒泡排序，还是快速排序等等，都是基于元素之间的比较来进行排序。有一种特殊的算法叫做 &lt;strong&gt;计数排序&lt;/strong&gt;，这种排序算法不是基于元素比较，而是利用数组下标来确定元素的正确位置。&lt;/p&gt;
    
    </summary>
    
      <category term="Sorting" scheme="https://www.blogs.rhsphere.com/categories/Sorting/"/>
    
    
      <category term="sort" scheme="https://www.blogs.rhsphere.com/tags/sort/"/>
    
      <category term="CountSort" scheme="https://www.blogs.rhsphere.com/tags/CountSort/"/>
    
  </entry>
  
  <entry>
    <title>排序(7) 快速排序</title>
    <link href="https://www.blogs.rhsphere.com/2019/04/01/quick-sort.html"/>
    <id>https://www.blogs.rhsphere.com/2019/04/01/quick-sort.html</id>
    <published>2019-04-01T08:14:06.000Z</published>
    <updated>2019-05-25T07:28:06.553Z</updated>
    
    <content type="html"><![CDATA[<p class="description">快速排序的基本思想：通过一趟排序将待排数列分隔成独立的两部分，其中一部分数列的关键字均比另一部分的关键字小，则可分别对这两部分数列继续进行排序，以达到整个序列有序。 其中，最重要的partition主要有两种方法： 1)指针交换法。先把选定为pivot的元素放到最后，然后设定指针low和指针high，low指针右移，high指针左移，当两个指针相撞后停止移动。期间如果符合交换条件，两元素交换。最后把pivot元素放到中间。 2)挖坑法。类似冒泡排序的思路，把比pivot大的元素“往下沉”，把比pivot小的元素“往上浮”。</p><a id="more"></a><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h3 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h3><p>快速排序是从冒泡排序演变而来的算法，但是使用了 <strong>分治法</strong>，比冒泡排序要高效得多，所以叫快速排序。</p><p>同冒泡排序一样，快速排序也属于交换排序，通过元素之间的比较和交换位置来达到排序的目的。</p><p>不同的是，冒泡排序在每一轮只把一个元素冒泡到数列的一端，而快速排序 <strong>在每一轮挑选一个基准元素，并让其他比它大的元素移动到数列一边，比它小的元素移动到数列的另一边，从而把数列拆解成了两个部分。</strong><br>这种思路就叫做分治法。</p><p>在分治法的思想下，原数列在每一轮被拆成两部分，每一部分在下一轮又分别被拆成两部分，直到不可再分为止。</p><p>基准元素的选择：最简单的方式是选择数列的第一个元素。<br><strong>但是假如有一个原本逆序的数列，期望排序成顺序数列，这样数列每一轮仅仅确定了基准元素的位置。 第一个元素要么是最小值，要么是最大值，根本无法发挥分治法的优势。 在这种极端情况下，快速排序需要进行n轮，时间复杂度退化成了O(n^2)。</strong></p><p>如何避免上述情况的发生，最简单的方法，不选择数列的第一个元素，而是随机选择一个元素作为基准元素。 这样一来，即使在数列完全逆序的情况下，也可以有效地将数列分成两部分。当然，即使是随机选择基准元素，每一次也有极小的几率选到数列的最大值或最小值，同样会影响到分治的效果。 </p><p><strong>快速排序是目前被认为最好的一种内部排序方法。快速排序算法处理的最好情况指每次都是将待排序数列划分为均匀的两部分，通常认为快速排序的平均时间复杂度是O(nlogn)。</strong></p><p><strong>但是，快速排序的最差情况就是基本逆序或者基本有序的情况，那么此时快速排序将蜕化成冒泡排序，其时间复杂度为O(n^2)</strong></p><h3 id="元素的移动"><a href="#元素的移动" class="headerlink" title="元素的移动"></a>元素的移动</h3><p>选定了基准元素，要做的就是把其他元素当中小于基准元素的都移动到基准元素一边，大于基准元素的都移动到基准元素另一边。<br>有两种方法：</p><ol><li>挖坑法</li><li>指针交换法</li></ol><h2 id="快排（挖坑法）"><a href="#快排（挖坑法）" class="headerlink" title="快排（挖坑法）"></a>快排（挖坑法）</h2><figure class="highlight java"><figcaption><span>快速排序挖坑法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//递归结束条件</span></span><br><span class="line">        <span class="keyword">if</span> (startIndex &gt;= endIndex) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 得到基准元素位置</span></span><br><span class="line">        <span class="keyword">int</span> pivotIndex = partition(arr, startIndex, endIndex);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用分治法递归数列两部分</span></span><br><span class="line">        quickSort(arr, startIndex, pivotIndex - <span class="number">1</span>);</span><br><span class="line">        quickSort(arr, startIndex + <span class="number">1</span>, endIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 取第一个位置的元素作为基准元素</span></span><br><span class="line">        <span class="keyword">int</span> pivot = arr[startIndex];</span><br><span class="line">        <span class="keyword">int</span> left = startIndex;</span><br><span class="line">        <span class="keyword">int</span> right = endIndex;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 坑的位置，初始等于pivot的位置</span></span><br><span class="line">        <span class="keyword">int</span> index = startIndex;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 大循环左右指针重合或者指针交换时结束</span></span><br><span class="line">        <span class="keyword">while</span> (right &gt;= left) &#123;</span><br><span class="line">            <span class="comment">// right指针从右向左进行比较</span></span><br><span class="line">            <span class="keyword">while</span> (right &gt;= left) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[right] &lt; pivot) &#123;</span><br><span class="line">                    arr[left] = arr[right];</span><br><span class="line">                    index = right;</span><br><span class="line">                    left++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//left指针从左向右进行比较</span></span><br><span class="line">            <span class="keyword">while</span> (right &gt;= left) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[left] &gt; pivot) &#123;</span><br><span class="line">                    arr[right] = arr[left];</span><br><span class="line">                    index = left;</span><br><span class="line">                    right--;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[index] = pivot;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123; <span class="number">4</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">1</span> &#125;;</span><br><span class="line">        quickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="指针交换法代码实现"><a href="#指针交换法代码实现" class="headerlink" title="指针交换法代码实现"></a>指针交换法代码实现</h2><p>和挖坑法相比，指针交换法在partition方法中进行的元素交换次数更少。</p><p>对于数列 {4, 7, 6, 5, 3, 2, 8, 1 }</p><p>由于left一开始指向的是基准元素，判断肯定相等，所以left右移一位。</p><p>进入第四次循环，right移动到元素3停止，这时候请注意，left和right指针已经重合在了一起。</p><p>当left和right指针重合之时，我们让pivot元素和left与right重合点的元素进行交换。此时数列左边的元素都小于4，数列右边的元素都大于4，这一轮交换终告结束。</p><figure class="highlight java"><figcaption><span>快速排序指针交换法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (startIndex &gt;= endIndex) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 得到基准信息</span></span><br><span class="line">        <span class="keyword">int</span> pivotIndex = partition(arr, startIndex, endIndex);</span><br><span class="line">        <span class="comment">//根据基准元素，分成两部分进行递归</span></span><br><span class="line">        quickSort(arr, startIndex, pivotIndex - <span class="number">1</span>);</span><br><span class="line">        quickSort(arr, pivotIndex + <span class="number">1</span>, endIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 取第一个元素作为基准元素</span></span><br><span class="line">        <span class="keyword">int</span> pivot = arr[startIndex];</span><br><span class="line">        <span class="keyword">int</span> left = startIndex;</span><br><span class="line">        <span class="keyword">int</span> right = endIndex;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left != right) &#123;</span><br><span class="line">            <span class="comment">// 控制right指针比较并左移</span></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; arr[right] &gt; pivot) &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 控制left指针比较并左移</span></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; arr[left] &lt;= pivot) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 交换left和right指向的元素</span></span><br><span class="line">            <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = arr[left];</span><br><span class="line">                arr[left] = arr[right];</span><br><span class="line">                arr[right] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// pivot和指针重合交换</span></span><br><span class="line">        <span class="keyword">int</span> tmp = arr[left];</span><br><span class="line">        arr[left] = arr[startIndex];</span><br><span class="line">        arr[startIndex] = tmp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123; <span class="number">4</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">1</span> &#125;;</span><br><span class="line">        quickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="partition函数的单边循环法"><a href="#partition函数的单边循环法" class="headerlink" title="partition函数的单边循环法"></a>partition函数的单边循环法</h2><p>无论是挖坑法还是指针交换法，都是一层循环内嵌一层循环，从数组的两边交替遍历元素，代码不够简洁。<br>单边循环法只从数组的一边对元素进行遍历和交换。</p><figure class="highlight java"><figcaption><span>单边循环法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (startIndex &gt;= endIndex) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> pivotIndex = partition(arr, startIndex, endIndex);</span><br><span class="line">    quickSort(arr, startIndex, pivotIndex - <span class="number">1</span>);</span><br><span class="line">    quickSort(arr, pivotIndex + <span class="number">1</span>, endIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot = arr[startIndex];</span><br><span class="line">    <span class="keyword">int</span> mark = startIndex;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = startIndex + <span class="number">1</span>; i &lt;= endIndex; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; pivot) &#123;</span><br><span class="line">            mark++;</span><br><span class="line">            <span class="keyword">int</span> tmp = arr[mark];</span><br><span class="line">            arr[mark] = arr[i];</span><br><span class="line">            arr[i] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    arr[startIndex] = arr[mark];</span><br><span class="line">    arr[mark] = pivot;</span><br><span class="line">    <span class="keyword">return</span> mark;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="非递归实现"><a href="#非递归实现" class="headerlink" title="非递归实现"></a>非递归实现</h2><p>上面的代码都是依靠递归来实现的，绝大多数用递归来实现的问题，都可以用栈的方式来代替。<br>因为我们代码中一层一层的方法调用，本身就是一个函数栈。每次进入一个新方法，就相当于入栈；每次有方法返回，就相当于出栈。<br>所以，我们可以把原本的递归实现转化成一个栈的实现，在栈当中存储每一次方法调用的参数：</p><figure class="highlight java"><figcaption><span>使用非递归实现快速排序</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 用一个集合栈来代替递归的函数栈</span></span><br><span class="line">        Stack&lt;Map&lt;String, Integer&gt;&gt; quickSortStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="comment">// 整个数列的起止下标，以哈希的形式入栈</span></span><br><span class="line">        Map&lt;String, Integer&gt; rootParam = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        rootParam.put(<span class="string">"startIndex"</span>, startIndex);</span><br><span class="line">        rootParam.put(<span class="string">"endIndex"</span>, endIndex);</span><br><span class="line">        quickSortStack.push(rootParam);</span><br><span class="line">        <span class="comment">// 循环结束条件，栈为空时结束</span></span><br><span class="line">        <span class="keyword">while</span> (!quickSortStack.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 栈顶元素出栈，得到起止下标</span></span><br><span class="line">            Map&lt;String, Integer&gt; param = quickSortStack.pop();</span><br><span class="line">            <span class="comment">// 得到基准元素位置</span></span><br><span class="line">            <span class="keyword">int</span> pivotIndex = partition(arr, param.get(<span class="string">"startIndex"</span>), param.get(<span class="string">"endIndex"</span>));</span><br><span class="line">            <span class="comment">// 根据基准元素分成两部分，把每一部分的起止下标入栈</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (param.get(<span class="string">"startIndex"</span>) &lt; pivotIndex - <span class="number">1</span>) &#123;</span><br><span class="line">                Map&lt;String, Integer&gt; leftParam = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">                leftParam.put(<span class="string">"startIndex"</span>, param.get(<span class="string">"startIndex"</span>));</span><br><span class="line">                leftParam.put(<span class="string">"endIndex"</span>, pivotIndex - <span class="number">1</span>);</span><br><span class="line">                quickSortStack.push(leftParam);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (param.get(<span class="string">"endIndex"</span>) &gt; pivotIndex + <span class="number">1</span>) &#123;</span><br><span class="line">                Map&lt;String, Integer&gt; rightParam = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">                rightParam.put(<span class="string">"startIndex"</span>, pivotIndex + <span class="number">1</span>);</span><br><span class="line">                rightParam.put(<span class="string">"endIndex"</span>, param.get(<span class="string">"endIndex"</span>));</span><br><span class="line">                quickSortStack.push(rightParam);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 取第一个元素作为基准元素</span></span><br><span class="line">        <span class="keyword">int</span> pivot = arr[startIndex];</span><br><span class="line">        <span class="keyword">int</span> left = startIndex;</span><br><span class="line">        <span class="keyword">int</span> right = endIndex;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left != right) &#123;</span><br><span class="line">            <span class="comment">// 控制right指针比较并左移</span></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; arr[right] &gt; pivot) &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 控制left指针比较并右移</span></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; arr[left] &lt;= pivot) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 交换left和right指向的元素</span></span><br><span class="line">            <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = arr[left];</span><br><span class="line">                arr[left] = arr[right];</span><br><span class="line">                arr[right] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// pivot和指针重合点交换</span></span><br><span class="line">        <span class="keyword">int</span> tmp = arr[left];</span><br><span class="line">        arr[left] = arr[startIndex];</span><br><span class="line">        arr[startIndex] = tmp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">4</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">1</span> &#125;;</span><br><span class="line">        quickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">        System.out.print(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和刚才的递归实现相比，代码的变动仅仅在quickSort方法当中。该方法中引入了一个存储Map类型元素的栈，用于存储每一次交换时的起始下标和结束下标。</p><p>每一次循环，都会让栈顶元素出栈，进行排序，并且按照基准元素的位置分成左右两部分，左右两部分再分别入栈。当栈为空时，说明排序已经完毕，退出循环。</p><h2 id="改进主元选择的快排"><a href="#改进主元选择的快排" class="headerlink" title="改进主元选择的快排"></a>改进主元选择的快排</h2><p>在线性表中的第一个元素、中间元素和最后一个元素中选择一个 <strong>中位数</strong>作主元。</p><figure class="highlight java"><figcaption><span>中位数选择的函数，如（1, 3, 5）选择3</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">median</span><span class="params">(<span class="keyword">int</span> first, <span class="keyword">int</span> middle, <span class="keyword">int</span> last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(Math.min(first, middle), </span><br><span class="line">            Math.min(Math.max(first, middle), last));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度及稳定性"><a href="#复杂度及稳定性" class="headerlink" title="复杂度及稳定性"></a>复杂度及稳定性</h2><p>算法复杂度：<br>时间复杂度（平均）： O(nlogn)<br>时间复杂度（最坏）： O(n^2)<br>时间复杂度（最好）： O(nlogn)</p><p>空间复杂度：  O(nlogn)<br>快速排序是不稳定的排序算法。</p><p>快速排序有两个方向，左边的left指针一直往右走，当arr[left] &lt;= pivot。而右边的right指针一直往左走，当arr[right] &gt; pivot。如果left和right都走不动了，left &lt;= right，交换arr[left]和arr[right]，重复上面的过程，直到left &gt; right。 交换arr[left]和arr[startIndex]，完成一趟快速排序。<br>在中枢元素和a[left]交换的时候，很有可能把前面的元素的稳定性打乱，比如序列为5 3 3 4 3 8 9 10 11，现在中枢元素5和3（第5个元素，下标从1开始计）交换就会把元素3的稳定性打乱，所以快速排序是一个不稳定的排序算法，不稳定发生在中枢元素和arr[left] 交换的时刻。</p><h2 id="快排和归并"><a href="#快排和归并" class="headerlink" title="快排和归并"></a>快排和归并</h2><p>归并排序和快速排序都使用了分而治之法。<br>对于归并排序，大量的工作是将两个子线性表进行归并，归并是在两个子线性表都 <strong>排好序后</strong>进行的。<br>对于快速排序，大量的工作是将线性表划分成两个子线性表，划分是在子线性表 <strong>排好序前</strong>进行的。<br>最差的情况下，归并排序的效率高于快速排序，但是，在平均情况下，两者效率相同。归并排序在归并两个数组是需要一个临时数组，而快速排序不需要额外的数组空间。因此，快速排序的空间效率高于归并排序。</p><h2 id="快排和堆排序"><a href="#快排和堆排序" class="headerlink" title="快排和堆排序"></a>快排和堆排序</h2><p>相同点：堆排序和快速排序的平均时间复杂度都是O(nlogn)，并且都是 <strong>不稳定排序</strong>。</p><p>不同点：快速排序的最坏时间复杂度是O(n^2)，而堆排序最坏时间复杂度稳定在O(nlogn)。<br>此外，快速排序的递归和非递归的空间复杂度都是O(n)，而堆排序的空间复杂度是O(1)。</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;快速排序的基本思想：通过一趟排序将待排数列分隔成独立的两部分，其中一部分数列的关键字均比另一部分的关键字小，则可分别对这两部分数列继续进行排序，以达到整个序列有序。 其中，最重要的partition主要有两种方法： 1)指针交换法。先把选定为pivot的元素放到最后，然后设定指针low和指针high，low指针右移，high指针左移，当两个指针相撞后停止移动。期间如果符合交换条件，两元素交换。最后把pivot元素放到中间。 2)挖坑法。类似冒泡排序的思路，把比pivot大的元素“往下沉”，把比pivot小的元素“往上浮”。&lt;/p&gt;
    
    </summary>
    
      <category term="Sorting" scheme="https://www.blogs.rhsphere.com/categories/Sorting/"/>
    
    
      <category term="sort" scheme="https://www.blogs.rhsphere.com/tags/sort/"/>
    
      <category term="QuickSort" scheme="https://www.blogs.rhsphere.com/tags/QuickSort/"/>
    
  </entry>
  
  <entry>
    <title>排序(6) 归并排序</title>
    <link href="https://www.blogs.rhsphere.com/2019/04/01/merge-sort.html"/>
    <id>https://www.blogs.rhsphere.com/2019/04/01/merge-sort.html</id>
    <published>2019-04-01T08:13:56.000Z</published>
    <updated>2019-05-25T07:28:06.552Z</updated>
    
    <content type="html"><![CDATA[<p class="description">归并排序是采用分治法（Divide and Conquer）的一个非常典型的应用。归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(nlogn）的时间复杂度，代价是需要额外的内存空间。 归并排序算法将数组每一次都分解为原来的一半大小的两个子数组，当分解到了右边界比左边界还大的时候，不再分解，开始排序。 然后将排序好的子数组逐级合并，最后得到的结果就是排序好的数组。</p><a id="more"></a><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h3 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h3><p>归并排序是采用分治法（Divide and Conquer）的一个非常典型的应用。<br>将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。 </p><p>在这里我们只不过是利用了递归的思想，将数组每一次都分解为原来的一半大小的两个子数组，当分解到了右边界比左边界还大的时候，不再分解，开始排序。然后将排序好的子数组逐级合并，最后得到的结果就是排序好的数组。</p><p>首先考虑下如何将两个有序数列合并。这个非常简单，只要从比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可。这需要将待排序序列中的所有记录扫描一遍，因此耗费O(n)时间，而由完全二叉树的深度可知，整个归并排序需要进行 logn次，因此，总的时间复杂度为O(nlogn)。</p><p>归并排序在归并过程中需要与原始记录序列同样数量的存储空间存放归并结果，因此空间复杂度为O(n)。</p><p>归并算法需要两两比较，不存在跳跃，因此归并排序是一种稳定的排序算法。 </p><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>所谓递归，指的是程序直接或间接调用本身的一种方法，它通常把一个大型的、复杂的问题不直接解决，而是转化成为一个与原问题相似的、规模较小的问题来解决。<br>简单来说， <strong>递归就是把问题层层分解，直到程序出口处。</strong><br>任何递归都必须有递归调用的结束条件，否则，程序将会陷入无限递归而无法结束，而这个结束条件满足时，一定不会调用本身，否则递归调用将无法结束。</p><h3 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h3><p>归并排序的算法伪代码：<br><figure class="highlight java"><figcaption><span>归并排序的算法伪代码</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        mergeSort(arr[<span class="number">0</span> ... arr.length/<span class="number">2</span>]);</span><br><span class="line">        mergeSort(arr[arr.length/<span class="number">2</span> + <span class="number">1</span> ... arr.length]);</span><br><span class="line">        merge arr[<span class="number">0</span> ... arr.length / <span class="number">2</span>] with </span><br><span class="line">            arr[arr.length/<span class="number">2</span> + <span class="number">1</span> ... arr.length];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对数列 {2, 9, 5, 4, 8, 1, 6, 7} 进行归并排序。<br>先进行 <strong>拆分</strong>数列，直到数列只有一个元素为止，然后，再将其 <strong>归并</strong>为一个新的有序数列。<br>递归调用持续将数组划分为子数组，直到每个子数组只包含一个元素。然后，该算法将这些小的子数组归并为稍大的有序子数组，直到最后形成一个有序的数组。</p><h2 id="归并排序（法一）"><a href="#归并排序（法一）" class="headerlink" title="归并排序（法一）"></a>归并排序（法一）</h2><p>归并排序利用的是分治的思想，对于给定的一组数据，利用递归与分治技术将数据序列划分成为越来越小的子序列，之后对子序列排序，后再用递归方法将排好序的子序列合并成为有序序列。</p><p>合并两个子序列时，需要申请两个子序列加起来长度的内存，临时存储新的生成序列，再将新生成的序列赋值到原数组相应的位置。<br>MergeSort方法在分解过程中创建两个临时数组，将数组前半部分和后半部分复制到临时数组中，对临时数组排序，然后将它们归并到原始数组中，这样产生很多额外的空间开销。</p><p>代码如下：</p><figure class="highlight java"><figcaption><span>归并排序（）</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] list)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (list.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">// 对前半部分进行归并</span></span><br><span class="line"><span class="keyword">int</span>[] firstHalf = <span class="keyword">new</span> <span class="keyword">int</span>[list.length / <span class="number">2</span>];</span><br><span class="line">System.arraycopy(list, <span class="number">0</span>, firstHalf,</span><br><span class="line">   <span class="number">0</span>, list.length / <span class="number">2</span>);</span><br><span class="line">mergeSort(firstHalf);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对后半部分进行归并</span></span><br><span class="line"><span class="keyword">int</span> secondHalfLength = list.length - list.length / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span>[] secondHalf = <span class="keyword">new</span> <span class="keyword">int</span>[secondHalfLength];</span><br><span class="line">System.arraycopy(list, list.length / <span class="number">2</span>, secondHalf, </span><br><span class="line"><span class="number">0</span>, secondHalfLength);</span><br><span class="line">mergeSort(secondHalf);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把两部分数列合并到一个数列中</span></span><br><span class="line">merge(firstHalf, secondHalf, list);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] list1, <span class="keyword">int</span>[] list2, <span class="keyword">int</span>[] temp)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> current1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> current2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> current3 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (current1 &lt; list1.length &amp;&amp; current2 &lt; list2.length) &#123;</span><br><span class="line"><span class="keyword">if</span> (list1[current1] &lt; list2[current2])</span><br><span class="line">temp[current3++] = list1[current1++];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">temp[current3++] = list2[current2++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (current1 &lt; list1.length)</span><br><span class="line">temp[current3++] = list1[current1++];</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (current2 &lt; list2.length)</span><br><span class="line">temp[current3++] = list2[current2++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] list = &#123; <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">1</span>, -<span class="number">2</span>, <span class="number">3</span>, <span class="number">14</span>, <span class="number">12</span> &#125;;</span><br><span class="line">mergeSort(list);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.length; i++)</span><br><span class="line">System.out.print(list[i] + <span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在方法二中，递归地对数组的前半部分和后半部分进行排序，而不创建新的临时数组，然后把两个数组归并到一个临时数组中并将它的内容复制到初始数组中。</p><h2 id="归并排序（推荐）"><a href="#归并排序（推荐）" class="headerlink" title="归并排序（推荐）"></a>归并排序（推荐）</h2><figure class="highlight java"><figcaption><span>归并排序（法二）</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (left == right) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//  取中间的数进行拆分</span></span><br><span class="line"><span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line"><span class="comment">//  左边的数不断进行拆分</span></span><br><span class="line">mergeSort(arr, left, mid);</span><br><span class="line"><span class="comment">//  右边的数不断进行拆分</span></span><br><span class="line">mergeSort(arr, mid + <span class="number">1</span>, right);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并</span></span><br><span class="line">merge(arr, left, mid + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] leftArray = <span class="keyword">new</span> <span class="keyword">int</span>[mid - left];</span><br><span class="line"><span class="keyword">int</span>[] rightArray = <span class="keyword">new</span> <span class="keyword">int</span>[right - mid + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt; mid; i++) &#123;</span><br><span class="line">leftArray[i - left] = arr[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = mid; i &lt;= right; i++) &#123;</span><br><span class="line">rightArray[i - mid] = arr[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> k = left;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (i &lt; leftArray.length &amp;&amp; j &lt; rightArray.length) &#123;</span><br><span class="line"><span class="keyword">if</span> (leftArray[i] &lt; rightArray[j]) &#123;</span><br><span class="line">arr[k++] = leftArray[i++];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">arr[k++] = rigthArray[j++];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (i &lt; leftArray.length) &#123;</span><br><span class="line">arr[k++] = leftArray[i++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (j &lt; rightArray.length) &#123;</span><br><span class="line">arr[k++] = rigthArray[j++];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] arrays = &#123; <span class="number">9</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">10</span> &#125;;</span><br><span class="line"><span class="comment">//设置4个值的断点查看递归调用栈变化</span></span><br><span class="line"><span class="comment">//int[] arrays = &#123; 9, 2, 5, 1 &#125;;</span></span><br><span class="line">mergeSort(arrays, <span class="number">0</span>, arrays.length - <span class="number">1</span>);</span><br><span class="line">System.out.println(Arrays.toString(arrays));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以在Eclipse的debug中设置断点，查看递归调用和返回的次序，注意观察变量值的变化。</p><h2 id="算法复杂度及稳定性"><a href="#算法复杂度及稳定性" class="headerlink" title="算法复杂度及稳定性"></a>算法复杂度及稳定性</h2><p>算法复杂度：<br>时间复杂度（平均）： O(nlogn)<br>时间复杂度（最坏）： O(nlogn)<br>时间复杂度（最好）： O(nlogn)</p><p>空间复杂度：  O(n)</p><p>在这里我们只不过是利用了递归的思想，将数组每一次都分解为原来的一半大小的两个子数组，当分解到了右边界比左边界还大的时候，不再分解，开始排序。然后将排序好的子数组逐级合并，最后得到的结果就是排序好的数组。</p><p>原数组的长度为n，则细分得最大深度为logn，每一层需要排序的元素为n；则归并排序的时间复杂度为O(nlogn)。</p><p>稳定性：因为交换元素时，可以在相等的情况下做出不移动的限制，所以归并排序是可以稳定的。</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;归并排序是采用分治法（Divide and Conquer）的一个非常典型的应用。归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(nlogn）的时间复杂度，代价是需要额外的内存空间。 归并排序算法将数组每一次都分解为原来的一半大小的两个子数组，当分解到了右边界比左边界还大的时候，不再分解，开始排序。 然后将排序好的子数组逐级合并，最后得到的结果就是排序好的数组。&lt;/p&gt;
    
    </summary>
    
      <category term="Sorting" scheme="https://www.blogs.rhsphere.com/categories/Sorting/"/>
    
    
      <category term="MergeSort" scheme="https://www.blogs.rhsphere.com/tags/MergeSort/"/>
    
      <category term="sort" scheme="https://www.blogs.rhsphere.com/tags/sort/"/>
    
  </entry>
  
  <entry>
    <title>排序(5) 鸡尾酒排序</title>
    <link href="https://www.blogs.rhsphere.com/2019/04/01/cock-tail-sort.html"/>
    <id>https://www.blogs.rhsphere.com/2019/04/01/cock-tail-sort.html</id>
    <published>2019-04-01T08:13:36.000Z</published>
    <updated>2019-05-25T07:28:06.552Z</updated>
    
    <content type="html"><![CDATA[<p class="description">冒泡排序已经对算法进行有优化，但仍然不是最优。鸡尾酒排序又叫快乐小时排序，它基于冒泡排序又做了一点优化。博客中给出了鸡尾酒排序的优化版本。</p><a id="more"></a><h2 id="鸡尾酒排序"><a href="#鸡尾酒排序" class="headerlink" title="鸡尾酒排序"></a>鸡尾酒排序</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>回顾冒泡排序的思想：<br>冒泡排序的每一个元素都可以像一个小气泡一样，根据自身大小，一点一点向着数组的一侧移动。算法的每一轮都是 <strong>从左到右比较元素，进行单向的位置交换</strong>。</p><p>那么鸡尾酒排序做了怎样的优化呢？<br>鸡尾酒排序的元素比较和交换过程是 <strong>双向的</strong>。 </p><p>举个例子：<br>有8个数组成一个无序数列 {2, 3, 4, 5, 6, 7, 8, 1}，希望从小到大排序</p><p>冒泡排序过程省略，可以看出来，需要将1进行7轮排序。</p><p>按照冒泡排序，事实上，2到8已经是有序了，只有元素1的位置不对，却还要进行7轮排序！！这明显不合理，需要改进。<br>而鸡尾酒排序正是要解决这种问题。</p><h3 id="鸡尾酒排序过程"><a href="#鸡尾酒排序过程" class="headerlink" title="鸡尾酒排序过程"></a>鸡尾酒排序过程</h3><p>那么鸡尾酒排序又是什么样的？下面看看详细过程：</p><p>数列{2, 3, 4, 5, 6, 7, 8, 1}</p><p>第一轮（和冒泡排序一样，8和1交换）：<br>交换后 {2, 3, 4, 5, 6, 7, 1, 8}</p><p>第二轮：<br>反过来 <strong>从右往左</strong>比较和交换：</p><ul><li>8已经处于有序区，我们忽略掉8，让1和7比较。元素1小于7，所以1和7交换位置：{2, 3, 4, 5, 6, 1, 7, 8}</li><li>接下来1和6比较，元素1小于6，所以1和6交换位置：{2, 3, 4, 5, 1, 6, 7, 8}</li><li>接下来1和5比较，元素1小于5，所以1和5交换位置：{2, 3, 4, 1, 5, 6, 7, 8}</li><li>接下来1和4交换，1和3交换，1和2交换，最终成为了下面的结果：<br>{1, 2, 3, 4, 5, 6, 7, 8}</li></ul><p>第三轮（虽然已经有序，但是流程并没有结束）：</p><ul><li>鸡尾酒排序的第三轮，需要重新从左向右比较和交换</li><li>1和2比较，位置不变；2和3比较，位置不变；3和4比较，位置不变……6和7比较，位置不变。</li><li>没有元素位置交换，证明已经有序，排序结束。</li></ul><p>以上就是鸡尾酒排序的思路。排序过程就像钟摆一样，第一轮从左到右，第二轮从右到左，第三轮再从左到右……</p><h2 id="原始实现"><a href="#原始实现" class="headerlink" title="原始实现"></a>原始实现</h2><p>下面这段代码是鸡尾酒排序的原始实现。<br>代码外层的大循环控制着所有排序回合，大循环内包含两个小循环，第一个循环从左向右比较并交换元素，第二个循环从右向左比较并交换元素。</p><figure class="highlight java"><figcaption><span>鸡尾酒排序java原始实现</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CockTailSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cockTailSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length / <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//有序标记，每一轮的初始是true</span></span><br><span class="line">            <span class="keyword">boolean</span> isSorted = <span class="keyword">true</span>; </span><br><span class="line">            <span class="comment">//奇数轮，从左向右比较和交换</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; arr.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    tmp = arr[j];</span><br><span class="line">                    arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                    arr[j + <span class="number">1</span>] = tmp;</span><br><span class="line">                    <span class="comment">//有元素交换，所以不是有序，标记变为false</span></span><br><span class="line">                    isSorted = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (isSorted) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//偶数轮之前，重新标记为true</span></span><br><span class="line">            isSorted = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">//偶数轮，从右向左比较和交换</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = arr.length - i - <span class="number">1</span>; j &gt; i; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &lt; arr[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    tmp = arr[j];</span><br><span class="line">                    arr[j] = arr[j - <span class="number">1</span>];</span><br><span class="line">                    arr[j -<span class="number">1</span>] = tmp;</span><br><span class="line">                    <span class="comment">//有元素交换，所以不是有序，标记变为false</span></span><br><span class="line">                    isSorted = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isSorted) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] list = &#123;<span class="number">2</span>, <span class="number">32</span>, <span class="number">3</span>, <span class="number">34</span>, <span class="number">45</span>, <span class="number">8</span>, <span class="number">89</span>, <span class="number">20</span>, <span class="number">23</span>, -<span class="number">1</span>, -<span class="number">2</span>, -<span class="number">3</span>, -<span class="number">25</span>&#125;;</span><br><span class="line">        cockTailSort(list);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i: list)</span><br><span class="line">            System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">        System.out.println();            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="鸡尾酒排序进一步优化"><a href="#鸡尾酒排序进一步优化" class="headerlink" title="鸡尾酒排序进一步优化"></a>鸡尾酒排序进一步优化</h2><p>在将冒泡排序的时候，有一种针对有序区的优化，鸡尾酒排序也可以根据这个思路来进行优化。</p><p>回顾一下冒泡排序针对有序区的优化思路：<br>原始的冒泡排序，有序区的长度和排序的轮数是相等的。比如第一轮排序过后的有序区长度是1，第二轮排序过后的有序区长度是2……</p><p>要想优化，我们可以在每一轮排序的最后，记录下最后一次元素交换的位置，那个位置也就是无序数列的边界，再往后就是有序区了。</p><p>对于单向的冒泡排序，我们需要设置一个边界值，对于 <strong>双向的鸡尾酒排序，我们需要设置两个边界值</strong>。</p><figure class="highlight java"><figcaption><span>优化边界条件的鸡尾酒排序代码</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CockTailSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cockTailSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> lastRightExchangedIndex = <span class="number">0</span>;    <span class="comment">//记录右侧最后一次交换的位置</span></span><br><span class="line">        <span class="keyword">int</span> lastLeftExchangedIndex = <span class="number">0</span>;    <span class="comment">//记录左侧最后一次交换的位置 </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//无序数列的右边界，每次比较只需要比到这里为止</span></span><br><span class="line">        <span class="keyword">int</span> rigthSortBorder = arr.length - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//无序数列的左边界，每次比较只需要比到这里为止</span></span><br><span class="line">        <span class="keyword">int</span> leftSortBorder = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length / <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> isSorted = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">//奇数轮，从左向右比较和交换</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = leftSortBorder; j &lt; rigthSortBorder; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    tmp = arr[j];</span><br><span class="line">                    arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                    arr[j + <span class="number">1</span>] = tmp;</span><br><span class="line"></span><br><span class="line">                    isSorted = <span class="keyword">false</span>;</span><br><span class="line">                    lastRightExchangedIndex = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            rigthSortBorder = lastRightExchangedIndex;</span><br><span class="line">            <span class="keyword">if</span> (isSorted) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            isSorted = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">//偶数轮，从右向左比较和交换</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = rigthSortBorder; j &gt; leftSortBorder; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &lt; arr[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    tmp = arr[j];</span><br><span class="line">                    arr[j] = arr[j - <span class="number">1</span>];</span><br><span class="line">                    arr[j - <span class="number">1</span>] = tmp;</span><br><span class="line"></span><br><span class="line">                    isSorted = <span class="keyword">false</span>;</span><br><span class="line">                    lastLeftExchangedIndex = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            leftSortBorder = lastLeftExchangedIndex;</span><br><span class="line">            <span class="keyword">if</span> (isSorted) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中使用了左右两个边界值，rightSortBorder 代表右边界，leftSortBorder代表左边界。 </p><p>在比较和交换元素时，奇数轮从 leftSortBorder 遍历到 rightSortBorder 位置，偶数轮从 rightSortBorder 遍历到 leftSortBorder 位置。</p><h2 id="复杂度及稳定性"><a href="#复杂度及稳定性" class="headerlink" title="复杂度及稳定性"></a>复杂度及稳定性</h2><p>鸡尾酒排序的优点是能够在特定条件下，减少排序的回合数；<br>缺点是，代码量几乎扩大了一倍。</p><p>至于能发挥出优势的场景，就是在 <strong>大部分元素已经有序</strong> 的情况下，比冒泡完美版还要好。</p><p>但是鸡尾酒排序即使优化了，时间复杂度也是O(n^2)，和冒泡排序的是时间复杂度相同。</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;冒泡排序已经对算法进行有优化，但仍然不是最优。鸡尾酒排序又叫快乐小时排序，它基于冒泡排序又做了一点优化。博客中给出了鸡尾酒排序的优化版本。&lt;/p&gt;
    
    </summary>
    
      <category term="Sorting" scheme="https://www.blogs.rhsphere.com/categories/Sorting/"/>
    
    
      <category term="sort" scheme="https://www.blogs.rhsphere.com/tags/sort/"/>
    
      <category term="CockTailSort" scheme="https://www.blogs.rhsphere.com/tags/CockTailSort/"/>
    
  </entry>
  
  <entry>
    <title>排序(4) 冒泡排序</title>
    <link href="https://www.blogs.rhsphere.com/2019/04/01/bubble-sort.html"/>
    <id>https://www.blogs.rhsphere.com/2019/04/01/bubble-sort.html</id>
    <published>2019-04-01T08:13:30.000Z</published>
    <updated>2019-05-25T07:28:06.551Z</updated>
    
    <content type="html"><![CDATA[<p class="description">冒泡排序算法多次遍历数组，在每次遍历中连续比较相邻的元素，如果元素没有按照顺序排列，则互换他们的值。 博客中先给出了朴素版本，再给出了优化了每一轮内循环结束点（减少遍历轮次）的needNextPass版本和isSorted版本，还有进一步优化判断边界的sortBorder版本，sortBorder版本为最优化版本。</p><a id="more"></a><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>冒泡排序算法需要遍历几次数组。在每次遍历中，比较连续相邻的元素。如果某一堆元素是降序，则互换他们的值；否则，保持不变。<br>由于较小的值像“气泡”一样逐渐浮向顶部，而较大的值沉向底部，由此得名冒泡排序（bubble sort）或下沉排序（sinking sort）。</p><p>冒泡排序的名字很形象，实际实现是相邻两节点进行比较，大的向后移一个，经过第一轮两两比较和移动，最大的元素移动到了最后，第二轮次大的位于倒数第二个，依次进行。这是最基本的冒泡排序，还可以进行一些优化。</p><p><strong>优化一：</strong> 如果某一轮两两比较中没有任何元素交换，这说明已经都排好序了，算法结束，可以使用一个isSorted做标记，默认为true，如果发生交互则置为false，每轮结束时检测isSorted，如果为false则继续，如果为true则返回。</p><p><strong>优化二：</strong> 某一轮结束位置为j，但是这一轮的最后一次交换发生在lastExchangedIndex的位置，则lastExchangedIndex到j之间是排好序的，下一轮的结束点就不必是j–了，而直接到lastExchangedIndex即可。</p><h3 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h3><p>第一次遍历后，最后一个元素称为数组中的最大数。第二次遍历后，倒数第二个元素成为数组中的第二大数。整个过程持续到所有元素都已排好序。<br>第k次遍历时，不需要考虑最后k-1个元素，因为它们已经排好序了。</p><p>朴素版本伪代码描述：<br><figure class="highlight java"><figcaption><span>朴素版本伪代码</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; arr.length; k++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - k; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; arr[i + <span class="number">1</span>])</span><br><span class="line">            swap arr[i] with arr[i + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意到如果在某次遍历中没有发生交换，那么就不必进行下一次遍历，因为所有的元素已经排好序了。可以用下面的伪代码描述needNextPass版本：<br>如果某一轮两两比较中没有任何元素交换，这说明已经都排好序了，算法结束，可以使用一个needNextPass做标记，默认为false，如果发生交互则置为true，每轮结束时检测needNextPass，如果为true则继续，如果为false则返回。</p><figure class="highlight java"><figcaption><span>needNextPass版本伪代码</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> needNextPass = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; arr.length &amp;&amp; needNextPass; k++) &#123;</span><br><span class="line">    <span class="comment">// 数组可能已经排好序，不需要再进入下次循环</span></span><br><span class="line">    needNextPass = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 第k次遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - k; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; arr[i + <span class="number">1</span>]) &#123;</span><br><span class="line">            swap arr[i] with arr[i + <span class="number">1</span>];</span><br><span class="line">            needNextPass = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="冒泡排序朴素版本"><a href="#冒泡排序朴素版本" class="headerlink" title="冒泡排序朴素版本"></a>冒泡排序朴素版本</h2><p>代码非常简单，使用双循环来进行排序。外部循环控制所有的回合，内部循环代表每一轮冒泡处理，先进行元素比较，再进行元素交换。这种写法不会拿到offer的。</p><figure class="highlight java"><figcaption><span>java实现朴素版本</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 内部循环代表每一轮冒泡处理</span></span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; arr.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j + <span class="number">1</span>] &lt; arr[j]) &#123;</span><br><span class="line">                    tmp = arr[j];</span><br><span class="line">                    arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                    arr[j + <span class="number">1</span>] = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">5</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">7</span> &#125;;</span><br><span class="line">        bubbleSort(array);</span><br><span class="line">        System.out.println(Arrays.toString(array));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显可以看出，自从经过第六轮排序，整个数列已然是有序的了。可是我们的排序算法仍然“兢兢业业”地继续执行第七轮、第八轮。<br><strong>这种情况下，如果我们能判断出数列已经有序，并且做出标记，剩下的几轮排序就可以不必执行，提早结束工作。</strong></p><h2 id="冒泡排序优化一"><a href="#冒泡排序优化一" class="headerlink" title="冒泡排序优化一"></a>冒泡排序优化一</h2><p>第一步优化，可以使用needNextPass版本或者isSorted版本。这两个版本的含义，从两个flag的字面就能理解其作用。本质上是一样的。</p><h3 id="needNextPass版本代码"><a href="#needNextPass版本代码" class="headerlink" title="needNextPass版本代码"></a>needNextPass版本代码</h3><p>如果某一轮两两比较中没有任何元素交换，这说明已经都排好序了，那么就不必进行下一次遍历，因为所有的元素都已排好序，算法结束。</p><p>可以使用一个needNextPass做标记，默认为false，如果发生交换则置为true，每轮结束时检测needNextPass，如果为true则继续，如果为false则返回。</p><figure class="highlight java"><figcaption><span>needNextPass版本</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> needNextPass = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length &amp;&amp; needNextPass; i++) &#123;</span><br><span class="line">            needNextPass = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length - i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> tmp = arr[j];</span><br><span class="line">                    arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                    arr[j + <span class="number">1</span>] = tmp;</span><br><span class="line">                    <span class="comment">//  改变标志位</span></span><br><span class="line">                    needNextPass = <span class="keyword">true</span>;</span><br><span class="line">                &#125;                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] list = &#123; <span class="number">2</span>, <span class="number">32</span>, <span class="number">3</span>, <span class="number">34</span>, <span class="number">45</span>, <span class="number">8</span>, <span class="number">89</span>, <span class="number">20</span>, <span class="number">23</span>, -<span class="number">1</span>, -<span class="number">2</span> &#125;;</span><br><span class="line">        bubbleSort(list);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : list)</span><br><span class="line">            System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="isSorted版本代码"><a href="#isSorted版本代码" class="headerlink" title="isSorted版本代码"></a>isSorted版本代码</h3><p>这一版代码做了小小的改动，利用布尔变量isSorted作为标记。如果在本轮排序中，元素有交换，则说明数列无序；如果没有元素交换，说明数列已然有序，直接跳出大循环。</p><p>如果某一轮两两比较中没有任何元素交换，这说明已经都排好序了，算法结束，可以使用一个isSorted做标记，默认为true，如果发生交换则置为false，每轮结束时检测isSorted，如果为false则继续，如果为true则返回。</p><figure class="highlight java"><figcaption><span>isSorted版本</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> isSorted = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    tmp = arr[j];</span><br><span class="line">                    arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                    arr[j + <span class="number">1</span>] = tmp;</span><br><span class="line"></span><br><span class="line">                    isSorted = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (isSorted) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] list = &#123; <span class="number">2</span>, <span class="number">32</span>, <span class="number">3</span>, <span class="number">34</span>, <span class="number">45</span>, <span class="number">8</span>, <span class="number">89</span>, <span class="number">20</span>, <span class="number">23</span>, -<span class="number">1</span>, -<span class="number">2</span> &#125;;</span><br><span class="line">        bubbleSort(list);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : list)</span><br><span class="line">            System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="sortBorder版本-结合优化一和优化二"><a href="#sortBorder版本-结合优化一和优化二" class="headerlink" title="sortBorder版本(结合优化一和优化二)"></a>sortBorder版本(结合优化一和优化二)</h2><h3 id="具体分析"><a href="#具体分析" class="headerlink" title="具体分析"></a>具体分析</h3><p>为了说明问题，用下面的数列为例（在纸上演示一下）：<br>{3, 4, 2, 1, 5, 6, 7, 8}<br>这个数组的特点是前半部分{3, 4, 2, 1}无序，后半部分{5, 6, 7, 8}有序，并且后半部分的元素已经是数列最大值。</p><p>按照冒泡排序的思路来排序：</p><p>第一轮：</p><ul><li>元素3和4比较，发现3小于4，所以位置不变；</li><li>元素4和2比较，发现4大于2，所以4和2交换；</li><li>元素4和1比较，发现4大于1，所以4和1交换。</li></ul><p>此时数列：{3, 2, 1, 4, 5, 6, 7, 8}</p><p>但是接下来：</p><ul><li>元素4和5比较，发现4小于5，所以位置不变；</li><li>元素5和6比较，发现5小于6，所以位置不变；</li><li>元素6和7比较，发现6小于7，所以位置不变；</li><li>元素7和8比较，发现7小于8，所以位置不变。</li></ul><p>第一轮结束，数列有序区包含一个元素： 8<br>{3, 2, 1, 4, 5, 6, 7, 8}</p><p>第二轮：</p><ul><li>元素3和2比较，发现3大于2，所以3和2交换；</li><li>元素3和1比较，发现3大于1，所以3和1交换。</li></ul><p>此时数列：{2, 1, 3, 4, 5, 6, 7, 8}</p><p>但是接下来</p><ul><li>元素3和4比较，发现3小于4，所以位置不变；</li><li>元素4和5比较，发现4小于5，所以位置不变；</li><li>元素5和6比较，发现5小于6，所以位置不变；</li><li>元素6和7比较，发现6小于7，所以位置不变；</li><li>元素7和8比较，发现7小于8，所以位置不变。</li></ul><p>第二轮结束，数列有序区包含一个元素： 7, 8<br>{2, 1, 3, 4, 5, 6, 7, 8}</p><p><strong>由上面两轮分析，发现问题：右面的许多元素已经是有序了，可是每一轮还是白白比较了许多次。这正是冒泡排序当中另一个需要优化的点。</strong></p><p>接下来的讨论，在代码实现部分进行。</p><h3 id="完全优化版本代码"><a href="#完全优化版本代码" class="headerlink" title="完全优化版本代码"></a>完全优化版本代码</h3><p>这个问题的关键点在哪里呢？<strong>关键在于对数列有序区的界定。</strong></p><p>按照现有的逻辑，有序区的长度和排序的轮数是相等的。比如第一轮排序过后的有序区长度是1，第二轮排序过后的有序区长度是2,……</p><p>实际上，数列真正的有序区可能会大于这个长度，比如例子中仅仅第二轮，后面5个元素实际都已经属于有序区。因此后面的许多次元素比较是没有意义的。</p><p>如何避免这种情况呢？我们可以在每一轮排序的最后，<strong>记录下最后一次元素交换的位置，那个位置也就是无序数列的边界，再往后就是有序区了</strong>。</p><figure class="highlight java"><figcaption><span>sortBorder版本（完美版本）</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//记录最后一次交换的位置</span></span><br><span class="line">        <span class="keyword">int</span> lastExchangedIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//无序数列的边界，每次比较只需要比到这里为止        </span></span><br><span class="line">        <span class="keyword">int</span> sortBorder = arr.length - <span class="number">1</span>;  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="comment">//有序标记，每一轮的初始是true</span></span><br><span class="line">            <span class="keyword">boolean</span> isSorted = <span class="keyword">true</span>;    </span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; sortBorder; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    tmp = arr[j];</span><br><span class="line">                    arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                    arr[j + <span class="number">1</span>] = tmp;</span><br><span class="line">                    <span class="comment">//有元素交换，所以不是有序，标记变为false</span></span><br><span class="line">                    isSorted = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//把无序数列的边界更新为最后一次交换元素的位置</span></span><br><span class="line">                    lastExchangedIndex = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            sortBorder = lastExchangedIndex;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (isSorted) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">5</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">7</span> &#125;;</span><br><span class="line">        bubbleSort(array);</span><br><span class="line">        System.out.println(Arrays.toString(array));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一版代码中，sortBorder就是无序数列的边界。每一轮排序过程中，sortBorder之后的元素就完全不需要比较了，肯定是有序的。</p><h2 id="算法复杂度和稳定性"><a href="#算法复杂度和稳定性" class="headerlink" title="算法复杂度和稳定性"></a>算法复杂度和稳定性</h2><p>其实这样的实现，仍然不是最优，有一种排序算法叫做 <strong>鸡尾酒排序</strong>，是基于冒泡排序的一种升级。具体见博客<a href="https://blogs.rhsphere.com/leetcode/2019/04/01/cock-tail-sort.html" target="_blank" rel="noopener">鸡尾酒排序</a>。</p><p>算法复杂度：<br>时间复杂度（平均）： O(n^2)<br>时间复杂度（最坏）： O(n^2)<br>时间复杂度（最好）： O(n)</p><p>空间复杂度：  O(1)</p><p>冒泡排序把小元素往前调或者把大元素往后调，在相邻的两个元素间比较和交换。<br>如果两个元素相等且相邻，它们不会进行交换；如果两个相等的元素没有相邻，那么即使通过前面的两两交换把两个相邻起来，这时候也不会交换。</p><p>所以相同元素的前后顺序并没有改变，冒泡排序是一种 <strong>稳定</strong>排序算法。</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;冒泡排序算法多次遍历数组，在每次遍历中连续比较相邻的元素，如果元素没有按照顺序排列，则互换他们的值。 博客中先给出了朴素版本，再给出了优化了每一轮内循环结束点（减少遍历轮次）的needNextPass版本和isSorted版本，还有进一步优化判断边界的sortBorder版本，sortBorder版本为最优化版本。&lt;/p&gt;
    
    </summary>
    
      <category term="Sorting" scheme="https://www.blogs.rhsphere.com/categories/Sorting/"/>
    
    
      <category term="sort" scheme="https://www.blogs.rhsphere.com/tags/sort/"/>
    
      <category term="BubbleSort" scheme="https://www.blogs.rhsphere.com/tags/BubbleSort/"/>
    
  </entry>
  
  <entry>
    <title>排序(3) 希尔排序</title>
    <link href="https://www.blogs.rhsphere.com/2019/04/01/shell-sort.html"/>
    <id>https://www.blogs.rhsphere.com/2019/04/01/shell-sort.html</id>
    <published>2019-04-01T08:13:27.000Z</published>
    <updated>2019-05-25T07:28:06.551Z</updated>
    
    <content type="html"><![CDATA[<p class="description">希尔排序又叫缩小增量排序，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。 希尔排序是对插入排序的优化，基于以下两个认识：1.数据量较小时插入排序速度较快，因为n和n²差距很小；2.数据基本有序时插入排序效率很高，因为比较和移动的数据量少。 希尔排序的时间复杂度和增量的选择策略有关，博客中的选择策略会导致排序的不稳定性。</p><a id="more"></a><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>因此，希尔排序的基本思想是，将需要排序的序列划分成为若干个较小的子序列，对子序列进行插入排序，通过插入排序能够使得原来序列成为基本有序。这样通过对较小的序列进行插入排序，然后对基本有序的数列进行插入排序，能够提高插入排序算法的效率。</p><p>希尔排序的划分子序列不是像归并排序那种的二分，而是采用的叫做增量的技术，例如有十个元素的数组进行希尔排序，首先选择增量为10/2=5，此时第1个元素和第（1+5）个元素配对成子序列使用插入排序进行排序，第2和（2+5）个元素组成子序列，完成后增量继续减半为2，此时第1个元素、第（1+2）、第（1+4）、第（1+6）、第（1+8）个元素组成子序列进行插入排序。这种增量选择方法的好处是可以使数组整体均匀有序，尽可能的减少比较和移动的次数。<br>二分法中即使前一半数据有序，后一半中如果有比较小的数据，还是会造成大量的比较和移动，因此这种增量的方法和插入排序的配合更佳。</p><p>在此我们选择增量gap=length/2，缩小增量继续以gap = gap/2的方式，这种增量选择我们可以用一个序列来表示，{n/2, (n/2)/2, …, 1}，称为增量序列。希尔排序的增量序列的选择与证明是个数学难题，我们选择的这个增量序列是比较常用的，也是希尔建议的增量，称为希尔增量，但其实这个增量序列不是最优的。</p><p>希尔排序的时间复杂度和增量的选择策略有关，上述增量方法造成希尔排序的不稳定性。</p><p>因为直接插入排序在元素基本有序的情况下，效率是很高的，因此希尔排序在时间效率上有很大提高。 </p><h3 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h3><p>无序序列：int a[] = {3, 1, 5, 7, 2, 4, 9, 6};</p><p>第一趟时：<br>n=8; gap = n/2 = 4； 把整个序列共分成了4个子序列{3, 2}、{1, 4}、{5, 9}、{7, 6}<br>第一趟结束时，数列为：{2, 1, 5, 6, 3, 4, 9, 7};</p><p>第二趟时：<br>gap = gap/2 = 2； 把整个序列共分成了2个子序列{2, 5, 3, 9}、{1, 6, 4, 7}<br>第一趟结束时，数列为：{2, 1, 3, 4, 5, 6, 9, 7};</p><p>第三趟时：<br>gap = gap/2 = 1； 对整个序列进行 <strong>插入排序</strong></p><p>##代码实现<br><figure class="highlight java"><figcaption><span>Shell排序</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShellSort</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] shellSort(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> gap = arr.length / <span class="number">2</span>; gap &gt;= <span class="number">1</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line"><span class="comment">// 对子序列插入排序</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; arr.length; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> j = i;</span><br><span class="line"><span class="keyword">int</span> currentElement = arr[i];</span><br><span class="line"><span class="keyword">while</span> (j - gap &gt;= <span class="number">0</span> &amp;&amp; arr[j - gap] &gt; currentElement) &#123;</span><br><span class="line">arr[j] = arr[j - gap];</span><br><span class="line">j -= gap;</span><br><span class="line">&#125;</span><br><span class="line">arr[j] = currentElement;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] testList = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; -<span class="number">6</span>, -<span class="number">3</span>, -<span class="number">2</span>, <span class="number">7</span>, -<span class="number">15</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">int</span>[] test = shellSort(testList);</span><br><span class="line">System.out.println(Arrays.toString(test));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="复杂度及稳定性"><a href="#复杂度及稳定性" class="headerlink" title="复杂度及稳定性"></a>复杂度及稳定性</h2><h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><p>时间复杂度（平均）： O(n^1.3)<br>时间复杂度（最坏）： O(n^2)<br>时间复杂度（最好）： O(n)</p><p>空间复杂度：  O(1)</p><h3 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h3><p>Shell排序通过将数据分成不同的组，先对每一组进行排序，然后再对所有的元素进行一次插入排序，以减少数据交换和移动的次数。</p><p><strong>希尔排序是按照不同步长对元素进行插入排序，当刚开始元素很无序的时候，步长最大，所以插入排序的元素个数很少，速度很快；当元素基本有序了，步长很小，插入排序对于有序的序列效率很高。</strong></p><p>由于多次插入排序，我们知道一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱，所以，Shell排序是 <strong>不稳定的</strong>。</p><p>例如，有100个整数需要排序：<br>第一趟排序，先把它分成50组，每组2个整数，分别排序。<br>第二趟排序，再把经过第一趟排序后的100个整数分成25组，每组4个整数，分别排序。<br>第三趟排序，再把前一次排序后的数分成12组，第组8个整数，分别排序。</p><p>照这样子分下去，最后一趟分成100组，每组一个整数，这就相当于一次插入排序。<br>由于开始时每组只有很少整数，所以排序很快。之后每组含有的整数越来越多，但是由于这些数也越来越有序，所以排序速度也很快。</p><p>希尔排序平均效率是O(nlogn)，其中分组的合理性会对算法产生重要的影响。</p><p>Shell排序比冒泡排序快5倍，比插入排序大致快2倍。<br>Shell排序比起QuickSort，MergeSort，HeapSort慢很多。但是它相对比较简单，它适合于数据量在5000以下并且速度并不是特别重要的场合。它对于数据量较小的数列重复排序是非常好的。</p><p>由于开始时每组只有很少整数，所以排序很快。之后每组含有的整数越来越多，但是由于这些数也越来越有序，所以排序速度也很快。<br>然而，情况并不总是这么理想的，在一些特定（但并不算罕见）的情况下，虽然经过了很多趟排序但是数据却没有变得更有序。例如，如果用上面的算法对下面这些数进行排序：<br>1, 9, 2, 10, 3, 11, 4, 12, 5, 13, 6, 14, 7, 15, 8, 16</p><p><strong>在gap = 1之前的每一趟排序都在浪费时间！</strong></p><p>这种坏情形是可以避免的，就是把上面的增量数列（1, 2, 4, 8）改成Hibbard增量（1, 3, 5, 7）由此可见，增量数列的选择对希尔排序的性能有着极大的影响。</p><p>Mark Allen Weiss指出，最好的增量序列是Sedgewick提出的 (1, 5, 19, 41, 109, …)，该序列的项来自 9 <em> 4^i - 9 </em> 2^i + 1 和 4^i - 3 * 2^i + 1 这两个算式。</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;希尔排序又叫缩小增量排序，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。 希尔排序是对插入排序的优化，基于以下两个认识：1.数据量较小时插入排序速度较快，因为n和n²差距很小；2.数据基本有序时插入排序效率很高，因为比较和移动的数据量少。 希尔排序的时间复杂度和增量的选择策略有关，博客中的选择策略会导致排序的不稳定性。&lt;/p&gt;
    
    </summary>
    
      <category term="Sorting" scheme="https://www.blogs.rhsphere.com/categories/Sorting/"/>
    
    
      <category term="sort" scheme="https://www.blogs.rhsphere.com/tags/sort/"/>
    
      <category term="ShellSort" scheme="https://www.blogs.rhsphere.com/tags/ShellSort/"/>
    
  </entry>
  
  <entry>
    <title>排序(2) 插入排序</title>
    <link href="https://www.blogs.rhsphere.com/2019/04/01/insertion-sort.html"/>
    <id>https://www.blogs.rhsphere.com/2019/04/01/insertion-sort.html</id>
    <published>2019-04-01T08:13:17.000Z</published>
    <updated>2019-06-08T02:17:02.922Z</updated>
    
    <content type="html"><![CDATA[<p class="description">插入排序重复地将新的元素插入到一个排好序的子线性表中，直到整个线性表排好序。 遍历数组，遍历到i时，a0,a1,…,ai-1是已经排好序的，取出ai，从ai-1开始向前和每个比较大小，如果小于，则将此位置元素向后移动，继续先前比较，如果不小于，则放到正在比较的元素之后。可见相等元素比较是，原来靠后的还是排在后边，所以插入排序是稳定的。 当待排序的数据基本有序时，插入排序的效率比较高，只需要进行很少的数据移动。</p><a id="more"></a><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>遍历数组，遍历到i时，a0,a1,…,ai-1是已经排好序的，取出ai，从ai-1开始向前和每个比较大小，如果小于，则将此位置元素向后移动，继续先前比较，如果不小于，则放到正在比较的元素之后。<br>可见相等元素比较是，原来靠后的还是排在后边，所以插入排序是稳定的。<br>当待排序的数据基本有序时，插入排序的效率比较高，只需要进行很少的数据移动。</p><p><strong>插入排序的一个重要的特点是，如果原始数据的大部分元素已经排序，那么插入排序的速度很快（因为需要移动的元素很少）。从这个事实我们可以想到，如果原始数据只有很少元素，那么排序的速度也很快。</strong><br>－－希尔排序就是基于这两点对插入排序作出了改进。</p><h3 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h3><p>对数列{2, 9, 5, 4, 8, 1, 6}进行排序，可以自己模拟对未排序的数列{9, 5, 4, 8, 1, 6}插入排序，直到数列排好序。</p><p>这个算法可以描述为：<br><figure class="highlight java"><figcaption><span>插入排序伪代码</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    将arr[i]插入到已排好序的只线性表中，这样arr[<span class="number">0</span> ... i]也是排好序的</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>插入arr[i]到arr[0, …, i-1]中有下面的过程：<br>1.将arr[i]存储在一个名为currentElement的临时变量中；<br>2.如果arr[i - 1] &gt; currentElement，就将arr[i - 1]移到arr[i]中；<br>3.如果arr[i - 2] &gt; currentElement，就将arr[i - 2]移到arr[i - 1]中；<br>4.依此类推，直到arr[i - k] &lt;= currentElement 或者 k &gt; i(传递的是排好序的数列的第一个元素)， 将currentElement赋值给arr[i - k + 1]。</p><h2 id="插入排序代码"><a href="#插入排序代码" class="headerlink" title="插入排序代码"></a>插入排序代码</h2><p>插入排序的过程很好理解，代码如下：</p><figure class="highlight java"><figcaption><span>插入排序</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertionSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 插入arr[i]到已经排好序的子线性表arr[0 ... i-1]中</span></span><br><span class="line">            <span class="keyword">int</span> currentElement = arr[i];</span><br><span class="line">            <span class="keyword">int</span> k;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (k = i - <span class="number">1</span>; k &gt;= <span class="number">0</span> &amp;&amp; arr[k] &gt; currentElement; k--) &#123;</span><br><span class="line">                arr[k+<span class="number">1</span>] = arr[k];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//  插入当前元素到arr[k+1]中</span></span><br><span class="line">            arr[k + <span class="number">1</span>] = currentElement;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] list = &#123;<span class="number">2</span>, <span class="number">32</span>, <span class="number">3</span>, <span class="number">34</span>, <span class="number">45</span>, <span class="number">8</span>, <span class="number">89</span>, <span class="number">20</span>, <span class="number">23</span>, -<span class="number">1</span>&#125;;        </span><br><span class="line">        insertionSort(list);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i: list)</span><br><span class="line">            System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内外层循环的作用：<br>外层循环（循环控制变量i）的迭代是为了获取已排好序的子线性表，其范围是arr[0] 到arr[i]。</p><p>内层循环（循环控制变量k）将arr[i]插入到arr[0]到arr[i-1]的子线性表。</p><h2 id="复杂度和稳定性"><a href="#复杂度和稳定性" class="headerlink" title="复杂度和稳定性"></a>复杂度和稳定性</h2><p>时间复杂度（平均）： O(n^2)<br>时间复杂度（最坏）： O(n^2)<br>时间复杂度（最好）： O(n)</p><p>空间复杂度：  O(1)</p><p>因为在有序部分元素和待插入元素相等的时候，可以将待插入的元素放在前面，所以插入排序是 <strong>稳定的</strong>。</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;插入排序重复地将新的元素插入到一个排好序的子线性表中，直到整个线性表排好序。 遍历数组，遍历到i时，a0,a1,…,ai-1是已经排好序的，取出ai，从ai-1开始向前和每个比较大小，如果小于，则将此位置元素向后移动，继续先前比较，如果不小于，则放到正在比较的元素之后。可见相等元素比较是，原来靠后的还是排在后边，所以插入排序是稳定的。 当待排序的数据基本有序时，插入排序的效率比较高，只需要进行很少的数据移动。&lt;/p&gt;
    
    </summary>
    
      <category term="Sorting" scheme="https://www.blogs.rhsphere.com/categories/Sorting/"/>
    
    
      <category term="sort" scheme="https://www.blogs.rhsphere.com/tags/sort/"/>
    
      <category term="InsertionSort" scheme="https://www.blogs.rhsphere.com/tags/InsertionSort/"/>
    
  </entry>
  
  <entry>
    <title>排序(1) 选择排序</title>
    <link href="https://www.blogs.rhsphere.com/2019/04/01/selection-sort.html"/>
    <id>https://www.blogs.rhsphere.com/2019/04/01/selection-sort.html</id>
    <published>2019-04-01T08:12:38.000Z</published>
    <updated>2019-05-25T07:28:06.550Z</updated>
    
    <content type="html"><![CDATA[<p class="description">选择排序是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。  遍历数组，遍历到i时，a0,a1,…,ai-1是已经排好序的，然后从i到n选择出最小的，记录下位置，如果不是第i个，则和第i个元素交换。此时第i个元素可能会排到相等元素之后，造成排序的不稳定。</p><a id="more"></a><h2 id="选择排序（最小元素）"><a href="#选择排序（最小元素）" class="headerlink" title="选择排序（最小元素）"></a>选择排序（最小元素）</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>假设要按照升序排列一个数列 {2, 9, 5, 4, 8, 1, 6}。<br>选择排序法首先找到数列中最小的数，然后将它和第一个元素交换。接下来，在剩下的数中找到最小数，将它和第二个元素交换，以此类推，直到数列中仅剩一个数为止。</p><p>可以在纸上模拟一下具体选择排序过程。 </p><p>开始编写第一次迭代的代码，找出数列中的最大数，将其与最后一个元素互换，然后观察第二次迭代与第一次的不同之处，接着是第三次，以此类推。通过这样的观察可以写出推广到所有迭代的循环。</p><figure class="highlight java"><figcaption><span>解决方案伪代码</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">select the smallest element in arr[i ... arr.length-<span class="number">1</span>];</span><br><span class="line">swap the smallest with arr[i], <span class="keyword">if</span> necessary;</span><br><span class="line"></span><br><span class="line"><span class="comment">// arr[i] is in its correct position</span></span><br><span class="line"><span class="comment">// the next iteration applies on arr[i+1 ... arr.length-1]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="java实现选择排序（最小元素）"><a href="#java实现选择排序（最小元素）" class="headerlink" title="java实现选择排序（最小元素）"></a>java实现选择排序（最小元素）</h3><p>代码实现过程比较简单，如下：</p><figure class="highlight java"><figcaption><span>选取最小值的选择排序</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectionSort</span> </span>&#123;</span><br><span class="line"><span class="comment">//  选择排序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; = <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> currentMin;</span><br><span class="line">        <span class="keyword">int</span> currentMinIndex;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//  找到最小值和最小值下标位置，在范围arr[i  ... arr.length-1]</span></span><br><span class="line">            currentMin = arr[i];</span><br><span class="line">            currentMinIndex = i;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (currentMin &gt; arr[j]) &#123;</span><br><span class="line">                    currentMin = arr[j];</span><br><span class="line">                    currentMindIndex = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (currentMinIndex != i) &#123;</span><br><span class="line">                arr[currentMinIndex] = arr[i];</span><br><span class="line">                arr[i] = currentMin;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] list = &#123;<span class="number">2</span>, <span class="number">32</span>, <span class="number">3</span>, <span class="number">34</span>, <span class="number">45</span>, <span class="number">8</span>, <span class="number">89</span>, <span class="number">20</span>, <span class="number">23</span>&#125;;        </span><br><span class="line">        selectionSort(list);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i: list)</span><br><span class="line">            System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="选择排序（最大值）"><a href="#选择排序（最大值）" class="headerlink" title="选择排序（最大值）"></a>选择排序（最大值）</h2><p>上面的选择排序法重复地在当前数组中找到最小值，然后将这个最小值与该数组中的第一个数进行交换。<br>修改成：<br>重复地选取当前数组中最大值，然后将这个最大值与该数组中的最后一个数进行交换，直到数组中的第一个元素。</p><figure class="highlight java"><figcaption><span>选择最大值的选择排序</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectionSort</span></span>&#123;</span><br><span class="line"><span class="comment">// 选择排序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> currentMax;</span><br><span class="line">        <span class="keyword">int</span> currentMaxIndex;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = list.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            currentMax = list[i];</span><br><span class="line">            currentMaxIndex = i;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (currentMax &lt; arr[j]) &#123;</span><br><span class="line">                    currentMax = arr[j];</span><br><span class="line">                    currentMaxIndex = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (currentMaxIndex != i) &#123;</span><br><span class="line">                arr[currentMaxIndex] = arr[i];</span><br><span class="line">                arr[i] = currentMax;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ========测试用例略=========</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h2><p>选择排序复杂度：<br>时间复杂度（平均）： O(n^2)<br>时间复杂度（最坏）： O(n^2)<br>时间复杂度（最好）： O(n^2)</p><p>空间复杂度：  O(1)</p><h2 id="选择排序稳定性"><a href="#选择排序稳定性" class="headerlink" title="选择排序稳定性"></a>选择排序稳定性</h2><p><strong>选择排序是不稳定的算法。</strong></p><h3 id="算法稳定性定义"><a href="#算法稳定性定义" class="headerlink" title="算法稳定性定义"></a>算法稳定性定义</h3><p>在待排序的数据中，存在多个相同的数据，经过排序之后，他们的对相对顺序依旧保持不变，实际上就是说 array[i] = array[j], i &lt; j<br>就是array[i]在array[j]之前，那么经过排序之后array[i]依旧在array[j]之前，那么这个排序算法稳定，否则，这个排序算法不稳定</p><p>也就是说，只要能举出一个反例来说明这个算法不稳定，那么这个算法就是不稳定的</p><p>针对选择排序算法，如下反例：<br>数列 {5, 8, 5, 2, 9}</p><p>这个在执行选择排序的时候，第一遍，肯定会将array[0]=5，交换到2所在的位置:<br>也就是 {2, 8, 5, 5, 9}</p><p>那么很显然，之后的排序我们就会发现，array[2]中的5会出现在原先的array[0]之前，所以选择排序不是一个稳定的排序。</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;选择排序是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。  遍历数组，遍历到i时，a0,a1,…,ai-1是已经排好序的，然后从i到n选择出最小的，记录下位置，如果不是第i个，则和第i个元素交换。此时第i个元素可能会排到相等元素之后，造成排序的不稳定。&lt;/p&gt;
    
    </summary>
    
      <category term="Sorting" scheme="https://www.blogs.rhsphere.com/categories/Sorting/"/>
    
    
      <category term="SelectionSort" scheme="https://www.blogs.rhsphere.com/tags/SelectionSort/"/>
    
      <category term="sort" scheme="https://www.blogs.rhsphere.com/tags/sort/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer(9) 用两个栈实现队列</title>
    <link href="https://www.blogs.rhsphere.com/2019/03/29/queue-with-two-stacks.html"/>
    <id>https://www.blogs.rhsphere.com/2019/03/29/queue-with-two-stacks.html</id>
    <published>2019-03-29T15:18:53.000Z</published>
    <updated>2019-10-08T15:25:31.299Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数appendTail和deleteHead，分别完成在队列尾部插入结点和在队列头部删除结点的功能。</p><h1 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>插入删除的过程（在草稿纸上动手画一下）：</p><ul><li>插入肯定是往一个栈stack1中一直插入；</li><li>删除时，直接出栈无法实现队列的先进先出规则，这时需要将元素从stack1出栈，压到另一个栈stack2中，然后再从stack2中出栈就OK了。 </li><li>需要稍微注意的是：当stack2中还有元素，stack1中的元素不能压进来；当stack2中没元素时，stack1中的所有元素都必须压入stack2中。否则顺序就会被打乱。</li></ul><h3 id="测试用例："><a href="#测试用例：" class="headerlink" title="测试用例："></a>测试用例：</h3><ol><li>往空队列添加、删除元素</li><li>往非空队列里添加、删除元素</li><li>连续删除元素至队列为空</li></ol><h2 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueWithStacks</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Queue</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 插入节点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">            stack1.push(node);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 删除节点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (stack2.empty()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (stack1.empty()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"队列为空"</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span> (!stack1.empty())</span><br><span class="line">                        stack2.push(stack1.pop());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> stack2.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// =======测试代码==========</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Queue queue = <span class="keyword">new</span> Queue();</span><br><span class="line">        queue.push(<span class="number">1</span>);</span><br><span class="line">        queue.push(<span class="number">2</span>);</span><br><span class="line">        System.out.println(queue.pop());</span><br><span class="line">        queue.push(<span class="number">3</span>);</span><br><span class="line">        System.out.println(queue.pop());</span><br><span class="line">        System.out.println(queue.pop());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 往空队列删除元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Queue queue = <span class="keyword">new</span> Queue();</span><br><span class="line">        System.out.println(queue.pop());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        QueueWithStacks demo = <span class="keyword">new</span> QueueWithStacks();</span><br><span class="line">        demo.test1();</span><br><span class="line">        <span class="comment">// demo.test2();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>队列和栈的主要区别在于元素进出顺序，因此，需要修改peek()和pop()，以相反的顺序执行。<br>利用第二个栈反转元素的次序（弹出s1的元素，压入s2）。</p><p>在这种实现中，每当执行peek()和pop()操作时，就要将s1的所有元素弹出，压入s2中，然后执行peek()和pop()操作，再将元素压入s1.</p><p>但是若连续执行两次peek()和pop()操作，那么，所有元素移来移去，重复移动。 可以延迟元素的移动，即让元素一直留在s2中，只有必须反转元素次序是才移动元素。</p><p>stackNew顶端为最新元素，stackOld顶端为最旧元素。在将一个元素出列是，我们希望先移除最旧元素，因此先将元素从stackOld将元素出列。若stackOld为空，在将stackNew中所有元素以相反的顺序移到stackOld中。如果要插入元素，就将其压入stackNew，因为最新元素位于它的顶端。</p><h2 id="Java代码-1"><a href="#Java代码-1" class="headerlink" title="Java代码"></a>Java代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    Stack&lt;T&gt; stackNew, stackOld;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stackNew = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stackOld = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stackNew.size() + stackOld.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T val)</span> </span>&#123;</span><br><span class="line">        stackNew.push(val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">shiftStacks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stackOld.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stackNew.isEmpty()) &#123;</span><br><span class="line">                stackOld.push(stackNew.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        shiftStacks();</span><br><span class="line">        <span class="keyword">return</span> stackOld.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        shiftStacks();</span><br><span class="line">        <span class="keyword">return</span> stackOld.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="剑指Offer" scheme="https://www.blogs.rhsphere.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="Queue" scheme="https://www.blogs.rhsphere.com/tags/Queue/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer(8) 二叉树的下一个节点</title>
    <link href="https://www.blogs.rhsphere.com/2019/03/28/next-node-in-binary-tree.html"/>
    <id>https://www.blogs.rhsphere.com/2019/03/28/next-node-in-binary-tree.html</id>
    <published>2019-03-28T04:24:39.000Z</published>
    <updated>2019-08-28T16:41:54.734Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><h2 id="二叉树的下一个节点"><a href="#二叉树的下一个节点" class="headerlink" title="二叉树的下一个节点"></a>二叉树的下一个节点</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一棵二叉树和其中的一个结点，如何找出中序遍历顺序的下一个结点？ 树中的结点除了有两个分别指向左右子结点的指针以外，还有一个指向父结点的指针。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>首先自己在草稿纸上画图，进行分析（不再展开）。可以发现下一个结点的规律为：</p><ol><li>若当前节点有右子树，旗下一个节点为右子树中最左子节点；</li><li>若当前节点无右子树时，<ol><li>若当前节点为其父节点的左子结点时，其子啊一个节点为其父节点；</li><li>若当前节点为其父节点的右子节点时，继续向上遍历父节点的父节点，直到找到一个节点是其父节点的左子结点（与(1)中判断相同），该节点的父节点即为下一节点。</li></ol></li></ol><h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><ol><li>正常二叉树</li><li>左斜树、右斜树</li><li>单个节点</li><li>null</li><li>不同位置节点的下一节点(包含下一个节点为当前节点的右子树节点，右子树的最左子节点，父节点，跨层的父节点等；当前节点没有下一个节点)</li></ol><h2 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NextNodeInBinaryTrees</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeLinkNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line"></span><br><span class="line">        TreeLinkNode left = <span class="keyword">null</span>;</span><br><span class="line">        TreeLinkNode right = <span class="keyword">null</span>;</span><br><span class="line">        TreeLinkNode parent = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        TreeLinkNode(<span class="keyword">int</span> val) &#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeLinkNode <span class="title">getNext</span><span class="params">(TreeLinkNode pNode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.print(<span class="string">"节点为null"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pNode.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            pNode = pNode.right;</span><br><span class="line">            <span class="keyword">while</span> (pNode.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                pNode = pNode.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> pNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (pNode.parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pNode == pNode.parent.left) &#123;</span><br><span class="line">                <span class="keyword">return</span> pNode.parent;</span><br><span class="line">            &#125;</span><br><span class="line">            pNode = pNode.parent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NextNodeInBinaryTrees</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ==================================测试代码==================================</span></span><br><span class="line">    <span class="comment">// 创建树较为繁琐，未包括所有测试代码。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        TreeLinkNode node = <span class="keyword">null</span>;</span><br><span class="line">        TreeLinkNode nextNode = getNext(node);</span><br><span class="line">        <span class="keyword">if</span> (nextNode != <span class="keyword">null</span>)</span><br><span class="line">            System.out.println(nextNode.val);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            System.out.println(<span class="string">"无下一结点"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        TreeLinkNode node1 = <span class="keyword">new</span> TreeLinkNode(<span class="number">1</span>);</span><br><span class="line">        TreeLinkNode node2 = <span class="keyword">new</span> TreeLinkNode(<span class="number">2</span>);</span><br><span class="line">        TreeLinkNode node3 = <span class="keyword">new</span> TreeLinkNode(<span class="number">3</span>);</span><br><span class="line">        TreeLinkNode node4 = <span class="keyword">new</span> TreeLinkNode(<span class="number">4</span>);</span><br><span class="line">        node1.left = node2;</span><br><span class="line">        node1.right = node3;</span><br><span class="line">        node2.parent = node1;</span><br><span class="line">        node3.parent = node1;</span><br><span class="line">        node4.left = node1;</span><br><span class="line">        node1.parent = node4;</span><br><span class="line">        TreeLinkNode nextNodeOf1 = getNext(node1);</span><br><span class="line">        TreeLinkNode nextNodeOf2 = getNext(node2);</span><br><span class="line">        TreeLinkNode nextNodeOf3 = getNext(node3);</span><br><span class="line">        TreeLinkNode nextNodeOf4 = getNext(node4);</span><br><span class="line">        <span class="keyword">if</span> (nextNodeOf1 != <span class="keyword">null</span>)</span><br><span class="line">            System.out.println(<span class="string">"1结点的下一个结点值为："</span> + nextNodeOf1.val);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            System.out.println(<span class="string">"1结点无下一结点"</span>);</span><br><span class="line">        <span class="keyword">if</span> (nextNodeOf2 != <span class="keyword">null</span>)</span><br><span class="line">            System.out.println(<span class="string">"2结点的下一个结点值为："</span> + nextNodeOf2.val);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            System.out.println(<span class="string">"2结点无下一结点"</span>);</span><br><span class="line">        <span class="keyword">if</span> (nextNodeOf3 != <span class="keyword">null</span>)</span><br><span class="line">            System.out.println(<span class="string">"3结点的下一个结点值为："</span> + nextNodeOf3.val);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            System.out.println(<span class="string">"3结点无下一结点"</span>);</span><br><span class="line">        <span class="keyword">if</span> (nextNodeOf4 != <span class="keyword">null</span>)</span><br><span class="line">            System.out.println(<span class="string">"4结点的下一个结点值为："</span> + nextNodeOf4.val);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            System.out.println(<span class="string">"4结点无下一结点"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        NextNodeInBinaryTrees demo = <span class="keyword">new</span> NextNodeInBinaryTrees();</span><br><span class="line">        System.out.print(<span class="string">"test1:"</span>);</span><br><span class="line">        demo.test1();</span><br><span class="line">        System.out.print(<span class="string">"test2:"</span>);</span><br><span class="line">        demo.test2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>在面对复杂问题时要学会画图和举例分析。</li><li>在分情况讨论时，一定要考虑到所有情况，这些都是在写代码前需要考虑到的。</li></ol><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="剑指Offer" scheme="https://www.blogs.rhsphere.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="BinaryTree" scheme="https://www.blogs.rhsphere.com/tags/BinaryTree/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer(7) 重建二叉树</title>
    <link href="https://www.blogs.rhsphere.com/2019/03/27/construct-binary-tree.html"/>
    <id>https://www.blogs.rhsphere.com/2019/03/27/construct-binary-tree.html</id>
    <published>2019-03-27T13:31:48.000Z</published>
    <updated>2019-08-27T15:29:03.100Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><h1 id="根据前序和中序遍历重建二叉树"><a href="#根据前序和中序遍历重建二叉树" class="headerlink" title="根据前序和中序遍历重建二叉树"></a>根据前序和中序遍历重建二叉树</h1><h2 id="热身题目"><a href="#热身题目" class="headerlink" title="热身题目"></a>热身题目</h2><p>已知二叉树先序遍历序列是A-B-C-D-E-F-G，中序遍历序列是C-B-D-A-E-G-F。由这两个序列可唯一确定一颗二叉树。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>从先序遍历序列第一个节点可知二叉树根节点是A。</p><p>由节点A在中序遍历序列里位置可知该根点左子树包含节点 B-C-D，右子树包含节点 E-G-F。</p><p>由先序序列片段 B-C-D可知，B是A左子树根节点，再结合中序序列片段 C-B-D可知，C和D分别是B的左右子节点。<br>由先序序列片段E-F-G可知，E是A的右子节点，结合中序序列片段E-F-G可知，G和F均是E的右子树节点。</p><p>再由先序序列片段F-G和中序序列片段G-F可知，F是E的右子节点，并且G是F的左子结点。</p><h2 id="正题"><a href="#正题" class="headerlink" title="正题"></a>正题</h2><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。 例如输入前序遍历序列{1, 2, 4, 7, 3, 5, 6, 8}和中序遍历序列{4, 7, 2, 1, 5, 3, 8, 6}，则重建出其二叉树并输出它的头结点。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>前序遍历第一个值就是根结点的值，根据该值在中序遍历的位置，可以轻松找出该根结点左右子树的前序遍历和中序遍历，之后又可以用同样方法构建左右子树，所以该题可以采用递归的方法完成。</p><p>刚开始思考的时候，想的是构建一个遍历函数，输入为前序和中序遍历的数组，输出为根结点。但是这样的话每次都需要构建子树的数组，非常麻烦。</p><p>之后想到，该函数的输入不一定要用数组，因为最初的前序和中序遍历数组已经有了，就直接用该数组的下标来表示子树的数组即可。</p><p>即构建函数 construct(int[] pre, int[] in, int pStart, int pEnd, int iStart, int iEnd) ，pre和in始终用最初前序遍历和中序遍历的数组代入，pStart、pEnd代表当前树的前序数组开始和结束位置，iStart、iEnd代表中序数组开始和结束位置。</p><h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><ol><li>正常二叉树</li><li>左斜树</li><li>右斜树</li><li>单个结点</li><li>数组为空</li><li>前序与中序不匹配</li></ol><h2 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstructBinaryTree</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span>[] pre, <span class="keyword">int</span>[] in)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pre == <span class="keyword">null</span> || in == <span class="keyword">null</span> || pre.length &lt;= <span class="number">0</span> || in.length &lt;= <span class="number">0</span> || pre.length != in.length) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"数组不符合规范"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> construct(pre, in, <span class="number">0</span>, pre.length - <span class="number">1</span>, <span class="number">0</span>, in.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span> 由前序遍历序列和中序遍历序列得到根结点 pre、in：始终用最初的前序遍历和中序遍历数组代入</span></span><br><span class="line"><span class="comment">     *              pStart、pEnd：当前树的前序数组开始和结束位置 iStart、iEnd：中序数组开始和结束位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">construct</span><span class="params">(<span class="keyword">int</span>[] pre, <span class="keyword">int</span>[] in, <span class="keyword">int</span> pStart, <span class="keyword">int</span> pEnd, <span class="keyword">int</span> iStart, <span class="keyword">int</span> iEnd)</span> </span>&#123;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(pre[pStart]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pStart == pEnd &amp;&amp; iStart == iEnd) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pre[pStart] != in[iStart])</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"数组不符合规范"</span>);</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = iStart;</span><br><span class="line">        <span class="keyword">while</span> (root.val != in[index] &amp;&amp; index &lt;= iEnd) &#123;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (index &gt; iEnd) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"数组不符合规范"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> leftLength = index - iStart;</span><br><span class="line">        <span class="keyword">if</span> (leftLength &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            root.left = construct(pre, in, pStart + <span class="number">1</span>, pStart + leftLength, iStart, index - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (leftLength &lt; iEnd - iStart) &#123;</span><br><span class="line">            root.right = construct(pre, in, pStart + leftLength + <span class="number">1</span>, pEnd, index + <span class="number">1</span>, iEnd);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试部分代码，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstructBinaryTree</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">preOrderTraverse</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        System.out.print(node.val);</span><br><span class="line">        preOrderTraverse(node.left);</span><br><span class="line">        preOrderTraverse(node.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inOrderTraverse</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        inOrderTraverse(node.left);</span><br><span class="line">        System.out.print(node.val);</span><br><span class="line">        inOrderTraverse(node.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 正常二叉树</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] pre = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span> &#125;;</span><br><span class="line">        <span class="keyword">int</span>[] in = &#123; <span class="number">4</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">6</span> &#125;;</span><br><span class="line">        TreeNode root = reConstructBinaryTree(pre, in);</span><br><span class="line">        System.out.print(<span class="string">"test1:"</span>);</span><br><span class="line">        preOrderTraverse(root);</span><br><span class="line">        System.out.print(<span class="string">"//"</span>);</span><br><span class="line">        inOrderTraverse(root);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 左斜树</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] pre = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">        <span class="keyword">int</span>[] in = &#123; <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span> &#125;;</span><br><span class="line">        TreeNode root = reConstructBinaryTree(pre, in);</span><br><span class="line">        System.out.print(<span class="string">"test2:"</span>);</span><br><span class="line">        preOrderTraverse(root);</span><br><span class="line">        System.out.print(<span class="string">"//"</span>);</span><br><span class="line">        inOrderTraverse(root);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 右斜树</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] pre = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">        <span class="keyword">int</span>[] in = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">        TreeNode root = reConstructBinaryTree(pre, in);</span><br><span class="line">        System.out.print(<span class="string">"test3:"</span>);</span><br><span class="line">        preOrderTraverse(root);</span><br><span class="line">        System.out.print(<span class="string">"//"</span>);</span><br><span class="line">        inOrderTraverse(root);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 单个节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] pre = &#123; <span class="number">1</span> &#125;;</span><br><span class="line">        <span class="keyword">int</span>[] in = &#123; <span class="number">1</span> &#125;;</span><br><span class="line">        TreeNode root = reConstructBinaryTree(pre, in);</span><br><span class="line">        System.out.print(<span class="string">"test4:"</span>);</span><br><span class="line">        preOrderTraverse(root);</span><br><span class="line">        System.out.print(<span class="string">"//"</span>);</span><br><span class="line">        inOrderTraverse(root);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数组为空</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] pre = &#123;&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] in = &#123;&#125;;</span><br><span class="line">        TreeNode root = reConstructBinaryTree(pre, in);</span><br><span class="line">        System.out.print(<span class="string">"test5:"</span>);</span><br><span class="line">        preOrderTraverse(root);</span><br><span class="line">        System.out.print(<span class="string">"//"</span>);</span><br><span class="line">        inOrderTraverse(root);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ConstructBinaryTree demo = <span class="keyword">new</span> ConstructBinaryTree();</span><br><span class="line">        demo.test1();</span><br><span class="line">        demo.test2();</span><br><span class="line">        demo.test3();</span><br><span class="line">        demo.test4();</span><br><span class="line">        <span class="comment">// demo.test5();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>在递归问题中，代码可以用下标表示的就用下标表示，不用重新构建新的数组。</li><li>数组为空与数组为null不是一回事。</li></ol><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="剑指Offer" scheme="https://www.blogs.rhsphere.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="BinaryTree" scheme="https://www.blogs.rhsphere.com/tags/BinaryTree/"/>
    
  </entry>
  
  <entry>
    <title>React项目实践</title>
    <link href="https://www.blogs.rhsphere.com/2019/03/27/React%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5.html"/>
    <id>https://www.blogs.rhsphere.com/2019/03/27/React项目实践.html</id>
    <published>2019-03-27T07:30:59.000Z</published>
    <updated>2019-03-27T08:50:16.342Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><h2 id="指定计划"><a href="#指定计划" class="headerlink" title="指定计划"></a>指定计划</h2><h3 id="功能模块"><a href="#功能模块" class="headerlink" title="功能模块"></a>功能模块</h3><h3 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h3><ul><li>前后端完全分离</li><li>单页应用</li><li>模块化开发</li></ul><h3 id="技术储备"><a href="#技术储备" class="headerlink" title="技术储备"></a>技术储备</h3><ul><li>React框架</li></ul><ul><li>React16 JSX表达式</li><li>React组件</li><li>生命周期</li></ul><ul><li>React-Router</li></ul><ul><li>浏览器路由原理</li><li>动态路由 VS 静态路由</li><li>React-Router</li></ul><ul><li><p>Sass Bootstrap </p></li><li><p>ES6语法</p></li></ul><ul><li>基础语法</li><li>Promise</li><li>面向对象</li></ul><ul><li>浏览器资源加载</li></ul><ul><li>URL结构</li><li>资源加载</li><li>浏览器渲染</li></ul><ul><li>本地存储</li></ul><ul><li>Cookie &amp;&amp; Seeeion</li><li>用户登录状态保持</li><li>H5本地存储</li></ul><ul><li>发布上线</li></ul><ul><li>Linux服务器配置</li><li>自动化发布脚本</li><li>域名解析</li></ul><h2 id="后台管理系统的需求分析及技术选型"><a href="#后台管理系统的需求分析及技术选型" class="headerlink" title="后台管理系统的需求分析及技术选型"></a>后台管理系统的需求分析及技术选型</h2><h3 id="核心需求"><a href="#核心需求" class="headerlink" title="核心需求"></a>核心需求</h3><p>根据实际情况来定义</p><h3 id="功能拆分"><a href="#功能拆分" class="headerlink" title="功能拆分"></a>功能拆分</h3><p>根据实际情况来定义</p><h3 id="技术选型–语言和框架"><a href="#技术选型–语言和框架" class="headerlink" title="技术选型–语言和框架"></a>技术选型–语言和框架</h3><ul><li>React</li><li>Sass + Bootstrap</li><li>ES6</li></ul><h3 id="技术选型–语言和框架-1"><a href="#技术选型–语言和框架-1" class="headerlink" title="技术选型–语言和框架"></a>技术选型–语言和框架</h3><ul><li>前后端分离</li><li>分层架构</li><li>模块化开发</li></ul><h3 id="技术选型–辅助工具"><a href="#技术选型–辅助工具" class="headerlink" title="技术选型–辅助工具"></a>技术选型–辅助工具</h3><p>node   npm安装速度慢，包之间的依赖关系很难搞</p><ul><li>yarn 包管理工具</li><li>webpack 代码打包</li><li>git 托管代码，做代码的版本维护</li></ul><h3 id="技术选型–发布过程"><a href="#技术选型–发布过程" class="headerlink" title="技术选型–发布过程"></a>技术选型–发布过程</h3><ul><li>环境配置</li><li>代码部署</li><li>nginx配置</li><li>域名配置</li></ul><h2 id="数据接口的定义"><a href="#数据接口的定义" class="headerlink" title="数据接口的定义"></a>数据接口的定义</h2><h3 id="接口文档规范–格式"><a href="#接口文档规范–格式" class="headerlink" title="接口文档规范–格式"></a>接口文档规范–格式</h3><h3 id="接口文档规范–请求和相应"><a href="#接口文档规范–请求和相应" class="headerlink" title="接口文档规范–请求和相应"></a>接口文档规范–请求和相应</h3><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://&quot; alt=&quot;&quot; style=&quot;width:100%&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>剑指Offer(6) 从尾到头打印链表</title>
    <link href="https://www.blogs.rhsphere.com/2019/03/26/print-list-from-head-to-tail.html"/>
    <id>https://www.blogs.rhsphere.com/2019/03/26/print-list-from-head-to-tail.html</id>
    <published>2019-03-26T15:07:55.000Z</published>
    <updated>2019-08-27T02:12:38.048Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><h2 id="从头到尾打印链表"><a href="#从头到尾打印链表" class="headerlink" title="从头到尾打印链表"></a>从头到尾打印链表</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入一个链表的头结点，从尾到头反过来打印出每个结点的值。节点定义如下：</p><p>class ListNode {<br>    int val;<br>    ListNode next;<br>    ListNode(int val) {<br>        this.val = val;<br>    }<br>}</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>输入一个链表的头结点，从尾到头反过来打印出每个结点的值。对于“后进先出”问题，要快速想到”栈“，也同时想到递归。</p><p>结点遍历顺序只能从头到尾，但是输出的顺序却为从尾到头，是典型的“后进先出”问题，这就要联想到使用栈，从而也可以联想到使用递归。</p><h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><ol><li>功能测试（单个节点链表，多个节点链表）</li><li>特殊输入测试（链表为空）</li></ol><h2 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintListInReversedOrder</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> element;</span><br><span class="line">        Node next;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> element)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.element = element;           </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 采用栈</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printListReversingly_Iteratively</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(node);</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!stack.empty()) &#123;</span><br><span class="line">            System.out.println(stack.pop().element);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 采用递归</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printListReversingly_Recursively</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            printListReversingly_Recursively(node.next);</span><br><span class="line">            System.out.println(node.element);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintListInReversedOrder</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 链表为空</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node aNode = <span class="keyword">null</span>;</span><br><span class="line">        System.out.println(<span class="string">"采用栈："</span>);</span><br><span class="line">        printListReversingly_Iteratively(aNode);</span><br><span class="line">        System.out.println(<span class="string">"采用递归："</span>);</span><br><span class="line">        printListReversingly_Recursively(aNode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 多个结点链表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node Node1 = <span class="keyword">new</span> Node(<span class="number">1</span>);</span><br><span class="line">        Node Node2 = <span class="keyword">new</span> Node(<span class="number">2</span>);</span><br><span class="line">        Node Node3 = <span class="keyword">new</span> Node(<span class="number">3</span>);</span><br><span class="line">        Node Node4 = <span class="keyword">new</span> Node(<span class="number">4</span>);</span><br><span class="line">        Node Node5 = <span class="keyword">new</span> Node(<span class="number">5</span>);</span><br><span class="line">        Node1.next = Node2;</span><br><span class="line">        Node2.next = Node3;</span><br><span class="line">        Node3.next = Node4;</span><br><span class="line">        Node4.next = Node5;</span><br><span class="line">        System.out.println(<span class="string">"采用栈："</span>);</span><br><span class="line">        printListReversingly_Iteratively(Node1);</span><br><span class="line">        System.out.println(<span class="string">"采用递归："</span>);</span><br><span class="line">        printListReversingly_Recursively(Node1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 单个结点链表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node Node1 = <span class="keyword">new</span> Node(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">"采用栈："</span>);</span><br><span class="line">        printListReversingly_Iteratively(Node1);</span><br><span class="line">        System.out.println(<span class="string">"采用递归："</span>);</span><br><span class="line">        printListReversingly_Recursively(Node1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PrintListInReversedOrder demo = <span class="keyword">new</span> PrintListInReversedOrder();</span><br><span class="line">        System.out.println(<span class="string">"test1:"</span>);</span><br><span class="line">        demo.test1();</span><br><span class="line">        System.out.println(<span class="string">"test2:"</span>);</span><br><span class="line">        demo.test2();</span><br><span class="line">        System.out.println(<span class="string">"test3:"</span>);</span><br><span class="line">        demo.test3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="递归的其他写法"><a href="#递归的其他写法" class="headerlink" title="递归的其他写法"></a>递归的其他写法</h3><p>递归部分代码也可以像下面这样写，注意体会不同的递归写法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printListReversingly_Recursively</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            printListReversingly_Recursively(node.next);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(node.element);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="牛客网提交代码"><a href="#牛客网提交代码" class="headerlink" title="牛客网提交代码"></a>牛客网提交代码</h3><p>采用的递归，非常简洁，很值得学习。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*    public class ListNode &#123;</span></span><br><span class="line"><span class="comment">*        int val;</span></span><br><span class="line"><span class="comment">*        ListNode next = null;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*        ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">*            this.val = val;</span></span><br><span class="line"><span class="comment">*        &#125;</span></span><br><span class="line"><span class="comment">*    &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.printListFromTailToHead(listNode.next);</span><br><span class="line">            list.add(node.val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>对于“后进先出”问题，要快速想到”栈“，也同时想到递归。</li><li>采用递归时，返回的函数值不一定要有赋值操作，只要实现了遍历的作用就可以了，牛客网的代码可以多多学习。</li></ol><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="剑指Offer" scheme="https://www.blogs.rhsphere.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="Recursive" scheme="https://www.blogs.rhsphere.com/tags/Recursive/"/>
    
      <category term="LikedList" scheme="https://www.blogs.rhsphere.com/tags/LikedList/"/>
    
  </entry>
  
  <entry>
    <title>Spring框架快速入门</title>
    <link href="https://www.blogs.rhsphere.com/2019/03/26/Spring%E6%A1%86%E6%9E%B6%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8.html"/>
    <id>https://www.blogs.rhsphere.com/2019/03/26/Spring框架快速入门.html</id>
    <published>2019-03-26T02:56:02.000Z</published>
    <updated>2019-03-26T02:56:02.783Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><p>##</p><p>##</p><p>##</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://&quot; alt=&quot;&quot; style=&quot;width:100%&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>剑指Offer(5) 替换空格</title>
    <link href="https://www.blogs.rhsphere.com/2019/03/24/replace-spaces.html"/>
    <id>https://www.blogs.rhsphere.com/2019/03/24/replace-spaces.html</id>
    <published>2019-03-23T16:37:04.000Z</published>
    <updated>2019-08-26T17:05:47.840Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><h1 id="替换空格"><a href="#替换空格" class="headerlink" title="替换空格"></a>替换空格</h1><p>本文有两道题。<br>第一道题，请实现一个函数，把字符串中的每个空格替换成”%20”。例如输入“We are happy.”，则输出“We%20are%20happy.”。 </p><p>第二道题，实现对一组无序的字母进行从小到大排序（区分大小写），当两个字母相同时，小写字母放在大写字母前。要求时间复杂度为O(n)。</p><h2 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h2><p>请实现一个函数，把字符串中的每个空格替换成”%20”。例如输入“We are happy.”，则输出“We%20are%20happy.”。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>首先要询问面试官是新建一个字符串还是在原有的字符串上修改，本题要求在原字符串上进行修改。</p><p>若从前往后依次替换，在每次遇到空格字符时，都需要移动后面O(n)个字符，对于含有O(n)个空格字符的字符串而言，总的时间效率为O(n^2)。</p><p>转变思路：先计算需要的总长度，然后从后往前进行复制和替换，则每个字符只需要复制一次即可。时间效率为O(n)。</p><h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><ol><li>字符串中无空格</li><li>字符串中含有空格（连续空格，空格在首尾等）</li><li>字符串为空字符串或者为null</li></ol><h2 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h2><p>根据牛客网的编程练习参考，方法的输入为StringBuffer（String无法改变长度，所以采用StringBuffer），输出为String。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReplaceSpaces</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replaceSpaces</span><span class="params">(StringBuffer str)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (str == <span class="keyword">null</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">"输入错误"</span>)；</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> length = str.length();</span><br><span class="line"><span class="keyword">int</span> indexOfOriginal = length - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (str.charAt(i) == <span class="string">' '</span>) &#123;</span><br><span class="line">length += <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">str.setLength(length);</span><br><span class="line"><span class="keyword">int</span> indexOfNew = length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (indexOfNew &gt; indexOfOriginal) &#123;</span><br><span class="line"><span class="keyword">if</span> (str.charAt(indexOfOriginal) != <span class="string">' '</span>) &#123;</span><br><span class="line">str.setCharAt(indexOfNew--, str.charAt(indexOfOriginal));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">str.setCharAt(indexOfNew--, <span class="string">'0'</span>);</span><br><span class="line">str.setCharAt(indexOfNew--, <span class="string">'2'</span>);</span><br><span class="line">str.setCharAt(indexOfNew--, <span class="string">'%'</span>);</span><br><span class="line">&#125;</span><br><span class="line">indexOfOriginal--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> str.toString();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在同一个类中，与上面的函数拆开的测试代码，为了函数更加简洁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReplaceSpaces</span> </span>&#123;</span><br><span class="line"><span class="comment">// ==================================测试代码==================================</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 输入为null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"Test1："</span>);</span><br><span class="line">        StringBuffer sBuffer = <span class="keyword">null</span>;</span><br><span class="line">        String s = replaceSpace(sBuffer);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 输入为空字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"Test2："</span>);</span><br><span class="line">        StringBuffer sBuffer = <span class="keyword">new</span> StringBuffer(<span class="string">""</span>);</span><br><span class="line">        String s = replaceSpace(sBuffer);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 输入字符串无空格</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"Test3："</span>);</span><br><span class="line">        StringBuffer sBuffer = <span class="keyword">new</span> StringBuffer(<span class="string">"abc"</span>);</span><br><span class="line">        String s = replaceSpace(sBuffer);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 输入字符串为首尾空格，中间连续空格</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"Test4："</span>);</span><br><span class="line">        StringBuffer sBuffer = <span class="keyword">new</span> StringBuffer(<span class="string">" a b  c  "</span>);</span><br><span class="line">        String s = replaceSpace(sBuffer);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReplaceSpaces rs = <span class="keyword">new</span> ReplaceSpaces();</span><br><span class="line">        rs.test1();</span><br><span class="line">        rs.test2();</span><br><span class="line">        rs.test3();</span><br><span class="line">        rs.test4();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="替换空格-采用数组的方法"><a href="#替换空格-采用数组的方法" class="headerlink" title="替换空格-采用数组的方法"></a>替换空格-采用数组的方法</h2><p>因为java字符串是不可变的，所以也可以使用字符数组来解决这个问题。</p><p>处理字符串的时候，常见做法是从尾部开始编辑，从后往前反向操作。这种做法很有用，因为字符串尾部有额外的缓冲，可以直接修改，不必担心会覆写原有数据。<br>采用上面的做法，进行两次扫描，第一次扫描先数出字符串中有多少空格，从而计算出最终的字符串有多长。第二次扫描才真正开始反向编辑字符串。检测到空格则将%20复制到下一个位置，若不是空白，就复制原先的字符。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">replaceSpace</span><span class="params">(<span class="keyword">char</span>[] str, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> spaceCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> newLength;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str[i] == <span class="string">' '</span>) &#123;</span><br><span class="line">            spaceCount++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    newLength = length + spaceCount * <span class="number">2</span>;</span><br><span class="line">    str[newLength] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = length - <span class="number">1</span>; i &gt;= <span class="number">0</span> ; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str[i] == <span class="string">' '</span>) &#123;</span><br><span class="line">            str[--newLength] = <span class="string">'0'</span>;</span><br><span class="line">            str[--newLength] = <span class="string">'2'</span>;</span><br><span class="line">            str[--newLength] = <span class="string">'%'</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            str[--newLength] = str[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>对于一个错误</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里用了 for (int i = 0; i &lt; length; i++) &#123;</span></span><br><span class="line">   <span class="comment">// 非常之愚蠢，因为在for循环体里面 length的值一直在变化</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">       <span class="keyword">if</span> (str.charAt(i) == <span class="string">' '</span>)</span><br><span class="line">           length += <span class="number">2</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>如果在从前往后进行复制时，需要多次移动数据，则可以考虑从后往前复制，从而减小移动次数，提高效率。</p></li><li><p>Java 打印输出字符数组 Java 中，char 类型数组可以直接使用数组名打印。char 类型的数组就相当于一个字符串。 输出流 System.out 是 PrintStream 对象，PrintStream 有多个重载的 println 方法，其中一个就是 public void println(char[ ] x)它会直接调用这个方法来打印字符数组。因此可以直接打印出数组内容，而不是地址。</p></li><li><p>不要使用 i % 2 == 1 来判断是否是奇数，因为i为负奇数时不成立，请 <strong>使用 i % 2 != 0 来判断是否是奇数</strong>，或使用 <strong>高效式 (i &amp; 1) != 0来判断奇数，奇数与1相与必为1。</strong>。 </p></li><li><p>生成char array的方法</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//生成char Array</span></span><br><span class="line">String s = <span class="string">"HappyBirthdayzLinkeRuIlikeyouazz"</span>;</span><br><span class="line"><span class="keyword">char</span>[] src = s.toCharArray();</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印char 数组成字符串</span></span><br><span class="line">System.out.print(src);</span><br><span class="line"></span><br><span class="line"><span class="comment">//数组转字符串</span></span><br><span class="line">String[] arr = &#123;<span class="string">"laowang"</span>, <span class="string">"stone"</span>, <span class="string">"wanglei"</span>&#125;;</span><br><span class="line">String str2 = Arrays.toString(arr);</span><br><span class="line">System.out.println(str2);  <span class="comment">// 输出[laowang, stone, wanglei]</span></span><br></pre></td></tr></table></figure><ol start="6"><li>数组拷贝</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">9</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] arr2 = Arrays.copyOf(arr, arr.length);</span><br><span class="line">System.out.println(Arrays.toString(arr2));</span><br></pre></td></tr></table></figure><h1 id="无序字母排序"><a href="#无序字母排序" class="headerlink" title="无序字母排序"></a>无序字母排序</h1><p>本题不属于剑指offer。</p><h2 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h2><p>实现对一组无序的字母进行从小到大排序（区分大小写），当两个字母相同时，小写字母放在大写字母前。要求时间复杂度为O(n)。</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>使用排序算法在最好的情况下的时间复杂度都在O(nlogn)，不满足题目要求。<br>通常字母为26个，当区分大小写后，变成26*2=52个，所以申请长度为52的int型数组，按照aAbB…zZ(小写字母保存在下标为偶数的位置，大写字母保存在下标为奇数的位置)的顺序一次记录各个字母出现的次数，当记录完成后，就可以遍历这个数组按照各个字母出现的次数来重组排序后的数组。</p><h2 id="Java代码-1"><a href="#Java代码-1" class="headerlink" title="Java代码"></a>Java代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SortCharacters</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">String s = <span class="string">"HappyBirthdayzLinkeRuIlikeyouazz"</span>;</span><br><span class="line"><span class="keyword">char</span>[] src = s.toCharArray();</span><br><span class="line">sort(src);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> ch : src) &#123;</span><br><span class="line">System.out.print(ch + <span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">char</span>[] src)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (src == <span class="keyword">null</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">"参数不合法"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 用于保存52个字符出现的次数，小写字母保存在下标为偶数的位置，大写字母保存在奇数位置</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] charCount = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">52</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; src.length; i++) &#123;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">if</span> (src[i] &gt;= <span class="string">'a'</span> &amp;&amp; src[i] &lt;= <span class="string">'z'</span>) &#123;</span><br><span class="line">charCount[(src[i] - <span class="string">'a'</span>) * <span class="number">2</span>]++;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (src[i] &gt;= <span class="string">'A'</span> &amp;&amp; src[i] &lt;= <span class="string">'Z'</span>) &#123;</span><br><span class="line">charCount[(src[i] - <span class="string">'A'</span>) * <span class="number">2</span> + <span class="number">1</span>]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; charCount.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (charCount[i] != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123; <span class="comment">// 小写字母</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; charCount[i]; j++)</span><br><span class="line">src[index++] = (<span class="keyword">char</span>) (i / <span class="number">2</span> + <span class="string">'a'</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 大写字母</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; charCount[i]; j++)</span><br><span class="line">src[index++] = (<span class="keyword">char</span>) ((i - <span class="number">1</span>) / <span class="number">2</span> + <span class="string">'A'</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="剑指Offer" scheme="https://www.blogs.rhsphere.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="String" scheme="https://www.blogs.rhsphere.com/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer(4) 二维数组中的查找</title>
    <link href="https://www.blogs.rhsphere.com/2019/03/24/find-in-partially-sorted-matrix.html"/>
    <id>https://www.blogs.rhsphere.com/2019/03/24/find-in-partially-sorted-matrix.html</id>
    <published>2019-03-23T16:36:36.000Z</published>
    <updated>2019-08-26T17:05:23.855Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><h2 id="二维数组中的查找"><a href="#二维数组中的查找" class="headerlink" title="二维数组中的查找"></a>二维数组中的查找</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>查找整数时，如果从左上角开始查找，情况较为复杂，可以转换思路，从右上角开始查找：左边数字比较小，下边数字比较大，容易进行判断。</p><p><strong>当我们需要解决一个复杂的问题是，一个很有效的办法就是从一个具体的问题入手，通过分析简单具体的例子，寻找普遍规律。</strong></p><h3 id="测试用例："><a href="#测试用例：" class="headerlink" title="测试用例："></a>测试用例：</h3><ol><li>要查找的数字在数组中</li><li>要查找的数字不在数组中</li><li>数组为空</li><li>数组不满足大小规则</li><li>数组每行长度不一致</li></ol><h2 id="Java代码及复杂度"><a href="#Java代码及复杂度" class="headerlink" title="Java代码及复杂度"></a>Java代码及复杂度</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FindInPartiallySortedMatrix</span> </span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 判断二维数组matrix中是否含有整数a</span></span><br><span class="line"><span class="comment">     * 返回值为a的下标，&#123;-1，-1&#125;代表不存在</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] find(<span class="keyword">int</span>[][] martrix, <span class="keyword">int</span> a) &#123;</span><br><span class="line"><span class="keyword">int</span>[] index = &#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">"数组无效"</span>);</span><br><span class="line"><span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> columns = matrix[<span class="number">0</span>].length;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.length; i) &#123;</span><br><span class="line"><span class="keyword">if</span> (matrix[i].length != columns) &#123;</span><br><span class="line">System.out.println(<span class="string">"数组列数不一致"</span>);</span><br><span class="line"><span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[i].length; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">break</span>;<span class="comment">//matrix[0][0]不比较</span></span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">0</span>) &#123; <span class="comment">//第一行的数,仅和前一列比较</span></span><br><span class="line"><span class="keyword">if</span> (matrix[i][j] &lt; matrix[i][j - <span class="number">1</span>])&#123;</span><br><span class="line">System.out.print(<span class="string">"数组中数字大小不符合要求"</span>)；</span><br><span class="line"><span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span>) &#123; <span class="comment">//第一列的，仅和前一行比较</span></span><br><span class="line"><span class="keyword">if</span> (matrix[i][j] &lt; matrix[i - <span class="number">1</span>][j]) &#123;</span><br><span class="line">System.out.print(<span class="string">"数组中数字大小不符合要求"</span>)；</span><br><span class="line"><span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (matrix[i][j] &lt; matrix[i - <span class="number">1</span>][j] || matrix[i][j] &lt; matrix[i][j - <span class="number">1</span>])&#123;</span><br><span class="line">System.out.print(<span class="string">"数组中数字大小不符合要求"</span>)；</span><br><span class="line"><span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找过程</span></span><br><span class="line"><span class="keyword">int</span> row = <span class="number">0</span>;  <span class="comment">//行数</span></span><br><span class="line"><span class="keyword">int</span> col = matrix[<span class="number">0</span>].length - <span class="number">1</span>;  <span class="comment">//列数</span></span><br><span class="line"><span class="keyword">while</span> (row &lt;= matrix.length - <span class="number">1</span> &amp;&amp; col &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (a == matrix[row][col]) &#123;</span><br><span class="line">index[<span class="number">0</span>] = row;</span><br><span class="line">index[<span class="number">1</span>] = col;</span><br><span class="line">System.out.println(<span class="string">"数字"</span> + a + <span class="string">"在二维数组中的下标为： "</span> + index[<span class="number">0</span>] + <span class="string">", "</span> + index[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">return</span> index;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (a &lt; matrix[row][col]) &#123;</span><br><span class="line">col--;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">row++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"数组中不含数字"</span> + a);</span><br><span class="line"><span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在同一个类中，与上面的函数拆开的测试代码，为了函数更加简洁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FindInPartiallySortedMatrix</span> </span>&#123;</span><br><span class="line"><span class="comment">// 1 2 8 9</span></span><br><span class="line">    <span class="comment">// 2 4 9 12</span></span><br><span class="line">    <span class="comment">// 4 7 10 13</span></span><br><span class="line">    <span class="comment">// 6 8 11 15</span></span><br><span class="line">    <span class="comment">// 要查找的数在数组中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"test1："</span>);</span><br><span class="line">        <span class="keyword">int</span>[][] matrix = &#123; &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">9</span> &#125;, &#123; <span class="number">2</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">12</span> &#125;, &#123; <span class="number">4</span>, <span class="number">7</span>, <span class="number">10</span>, <span class="number">13</span> &#125;, &#123; <span class="number">6</span>, <span class="number">8</span>, <span class="number">11</span>, <span class="number">15</span> &#125; &#125;;</span><br><span class="line">        <span class="keyword">int</span>[] index = find(matrix, <span class="number">7</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 1 2 8 9</span></span><br><span class="line">    <span class="comment">// 2 4 9 12</span></span><br><span class="line">    <span class="comment">// 4 7 10 13</span></span><br><span class="line">    <span class="comment">// 6 8 11 15</span></span><br><span class="line">    <span class="comment">// 要查找的数不在数组中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"test2："</span>);</span><br><span class="line">        <span class="keyword">int</span>[][] matrix = &#123; &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">9</span> &#125;, &#123; <span class="number">2</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">12</span> &#125;, &#123; <span class="number">4</span>, <span class="number">7</span>, <span class="number">10</span>, <span class="number">13</span> &#125;, &#123; <span class="number">6</span>, <span class="number">8</span>, <span class="number">11</span>, <span class="number">15</span> &#125; &#125;;</span><br><span class="line">        <span class="keyword">int</span>[] index = find(matrix, <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 数组为空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"test3："</span>);</span><br><span class="line">        <span class="keyword">int</span>[][] matrix = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span>[] index = find(matrix, <span class="number">7</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 1 2 8 9</span></span><br><span class="line">    <span class="comment">// 4 3 9 12</span></span><br><span class="line">    <span class="comment">// 4 7 10 13</span></span><br><span class="line">    <span class="comment">// 6 8 11 15</span></span><br><span class="line">    <span class="comment">// 数组不满足大小规则</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"test4："</span>);</span><br><span class="line">        <span class="keyword">int</span>[][] matrix = &#123; &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">9</span> &#125;, &#123; <span class="number">4</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">12</span> &#125;, &#123; <span class="number">4</span>, <span class="number">7</span>, <span class="number">10</span>, <span class="number">13</span> &#125;, &#123; <span class="number">6</span>, <span class="number">8</span>, <span class="number">11</span>, <span class="number">15</span> &#125; &#125;;</span><br><span class="line">        <span class="keyword">int</span>[] index = find(matrix, <span class="number">7</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 数组每行长度不一致</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"test5："</span>);</span><br><span class="line">        <span class="keyword">int</span>[][] matrix = &#123; &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">8</span> &#125;, &#123; <span class="number">4</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">12</span> &#125;, &#123; <span class="number">4</span>, <span class="number">7</span>, <span class="number">10</span> &#125;, &#123; <span class="number">6</span>, <span class="number">8</span>, <span class="number">11</span>, <span class="number">15</span> &#125; &#125;;</span><br><span class="line">        <span class="keyword">int</span>[] index = find(matrix, <span class="number">7</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FindInPartiallySortedMatrix f = <span class="keyword">new</span> FindInPartiallySortedMatrix();</span><br><span class="line">        f.test1(); <span class="comment">// 注意下标是从0开始的</span></span><br><span class="line">        f.test2();</span><br><span class="line">        f.test3();</span><br><span class="line">        f.test4();</span><br><span class="line">        f.test5();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="不含测试代码-简化版"><a href="#不含测试代码-简化版" class="headerlink" title="不含测试代码(简化版)"></a>不含测试代码(简化版)</h3><p>上面代码考虑了数组数字大小不符合规则的情况，较为繁琐。下面为剑指Offer4 二维数组中的查找(简化版)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span>[][] array)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length &lt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> row = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> col = array[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (row &lt;= array.length - <span class="number">1</span> &amp;&amp; col &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (target == array[row][col]) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; array[row][col]) &#123;</span><br><span class="line">col--;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">row++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="剑指Offer" scheme="https://www.blogs.rhsphere.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="Array" scheme="https://www.blogs.rhsphere.com/tags/Array/"/>
    
      <category term="Search" scheme="https://www.blogs.rhsphere.com/tags/Search/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之禅|6大设计原则</title>
    <link href="https://www.blogs.rhsphere.com/2019/03/23/solid-principles.html"/>
    <id>https://www.blogs.rhsphere.com/2019/03/23/solid-principles.html</id>
    <published>2019-03-23T08:15:50.000Z</published>
    <updated>2019-03-23T16:10:26.496Z</updated>
    
    <content type="html"><![CDATA[<p class="description">曾经对“设计模式”(Design Pattern)很膜拜，以为是最高大上的东西。现在看来更多的是前人总结的经验吧，了解一下就可以了，关键是要用的时候“熟能生巧”。最开始看的时候也正在学习Java，配合着这本书中的Java代码，感觉各种神奇。其实，Java语言设计之初为了避免像C++般复杂却过于简化了语法，结果大大降低了本身的表达能力。很多本来可以很简洁的代码，必须绕来绕去得写出来，这个时候就很需要利用设计模式来整理代码逻辑。另一方面，设计模式也还是有些用途的，尤其是在开发大型软件系统，很注重系统架构的设计和功能模块的解耦的场合。</p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><p>题外话，UML类图中类之间的关系有：<br>泛化 = 实现 &gt; 组合 &gt; 聚合 &gt; 关联 &gt; 依赖</p><ol><li>泛化(Generalization)： 继承关系，子类继承父类 继承用实线三角箭头指向父类</li><li>实现(Realization)： 对接口的实现，类实现一个接口 继承接口用虚线三角箭头指向接口</li><li>组合(Composition)： 整体与部分的关系,但部分不能离开整体而单独存在  实心菱形，菱形指向整体</li><li>聚合(Aggregation)： 整体与部分的关系,且部分可以离开整体而单独存在 空心菱形，菱形指向整体</li><li>关联(Association)： 拥有的关系，让一个类知道另一个类的属性方法 实线箭头，箭头指向被关联的类</li><li>依赖(Dependency)： 一种使用的关系，即一个类的实现需要另一个类的协助，所以尽量不要使用双向的相互依赖，代码体现：局部变量、方法的参数或者调用类的静态方法 虚线箭头，指向被使用者</li></ol><p>软件分析与设计是编码前的2个阶段，分析仅与业务有关，而与技术无关，设计以分析为基础，与具体技术有关。</p><p>紧耦合 类间耦合过重 接口封装过度 类间解耦，弱耦合</p><h2 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h2><p>单一职责原则的英文名称是Single Responsibility Principle，简称是SRP。这个原则存在争议之处在对职责的定义，什么是类的职责，以及怎么划分类的职责。</p><p>RBAC模式（Role-Based Access Control，基于角色的访问控制，通过分配和取消角色来完成用户权限的授予和取消，使动作主体（用户）与资源的行为（权限）分离）。<br>把用户的信息抽取成一个BO（Business Object, 业务对象），把行为抽取成一个Biz（Business Logic，业务逻辑）。</p><p>SRP的定义是：应该有且仅有一个原因引起类的变更。<br>SRP的原话解释：<br> <strong>There should never be more than one reason for a class to change.</strong><br>就一个类而言，应该只有一个引起它变化的原因。</p><p>单一职责原则的优点：</p><ul><li>可以降低类的复杂度，实现什么职责都有清晰明确的定义；</li><li>提高类的可读性；</li><li>提高系统的可维护性；</li><li>变更引起的风险降低，变更是必然的，如果单一职责原则遵守的好，一个接口修改只对相应地实现类有影响，对其他的接口无影响，这对系统的扩展性、维护性都有非常大的帮助。</li></ul><p>单一职责原则要求一个接口或类只有一个原因引起变化，也就是一个接口或类只有一个职责，它就负责一件事。一个职责就是一个接口。<br>对于接口，我们在设计的时候一定要做到单一，但是对于实现类就需要多方面考虑了，可能不会满足单一职责原则。<br>单一职责适用于接口、类，同时也适用于方法。一个方法尽可能做一件事情。</p><h2 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h2><p>在实际项目中，每个子类对应不同的业务含义，使用父类作为参数，<strong>传递不同的子类完成不同的业务逻辑，</strong>非常完美。<br>里氏替换原则(LSP:Liskov Substitution Principle)的定义：</p><ol><li>第一种定义，也是最正宗的定义： <strong>If for each object o1 of type S there is an object o2 of type T such that for all programs P defined in terms of T, the behavior of P is unchanged when o1 is substituted for o2 then S is a subtype of T.</strong>（如果对每一个类型为S的对象o1，都有类型为T的对象o2，使得以T定义的所有程序P在所在的对象o1都代换为o2时，程序P的行为没有发生变化，那么类型S是类型T的字类型。）</li><li>第二种定义：<strong>Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it.</strong>（所有引用基类的地方必须能透明地使用其子类的对象。）</li></ol><p>继承的优点：</p><ul><li>代码共享，减少创建类的工作量，每个子类都拥有父类的方法和属性。</li><li>提高代码的重用性。</li><li>子类可以形似父类，但又异于父类。</li><li>提高代码的可扩展性，只需实现父类的方法。</li><li>提高产品或项目的开放性。</li></ul><p>继承的缺点：</p><ul><li>继承是侵入性的。只要继承，就必须拥有父类的所有属性和方法。</li><li>降低代码的灵活性。子类必须拥有父类的属性和方法。</li><li>增强了耦合性。当父类的常量、变量和方法被修改时，必须要考虑子类的修改，而且在缺乏规范的环境下，这种修改可能带来非常糟糕的结果——大片代码需要重构。</li></ul><p><strong>在类中调用其他类时务必要使用父类或接口，如果不能使用负累或接口，则说明类的设计已经违背了LSP原则。</strong><br>里氏替换原则包含了4层含义：</p><ol><li>子类必须完全实现父类的方法<br>如果子类不能完整地实现父类的方法，或者父类的某些方法在子类中已经发生”畸变”，则建议断开父子继承关系，采用依赖、聚集、组合等关系代替继承。</li><li>子类可以有自己的个性<br>子类可以有自己的行为和外观，也就是方法和属性。</li><li>覆盖或实现父类的方法时输入参数可以被放大<br>子类的方法可以重载（Overload）父类的方法，并把输入参数设置成为父类的方法的输入参数的父类（即把输入参数放大）。这时，通过父类的引用调用这个方法，实际调用的还是父类的方法，子类的方法由于只是重载而不是覆写（Override），会被隐藏掉。子类可以覆写（Override）父类的方法。</li><li>覆写或实现父类的方法时输出结果可以被缩小<br>父类的方法返回值是一个类型T，子类的相同方法（重载或覆写）的返回值为S，那么里氏替换原则就要求S必须小于等于T，也就是说，要么S和T是同一个类型，要么S是T的子类。</li></ol><p>如果是覆写，父类和子类的同名方法的输入参数相同，两个方法的范围值S小于等于T，这是覆写的要求，这才是重中之重，子类覆写父类的方法，天经地义。</p><p>如果是重载，则要求方法的输入参数类型或数量不相同，在里氏替换原则要求下，就是子类的输入参数宽于或等于父类的输入参数，也就是说你写的这个方法是不会被调用的，参考上面讲的前置条件。</p><h2 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h2><p>依赖正置就是类间的依赖是实实在在的实现类间的依赖。</p><p>依赖倒置原则（Dependence Inversion Principle, DIP）的定义：<br><strong>High level modules should not depend upon low level modules. Both should depend upon abstractions. Abstractions should not depend upon details. Details should depend upon abstractions.</strong><br>翻译过来，有三重含义：</p><ol><li>高层模块不应该依赖底层模块，两者都应该依赖其抽象。</li><li>抽象不应该依赖细节。</li><li>细节应该依赖抽象。</li></ol><p>高层模块和低层模块容易理解，每一个逻辑的实现都是由原子逻辑组成的，不可分割的原子逻辑就是低层模块，原子逻辑的再组装就是高层模块。在Java中，抽象是指接口或抽象类，两者都不是不能直接被实例化的；细节就是实现类，实现接口或继承抽象类而产生的类就是细节，其特点就是可以直接被实例化。依赖倒置原则在Java语言中的表现就是：</p><ol><li>模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的。</li><li>接口或抽象类不依赖于实现类。</li><li>实现类依赖与接口或抽象类。</li></ol><p>更加精髓的定义就是 <strong>“面向接口编程”</strong>——面向对象设计的精髓之一。</p><p>采用依赖倒置原则可以减少类间的耦合性，提高系统的稳定性，降低并发开发引起的风险，提高代码的可读性和可维护性。</p><p><strong>依赖是可以传递的。只要做到抽象依赖，即使是多层的依赖传递也无所畏惧。</strong></p><p>依赖倒置原则要求我们在程序代码中传递参数时或在关联关系中，尽量 <strong>引用层次高的抽象层类</strong>，即使用 <strong>接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明</strong>，以及数据类型的转换等，而不要用具体类来做这些事情。</p><p>最佳实践：</p><ul><li>每个类尽量都有接口或抽象类，或者抽象类和接口两者都具备。接口负责定义public属性和方法，并且声明与其他对象的依赖关系，抽象类负责公共构造部分的实现，实现类准确的实现业务逻辑，同时在适当的世界对父类进行细化。</li><li>变量的表名类型尽量是接口或者抽象类。</li><li>任何类都不应该从具体类派生。</li><li>尽量不要覆写基类的方法。</li><li>结合里氏替换原则使用。</li></ul><p>对象的依赖关系又三种方式来传递：</p><ol><li>构造函数传递依赖对象</li><li>Setter方法传递依赖对象</li><li>接口声明依赖对象</li></ol><h2 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h2><p>接口的两种类型：</p><ol><li>实例接口（Object Interface），在Java中声明一个类，然后用new关键字产生一个实例，它是对一个类型的事物的描述，就是一种接口。</li><li>类接口（Class Interface），Java中经常使用的interface关键字定义的接口。<br>接口是我们设计时对外提供的契约。</li></ol><p>接口隔离原则(ISP：Interface Segregation Principle)定义：<br><strong>使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。</strong></p><p>根据接口隔离原则，当一个接口太大时，我们需要将它分割成一些更细小的接口，使用该接口的客户端仅需知道与之相关的方法即可。每一个接口应该承担一种相对独立的角色，不干不该干的事，该干的事都要干。</p><p>看到这里好像接口隔离原则与单一职责原则是相同的。其实接口隔离原则与单一职责原则的审视角度是不相同的，单一职责原则要求的是类和接口职责单一，注重的是职责，这是业务逻辑上的划分，而接口隔离原则要求接口的方法尽量少。</p><p>接口隔离原则是对接口进行规范约束，其包含的以下4层含义：</p><ol><li><p>接口要尽量小<br>这是接口隔离原则的核心定义。但是”小”是有限度的，首先就是不能违反单一职责原则，已经做到单一职责的接口不应该再分。即，根据接口隔离原则拆分接口时，首先必须满足单一职责原则。</p></li><li><p>接口要高内聚<br>高内聚就是提高接口、类、模块的处理能力，减少对外的交互。具体到接口隔离原则就是，要求在接口中尽量少公布public方法，接口是对外的承诺，承诺越少对系统的开发越有利，变更的风险也就越少，同时也有利于降低成本。</p></li><li><p>定制服务<br>定制服务就是单独为一个个体提供优良的服务。要求就是：只提供访问者需要的方法。</p></li><li><p>接口设计是有限度的<br>接口的设计粒度越小，系统越灵活。但是，灵活的同时也带来了结构的复杂化，开发难度增加，可维护性降低。所以接口设计一定要注意适度。</p></li></ol><p>最佳实践：</p><ul><li>一个接口只服务于一个子模块或业务逻辑。</li><li>通过业务逻辑压缩接口中的public方法，接口时常去回顾，尽量让接口达到“满身筋骨肉”，而不是“肥嘟嘟”的一大堆方法。</li><li>已经被污染了的接口，尽量去修改，若变更的风险较大，则采用适配器模式进行转化处理。</li><li>了解环境，拒绝盲从。环境不同，接口拆分的标准就不同，深入了解业务逻辑，根据实际情况设计接口。</li></ul><h2 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h2><p>最小知识原则（Least Knowledge Principle，LKP）：<br> <strong>一个对象应该对其他对象有最少的了解。</strong></p><p>通俗地讲，一个类应该对自己需要耦合或调用的类知道得最少。<br>最小知识原则包含以下4层含义：</p><ol><li>只和朋友交流<br>Only talk to your immedate friends（只和直接朋友通信。）<br>两个对象之间的耦合就成为朋友关系。</li></ol><p>类和类之间的关系是建立在类间的，而不是方法间。<br><strong>朋友类：出现在在成员变量、方法的输入输出参数中的类成为成员朋友类</strong>，而出现在方法内部的类不属于朋友类。</p><ol start="2"><li><p>朋友间也是有距离的<br>朋友类之间也不应该暴露太多方法。<br>尽量不要对外公布太多的public和非静态的public变量，尽量内敛，多使用protected、package-private、protected等访问权限。</p></li><li><p>是自己的就是自己的<br><strong>如果一个方法放在本类中，既不增加类间关系，也对本类不产生负面影响，就放置在本类中。</strong></p></li><li><p>谨慎使用Serializable<br><strong>可能会因为对类的更改未在服务器和客户端之间同步而引起序列化失败问题。</strong></p></li></ol><p><strong>迪米特法则的核心观念就是类间解耦，弱耦合</strong></p><h2 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h2><p>开闭原则(OCP:Open-Closed Principle)的定义：<br><strong>Software entities like classes, modules and functions should be open for extension but closed for modifications.（一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。）</strong><br>一个软件实体（模块、类、接口、方法）应该通过 <strong>扩展</strong>来实现变化，而不是通过修改已有的代码来实现变化。</p><p>开闭原则是最基本的原则，是其他原则和设计模式的精神。</p><p>开闭原则的重要性：</p><ul><li><p><strong>开闭原则对测试的影响</strong><br>所有已经投产的代码都是有意义的，并且都不受系统规则的约束。如果通过修改而不是扩展代码来应对需求变化，需要重新测试已经修改的代码。</p></li><li><p>开闭原则可以提高复用性<br>在面向对象的设计中，所有的逻辑都是从原子逻辑组合而来的，而不是在一个类中独立实现一个业务逻辑。</p></li><li><p>开闭原则可以提高可维护性</p></li><li>面向对象开发的要求<br>快速的应对变化，需要在设计之初就考虑所有可能变化的因素，然后留下接口。</li></ul><p>需求变化的三种类型：</p><ol><li><p>逻辑变化<br>可以通过修改原有类中的方法的方式来完成</p></li><li><p>子模块变化<br>通过扩展来应对</p></li><li><p>可见视图变化<br>可见视图是提供给客户使用的界面，该部分的变化一般会引起连锁反应，但还是可以通过扩展来完成变化，这就要看原来的设计是否灵活。</p></li></ol><p>应对需求变化的原则： <strong>保持历史的纯洁性，不去修改历史。</strong></p><p>应对需求变化的三种方法：</p><ol><li><p>修改接口<br>不可靠的，该方案应该被直接否定。</p></li><li><p>修改实现类<br>该方法在项目有明确的章程或优良的架构设计时，是一个非常优秀的方法，但是仍有缺陷。</p></li><li><p>通过扩展实现变化<br>好方法，修改少，风险小。</p></li></ol><p>最佳实践：</p><ol><li><p>抽象约束<br>首先通过接口或抽象类约束扩展，对扩展进行边界限定，不允许出现在接口或抽象类中不存在的public方法；第二，参数类型，引用对象尽量使用接口或者抽象类，而不是实现类；第三，抽象层尽量保持稳定，一旦确定既不允许修改。</p></li><li><p>元数据(metadata)控制模块行为<br>尽量使用元数据(用来描述环境和数据的数据，通俗的说就是配置参数)来控制程序的行为，减少重复开发。</p></li><li><p>制定项目章程<br>对于项目来说，约定优于配置。</p></li><li><p>封装变化<br>第一，将相同的变化封装到一个接口或抽象类中；第二，将不同的变化封装到不同的接口或抽象类中，不应该有两个不同的变化出现在同一个接口或抽象类中。</p></li></ol><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;曾经对“设计模式”(Design Pattern)很膜拜，以为是最高大上的东西。现在看来更多的是前人总结的经验吧，了解一下就可以了，关键是要用的时候“熟能生巧”。最开始看的时候也正在学习Java，配合着这本书中的Java代码，感觉各种神奇。其实，Java语言设计之初为了避免像C++般复杂却过于简化了语法，结果大大降低了本身的表达能力。很多本来可以很简洁的代码，必须绕来绕去得写出来，这个时候就很需要利用设计模式来整理代码逻辑。另一方面，设计模式也还是有些用途的，尤其是在开发大型软件系统，很注重系统架构的设计和功能模块的解耦的场合。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://&quot; alt=&quot;&quot; style=&quot;width:100%&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="DPModel" scheme="https://www.blogs.rhsphere.com/categories/DPModel/"/>
    
    
      <category term="DPModel" scheme="https://www.blogs.rhsphere.com/tags/DPModel/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer(3) 数组中重复的数字</title>
    <link href="https://www.blogs.rhsphere.com/2019/03/21/duplication-in-array.html"/>
    <id>https://www.blogs.rhsphere.com/2019/03/21/duplication-in-array.html</id>
    <published>2019-03-21T14:56:44.000Z</published>
    <updated>2019-08-26T17:06:03.272Z</updated>
    
    <content type="html"><![CDATA[<p class="description">本文参考《剑指Offer》一书，代码采用Java实现。题目一：在一个长度为n的数组里的所有数字都在0到n-1的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。 题目二：在一个长度为n+1的数组里的所有数字都在1到n的范围内，所以数组中至少有一个数字是重复的。请找出数组中任意一个重复的数字，但不能修改输入的数组。 本文的两道题解题思路是不一样的，具体事项见正文。</p><a id="more"></a><h1 id="找出数组中重复数字"><a href="#找出数组中重复数字" class="headerlink" title="找出数组中重复数字"></a>找出数组中重复数字</h1><h2 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h2><p>在一个长度为n的数组里的所有数字都在0到n-1的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。例如，如果输入长度为7的数组 {2, 3, 1, 0, 2, 5, 3} ，那么对应的输出是重复的数字2或者3。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>从哈希表的思路拓展，重排数组：把扫描的每个数字（如数字m）放到其对应下标（m下标）的位置上，若同一位置有重复，则说明该数字重复。</p><p>（在动手写代码前应该先想好测试用例）</p><h3 id="测试用例："><a href="#测试用例：" class="headerlink" title="测试用例："></a>测试用例：</h3><ol><li>数组中带有一个或多个重复数字</li><li>数组中不包含重复数字</li><li>无效输入测试用例（空数组、数组数字越界等）</li></ol><h2 id="Java代码及复杂度"><a href="#Java代码及复杂度" class="headerlink" title="Java代码及复杂度"></a>Java代码及复杂度</h2><p>复杂度：<br>时间复杂度： O(n)<br>空间复杂度： O(1)</p><p>尽管有两重循环，但是每个数字最多只要交换两次就能找到属于它的位置，因此钟的时间按复杂度是O(n)。<br>另外所有操作时在输入数组上进行的，不需要分配内存，空间复杂度是O(1)。</p><h3 id="含测试代码"><a href="#含测试代码" class="headerlink" title="含测试代码"></a>含测试代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FindDuplicateNumber1</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDuplicate</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">"数组输入无效"</span>);</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> a : arr) &#123;</span><br><span class="line"><span class="keyword">if</span> (a &lt; <span class="number">0</span> || a &gt; arr.length - <span class="number">1</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">"数字大小超出范围"</span>);</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line"><span class="keyword">while</span> (arr[i] != i) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr[arr[i]] = arr[i]) &#123;</span><br><span class="line"><span class="keyword">return</span> arr[i];</span><br><span class="line">&#125;</span><br><span class="line">tmp = arr[i];</span><br><span class="line">arr[i] = arr[tmp];</span><br><span class="line">arr[tmp] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"数组中无重复数字"</span>);</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在同一个类中，与上面的函数拆开的测试代码，为了函数更加简洁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FindDuplicateNumber1</span> </span>&#123;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *数组为null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.print(<span class="string">"test1："</span>);</span><br><span class="line"><span class="keyword">int</span>[] a = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">int</span> dup = getDuplicate(a);</span><br><span class="line"><span class="keyword">if</span> (dup &gt;= <span class="number">0</span>)</span><br><span class="line">System.out.println(<span class="string">"重复数字为："</span> + dup);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数组无重复数字</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.print(<span class="string">"test2："</span>);</span><br><span class="line"><span class="keyword">int</span>[] a = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> dup = getDuplicate(a);</span><br><span class="line"><span class="keyword">if</span> (dup &gt;= <span class="number">0</span>)</span><br><span class="line">System.out.println(<span class="string">"重复数字为："</span> + dup);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数组数字越界</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.print(<span class="string">"test3："</span>);</span><br><span class="line"><span class="keyword">int</span>[] a = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> dup = getDuplicate(a);</span><br><span class="line"><span class="keyword">if</span> (dup &gt;= <span class="number">0</span>)</span><br><span class="line">System.out.println(<span class="string">"重复数字为："</span> + dup);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数组带重复数字</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.print(<span class="string">"test4："</span>);</span><br><span class="line"><span class="keyword">int</span>[] a = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> dup = getDuplicate(a);</span><br><span class="line"><span class="keyword">if</span> (dup &gt;= <span class="number">0</span>)</span><br><span class="line">System.out.println(<span class="string">"重复数字为："</span> + dup);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">FindDuplicateNumber1 f = <span class="keyword">new</span> FindDuplicateNumber1();</span><br><span class="line">f.test1();</span><br><span class="line">f.test2();</span><br><span class="line">f.test3();</span><br><span class="line">f.test4();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="不含测试代码（牛客网提交）"><a href="#不含测试代码（牛客网提交）" class="headerlink" title="不含测试代码（牛客网提交）"></a>不含测试代码（牛客网提交）</h3><p>这里的代码为牛客网上通过的代码，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">duplication</span><span class="params">(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> length, <span class="keyword">int</span>[] duplication)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (numbers == <span class="keyword">null</span> || numbers.length &lt;= <span class="number">0</span>) </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> a : numbers) &#123;</span><br><span class="line"><span class="keyword">if</span> (a &lt; <span class="number">0</span> ||　ａ &gt;= length)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tmp;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; length; i++) &#123;</span><br><span class="line"><span class="keyword">while</span> (numbers[i] != i) &#123;</span><br><span class="line"><span class="keyword">if</span> (numbers[numbers[i]] == numbers[i]) &#123;</span><br><span class="line">duplication[<span class="number">0</span>] = numbers[i];</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">tmp = numbers[i];</span><br><span class="line">numbers[i] = numbers[tmp];</span><br><span class="line">numbers[tmp] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="不修改数组找出数组中重复数字"><a href="#不修改数组找出数组中重复数字" class="headerlink" title="不修改数组找出数组中重复数字"></a>不修改数组找出数组中重复数字</h1><h2 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h2><p>在一个长度为n+1的数组里的所有数字都在1到n的范围内，所以数组中至少有一个数字是重复的。请找出数组中任意一个重复的数字，但不能修改输入的数组。例如，如果输入长度为8的数组{2, 3, 5, 4, 3, 2, 6, 7}，那么对应的输出是重复的数字2或者3。</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>数组长度为n+1，而数字只从1到n， —说明必定有重复数字—。</p><p>可以由二分查找法拓展：把1~n的数字从中间数字m分成两部分，若前一半1~m的数字数目超过m个，说明重复数字在前一半区间，否则，在后半区间m+1~n。每次在区间中都一分为二，知道找到重复数字。</p><p>更简单的思路：把该数组看作一个链表，下标代表当前结点，值代表next指针。</p><h3 id="测试用例：-1"><a href="#测试用例：-1" class="headerlink" title="测试用例："></a>测试用例：</h3><ol><li>数组中带有一个或多个重复数字</li><li><del>数组中不包含重复的数字(题目设置必有重复)</del></li><li>无效输入测试用例（空数组、数组数字越界等）</li></ol><h2 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h2><p>时间复杂度说明：函数countRange()将被调用O(logn)次，每次需要O(n)的时间。</p><p>时间复杂度：O(nlogn)  （while循环为O(logn)，coutRange()函数为O(n)）</p><p>空间复杂度：O(1)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FindDuplicateNumber2</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 找到数组中一个重复的数字</span></span><br><span class="line"><span class="comment">     * 返回-1代表无重复数字或者输入无效</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDuplicate</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.lenght &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">             System.out.println(<span class="string">"数组输入无效！"</span>);</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a : arr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a &lt; <span class="number">1</span> || a &gt; arr.length - <span class="number">1</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"数字大小超出范围！"</span>);</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high = arr.length - <span class="number">1</span>; <span class="comment">//为题目中的n</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mid, count;</span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">            mid = low + ((high - low) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            count = countRange(arr, low, mid);</span><br><span class="line">            <span class="keyword">if</span> (low == high) &#123;</span><br><span class="line">                <span class="keyword">if</span> (count &gt; <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">return</span> low;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (count &gt; mid - low + <span class="number">1</span>) &#123;</span><br><span class="line">                high = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回在[low,high]范围中数字的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countRange</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a : arr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a &gt;= low &amp;&amp; a &lt;= high) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在同一个类中，与上面的函数拆开的测试代码，为了函数更加简洁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FindDuplicateNumber2</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     *数组为null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"test1："</span>);</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> dup = getDuplicate(a);</span><br><span class="line">        <span class="keyword">if</span> (dup &gt;= <span class="number">0</span>)</span><br><span class="line">            System.out.println(<span class="string">"重复数字为："</span> + dup);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *数组数字越界</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"test2："</span>);</span><br><span class="line">        <span class="keyword">int</span>[] a = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;;</span><br><span class="line">        <span class="keyword">int</span> dup = getDuplicate(a);</span><br><span class="line">        <span class="keyword">if</span> (dup &gt;= <span class="number">0</span>)</span><br><span class="line">            System.out.println(<span class="string">"重复数字为："</span> + dup);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *数组带重复数字</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"test3："</span>);</span><br><span class="line">        <span class="keyword">int</span>[] a = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span> &#125;;</span><br><span class="line">        <span class="keyword">int</span> dup = getDuplicate(a);</span><br><span class="line">        <span class="keyword">if</span> (dup &gt;= <span class="number">0</span>)</span><br><span class="line">            System.out.println(<span class="string">"重复数字为："</span> + dup);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FindDuplicateNumber2 f2 = <span class="keyword">new</span> FindDuplicateNumber2();</span><br><span class="line">        f2.test1();</span><br><span class="line">        f2.test2();</span><br><span class="line">        f2.test3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;本文参考《剑指Offer》一书，代码采用Java实现。题目一：在一个长度为n的数组里的所有数字都在0到n-1的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。 题目二：在一个长度为n+1的数组里的所有数字都在1到n的范围内，所以数组中至少有一个数字是重复的。请找出数组中任意一个重复的数字，但不能修改输入的数组。 本文的两道题解题思路是不一样的，具体事项见正文。&lt;/p&gt;
    
    </summary>
    
      <category term="剑指Offer" scheme="https://www.blogs.rhsphere.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="Array" scheme="https://www.blogs.rhsphere.com/tags/Array/"/>
    
      <category term="BinarySearch" scheme="https://www.blogs.rhsphere.com/tags/BinarySearch/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer(2) 实现Singleton模式</title>
    <link href="https://www.blogs.rhsphere.com/2019/03/21/singleton.html"/>
    <id>https://www.blogs.rhsphere.com/2019/03/21/singleton.html</id>
    <published>2019-03-21T07:47:17.000Z</published>
    <updated>2019-05-25T07:28:06.547Z</updated>
    
    <content type="html"><![CDATA[<p class="description">饿汉模式不会出现产生多个实例的情况，见单例模式的通用代码。懒汉模式在volatile关键字修饰后，使用双重锁机制，可以解决多个实例被构建的情况，以及由于指令重排而导致的返回一个没有初始化完成的singleton对象。 实现单例模式的手段非常多，还有通过静态内部类实现的方法。 但是上述方法存在共同的问题： 无法防止利用反射来重复构建对象。 阻止反射的构建方式是使用枚举类型，有了enum语法糖，JVM会阻止反射获取枚举类的私有构造方法。 最后还有使用工厂方法模式替代单例模式，当然，其他类也可以通过反射的方式构建一个单例模式。 本文还简单的总结了volatile的两种语义的使用。</p><a id="more"></a><h2 id="DPModel中单例模式"><a href="#DPModel中单例模式" class="headerlink" title="DPModel中单例模式"></a>DPModel中单例模式</h2><h3 id="单例模式的通用代码-线程安全"><a href="#单例模式的通用代码-线程安全" class="headerlink" title="单例模式的通用代码(线程安全)"></a>单例模式的通用代码(线程安全)</h3><p>如果单例初始值是null，还未构建，则构建单例对象并返回。这个写法属于单例模式当中的懒汉模式。<br>如果单例对象一开始就被new Singleton()主动构建，则不再需要判空操作，这种写法属于饿汉模式。</p><figure class="highlight java"><figcaption><span>单例模式的通用代码(饿汉模式)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程不安全的单例模式"><a href="#线程不安全的单例模式" class="headerlink" title="线程不安全的单例模式"></a>线程不安全的单例模式</h3><ul><li>假设Singleton类刚刚被初始化，singleton对象还是空，这时候两个线程同时访问getInstance方法</li><li>因为singleton对象为空，所以两个线程同时通过了条件判断，开始执行new操作</li><li>这样一来，显然instance被构建了两次。</li></ul><figure class="highlight java"><figcaption><span>线程不安全的单例(懒汉模式)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">            singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单例模式第二版-双重检测机制"><a href="#单例模式第二版-双重检测机制" class="headerlink" title="单例模式第二版(双重检测机制)"></a>单例模式第二版(双重检测机制)</h2><h3 id="单例模式第二版"><a href="#单例模式第二版" class="headerlink" title="单例模式第二版"></a>单例模式第二版</h3><p>两次判空的机制叫做双重检测机制。 但是不是绝对的安全！！！<br><figure class="highlight java"><figcaption><span>双重检测</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  <span class="comment">//双重检测</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;  <span class="comment">//同步锁</span></span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  <span class="comment">//双重检测</span></span><br><span class="line">                    singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol><li>为了防止new Singleton被执行多次，因此在new操作之前加上Synchronized 同步锁，锁住整个类（注意，这里不能使用对象锁）；</li><li>进入Synchronized 临界区以后，还要再做一次判空。因为当两个线程同时访问的时候，线程A构建完对象，线程B也已经通过了最初的判空验证，不做第二次判空的话，线程B还是会再次构建instance对象。</li></ol><h3 id="隐藏的漏洞-指令重排"><a href="#隐藏的漏洞-指令重排" class="headerlink" title="隐藏的漏洞(指令重排)"></a>隐藏的漏洞(指令重排)</h3><p>！！！！隐藏的漏洞<br>假设这样的场景，当两个线程一先一后访问getInstance方法的时候，当A线程正在构建对象，B线程刚刚进入方法。<br>这种情况表面看似没什么问题，要么singleton还没被线程A构建，线程B执行 if（singleton == null）的时候得到true；要么singleton已经被线程A构建完成，线程B执行 if（singleton == null）的时候得到false。</p><p>真的如此吗？答案是否定的。这里涉及到了JVM编译器的 <strong>指令重排</strong>。</p><p>指令重排是什么意思呢？比如java中简单的一句 singleton = new Singleton，会被编译器编译成如下JVM指令：</p><p>memory =allocate();    //1：分配对象的内存空间<br>ctorInstance(memory);  //2：初始化对象<br>singleton =memory;     //3：设置instance指向刚分配的内存地址 </p><p>但是这些指令顺序并非一成不变，有可能会经过JVM和CPU的优化，指令重排成下面的顺序：</p><p>memory =allocate();    //1：分配对象的内存空间<br>singleton =memory;     //3：设置instance指向刚分配的内存地址<br>ctorInstance(memory);  //2：初始化对象 </p><p>当线程A执行完1,3,时，singleton对象还未完成初始化，但已经不再指向null。此时如果线程B抢占到CPU资源，执行  if（singleton ==  null）的结果会是false，从而返回一个 <strong>没有初始化完成的singleton对象</strong>。</p><p>如何避免这一情况呢？我们需要在instance对象前面增加一个 <strong>修饰符volatile</strong>。</p><h2 id="单例模式第三版-volatile关键字加双重检测"><a href="#单例模式第三版-volatile关键字加双重检测" class="headerlink" title="单例模式第三版(volatile关键字加双重检测)"></a>单例模式第三版(volatile关键字加双重检测)</h2><figure class="highlight java"><figcaption><span>volatile实现</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  <span class="comment">//双重检测机制</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;  <span class="comment">//同步锁</span></span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  <span class="comment">//双重检测机制</span></span><br><span class="line">                    singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过volatile的修饰，当线程A执行singleton = new Singleton的时候，JVM执行顺序是什么样？始终保证是下面的顺序：</p><p>memory =allocate();    //1：分配对象的内存空间<br>ctorInstance(memory);  //2：初始化对象<br>singleton =memory;     //3：设置instance指向刚分配的内存地址 </p><p>如此在线程B看来，singleton对象的引用要么指向null，要么指向一个初始化完毕的Singleton，而不会出现某个中间态，保证了安全。</p><h2 id="静态内部类实现方式"><a href="#静态内部类实现方式" class="headerlink" title="静态内部类实现方式"></a>静态内部类实现方式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton SINGLETON = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LazyHolder.SINGLETON;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有几个需要注意的点：</p><ol><li><p>从外部无法访问静态内部类LazyHolder，只有当调用Singleton.getInstance方法的时候，才能得到单例对象SINGLETON。</p></li><li><p>SINGLETON对象初始化的时机并不是在单例类Singleton被加载的时候，而是在调用getInstance方法，使得静态内部类LazyHolder被加载的时候。因此这种实现方式是利用 <strong>classloader的加载机制</strong>来实现懒加载，并保证构建单例的线程安全。</p></li></ol><p><strong>!!!!缺点：无法防止利用反射来重复构建对象。 这也是单例模式共同的问题。</strong></p><h2 id="使用工厂方法模式-利用反射打破单例"><a href="#使用工厂方法模式-利用反射打破单例" class="headerlink" title="使用工厂方法模式(利用反射打破单例)"></a>使用工厂方法模式(利用反射打破单例)</h2><figure class="highlight java"><figcaption><span>单例类</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Singleton &#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> doSomething&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>通过反射方式创建单例的工厂类</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingeltonFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class c1 = Class.forName(singleton.class.getName());</span><br><span class="line">            Constructor constructor = c1.getDeclaredConstructor();</span><br><span class="line">            constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">            singleton = (Singleton) constructor.newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// 异常处理</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获得构造器</span></span><br><span class="line">Constructor con = Singleton.class.getDeclaredConstructor();</span><br><span class="line"><span class="comment">//设置为可访问</span></span><br><span class="line">con.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">//构造两个不同的对象</span></span><br><span class="line">Singleton singleton1 = (Singleton)con.newInstance();</span><br><span class="line">Singleton singleton2 = (Singleton)con.newInstance();</span><br><span class="line"><span class="comment">//验证是否是不同对象</span></span><br><span class="line">System.out.println(singleton1.equals(singleton2));</span><br></pre></td></tr></table></figure><p>代码可以简单归纳为三个步骤：</p><p>第一步，获得单例类的构造器。<br>第二步，把构造器设置为可访问。<br>第三步，使用newInstance方法构造对象。</p><p>最后为了确认这两个对象是否真的是不同的对象，我们使用equals方法进行比较。毫无疑问，比较结果是false。</p><h2 id="无懈可击的单例模式-枚举类实现"><a href="#无懈可击的单例模式-枚举类实现" class="headerlink" title="无懈可击的单例模式(枚举类实现)"></a>无懈可击的单例模式(枚举类实现)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> SingletonEnum &#123;</span><br><span class="line">    SINGLETON;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让我们来做一个实验，仍然执行刚才的反射代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获得构造器</span></span><br><span class="line">Constructor con = SingletonEnum.class.getDeclaredConstructor();</span><br><span class="line"><span class="comment">//设置为可访问</span></span><br><span class="line">con.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">//构造两个不同的对象</span></span><br><span class="line">SingletonEnum singleton1 = (SingletonEnum)con.newInstance();</span><br><span class="line">SingletonEnum singleton2 = (SingletonEnum)con.newInstance();</span><br><span class="line"><span class="comment">//验证是否是不同对象</span></span><br><span class="line">System.out.println(singleton1.equals(singleton2));</span><br></pre></td></tr></table></figure><p>执行获得构造器这一步的时候，抛出了异常。</p><p>唯一的缺点是，并非适用懒加载，其单例对象是在枚举类被加载的时候进行初始化的。</p><h2 id="单例模式实现简单总结"><a href="#单例模式实现简单总结" class="headerlink" title="单例模式实现简单总结"></a>单例模式实现简单总结</h2><table><thead><tr><th>单例模式实现</th><th>是否线程安全</th><th>是否懒加载</th><th>是否防止反射构建</th></tr></thead><tbody><tr><td>双重锁检测(第三版)</td><td>是</td><td>是</td><td>否</td></tr><tr><td>静态内部类</td><td>是</td><td>是</td><td>否</td></tr><tr><td>枚举</td><td>是</td><td>否</td><td>是</td></tr></tbody></table><p>几点补充：</p><ol><li>volatile关键字不但可以防止指令重排，也可以保证线程访问的变量值是主内存中的最新值。</li><li>使用枚举实现的单例模式，不但可以防止利用反射强行构建单例对象，而且可以在枚举类对象被反序列化的时候，保证反序列的返回结果是同一对象。</li><li>对于其他方式实现的单例模式，如果既想要做到可序列化，又想要反序列化为同一对象，则必须实现readResolve方法。</li></ol><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>C/C++ 的枚举类型是int类型常量值，不安全。</p><p>java在1.5 加入枚举。</p><ul><li>枚举是类，枚举常量是类的对象，在枚举类外无法创建枚举对象，可以保证枚举的类型安全性</li><li>所有的枚举类都继承自java.lang.Enum，并且所有的枚举类都声明为final，每个枚举常量都声明为public static final，我们不能显示地继承Enum类</li><li>枚举类实例初始化中不能访问静态变量（枚举类特殊初始化方式：构造器先于静态初始化）</li></ul><h2 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h2><h3 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h3><p>Java内存模型简称JMM（Java Memory Model），是Java虚拟机所定义的一种抽象规范，用来屏蔽不同硬件和操作系统的内存访问差异，让java程序在各种平台下都能达到一致的内存访问效果。</p><ol><li><p>主内存（Main Memory）<br>主内存可以简单理解为计算机当中的内存，但又不完全等同。主内存被所有的线程所共享，对于一个共享变量（比如静态变量，或是堆内存中的实例）来说，主内存当中存储了它的“本尊”。</p></li><li><p>工作内存（Working Memory）<br>工作内存可以简单理解为计算机当中的CPU高速缓存，但又不完全等同。每一个线程拥有自己的工作内存，对于一个共享变量来说，工作内存当中存储了它的“副本”。</p></li></ol><p>线程对共享变量的所有操作都必须在工作内存进行，不能直接读写主内存中的变量。不同线程之间也无法访问彼此的工作内存，变量值的传递只能通过主内存来进行。</p><p>volatile关键字具有许多特性，其中最重要的特性就是保证了 <strong>用volatile修饰的变量对所有线程的可见性</strong>。</p><p>为什么volatile关键字可以有这样的特性？这得益于java语言的先行发生原则（happens-before）。在计算机科学中，先行发生原则是两个事件的结果之间的关系，如果一个事件发生在另一个事件之前，结果必须反映，即使这些事件实际上是乱序执行的（通常是优化程序流程）。<br>这里所谓的事件，实际上就是各种指令操作，比如读操作、写操作、初始化操作、锁操作等等。先行发生原则作用于很多场景下，包括同步锁、线程启动、线程终止、volatile。</p><p><strong>volatile关键字只能保证变量的可见性，并不能保证变量的原子性。 不能保证线程安全！</strong><br>因此，什么时候适合用volatile呢？</p><ol><li><strong>运行结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。</strong></li><li><strong>变量不需要与其他的状态变量共同参与不变约束。</strong></li></ol><h3 id="指令重排"><a href="#指令重排" class="headerlink" title="指令重排"></a>指令重排</h3><p>指令重排是指JVM在编译Java代码的时候，或者CPU在执行JVM字节码的时候，对现有的指令顺序进行重新排序。<br>指令重排的目的是为了在不改变程序执行结果的前提下，优化程序的运行效率。需要注意的是，这里所说的不改变执行结果，指的是不改变单线程下的程序执行结果。<br>然而，指令重排是一把双刃剑，虽然优化了程序的执行效率，但是在某些情况下，会影响到多线程的执行结果。</p><h3 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h3><p>内存屏障（Memory Barrier）是一种CPU指令。<br>内存屏障也称为内存栅栏或栅栏指令，是一种屏障指令，它使CPU或编译器对屏障指令之前和之后发出的内存操作执行一个排序约束。 这通常意味着在屏障之前发布的操作被保证在屏障之后发布的操作之前执行。<br>内存屏障共分为四种类型：</p><ol><li>LoadLoad屏障</li><li>StoreStore屏障</li><li>LoadStore屏障</li><li>StoreLoad屏障</li></ol><h3 id="volatile做了什么？"><a href="#volatile做了什么？" class="headerlink" title="volatile做了什么？"></a>volatile做了什么？</h3><p>在一个变量被volatile修饰后，JVM会为我们做两件事：</p><ol><li><p>在每个volatile写操作前插入StoreStore屏障，在写操作后插入StoreLoad屏障。</p></li><li><p>在每个volatile读操作前插入LoadLoad屏障，在读操作后插入LoadStore屏障。</p></li></ol><h3 id="两种语义"><a href="#两种语义" class="headerlink" title="两种语义"></a>两种语义</h3><p>volatile特性之一：</p><p>保证变量在线程之间的可见性。可见性的保证是基于CPU的内存屏障指令，被JSR-133抽象为happens-before原则。</p><p>volatile特性之二：<br>阻止编译时和运行时的指令重排。编译时JVM编译器遵循内存屏障的约束，运行时依靠CPU屏障指令来阻止重排。</p><p>几点补充：</p><ol><li>关于volatile的介绍，本文很多内容来自《深入理解Java虚拟机》这本书。</li><li>在使用volatile引入内存屏障的时候，普通读、普通写、volatile读、volatile写会排列组合出许多不同的场景。</li><li>volatile除了保证可见性和阻止指令重排，还解决了long类型和double类型数据的8字节赋值问题。这个特性相对简单，本文就不详细描述了。</li></ol><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;饿汉模式不会出现产生多个实例的情况，见单例模式的通用代码。懒汉模式在volatile关键字修饰后，使用双重锁机制，可以解决多个实例被构建的情况，以及由于指令重排而导致的返回一个没有初始化完成的singleton对象。 实现单例模式的手段非常多，还有通过静态内部类实现的方法。 但是上述方法存在共同的问题： 无法防止利用反射来重复构建对象。 阻止反射的构建方式是使用枚举类型，有了enum语法糖，JVM会阻止反射获取枚举类的私有构造方法。 最后还有使用工厂方法模式替代单例模式，当然，其他类也可以通过反射的方式构建一个单例模式。 本文还简单的总结了volatile的两种语义的使用。&lt;/p&gt;
    
    </summary>
    
      <category term="剑指Offer" scheme="https://www.blogs.rhsphere.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="DPModel" scheme="https://www.blogs.rhsphere.com/tags/DPModel/"/>
    
      <category term="Singleton" scheme="https://www.blogs.rhsphere.com/tags/Singleton/"/>
    
      <category term="volatile" scheme="https://www.blogs.rhsphere.com/tags/volatile/"/>
    
  </entry>
  
  <entry>
    <title>动态规划前瞻</title>
    <link href="https://www.blogs.rhsphere.com/2019/03/20/outpost-of-DP.html"/>
    <id>https://www.blogs.rhsphere.com/2019/03/20/outpost-of-DP.html</id>
    <published>2019-03-20T01:32:53.000Z</published>
    <updated>2019-05-25T07:28:06.549Z</updated>
    
    <content type="html"><![CDATA[<p class="description"><div>Those who cannot remember the past are condemned to repeat it.</div><div>-Dynamic Programming.</div></p><a id="more"></a><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>动态规划（dynamic programming）是通过组合子问题而解决整个问题的解。   分治法是将问题划分成一些独立的子问题，递归地求解各子问题，然后合并子问题的解。    动态规划适用于子问题不是独立的情况，也就是各子问题包含公共的子子问题。<br>此时，分治法会做许多不必要的工作，即重复地求解公共的子问题。动态规划算法对每个子问题只求解一次，将其结果保存起来，从而避免每次遇到各个子问题时重新计算答案。</p><h3 id="适用范围"><a href="#适用范围" class="headerlink" title="适用范围"></a>适用范围</h3><p>最优性原理体现为问题的最优子结构特性。当一个问题的最优解中包含了子问题的最优解时，则称该问题具有最优子结构特性。<br>最优性原理是动态规划的基础。任何一个问题，如果失去了这个最优性原理的支持，就不可能用动态规划设计求解。</p><ul><li>问题中的状态满足最优性原理。</li><li>问题中的状态必须满足无后效性。</li></ul><p>所谓无后效性是指：“下一时刻的状态只与当前状态有关，而和当前状态之前的状态无关，当前状态是对以往决策的总结”。</p><p>首先，动态规划方法适合的题型4个基本特点是： </p><ol><li>最优子结构，当前一个状态得到最佳解时，当前状态在前一个状态下一定有最佳解； </li><li>子问题重叠，每个状态下要解决的问题除参数不同外，其本质是一样的； </li><li>有边界，当解决了最后一个子问题时，整个问题得解； </li><li>子问题独立，解决一个子问题时不依赖于另一个同级的子问题，只与它的母问题有关。</li></ol><h3 id="动态规划的设计"><a href="#动态规划的设计" class="headerlink" title="动态规划的设计"></a>动态规划的设计</h3><p>两种方法：</p><ul><li>自顶向下（又称记忆化搜索、备忘录）：基本上对应着递归函数实现，从大范围开始计算，要注意不断保存中间结果，避免重复计算</li><li>自底向上（递推）：从小范围递推计算到大范围</li></ul><p>一般分为两个步骤：</p><ol><li>问题建模</li><li>求解问题</li></ol><h3 id="核心元素"><a href="#核心元素" class="headerlink" title="核心元素"></a>核心元素</h3><p>有三个核心元素：</p><ol><li>最优子结构</li><li>边界</li><li>状态转移方程</li></ol><h2 id="总结DP算法的思路"><a href="#总结DP算法的思路" class="headerlink" title="总结DP算法的思路"></a>总结DP算法的思路</h2><p>核心: 最优子结构、边界条件、状态转移方程 </p><p>解题步骤: 1.建立数学模型 2.写代码求解问题 </p><p>   如何建模?先写出所求问题的最优子结构,进而分析出边界和状态转移方程，数学模型即这2者的组合，对于2输入维度动态规划，画表格帮助分析，行列分别代表1个输入维度</p><p>   如何求解?<br>   建好模后，根据方程组写出自底向上的动态规划代码，一维输入就是1个for循环，二维输入就是2个for循环，如果方程组比较抽象，可以画表格帮助分析</p><h2 id="棋盘问题"><a href="#棋盘问题" class="headerlink" title="棋盘问题"></a>棋盘问题</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>寻找一条从左上角（arr[0][0]）到右下角（arr[m - 1][n - 1]）的路线，使得沿途经过的数组中的整数和最小。</p><h3 id="递归算法"><a href="#递归算法" class="headerlink" title="递归算法"></a>递归算法</h3><p>从右下角倒着分析，最后一步到达arr[m - 1][n - 1]只有两条路径，即通过arr[m - 2][n - 1]或arr[m - 1][n - 2]到达。<br>推广到一半的情况，假设到达arr[i - 1][j]与arr[i][j - 1]的最短路径的和为f(i - 1, j)和f(i, j - 1)，那么到达arr[i][j]的路径上所有数字和的最小值为 f(i, j) = min{f(i - 1, j), f(i, j - 1)} + arr[i][j]</p><p>递归方法实现效率太低，有大量重复计算过程。</p><h3 id="动态规划算法"><a href="#动态规划算法" class="headerlink" title="动态规划算法"></a>动态规划算法</h3><p>动态规划其实是一种空间换时间的算法，通过缓存计算的中间值，减少重复计算的次数，从而提高算法的效率。<br>递归从arr[m - 1][n - 1]开始逆向通过递归来求解，采用动态规划可以自底向上求解，以便使用前面计算出来的结果。<br>对于本题而言，显然有边界条件，f(i, 0) = arr[0][0] + arr[i][0]， f(0, j) = arr[0][0] + arr[0][j]。<br>状态转移方程： f(i, j) = min{f(i - 1, j), f(i, j - 1)} + arr[i][j]</p><p>可以把遍历过程中求出所有的f(i, j)的值，保存到另一个二维数组中供后续使用。</p><figure class="highlight java"><figcaption><span>数组和最小的路线</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMinPath</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.lenth == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> row = arr.length;</span><br><span class="line"><span class="keyword">int</span> col = arr[<span class="number">0</span>].length;</span><br><span class="line"><span class="keyword">int</span>[][] cache = <span class="keyword">new</span> <span class="keyword">int</span>[row][col];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; row; i++)</span><br><span class="line">cache[i][<span class="number">0</span>] = cache[i-<span class="number">1</span>][<span class="number">0</span>] + arr[i][<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; col; j++)</span><br><span class="line">cache[<span class="number">0</span>][j] = cache[<span class="number">0</span>][j-<span class="number">1</span>] + arr[<span class="number">0</span>][j];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; row; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; col; j++) &#123;</span><br><span class="line"><span class="comment">//可以确定选择的路线为arr[i-1][j]</span></span><br><span class="line"><span class="keyword">if</span> (arr[i-<span class="number">1</span>][j] &lt; arr[i][j-<span class="number">1</span>]) &#123;</span><br><span class="line">cache[i][j] = cache[i-<span class="number">1</span>][j] + arr[i][j];</span><br><span class="line">System.out.print(<span class="string">"["</span> + (i - <span class="number">1</span>) + <span class="string">", "</span> + j + <span class="string">"] "</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">cache[i][j] = cache[i][j-<span class="number">1</span>] + arr[i][j];</span><br><span class="line">System.out.print(<span class="string">"["</span> + i + <span class="string">", "</span> + (j - <span class="number">1</span>) + <span class="string">"] "</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"["</span> + (row - <span class="number">1</span>) + <span class="string">", "</span> + (col - <span class="number">1</span>) + <span class="string">"]"</span>);</span><br><span class="line"><span class="keyword">return</span> cache[row - <span class="number">1</span>][col - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[][] arr = &#123;&#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>&#125;, &#123;<span class="number">8</span>,<span class="number">7</span>,<span class="number">5</span>&#125;, &#123;<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>&#125;&#125;;</span><br><span class="line">System.out.print(<span class="string">"路径： "</span>)；</span><br><span class="line">System.out.println(<span class="string">"最小值为： "</span> + getMinPath(arr));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对二维数组遍历一次，时间复杂度为O(mn)，申请了一个二维数组来保存中间结果，空间复杂度为O(mn)。</p><h2 id="国王与金矿"><a href="#国王与金矿" class="headerlink" title="国王与金矿"></a>国王与金矿</h2><p>知道 i-1 座金矿的最大产量就一定能知道 i 座金矿的最大产量，这是 <strong>最优子结构</strong>，每个人要知道i座金矿的最大产量就必须知道知道 i-1 座金矿的最大产量，这是 <strong>子问题重叠</strong>，最终当考虑第 1 座金矿的最大产量时，只要看是否有足够人手开采第 1 座金矿，有的话，答案是已探明的储量，没有的话就是0，然后答案汇报到上级，上级再得出第 2 座金矿开采与不开采得出的较大产量，再往上汇报…，这就是 <strong>边界</strong>，而每个人从上级得到的前提都是不同的，上级决定开不开采，再将这个前提之一告诉下属，而下属不需要考虑上级给另一个下属什么前提，这是 <strong>子问题独立</strong>。</p><p>把金矿数量设为n，工人数量设为w，金矿的黄金量设为g[]，金矿的用工量设为p[]。<br>F(n, w) = 0     (n &lt;= 1, w &lt; p[0]);<br>F(n, w) = g[0]    (n == 1, w &gt;= p[0]);<br>F(n, w) = F(n - 1, w)    (n &gt; 1, w &lt; p[n - 1]);<br>F(n, w) = max(F(n - 1, w)， F(n - 1, w - p[n - 1]) + g[n - 1])     (n &gt; 1, w &gt;= p[n-1]);</p><h3 id="递归算法-1"><a href="#递归算法-1" class="headerlink" title="递归算法"></a>递归算法</h3><p>把状态转移方程翻译成递归程序，递归结束条件是方程中的边界。 因为每个状态有两个最优子结构，所以递归的执行流程类似于一棵高度为N的二叉树。 时间复杂度为O(2^n)。</p><figure class="highlight java"><figcaption><span>递归解法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMostGold</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> w, <span class="keyword">int</span>[] g, <span class="keyword">int</span>[] p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; g.length)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"输入的n值大于给定的金矿数"</span>);</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span> &amp;&amp; w &lt; p[<span class="number">0</span>]) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span> &amp;&amp; w &gt;= p[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> g[<span class="number">0</span>];</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span> &amp;&amp; w &lt; p[n-<span class="number">1</span>]) </span><br><span class="line">        <span class="keyword">return</span> getMostGold(n-<span class="number">1</span>, w, g, p);</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">int</span> a = getMostGold(n-<span class="number">1</span>, w, g, p);</span><br><span class="line">    <span class="keyword">int</span> b = getMostGold(n-<span class="number">1</span>, w - p[n-<span class="number">1</span>], g, p) + g[n-<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> Math.max(a, b);</span><br><span class="line">         </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="DP解法"><a href="#DP解法" class="headerlink" title="DP解法"></a>DP解法</h3><p>画表格分析，表格第一列代表给定前1-5做金矿的情况，也就是N的取值。表格第一行代表给定的工人数，也就是w的取值。<br>其余空白格表示，给定n和w值对应的黄金获得数，也就是F(n,w)。</p><table><thead><tr><th></th><th>1工人</th><th>2工人</th><th>3工人</th><th>4工人</th><th>5工人</th><th>6工人</th><th>7工人</th><th>8工人</th><th>9工人</th><th>10工人</th></tr></thead><tbody><tr><td>1金矿</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>2金矿</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>3金矿</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>4金矿</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>5金矿</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>第一个金矿的信息：400金，5工人</p><table><thead><tr><th></th><th>1工人</th><th>2工人</th><th>3工人</th><th>4工人</th><th>5工人</th><th>6工人</th><th>7工人</th><th>8工人</th><th>9工人</th><th>10工人</th></tr></thead><tbody><tr><td>1金矿</td><td>0</td><td>0</td><td>0</td><td>0</td><td>400</td><td>400</td><td>400</td><td>400</td><td>400</td><td>400</td></tr><tr><td>2金矿</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>3金矿</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>4金矿</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>5金矿</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>第二个金矿的信息：500金，5工人<br>根据F(n,w) = Max(F(n-1, w), F(n-1, w-5) + 500)， 5-9格子为500，第2行第10个格子，n=2，w=10 F(n-1, w-5) = 400 Max(400, 400+500) = 900</p><table><thead><tr><th></th><th>1工人</th><th>2工人</th><th>3工人</th><th>4工人</th><th>5工人</th><th>6工人</th><th>7工人</th><th>8工人</th><th>9工人</th><th>10工人</th></tr></thead><tbody><tr><td>1金矿</td><td>0</td><td>0</td><td>0</td><td>0</td><td>400</td><td>400</td><td>400</td><td>400</td><td>400</td><td>400</td></tr><tr><td>2金矿</td><td>0</td><td>0</td><td>0</td><td>0</td><td>500</td><td>500</td><td>500</td><td>500</td><td>500</td><td>900</td></tr><tr><td>3金矿</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>4金矿</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>5金矿</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>第三个金矿的信息：200金，3工人</p><p>根据F(n,w) = Max(F(n-1, w), F(n-1, w-5) + 200)</p><table><thead><tr><th></th><th>1工人</th><th>2工人</th><th>3工人</th><th>4工人</th><th>5工人</th><th>6工人</th><th>7工人</th><th>8工人</th><th>9工人</th><th>10工人</th></tr></thead><tbody><tr><td>1金矿</td><td>0</td><td>0</td><td>0</td><td>0</td><td>400</td><td>400</td><td>400</td><td>400</td><td>400</td><td>400</td></tr><tr><td>2金矿</td><td>0</td><td>0</td><td>0</td><td>0</td><td>500</td><td>500</td><td>500</td><td>500</td><td>500</td><td>900</td></tr><tr><td>3金矿</td><td>0</td><td>0</td><td>200</td><td>200</td><td>500</td><td>500</td><td>500</td><td>700</td><td>700</td><td>900</td></tr><tr><td>4金矿</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>5金矿</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>第四个金矿的信息：300金，4工人</p><p>根据F(n,w) = Max(F(n-1, w), F(n-1, w-5) + 300)</p><table><thead><tr><th></th><th>1工人</th><th>2工人</th><th>3工人</th><th>4工人</th><th>5工人</th><th>6工人</th><th>7工人</th><th>8工人</th><th>9工人</th><th>10工人</th></tr></thead><tbody><tr><td>1金矿</td><td>0</td><td>0</td><td>0</td><td>0</td><td>400</td><td>400</td><td>400</td><td>400</td><td>400</td><td>400</td></tr><tr><td>2金矿</td><td>0</td><td>0</td><td>0</td><td>0</td><td>500</td><td>500</td><td>500</td><td>500</td><td>500</td><td>900</td></tr><tr><td>3金矿</td><td>0</td><td>0</td><td>200</td><td>200</td><td>500</td><td>500</td><td>500</td><td>700</td><td>700</td><td>900</td></tr><tr><td>4金矿</td><td>0</td><td>0</td><td>200</td><td>300</td><td>500</td><td>500</td><td>500</td><td>700</td><td>800</td><td>900</td></tr><tr><td>5金矿</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>第五个金矿的信息：350金，3工人</p><p>根据F(n,w) = Max(F(n-1, w), F(n-1, w-5) + 350)</p><table><thead><tr><th></th><th>1工人</th><th>2工人</th><th>3工人</th><th>4工人</th><th>5工人</th><th>6工人</th><th>7工人</th><th>8工人</th><th>9工人</th><th>10工人</th></tr></thead><tbody><tr><td>1金矿</td><td>0</td><td>0</td><td>0</td><td>0</td><td>400</td><td>400</td><td>400</td><td>400</td><td>400</td><td>400</td></tr><tr><td>2金矿</td><td>0</td><td>0</td><td>0</td><td>0</td><td>500</td><td>500</td><td>500</td><td>500</td><td>500</td><td>900</td></tr><tr><td>3金矿</td><td>0</td><td>0</td><td>200</td><td>200</td><td>500</td><td>500</td><td>500</td><td>700</td><td>700</td><td>900</td></tr><tr><td>4金矿</td><td>0</td><td>0</td><td>200</td><td>300</td><td>500</td><td>500</td><td>500</td><td>700</td><td>800</td><td>900</td></tr><tr><td>5金矿</td><td>0</td><td>0</td><td>350</td><td>350</td><td>500</td><td>550</td><td>650</td><td>850</td><td>850</td><td>900</td></tr></tbody></table><p>上述表格，比如5金矿10工人的结果，来自于4金矿7工人和4金矿10工人， Max(900, 500+350)=900</p><p>不需要存储整个表格，只需要存储前一行的结果，就可以推导出新的一行。使用动态规划如下：</p><figure class="highlight java"><figcaption><span>DP解法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMostGold</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> w, <span class="keyword">int</span>[] g, <span class="keyword">int</span>[] p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n &gt; g.length)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"输入的n值大于给定的金矿数"</span>)；</span><br><span class="line"><span class="keyword">if</span> (w &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"输入的工人数w不能为负数"</span>)；</span><br><span class="line"><span class="keyword">if</span> (n &lt; <span class="number">1</span> || w == <span class="number">0</span>) </span><br><span class="line">reurn <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> col = w + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span>[] preResults = <span class="keyword">new</span> in[col];</span><br><span class="line"><span class="keyword">int</span>[] results = <span class="keyword">new</span> <span class="keyword">int</span>[col];</span><br><span class="line"></span><br><span class="line"><span class="comment">//填充边界格子的值 (边界)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; col; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i &lt; p[<span class="number">0</span>]) &#123;</span><br><span class="line">preResults[i] = <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">preResults[i] = g[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> preResults = g[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//填充其余格子的值，外层循环是金矿的数量(递推的轮次)，内层循环是工人数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (j &lt; p[<span class="number">1</span>]) &#123;</span><br><span class="line">results[j] = preResults[j];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">results[j] = Math.max(preResults[j], reResults[j-p[i]] + g[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line"><span class="comment">//更新上一行的值，为下一轮递推做准备</span></span><br><span class="line">preResults[j] = results[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* preResults = results;</span></span><br><span class="line"><span class="comment">* 这样赋值会导致preResults和results指向同一个数组，</span></span><br><span class="line"><span class="comment">*在下一轮循环中改变results中的值也改变了preResults中的值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> results[w];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述方法利用两层迭代，外层迭代对表格每一行的迭代过程中，会保留上一行的结果数组preResults，并循环计算当前的结果数组results。<br>方法的时间复杂度为O(n*w)，空间复杂度是O(w)。<br>当金矿更多的时候，动态规划的优势就能体现出来。</p><p>然而，当工人为1000时，动态规划的时间复杂度为5 * 1000 = 5000，开辟1000单位的空间。 递归的时间复杂度是O(2^n)，需要计算32次，开辟5单位（递归深度）的空间。</p><p>动态规划方法的时间和空间都和w成正比，而简单递归和w无关，所以工人很多的时候，动规反而不如递归。</p><p>所以说，每一种算法都没有绝对的好与坏，关键看应用场景。</p><h3 id="备忘录解法"><a href="#备忘录解法" class="headerlink" title="备忘录解法"></a>备忘录解法</h3><figure class="highlight java"><figcaption><span>备忘录解法 </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该内部类对象用于备忘录算法中作为HashMap存储的键</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Input</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> w;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Input</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>.n = n;</span><br><span class="line"><span class="keyword">this</span>.w = w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> prime = <span class="number">31</span>;</span><br><span class="line"><span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">result = prime * result + n;</span><br><span class="line">result = prime * result + w;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> == obj)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">if</span> (obj == <span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">if</span> (getClass() != obj.getClass())</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">Input other = (Input) obj;</span><br><span class="line"><span class="keyword">if</span> (n != other.n)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">if</span> (w != other.w)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 备忘录算法解法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMostGold2</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> w, HashMap&lt;Input, Integer&gt; map, <span class="keyword">int</span>[] g, <span class="keyword">int</span>[] p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; g.length) </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"输入的n值大于给定的金矿数"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span> &amp;&amp; w &lt; p[<span class="number">0</span>]) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span> &amp;&amp; w &gt;= p[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> g[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span> &amp;&amp; w &lt; p[n-<span class="number">1</span>]) &#123;</span><br><span class="line">        Input input = <span class="keyword">new</span> Input(n-<span class="number">1</span>, w);</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(input)) </span><br><span class="line">            <span class="keyword">return</span> map.get(input);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> value = getMostGold2(n-<span class="number">1</span>, w, map, g, p);</span><br><span class="line">        map.put(input, value);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">   Input input1 = <span class="keyword">new</span> Input(n-<span class="number">1</span>, w);</span><br><span class="line">   Input input2 = <span class="keyword">new</span> Input(n-<span class="number">1</span>, w-p[n-<span class="number">1</span>]);</span><br><span class="line">   <span class="keyword">int</span> a = <span class="number">0</span>; <span class="comment">//用于记录F(n-1,w)的值</span></span><br><span class="line">   <span class="keyword">int</span> b = <span class="number">0</span>; <span class="comment">//用于记录F(n-1,w-p[n-1])+g[n-1])的值</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (map.containsKey(input1)) </span><br><span class="line">       a = map.get(input1);</span><br><span class="line">   a = getMostGold2(n-<span class="number">1</span>, w, map, g, p);</span><br><span class="line">   map.put(input1, a);</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">if</span> (map.containsKey(input2)) </span><br><span class="line">       b = map.get(input2) + g[n-<span class="number">1</span>];</span><br><span class="line">   b = getMostGold2(n-<span class="number">1</span>, w-p[n-<span class="number">1</span>], map, g, p);</span><br><span class="line">   map.put(input2, b);</span><br><span class="line">   b += g[n-<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;div&gt;Those who cannot remember the past are condemned to repeat it.&lt;/div&gt;&lt;div&gt;-Dynamic Programming.&lt;/div&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Dynamic Programming" scheme="https://www.blogs.rhsphere.com/categories/Dynamic-Programming/"/>
    
    
      <category term="Dynamic Programming" scheme="https://www.blogs.rhsphere.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>二叉搜索树</title>
    <link href="https://www.blogs.rhsphere.com/2019/03/16/binary-search-tree.html"/>
    <id>https://www.blogs.rhsphere.com/2019/03/16/binary-search-tree.html</id>
    <published>2019-03-16T14:00:40.000Z</published>
    <updated>2019-07-09T01:45:55.270Z</updated>
    
    <content type="html"><![CDATA[<p class="description">二叉搜索树（没有重复元素）的特征是：对于树中的每一个节点，它的左子树中的节点的值都小于该节点的值，而它的右子树中节点的值都大于该节点的值。</p><a id="more"></a><h2 id="表示二叉搜索树"><a href="#表示二叉搜索树" class="headerlink" title="表示二叉搜索树"></a>表示二叉搜索树</h2><p>二叉搜索树（Binary Search Tree,  BST）可以用一个链式节点的集合来表示二叉树。 每个节点都包含一个数值和两个称为left和right的链接，分别指向左孩子和右孩子。</p><figure class="highlight java"><figcaption><span>树的节点类</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** This inner class is static, because it does not access</span></span><br><span class="line"><span class="comment">    *any instance members defined in its outer class </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">E</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> E element;</span><br><span class="line">    <span class="keyword">protected</span> TreeNode&lt;E&gt; left;</span><br><span class="line">    <span class="keyword">protected</span> TreeNode&lt;E&gt; right;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        element = e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line">TreeNode&lt;Integer&gt; root = <span class="keyword">new</span> TreeNode&lt;&gt;(<span class="number">60</span>);</span><br></pre></td></tr></table></figure><p>变量root指向根节点。如果树为空，root的值为null。</p><h2 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h2><p>二叉树分为根节点、左子树和右子树，分别表示为 +、1、2。<br>二叉树本身是递归定义的，相应的遍历很自然就成为一种递归问题。</p><p>递归遍历操作的关键点是递归体和递归出口：</p><ul><li>递归出口是二叉树的空子树或叶节点，此时为空操作，递归不继续进行，只能回退；</li><li>递归体是对二叉树根节点或左、右子树进行相应处理。</li></ul><p>基于递归的遍历算法易于编写，操作简单，但可读性差，系统需要维护相应的工作栈，效率不是很高。递归转化为非递归的基本思想是如何实现原本是系统完成的递归工作栈，为此，可以仿照递归执行过程中工作栈状态变化而得到。</p><p>对二叉树进行前序、中序和后序遍历时都开始于根节点或结束于根节点，经由路线也相同。彼此差别在于对节点访问时机的选择不同。三种遍历方式都是沿着左子树不断深入下去，当到达二叉树左下节点而无法往下深入时，就向上逐一返回，行进到最近深入时曾遇到节点的右子树，然后进行同样的深入和返回，直到最终从根节点的右子树返回到根节点。<br>这样，遍历时返回顺序与深入节点顺序恰好相反，因此可以在实现二叉树遍历过程中，使用一个工作栈来保存当前深入到的节点信息，以供后面返回需要时使用。</p><h3 id="中序遍历-inorder-traversal"><a href="#中序遍历-inorder-traversal" class="headerlink" title="中序遍历(inorder traversal)"></a>中序遍历(inorder traversal)</h3><p>遍历顺序为： 1+2  可以递增顺序显示BST中所有节点。<br>中序遍历的黄金口诀：当前节点为空，从栈中弹出一个元素，当前节点向右移动；当前节点不为空，压栈，当前节点向左移动</p><ul><li>中序遍历访问左子二叉树</li><li>访问根节点</li><li>中序遍历访问右子二叉树</li></ul><figure class="highlight java"><figcaption><span>inorder递归遍历</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    inorder(root);      </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode&lt;E&gt; root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    inorder(root.left);  <span class="comment">// 递归遍历左子树</span></span><br><span class="line">    System.out.print(root.element + <span class="string">" "</span>);  <span class="comment">// 递归遍历根节点</span></span><br><span class="line">    inorder(root.right);  <span class="comment">// 递归遍历右子树 1+2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>中序非递归遍历</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    inorder(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode&lt;E&gt; root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    java.util.Stack&lt;TreeNode&lt;E&gt;&gt; stack = <span class="keyword">new</span> java.util.Stack&lt;&gt;();</span><br><span class="line">    TreeNode&lt;E&gt; current = root;</span><br><span class="line">    <span class="keyword">while</span> (!stack.empty() || current != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (current != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(current);</span><br><span class="line">            current = current.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;            </span><br><span class="line">            TreeNode&lt;E&gt; node = stack.pop();</span><br><span class="line">            System.out.print(node.element + <span class="string">" "</span>);</span><br><span class="line">            current = node.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="前序遍历-preorder-traversal"><a href="#前序遍历-preorder-traversal" class="headerlink" title="前序遍历(preorder traversal)"></a>前序遍历(preorder traversal)</h3><p>+12  深度优先遍历法(depth-first traversal)与前序遍历法相同。</p><ul><li>访问根节点</li><li>前序遍历访问左子二叉树</li><li>前序遍历访问右子二叉树</li></ul><figure class="highlight java"><figcaption><span>preorder递归遍历</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preorder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    preorder(root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">preorder</span><span class="params">(TreeNode&lt;E&gt; root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    System.out.println(root.element + <span class="string">" "</span>);  <span class="comment">// 递归遍历根节点</span></span><br><span class="line">    preorder(root.left);  <span class="comment">// 递归遍历左子树</span></span><br><span class="line">    preorder(root.right);  <span class="comment">// 递归遍历右子树 +12</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>前序非递归遍历</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preorder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    preorder(root);</span><br><span class="line">&#125;    </span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">preorder</span><span class="params">(TreeNode&lt;E&gt; root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    Stack&lt;TreeNode&lt;E&gt;&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!stack.empty()) &#123;</span><br><span class="line">        TreeNode&lt;E&gt; node = stack.pop();</span><br><span class="line">        System.out.print(node.element + <span class="string">" "</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Push the right child onto the stack </span></span><br><span class="line">        <span class="comment">// first so the left is processed first</span></span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="后序遍历-postorder-traversal"><a href="#后序遍历-postorder-traversal" class="headerlink" title="后序遍历(postorder traversal)"></a>后序遍历(postorder traversal)</h3><p>12+ </p><ul><li>后序遍历访问左子二叉树</li><li>后序遍历访问右子二叉树</li><li>访问根节点</li></ul><figure class="highlight java"><figcaption><span>postorder递归遍历</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postorder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    postorder(root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">postorder</span><span class="params">(TreeNode&lt;E&gt; root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    postorder(root.left);  <span class="comment">// 递归遍历左子树</span></span><br><span class="line">    postorder(root.right);  <span class="comment">// 递归遍历右子树</span></span><br><span class="line">    System.out.println(root.element + <span class="string">" "</span>);  <span class="comment">// 递归遍历根节点 12+</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>后序非递归遍历</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postorder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    postorder(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">postorder</span><span class="params">(TreeNode&lt;E&gt; root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create two stacks</span></span><br><span class="line">    Stack&lt;TreeNode&lt;E&gt;&gt; stack1 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    Stack&lt;TreeNode&lt;E&gt;&gt; stack2 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// push root to stack1</span></span><br><span class="line">    stack1.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!stack1.empty()) &#123;</span><br><span class="line">        <span class="comment">// Pop node from stack1 and push onto stack2</span></span><br><span class="line">        TreeNode&lt;E&gt; node = stack1.pop();</span><br><span class="line">        stack2.push(node);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="keyword">null</span>)</span><br><span class="line">            stack1.push(node.left);</span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="keyword">null</span>)</span><br><span class="line">            stack1.push(node.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Display elements in stack2</span></span><br><span class="line">    <span class="keyword">while</span> (!stack2.empty()) &#123;</span><br><span class="line">        System.out.print(stack2.pop().element + <span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="广度优先遍历-breadth-first-traversal"><a href="#广度优先遍历-breadth-first-traversal" class="headerlink" title="广度优先遍历(breadth-first traversal)"></a>广度优先遍历(breadth-first traversal)</h3><figure class="highlight java"><figcaption><span>广度优先遍历</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">breadthFirstTraversal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Queue Deque Linkedlist</span></span><br><span class="line">    java.util.Queue&lt;TreeNode&lt;E&gt;&gt; queue = <span class="keyword">new</span> java.util.LinkedList&lt;&gt;();  </span><br><span class="line"></span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        TreeNode&lt;E&gt; current = queue.element();</span><br><span class="line">        <span class="keyword">if</span> (current.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.add(current.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (current.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.add(current.right);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(queue.remove().element + <span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="搜索一个元素"><a href="#搜索一个元素" class="headerlink" title="搜索一个元素"></a>搜索一个元素</h2><p>二叉搜索树中搜索一个元素，可以从根节点向下扫描，知道找到匹配元素，或者达到一棵空子树为止。<br><figure class="highlight java"><figcaption><span>在BST中搜索一个元素</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    TreeNode&lt;E&gt; current = root; <span class="comment">// 当前指针指向根节点</span></span><br><span class="line">    <span class="keyword">while</span> (current != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.compareTo(current.element) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            current = current.left;  <span class="comment">// 比当前指针的元素小，则往左</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e.compareTo(current.element) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            current = current.right; <span class="comment">// 比当前指针的元素大，则往右</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 元素匹配</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;  <span class="comment">// 找到元素 return true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="插入一个元素"><a href="#插入一个元素" class="headerlink" title="插入一个元素"></a>插入一个元素</h2><p>BST中插入一个元素，需要确定在书中插入的位置，关键思路是确定新节点的父节点所在的位置。</p><ul><li>如果树是空的，使用新元素创建一个根节点；</li><li>否则，寻找新节点的父节点的位置</li><li>为该元素创建一个新节点，如果新元素的值小于父元素的值，左子节点；如果新元素的值大于父元素的值，右子节点；BST没有重复元素，重复则不插入</li></ul><figure class="highlight java"><figcaption><span>在BST中插入一个元素</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">insert</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        root = createNewNode(e);  <span class="comment">// 创建一个节点，树为空该节点成为根节点</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        TreeNode&lt;E&gt; parent = <span class="keyword">null</span>;  <span class="comment">// 定位父节点</span></span><br><span class="line">        TreeNode&lt;E&gt; current = root;  <span class="comment">// 当前指针指向根节点</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (current != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.compareTo(current.element) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                parent = current;</span><br><span class="line">                current = current.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e.compareTo(current.element) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                parent = current;</span><br><span class="line">                current = current.right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 元素已经在树中，return false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 为元素e创建一个节点</span></span><br><span class="line">        <span class="keyword">if</span> (e.compareTo(parent.element) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            parent.left = createNewNode(e);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            parent.right = createNewNode(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    size++;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode&lt;E&gt; <span class="title">createNewNode</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TreeNode&lt;&gt;(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除BST中的一个元素"><a href="#删除BST中的一个元素" class="headerlink" title="删除BST中的一个元素"></a>删除BST中的一个元素</h2><p>为了从一棵二叉搜索树中删除一个元素，首先需要定位该元素位置，然后再删除该元素以及重新连接树前，考虑两种情况–该节点有或者没有左子节点。<br>情况1：当前节点没有左子结点。只需将该节点的父节点和该节点的右子节点相连。如果当前节点是叶子节点，属于情况1；</p><p>情况2：当前节点有左子结点。假设rightMost指向包含current节点的左子树中的最大元素的节点，而parentOfRightMost指向rightMost节点的父节点。使用rightMost节点中的元素替代current节点中的元素值，将parentOfRightMost节点和rightMost节点的左子节点相连，然后删除rightMost节点。  rightMost作为最大值不能有右节点，但是可能会有左子节点！<br><figure class="highlight java"><figcaption><span>从BST中删除一个元素</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">delete</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果current为root,那么parent为null</span></span><br><span class="line">    TreeNode&lt;E&gt; parent = <span class="keyword">null</span>;  <span class="comment">// 指向current节点的父节点</span></span><br><span class="line">    TreeNode&lt;E&gt; current = root; <span class="comment">// 指向二叉搜索树中包含该元素的节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (current != <span class="keyword">null</span>) &#123; <span class="comment">// 递归寻找current节点</span></span><br><span class="line">        <span class="keyword">if</span> (e.compareTo(current.element) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            parent = current;</span><br><span class="line">            current = current.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e.compareTo(current.element) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            parent = current;</span><br><span class="line">            current = current.right;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;                </span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// 找到包含e的current节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (current == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 元素不在树内</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 情况1：当前节点没有左子节点</span></span><br><span class="line">    <span class="keyword">if</span> (current.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//只需将该节点的父节点和该节点的右子节点相连</span></span><br><span class="line">        <span class="keyword">if</span> (parent == <span class="keyword">null</span>) &#123;</span><br><span class="line">            root = current.right;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.compareTo(parent.element) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                parent.left = current.right;  <span class="comment">// e是父节点的左子结点</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                parent.right = current.right; <span class="comment">// e是父节点的右子结点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="comment">// 情况2：当前节点有左子节点</span></span><br><span class="line">        TreeNode&lt;E&gt; parentOfRightMost = current;  <span class="comment">// rightMost节点的父节点</span></span><br><span class="line">        TreeNode&lt;E&gt; rightMost = current.left;   <span class="comment">// 当前节点的左子树最右端的节点</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (rightMost.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            parentOfRightMost = rightMost;</span><br><span class="line">            rightMost = rightMost.right;  <span class="comment">// 向右不断递归</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 用rightMost节点的内容替换current中的内容</span></span><br><span class="line">        current.element = rightMost.element;</span><br><span class="line">        <span class="comment">// rightMost的父节点和rightMost的左子节点相连</span></span><br><span class="line">        <span class="keyword">if</span> (parentOfRightMost.right == rightMost) &#123;</span><br><span class="line">            <span class="comment">// rightMost是右子节点</span></span><br><span class="line">            parentOfRightMost.right = rightMost.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// rightMost是左子节点</span></span><br><span class="line">            parentOfRightMost.left = rightMost.left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    size--;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="找出叶子节点和非叶子结点"><a href="#找出叶子节点和非叶子结点" class="headerlink" title="找出叶子节点和非叶子结点"></a>找出叶子节点和非叶子结点</h2><figure class="highlight java"><figcaption><span>找出叶子节点的个数</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumberOfLeaves</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getNumberOfLeaves(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getNumberOfLeaves</span><span class="params">(TreeNode&lt;E&gt; root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root ==<span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// If node has no children return 1 </span></span><br><span class="line">    <span class="comment">// else return the sum of all the leaves</span></span><br><span class="line">    <span class="keyword">return</span> root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span> ? </span><br><span class="line">            <span class="number">1</span> : getNumberOfLeaves(root.left) + getNumberOfLeaves(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>找出非叶子节点的个数</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumberOfNonLeaves</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getNumberOfNonLeaves(root);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getNumberOfNonLeaves</span><span class="params">(TreeNode&lt;E&gt; root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// If node has children return 0</span></span><br><span class="line">    <span class="comment">// else return 1 plus the sum of the nonleaves</span></span><br><span class="line">    <span class="keyword">return</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) ? <span class="number">0</span> : </span><br><span class="line">        <span class="number">1</span> + getNumberOfNonLeaves(root.left) + </span><br><span class="line">        getNumberOfNonLeaves(root.right) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现equals和clone方法"><a href="#实现equals和clone方法" class="headerlink" title="实现equals和clone方法"></a>实现equals和clone方法</h2><figure class="highlight java"><figcaption><span>树的equals方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(BST&lt;E&gt; tree)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree.size != size) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> equals(root, tree.root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Equals helper */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(TreeNode&lt;E&gt; root1, TreeNode&lt;E&gt; root2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root1 == root2) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (root1 == <span class="keyword">null</span> || root2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> root1.element.equals(root2.element) &amp;&amp;</span><br><span class="line">    equals(root1.left, root2.left) &amp;&amp;</span><br><span class="line">    equals(root1.right, root2.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>树的clone方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> BST&lt;E&gt; <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">    BST&lt;E&gt; cloneBST = <span class="keyword">new</span> BST&lt;&gt;();</span><br><span class="line">    clone(cloneBST, root);</span><br><span class="line">    <span class="keyword">return</span> cloneBST;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Clone helper */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">clone</span><span class="params">(BST&lt;E&gt; clone, TreeNode&lt;E&gt; root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    clone.insert(root.element);</span><br><span class="line">    clone(clone, root.left);</span><br><span class="line">    clone(clone, root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BST类"><a href="#BST类" class="headerlink" title="BST类"></a>BST类</h2><p>使用一个Tree的接口来定义树的所有常用操作，提供AbstractTree的抽象类部分实现了Tree，最后实现了BST类。</p><h3 id="Tree接口"><a href="#Tree接口" class="headerlink" title="Tree接口"></a>Tree接口</h3><figure class="highlight java"><figcaption><span>Tree.java 接口定义树的常用操作</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Tree</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Iterable</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line">    <span class="comment">/** Return true 如果搜索成功 */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">search</span><span class="params">(E e)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 向二叉搜索树插入元素  Return true 如果成功添加 */</span>   </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">insert</span><span class="params">(E e)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Return true 如果成功从树中删除元素 */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">delete</span><span class="params">(E e)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 中序遍历打印节点 1+2 */</span> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 后序遍历打印节点 12+ */</span> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">postorder</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 前序遍历打印节点 +12 */</span> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">preorder</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 广度优先遍历打印节点 */</span>   </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">breadthFirstTraversal</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 返回树中节点数 */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Return true 如果树为空 */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AbstractTree抽象类"><a href="#AbstractTree抽象类" class="headerlink" title="AbstractTree抽象类"></a>AbstractTree抽象类</h3><figure class="highlight java"><figcaption><span>AbstractTree.java 抽象类部分地实现了Tree</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractTree</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Tree</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">/** 中序遍历打印节点 1+2 */</span>   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">/** 后序遍历打印节点 12+ */</span>   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postorder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">/** 前序遍历打印节点 +12 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preorder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">/** Return true 如果树为空 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getSize() == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="具体的BST"><a href="#具体的BST" class="headerlink" title="具体的BST"></a>具体的BST</h3><figure class="highlight java"><figcaption><span>BST.java 具体定义了BST</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 因为每个节点只遍历一次，遍历的时间复杂度都是O(n)</span></span><br><span class="line"><span class="comment"> * 搜索、插入和删除的时间复杂度是树的高度。</span></span><br><span class="line"><span class="comment"> * 最差的情况下，树的高度为O(n)</span></span><br><span class="line"><span class="comment"> * 如果树是平衡的，高度将是O（logn) </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BST</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">E</span>&gt;&gt; <span class="keyword">extends</span> <span class="title">AbstractTree</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> TreeNode&lt;E&gt; root; <span class="comment">//根节点</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> size = <span class="number">0</span>;  <span class="comment">//节点数目</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 默认构造方法 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BST</span><span class="params">()</span> </span>&#123;      </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** 泛型数组构造二叉搜索树 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BST</span><span class="params">(E[] objects)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; objects.length; i++)</span><br><span class="line">            insert(objects[i]);</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        TreeNode&lt;E&gt; current = root; <span class="comment">// 当前指针指向根节点</span></span><br><span class="line">        <span class="keyword">while</span> (current != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.compareTo(current.element) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                current = current.left;  <span class="comment">// 比当前指针的元素小，则往左</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e.compareTo(current.element) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                current = current.right; <span class="comment">// 比当前指针的元素大，则往右</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 元素匹配</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;  <span class="comment">// 找到元素 return true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">insert</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            root = createNewNode(e);  <span class="comment">// 创建一个节点，树为空该节点成为根节点</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            TreeNode&lt;E&gt; parent = <span class="keyword">null</span>;  <span class="comment">// 定位父节点</span></span><br><span class="line">            TreeNode&lt;E&gt; current = root;  <span class="comment">// 当前指针指向根节点</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> (current != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.compareTo(current.element) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    parent = current;</span><br><span class="line">                    current = current.left;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e.compareTo(current.element) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    parent = current;</span><br><span class="line">                    current = current.right;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 元素已经在树中，return false</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 为元素e创建一个节点</span></span><br><span class="line">            <span class="keyword">if</span> (e.compareTo(parent.element) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                parent.left = createNewNode(e);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                parent.right = createNewNode(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode&lt;E&gt; <span class="title">createNewNode</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TreeNode&lt;&gt;(e);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 为了从一棵二叉搜索树中删除一个元素，首先需要定位该元素位置，</span></span><br><span class="line"><span class="comment">     * 然后在删除该元素以及重新连接树之前，考虑两种情况：</span></span><br><span class="line"><span class="comment">     * 1）该节点有左子节点</span></span><br><span class="line"><span class="comment">     * 2）该节点没有左子节点 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">delete</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果current为root,那么parent为null</span></span><br><span class="line">        TreeNode&lt;E&gt; parent = <span class="keyword">null</span>;  <span class="comment">// 指向current节点的父节点</span></span><br><span class="line">        TreeNode&lt;E&gt; current = root; <span class="comment">// 指向二叉搜索树中包含该元素的节点</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (current != <span class="keyword">null</span>) &#123; <span class="comment">// 递归寻找current节点</span></span><br><span class="line">            <span class="keyword">if</span> (e.compareTo(current.element) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                parent = current;</span><br><span class="line">                current = current.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e.compareTo(current.element) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                parent = current;</span><br><span class="line">                current = current.right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;                </span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 找到包含e的current节点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (current == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 元素不在树内</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 情况1：当前节点没有左子节点</span></span><br><span class="line">        <span class="keyword">if</span> (current.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//只需将该节点的父节点和该节点的右子节点相连</span></span><br><span class="line">            <span class="keyword">if</span> (parent == <span class="keyword">null</span>) &#123;</span><br><span class="line">                root = current.right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.compareTo(parent.element) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    parent.left = current.right;  <span class="comment">// e是父节点的左子结点</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    parent.right = current.right; <span class="comment">// e是父节点的右子结点</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">            <span class="comment">// 情况2：当前节点有左子节点</span></span><br><span class="line">            TreeNode&lt;E&gt; parentOfRightMost = current;  <span class="comment">// rightMost节点的父节点</span></span><br><span class="line">            TreeNode&lt;E&gt; rightMost = current.left;   <span class="comment">// 当前节点的左子树最右端的节点</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> (rightMost.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                parentOfRightMost = rightMost;</span><br><span class="line">                rightMost = rightMost.right;  <span class="comment">// 向右不断递归</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 用rightMost节点的内容替换current中的内容</span></span><br><span class="line">            current.element = rightMost.element;</span><br><span class="line">            <span class="comment">// rightMost的父节点和rightMost的左子节点相连</span></span><br><span class="line">            <span class="keyword">if</span> (parentOfRightMost.right == rightMost) &#123;</span><br><span class="line">                <span class="comment">// rightMost是右子节点</span></span><br><span class="line">                parentOfRightMost.right = rightMost.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// rightMost是左子节点</span></span><br><span class="line">                parentOfRightMost.left = rightMost.left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        inorder(root);      </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode&lt;E&gt; root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        inorder(root.left);  <span class="comment">// 递归遍历左子树</span></span><br><span class="line">        System.out.print(root.element + <span class="string">" "</span>);  <span class="comment">// 递归遍历根节点</span></span><br><span class="line">        inorder(root.right);  <span class="comment">// 递归遍历右子树 1+2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postorder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        postorder(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">postorder</span><span class="params">(TreeNode&lt;E&gt; root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        postorder(root.left);  <span class="comment">// 递归遍历左子树</span></span><br><span class="line">        postorder(root.right);  <span class="comment">// 递归遍历右子树</span></span><br><span class="line">        System.out.println(root.element + <span class="string">" "</span>);  <span class="comment">// 递归遍历根节点 12+</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preorder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        preorder(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">preorder</span><span class="params">(TreeNode&lt;E&gt; root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        System.out.println(root.element + <span class="string">" "</span>);  <span class="comment">// 递归遍历根节点</span></span><br><span class="line">        preorder(root.left);  <span class="comment">// 递归遍历左子树</span></span><br><span class="line">        preorder(root.right);  <span class="comment">// 递归遍历右子树 +12</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">breadthFirstTraversal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        Queue&lt;TreeNode&lt;E&gt;&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();  <span class="comment">// Queue Deque Linkedlist</span></span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            TreeNode&lt;E&gt; current = queue.element();</span><br><span class="line">            <span class="keyword">if</span> (current.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.add(current.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (current.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.add(current.right);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(queue.remove().element + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**以数组线性表返回节点的路径：</span></span><br><span class="line"><span class="comment">     * 从根节点开始到该元素所在的节点</span></span><br><span class="line"><span class="comment">     * 元素可能不在树中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;TreeNode&lt;E&gt;&gt; path(E e) &#123;</span><br><span class="line">        ArrayList&lt;TreeNode&lt;E&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        TreeNode&lt;E&gt; current = root;</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="keyword">null</span>) &#123;</span><br><span class="line">            list.add(current);</span><br><span class="line">            <span class="keyword">if</span> (e.compareTo(current.element) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                current = current.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e.compareTo(current.element) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                current = current.right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">height</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> height(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">height</span><span class="params">(TreeNode&lt;E&gt; root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + Math.max(height(root.left), height(root.right));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode&lt;E&gt; <span class="title">getRoot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        root = <span class="keyword">null</span>;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** 测试完全二叉树，完全二叉树的节点格式为 2^depth - 1 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFullBST</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size == Math.pow(<span class="number">2</span>, height()) - <span class="number">1</span> ? <span class="keyword">true</span> : <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** 找出叶子节点的个数 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumberOfLeaves</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getNumberOfLeaves(root);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getNumberOfLeaves</span><span class="params">(TreeNode&lt;E&gt; root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root ==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// If node has no children return 1 </span></span><br><span class="line">        <span class="comment">// else return the sum of all the leaves</span></span><br><span class="line">        <span class="keyword">return</span> root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span> ? </span><br><span class="line">                <span class="number">1</span> : getNumberOfLeaves(root.left) + getNumberOfLeaves(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumberOfNonLeaves</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getNumberOfNonLeaves(root);</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getNumberOfNonLeaves</span><span class="params">(TreeNode&lt;E&gt; root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// If node has children return 0</span></span><br><span class="line">        <span class="comment">// else return 1 plus the sum of the nonleaves</span></span><br><span class="line">        <span class="keyword">return</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) ? <span class="number">0</span> : </span><br><span class="line">            <span class="number">1</span> + getNumberOfNonLeaves(root.left) + </span><br><span class="line">            getNumberOfNonLeaves(root.right) ;</span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns true if two trees are equal. </span></span><br><span class="line"><span class="comment">     Otherwise returns false (recursive) */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(BST&lt;E&gt; tree)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tree.size != size) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> equals(root, tree.root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Equals helper */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(TreeNode&lt;E&gt; root1, TreeNode&lt;E&gt; root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root1 == root2) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (root1 == <span class="keyword">null</span> || root2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> root1.element.equals(root2.element) &amp;&amp;</span><br><span class="line">        equals(root1.left, root2.left) &amp;&amp;</span><br><span class="line">        equals(root1.right, root2.right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">/** Override the protected clone method  </span></span><br><span class="line"><span class="comment">    defined in the Object class, and deep copy BST */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BST&lt;E&gt; <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        BST&lt;E&gt; cloneBST = <span class="keyword">new</span> BST&lt;&gt;();</span><br><span class="line">        clone(cloneBST, root);</span><br><span class="line">        <span class="keyword">return</span> cloneBST;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Clone helper */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">clone</span><span class="params">(BST&lt;E&gt; clone, TreeNode&lt;E&gt; root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        clone.insert(root.element);</span><br><span class="line">        clone(clone, root.left);</span><br><span class="line">        clone(clone, root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> InorderIterator();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">InorderIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> ArrayList&lt;E&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> current = <span class="number">0</span>;  <span class="comment">// 指向线性表中的第一个元素</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">InorderIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            inorder();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            inorder(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode&lt;E&gt; root)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            inorder(root.left);</span><br><span class="line">            list.add(root.element);</span><br><span class="line">            inorder(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (current &lt; list.size())  <span class="comment">// 检查current是否在list范围内</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> list.get(current++); <span class="comment">// 返回当前元素 然后current+1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            delete(list.get(current));  <span class="comment">// 删除当前元素</span></span><br><span class="line">            list.clear();  <span class="comment">// 清空线性表</span></span><br><span class="line">            inorder();  <span class="comment">// 创建一个新的线性表，每次通过迭代器删除一个元素都要重新构造整个线性表</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*  在使得remove方法不被迭代器支持后，</span></span><br><span class="line"><span class="comment">          * 无须为树中的元素维护一个线性表使得迭代器更加高效。</span></span><br><span class="line"><span class="comment">          * 可以使用栈来存储节点</span></span><br><span class="line"><span class="comment">          * </span></span><br><span class="line"><span class="comment">         public void remove() &#123;</span></span><br><span class="line"><span class="comment">            throw new UnsupportedOparetionException("removing </span></span><br><span class="line"><span class="comment">            an element from the iterator is not supported");</span></span><br><span class="line"><span class="comment">         &#125;                </span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">/** Returns an iterator for traversing the elements in preorder */</span></span><br><span class="line">    <span class="keyword">public</span> java.util.<span class="function">Iterator&lt;E&gt; <span class="title">preorderIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PreorderIterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Inner class preorderIterator</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">PreorderIterator</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">util</span>.<span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">// Store the elements in a list</span></span><br><span class="line">        <span class="keyword">private</span> java.util.ArrayList&lt;E&gt; list =</span><br><span class="line">            <span class="keyword">new</span> java.util.ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> current = <span class="number">0</span>; <span class="comment">// Point to the current element in list</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">PreorderIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            preorder(); <span class="comment">// Traverse binary tree and store elements in list</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** Preorder traversal from the root */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">preorder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            preorder(root);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** preorder traversal from a subtree */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">preorder</span><span class="params">(TreeNode&lt;E&gt; root)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">            list.add(root.element);</span><br><span class="line">            preorder(root.left);</span><br><span class="line">            preorder(root.right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span> <span class="comment">/** More elements for traversing? */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (current &lt; list.size())</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span> <span class="comment">/** Get the current element and move to the next */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> list.get(current++);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span> <span class="comment">/** Remove the current element */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            delete(list.get(current)); <span class="comment">// Delete the current element</span></span><br><span class="line">            list.clear(); <span class="comment">// Clear the list</span></span><br><span class="line">            preorder(); <span class="comment">// Rebuild the list</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** This inner class is static, because it does not access</span></span><br><span class="line"><span class="comment">    any instance members defined in its outer class */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">E</span>&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">protected</span> E element;</span><br><span class="line">        <span class="keyword">protected</span> TreeNode&lt;E&gt; left;</span><br><span class="line">        <span class="keyword">protected</span> TreeNode&lt;E&gt; right;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">            element = e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BST的测试用例"><a href="#BST的测试用例" class="headerlink" title="BST的测试用例"></a>BST的测试用例</h3><figure class="highlight java"><figcaption><span>BST测试用例</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBST</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 广度优先遍历和树的高度</span></span><br><span class="line">        BST&lt;String&gt; strTree = <span class="keyword">new</span> BST&lt;&gt;();</span><br><span class="line">        strTree.insert(<span class="string">"George"</span>);</span><br><span class="line">        strTree.insert(<span class="string">"Micheal"</span>);</span><br><span class="line">        strTree.insert(<span class="string">"Tom"</span>);</span><br><span class="line">        strTree.insert(<span class="string">"Adam"</span>);</span><br><span class="line">        strTree.insert(<span class="string">"Jones"</span>);</span><br><span class="line">        strTree.insert(<span class="string">"Peter"</span>);</span><br><span class="line">        strTree.insert(<span class="string">"Daniel"</span>);</span><br><span class="line">        </span><br><span class="line">        System.out.print(<span class="string">"\nBreadth-first: "</span>);</span><br><span class="line">        strTree.breadthFirstTraversal();        </span><br><span class="line">        System.out.print(<span class="string">"\nHeight of tree: "</span>); </span><br><span class="line">        System.out.println(strTree.height());</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 测试完全二叉树</span></span><br><span class="line">        Integer[] numbers1 = &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line">        Integer[] numbers2 = &#123;<span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">9</span>&#125;;</span><br><span class="line">        Integer[] numbers3 = &#123;<span class="number">10</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">15</span>, <span class="number">12</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">21</span>, <span class="number">19</span>, <span class="number">25</span>&#125;;</span><br><span class="line">        BST&lt;Integer&gt; intTree1 = <span class="keyword">new</span> BST&lt;&gt;(numbers1);</span><br><span class="line">        BST&lt;Integer&gt; intTree2 = <span class="keyword">new</span> BST&lt;&gt;(numbers2);</span><br><span class="line">        BST&lt;Integer&gt; intTree3 = <span class="keyword">new</span> BST&lt;&gt;(numbers3);</span><br><span class="line">        </span><br><span class="line">        System.out.print(<span class="string">"\nIs tree #1 a full binary tree? "</span>);</span><br><span class="line">        System.out.println(intTree1.isFullBST());</span><br><span class="line">        System.out.print(<span class="string">"\nIs tree #2 a full binary tree? "</span>);</span><br><span class="line">        System.out.println(intTree2.isFullBST());</span><br><span class="line">        System.out.print(<span class="string">"\nIs tree #3 a full binary tree? "</span>);</span><br><span class="line">        System.out.println(intTree3.isFullBST());</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 找出叶子节点和非叶子节点</span></span><br><span class="line">        Integer[] numbers = &#123;<span class="number">60</span>, <span class="number">55</span>, <span class="number">45</span>, <span class="number">47</span>, <span class="number">59</span>, <span class="number">100</span>, <span class="number">76</span>, <span class="number">107</span>, <span class="number">101</span>&#125;;        </span><br><span class="line">        BST&lt;Integer&gt; intTree = <span class="keyword">new</span> BST&lt;&gt;(numbers);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"Number of leaf nodes: "</span> + </span><br><span class="line">            intTree.getNumberOfLeaves());       </span><br><span class="line">        System.out.println(<span class="string">"Number of nonleaf nodes: "</span> + </span><br><span class="line">            intTree.getNumberOfNonLeaves());    </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 前序遍历</span></span><br><span class="line">        Integer[] numbers4 = &#123;<span class="number">60</span>, <span class="number">55</span>, <span class="number">45</span>, <span class="number">48</span>, <span class="number">59</span>, <span class="number">100</span>, <span class="number">76</span>, <span class="number">107</span>, <span class="number">101</span>&#125;;   </span><br><span class="line">        BST&lt;Integer&gt; intTree4 = <span class="keyword">new</span> BST&lt;&gt;(numbers4);</span><br><span class="line">        </span><br><span class="line">        System.out.print(<span class="string">"intTree: "</span>);</span><br><span class="line">        intTree4.preorder();</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试clone方法</span></span><br><span class="line">        BST&lt;Integer&gt; intTreeCopy = intTree.clone();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试equals方法</span></span><br><span class="line">        System.out.println(<span class="string">"\nIs intTree equal to intTree2? "</span> + </span><br><span class="line">            intTree.equals(intTree2));</span><br><span class="line">        System.out.println(<span class="string">"Is intTree equal to intTreeCopy? "</span> + </span><br><span class="line">            intTree.equals(intTreeCopy));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前序遍历</span></span><br><span class="line">        System.out.print(<span class="string">"intTreeCopy: "</span>);</span><br><span class="line">        intTreeCopy.preorder();</span><br><span class="line">        System.out.println();       </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 测试前序迭代器</span></span><br><span class="line">        BST&lt;String&gt; tree0 = <span class="keyword">new</span> BST&lt;&gt;();</span><br><span class="line">        tree0.insert(<span class="string">"George"</span>);</span><br><span class="line">        tree0.insert(<span class="string">"Michael"</span>);</span><br><span class="line">        tree0.insert(<span class="string">"Tom"</span>);</span><br><span class="line">        tree0.insert(<span class="string">"Adam"</span>);</span><br><span class="line">        tree0.insert(<span class="string">"Jones"</span>);</span><br><span class="line">        tree0.insert(<span class="string">"Peter"</span>);</span><br><span class="line">        tree0.insert(<span class="string">"Daniel"</span>);</span><br><span class="line"></span><br><span class="line">        Iterator&lt;String&gt; iterator = tree0.preorderIterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())</span><br><span class="line">            System.out.print(iterator.next().toUpperCase() + <span class="string">" "</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;二叉搜索树（没有重复元素）的特征是：对于树中的每一个节点，它的左子树中的节点的值都小于该节点的值，而它的右子树中节点的值都大于该节点的值。&lt;/p&gt;
    
    </summary>
    
      <category term="Tree" scheme="https://www.blogs.rhsphere.com/categories/Tree/"/>
    
    
      <category term="search" scheme="https://www.blogs.rhsphere.com/tags/search/"/>
    
      <category term="BST" scheme="https://www.blogs.rhsphere.com/tags/BST/"/>
    
      <category term="tree" scheme="https://www.blogs.rhsphere.com/tags/tree/"/>
    
  </entry>
  
  <entry>
    <title>堆排序</title>
    <link href="https://www.blogs.rhsphere.com/2019/03/14/heap-sort.html"/>
    <id>https://www.blogs.rhsphere.com/2019/03/14/heap-sort.html</id>
    <published>2019-03-14T08:00:06.000Z</published>
    <updated>2019-05-25T07:28:06.550Z</updated>
    
    <content type="html"><![CDATA[<p class="description">堆排序使用的是二叉堆。首先将所有的元素添加到一个堆上，然后不断移除最大的元素以获得一个排好序的线性表。</p><a id="more"></a><h2 id="堆的存储"><a href="#堆的存储" class="headerlink" title="堆的存储"></a>堆的存储</h2><p>堆排序(heap sort)使用二叉堆(binary heap)，它是一棵 <strong>完全二叉树</strong>，<strong>每个节点大于或等于它的任意一个孩子</strong>。<br>如果一颗二叉树的每一层都是满的，或者最后一层可以不填满并且最后一层的叶子都是靠左放置的，那么这棵二叉树就是完全的(complete)。<br>如果堆的大小是事先知道的，那么可将堆存储在一个ArrayList或一个数组中。树根在位置0处，它的两个子节点在位置1和位置2处。</p><p>对于位置<i>i</i>处的节点，它的：</p><ul><li>左子结点在位置 <span style="color:#5073b8">2i+1</span> 处</li><li>右子结点在位置 <span style="color:#5073b8">2i+2</span> 处</li><li>父节点在位置 <span style="color:#5073b8">(i-1)/2</span> 处</li></ul><h2 id="添加一个新结点"><a href="#添加一个新结点" class="headerlink" title="添加一个新结点"></a>添加一个新结点</h2><p>给堆添加一个新结点，首先将它添加到堆的末尾，然后按如下方式重建这棵树：<br><figure class="highlight java"><figcaption><span>Adding a New Node Psuedo Code</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Let the last node be the current node;</span><br><span class="line"><span class="keyword">while</span> (the current node is greater than its parent) &#123;</span><br><span class="line">    Swap the current node with its parent;</span><br><span class="line">    Now the current node is one level up;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">令最后一个节点的那个做当前节点;</span><br><span class="line"><span class="keyword">while</span> (当前节点大于他的父节点) &#123;</span><br><span class="line">    将当前节点和它的父节点交换;</span><br><span class="line">    现在当前节点往上面进了一个层级;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="删除一个结点"><a href="#删除一个结点" class="headerlink" title="删除一个结点"></a>删除一个结点</h2><p>经常需要从堆中删除最大的元素，也就是这个堆中的根节点。在删除根节点之后，就必须重建这棵树以保持堆的属性。重建该树的算法如下所示：</p><figure class="highlight java"><figcaption><span>Removing the Root Psuedo code</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Move the last node to replace the root;</span><br><span class="line">Let the root be the current node;</span><br><span class="line"><span class="keyword">while</span> (the current node has childen &amp;&amp; the current node is </span><br><span class="line">       smaller than one of its children) &#123;</span><br><span class="line">    Swap the current node with the larger of its children;</span><br><span class="line">    Now the current node is one level down;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">用最后一个节点替换根节点;</span><br><span class="line">让根节点成为当前节点;</span><br><span class="line"><span class="keyword">while</span> (当前节点具有子节点&amp;&amp;当前节点小于它的子节点) &#123;</span><br><span class="line">    将当前节点和它的较大子节点交换;</span><br><span class="line">    现在当前节点往下面退了一个层次;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Heap类"><a href="#Heap类" class="headerlink" title="Heap类"></a>Heap类</h2><p>Comparable可以认为是一个内比较器，实现了Comparable接口的类有一个特点，就是这些类是可以和自己比较的，至于具体和另一个实现了Comparable接口的类如何比较，则依赖compareTo方法的实现，compareTo方法也被称为自然比较方法。如果开发者进入一个Collection的对象想要Collections的sort方法帮你自动进行排序的话，那么这个对象必须实现Comparable接口。compareTo方法的返回值是int，有三种情况：</p><ol><li>比较者大于被比较者（也就是compareTo方法里面的对象），那么返回正整数</li><li>比较者等于被比较者，那么返回0</li><li>比较者小于被比较者，那么返回负整数</li></ol><p>Comparator可以认为是是一个外比较器，个人认为有两种情况可以使用实现Comparator接口的方式：<br>1)一个对象不支持自己和自己比较（没有实现Comparable接口），但是又想对两个对象进行比较;2)一个对象实现了Comparable接口，但是开发者认为compareTo方法中的比较方式并不是自己想要的那种比较方式<br>Comparator接口里面有一个compare方法，方法有两个参数T o1和T o2，是泛型的表示方式，分别表示待比较的两个对象，方法返回值和Comparable接口一样是int，有三种情况：</p><ol><li>o1大于o2，返回正整数</li><li>o1等于o2，返回0</li><li>o1小于o3，返回负整数</li></ol><h3 id="使用Comparable接口对元素排序"><a href="#使用Comparable接口对元素排序" class="headerlink" title="使用Comparable接口对元素排序"></a>使用Comparable接口对元素排序</h3><figure class="highlight java"><figcaption><span>使用Comparable接口对元素排序</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Heap</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Comparabel</span>&lt;<span class="title">E</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;E&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Heap</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Heap</span><span class="params">(E[] objects)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; objects.length; i++) &#123;</span><br><span class="line">            <span class="keyword">this</span>.add(objects[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E newObject)</span> </span>&#123;</span><br><span class="line">        list.add(newObject);</span><br><span class="line">        <span class="keyword">int</span> currentIndex = list.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (currentIndex &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> parentIndex = (currentIndex - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (list.get(currentIndex).compareTo(list.get(parentIndex)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                E tmp = list.get(currentIndex);</span><br><span class="line">                list.set(currentIndex, list.get(parentIndex));</span><br><span class="line">                list.set(parentIndex, tmp);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            currentIndex = parentIndex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (list.size() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        E removeObject = list.get(<span class="number">0</span>);</span><br><span class="line">        list.set(<span class="number">0</span>, list.get(list.size() - <span class="number">1</span>));</span><br><span class="line">        list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> currentIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (currentIndex &lt; list.size()) &#123;</span><br><span class="line">            <span class="keyword">int</span> leftChildIndex = <span class="number">2</span> * currentIndex + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> rightChildIndex = <span class="number">2</span> * currentIndex + <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (leftChildIndex &gt;= list.size())</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">int</span> maxIndex = leftChildIndex;</span><br><span class="line">            <span class="keyword">if</span> (rightChildIndex &lt; list.size()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (list.get(maxIndex).comparetTo(list.get(rightChildIndex)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    maxIndex = rightChildIndex;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (list.get(currentIndex).compareTo(list.get(maxIndex)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                E tmp = list.get(maxIndex);</span><br><span class="line">                list.set(maxIndex, list.get(currentIndex));</span><br><span class="line">                list.set(currentIndex, tmp)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            currentIndex = maxIndex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> removeObject;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用Comparator接口对元素排序"><a href="#使用Comparator接口对元素排序" class="headerlink" title="使用Comparator接口对元素排序"></a>使用Comparator接口对元素排序</h3><figure class="highlight java"><figcaption><span>使用Comparator接口对元素排序</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapA</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Comparator&lt;? <span class="keyword">super</span> E&gt; comparator;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;E&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HeapA</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.comparator = comparator;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E newObject)</span> </span>&#123;</span><br><span class="line">        list.add(newObject);</span><br><span class="line">        <span class="keyword">int</span> currentIndex = list.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (currentIndex &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> parentIndex = (currentIndex - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (comaprator.compare(list.get(currentIndex), list.getIparentIndex)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                E tmp = list.get(currentIndex);</span><br><span class="line">                list.set(currentIndex, list.get(parentIndex));</span><br><span class="line">                list.set(parentIndex, tmp);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            currentIndex = parentIndex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">pubic E <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (list.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        E removeObject = list.get(<span class="number">0</span>);</span><br><span class="line">        list.set(<span class="number">0</span>, list.get(list.size() - <span class="number">1</span>));</span><br><span class="line">        list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> currentIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (currentIndex &lt; list.size()) &#123;</span><br><span class="line">            <span class="keyword">int</span> leftChildIndex = <span class="number">2</span> * currentIndex + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> rightChildIndex = <span class="number">2</span> * currentIndex + <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//这里是大于等于</span></span><br><span class="line">            <span class="keyword">if</span> (leftChildIndex &gt;= list.size())</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">int</span> maxIndex = leftChildIndex;</span><br><span class="line">            <span class="keyword">if</span>(rigthChildIndex &lt; list.size()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (comparator.compare(list.get(maxIndex), list.get(rightChildIndex)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    maxIndex = rightChildIndex;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (comparator.compare(list.get(currentIndex), list.get(maxIndex)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                E tmp = list.get(maxIndex);</span><br><span class="line">                list.set(maxIndex, list.get(currentIndex));</span><br><span class="line">                list.set(currentIndex, tmp);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            currentIndex = maxIndex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> removeObject;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">pubic <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用Heap类进行排序"><a href="#使用Heap类进行排序" class="headerlink" title="使用Heap类进行排序"></a>使用Heap类进行排序</h2><p>使用Comparator需要编写测试用例，实现Comparator接口的的GeomatricObjectComparator，以及抽象父类GeometricObject,抽象方法getArea，在子类Circle和Rectangle类中实现。排序算法为HeapSort。</p><h3 id="HeapSort排序算法"><a href="#HeapSort排序算法" class="headerlink" title="HeapSort排序算法"></a>HeapSort排序算法</h3><figure class="highlight java"><figcaption><span>HeapSort排序算法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;E extends Comparable&lt;E&gt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(E[] list)</span> </span>&#123;</span><br><span class="line">        Heap&lt;E&gt; heap = <span class="keyword">new</span> Heap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.length; i++) &#123;</span><br><span class="line">            heap.add(list[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = list.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            list[i] = heap.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(E[] list, Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span> </span>&#123;</span><br><span class="line">        HeapA&lt;E&gt; heap = <span class="keyword">new</span> HeapA&lt;&gt;(comparator);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.length; i++) &#123;</span><br><span class="line">            heap.add(list[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = list.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            list[i] = heap.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;       </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/** Create an Array of Integers */</span></span><br><span class="line">        Integer[] intArray = &#123;-<span class="number">44</span>, -<span class="number">5</span>, -<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>, -<span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">53</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/** Create an Array of Doubles */</span></span><br><span class="line">        Double[] doubleArray = &#123;<span class="number">3.4</span>, <span class="number">1.3</span>, -<span class="number">22.1</span>, <span class="number">14.8</span>, <span class="number">6.0</span>, <span class="number">2.3</span>, <span class="number">12.2</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/** Create an Array of Characters */</span></span><br><span class="line">        Character[] charArray = &#123;<span class="string">'a'</span>, <span class="string">'J'</span>, <span class="string">'r'</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/** Create an Array of String */</span></span><br><span class="line">        String[] stringArray = &#123;<span class="string">"Tom"</span>, <span class="string">"Susan"</span>, <span class="string">"Kim"</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/** Heapsort the arrays */</span></span><br><span class="line">        heapSort(intArray);</span><br><span class="line">        heapSort(doubleArray);</span><br><span class="line">        heapSort(charArray);</span><br><span class="line">        heapSort(stringArray);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/** Display the array */</span></span><br><span class="line">        System.out.print(<span class="string">"Sorted Integers: "</span>);</span><br><span class="line">        printList(intArray);</span><br><span class="line">        </span><br><span class="line">        System.out.print(<span class="string">"Sorted Doubles: "</span>);</span><br><span class="line">        printList(doubleArray);</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">"Sorted Characters: "</span>);</span><br><span class="line">        printList(charArray);</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">"Sorted Strings: "</span>);</span><br><span class="line">        printList(stringArray);</span><br><span class="line">        </span><br><span class="line">        GeometricObject[] list = &#123;<span class="keyword">new</span> Circle(<span class="number">5</span>), <span class="keyword">new</span> Rectangle(<span class="number">4</span>, <span class="number">5</span>),</span><br><span class="line">            <span class="keyword">new</span> Circle(<span class="number">5.5</span>), <span class="keyword">new</span> Rectangle(<span class="number">2.4</span>, <span class="number">5</span>), <span class="keyword">new</span> Circle(<span class="number">0.5</span>), </span><br><span class="line">            <span class="keyword">new</span> Rectangle(<span class="number">4</span>, <span class="number">65</span>), <span class="keyword">new</span> Circle(<span class="number">4.5</span>), <span class="keyword">new</span> Rectangle(<span class="number">4.4</span>, <span class="number">1</span>),</span><br><span class="line">            <span class="keyword">new</span> Circle(<span class="number">6.5</span>), <span class="keyword">new</span> Rectangle(<span class="number">4</span>, <span class="number">5</span>)&#125;;</span><br><span class="line">        </span><br><span class="line">        heapSort(list, <span class="keyword">new</span> GeometricObjectComparator());</span><br><span class="line">        System.out.print(<span class="string">"Sorted elements: "</span>);</span><br><span class="line">        <span class="keyword">for</span> (GeometricObject e: list) &#123;</span><br><span class="line">            System.out.printf(<span class="string">"%.2f "</span>, e.getArea());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printList</span><span class="params">(Object[] list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.length; i++)</span><br><span class="line">            System.out.print(list[i] + <span class="string">" "</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="GeometricObjectComparator类实现java-util-Comparator接口"><a href="#GeometricObjectComparator类实现java-util-Comparator接口" class="headerlink" title="GeometricObjectComparator类实现java.util.Comparator接口"></a>GeometricObjectComparator类实现java.util.Comparator接口</h3><figure class="highlight java"><figcaption><span>GeometricObjectComparator类实现java.util.Comparator接口</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GeometricObjectComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">GeometricObject</span>&gt;, <span class="title">Serializable</span> </span>&#123;  </span><br><span class="line">   </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(GeometricObject o1, GeometricObject o2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">double</span> area1 = o1.getArea();</span><br><span class="line">        <span class="keyword">double</span> area2 = o2.getArea();</span><br><span class="line">        <span class="keyword">if</span> (area1 &lt; area2) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (area1 == area2) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="GeometricObject抽象父类"><a href="#GeometricObject抽象父类" class="headerlink" title="GeometricObject抽象父类"></a>GeometricObject抽象父类</h3><figure class="highlight java"><figcaption><span>GeometricObject抽象父类</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">GeometricObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String color = <span class="string">"white"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> filled;</span><br><span class="line">    <span class="keyword">private</span> Date dateCreated;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">GeometricObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        dateCreated = <span class="keyword">new</span> Date();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">GeometricObject</span><span class="params">(String color, <span class="keyword">boolean</span> filled)</span> </span>&#123;</span><br><span class="line">        dateCreated = <span class="keyword">new</span> Date();</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">        <span class="keyword">this</span>.filled = filled;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** Return color */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getColor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Set a new color */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColor</span><span class="params">(String color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Return filled. Since filled is boolean,</span></span><br><span class="line"><span class="comment">     *  the get method is named isFilled */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFilled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> filled;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Set a new filled */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFilled</span><span class="params">(<span class="keyword">boolean</span> filled)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.filled = filled;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Get dateCreated */</span></span><br><span class="line">    <span class="keyword">public</span> java.util.<span class="function">Date <span class="title">getDateCreated</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dateCreated;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"created on "</span> + dateCreated + <span class="string">"\ncolor: "</span> + color +</span><br><span class="line">            <span class="string">" and filled: "</span> + filled;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Abstract method getArea */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">getArea</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Abstract method getPerimeter */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">getPerimeter</span><span class="params">()</span></span>;  </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Circle类继承自GeometricObject"><a href="#Circle类继承自GeometricObject" class="headerlink" title="Circle类继承自GeometricObject"></a>Circle类继承自GeometricObject</h3><figure class="highlight java"><figcaption><span>Circle类继承自GeometricObject</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">GeometricObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> radius;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">(<span class="keyword">double</span> radius)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.radius = radius;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">(<span class="keyword">double</span> radius, </span></span></span><br><span class="line"><span class="function"><span class="params">        String color, <span class="keyword">boolean</span> filled)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.radius = radius;</span><br><span class="line">        setColor(color);</span><br><span class="line">        setFilled(filled);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getRadius</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> radius;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRadius</span><span class="params">(<span class="keyword">double</span> radius)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.radius = radius;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getArea</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> radius * radius * Math.PI;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getDiameter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * radius;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getPerimeter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * radius * Math.PI;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.toString() + <span class="string">", Circle, Created: "</span> </span><br><span class="line">            + getDateCreated() + <span class="string">", Radius: "</span> + radius;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Rectangle类继承自GeometricObject"><a href="#Rectangle类继承自GeometricObject" class="headerlink" title="Rectangle类继承自GeometricObject"></a>Rectangle类继承自GeometricObject</h3><figure class="highlight java"><figcaption><span>Rectangle类继承自GeometricObject</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">extends</span> <span class="title">GeometricObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> width;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> height;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Rectangle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Rectangle</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">double</span> width, <span class="keyword">double</span> height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.width = width;</span><br><span class="line">        <span class="keyword">this</span>.height = height;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Rectangle</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">double</span> width, <span class="keyword">double</span> height, String color, <span class="keyword">boolean</span> filled)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.width = width;</span><br><span class="line">        <span class="keyword">this</span>.height = height;</span><br><span class="line">        setColor(color);</span><br><span class="line">        setFilled(filled);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getWidth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> width;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWidth</span><span class="params">(<span class="keyword">double</span> width)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>. width = width;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getheight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> height;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setheight</span><span class="params">(<span class="keyword">double</span> height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.height = height;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getArea</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> width * height;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getPerimeter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * (width * height);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.toString() + <span class="string">" Rectangle, Created: "</span> </span><br><span class="line">            + getDateCreated() + <span class="string">", Width: "</span> + width + </span><br><span class="line">            <span class="string">", Height: "</span> + height;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="堆排序的时间复杂度"><a href="#堆排序的时间复杂度" class="headerlink" title="堆排序的时间复杂度"></a>堆排序的时间复杂度</h2><p>设h表示包含n个元素的堆的高度。 堆的高度为O(logn)。<br>由于add方法会追踪从叶子节点到根节点的路径，因此向堆中添加一个新元素最多需要h步。所以建立一个包含n个元素的数组的初始堆需要O(nlogn)时间。<br>由于remove方法要跟踪从根节点到叶子节点的路径，因此从堆中删除根节点后，重建堆最多需要h步。由于要调用n次remove方法，所以产生一个有序数组需要的总时间为O(nlogn)。<br>堆排序不需要额外的数组空间，空间效率高于归并排序。</p><h2 id="实现clone和equals的堆方法"><a href="#实现clone和equals的堆方法" class="headerlink" title="实现clone和equals的堆方法"></a>实现clone和equals的堆方法</h2><figure class="highlight java"><figcaption><span>实现clone和equals方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Heap</span> &lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">E</span>&gt;&gt; <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;E&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Create a default heap */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Heap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Create a heap from an array of objects */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Heap</span><span class="params">(E[] objects)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; objects.length; i++)</span><br><span class="line">            add(objects[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Add a new object into the heap */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E newObject)</span> </span>&#123;</span><br><span class="line">        list.add(newObject); <span class="comment">// Append to the heap</span></span><br><span class="line">        <span class="keyword">int</span> currentIndex = list.size() - <span class="number">1</span>; <span class="comment">// The index of the last node</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (currentIndex &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> parentIndex = (currentIndex - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// Swap if the current object is greater than its parent</span></span><br><span class="line">            <span class="keyword">if</span> (list.get(currentIndex).compareTo(</span><br><span class="line">                list.get(parentIndex)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                E temp = list.get(currentIndex);</span><br><span class="line">                list.set(currentIndex, list.get(parentIndex));</span><br><span class="line">                list.set(parentIndex, temp);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// The tree is a heap now</span></span><br><span class="line"></span><br><span class="line">            currentIndex = parentIndex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Remove the root from the heap */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (list.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        E removedObject = list.get(<span class="number">0</span>);</span><br><span class="line">        list.set(<span class="number">0</span>, list.get(list.size() - <span class="number">1</span>));</span><br><span class="line">        list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> currentIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (currentIndex &lt; list.size()) &#123;</span><br><span class="line">            <span class="keyword">int</span> leftChildIndex = <span class="number">2</span> * currentIndex + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> rightChildIndex = <span class="number">2</span> * currentIndex + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Find the maximum between two children</span></span><br><span class="line">            <span class="keyword">if</span> (leftChildIndex &gt;= list.size()) <span class="keyword">break</span>; <span class="comment">// The tree is a heap</span></span><br><span class="line">            <span class="keyword">int</span> maxIndex = leftChildIndex;</span><br><span class="line">            <span class="keyword">if</span> (rightChildIndex &lt; list.size()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (list.get(maxIndex).compareTo(</span><br><span class="line">                    list.get(rightChildIndex)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    maxIndex = rightChildIndex;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Swap if the current node is less than the maximum</span></span><br><span class="line">            <span class="keyword">if</span> (list.get(currentIndex).compareTo(</span><br><span class="line">                list.get(maxIndex)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                E temp = list.get(maxIndex);</span><br><span class="line">                list.set(maxIndex, list.get(currentIndex));</span><br><span class="line">                list.set(currentIndex, temp);</span><br><span class="line">                currentIndex = maxIndex;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// The tree is a heap</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> removedObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Get the number of nodes in the tree */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">/** Override teh proctected clone method defined in</span></span><br><span class="line"><span class="comment">        the Object class, and stregthen its accessibility */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">/** Override the equals method in the Object class */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object other)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (list.size() != ((Heap)(other)).getSize())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (list.get(i) != ((Heap)(other)).list.get(i))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;       </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;堆排序使用的是二叉堆。首先将所有的元素添加到一个堆上，然后不断移除最大的元素以获得一个排好序的线性表。&lt;/p&gt;
    
    </summary>
    
      <category term="Sorting" scheme="https://www.blogs.rhsphere.com/categories/Sorting/"/>
    
    
      <category term="sort" scheme="https://www.blogs.rhsphere.com/tags/sort/"/>
    
      <category term="heap" scheme="https://www.blogs.rhsphere.com/tags/heap/"/>
    
  </entry>
  
  <entry>
    <title>355. Design Twitter</title>
    <link href="https://www.blogs.rhsphere.com/2019/03/11/355.html"/>
    <id>https://www.blogs.rhsphere.com/2019/03/11/355.html</id>
    <published>2019-03-11T13:06:52.000Z</published>
    <updated>2019-05-25T07:28:06.542Z</updated>
    
    <content type="html"><![CDATA[<p class="description">设计一个简化版的推特(Twitter)，可以让用户实现发送推文，关注/取消关注其他用户，能够看见关注人（包括自己）的最近十条推文。</p><a id="more"></a><p>你的设计需要支持以下的几个功能：</p><ul><li>postTweet(userId, tweetId): 创建一条新的推文</li><li>getNewsFeed(userId): 检索最近的十条推文。每个推文都必须是由此用户关注的人或者是用户自己发出的。推文必须按照时间顺序由最近的开始排序。</li><li>follow(followerId, followeeId): 关注一个用户</li><li>unfollow(followerId, followeeId): 取消关注一个用户</li></ul><figure class="highlight java"><figcaption><span>355. 设计推特</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Twitter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> timeStamp=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// easy to find if user exist</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, User&gt; userMap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Tweet link to next Tweet so that we can save a lot of time</span></span><br><span class="line">    <span class="comment">// when we execute getNewsFeed(userId)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Tweet</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> id;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> time;</span><br><span class="line">        <span class="keyword">public</span> Tweet next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Tweet</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.id = id;</span><br><span class="line">            time = timeStamp++;</span><br><span class="line">            next=<span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// OO design so User can follow, unfollow and post itself</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> id;</span><br><span class="line">        <span class="keyword">public</span> Set&lt;Integer&gt; followed;</span><br><span class="line">        <span class="keyword">public</span> Tweet tweet_head;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.id=id;</span><br><span class="line">            followed = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">            follow(id); <span class="comment">// first follow itself</span></span><br><span class="line">            tweet_head = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">follow</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">            followed.add(id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unfollow</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">            followed.remove(id);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// everytime user post a new tweet, add it to the head of tweet list.</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">post</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">            Tweet t = <span class="keyword">new</span> Tweet(id);</span><br><span class="line">            t.next=tweet_head;</span><br><span class="line">            tweet_head=t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Twitter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        userMap = <span class="keyword">new</span> HashMap&lt;Integer, User&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Compose a new tweet. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postTweet</span><span class="params">(<span class="keyword">int</span> userId, <span class="keyword">int</span> tweetId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!userMap.containsKey(userId))&#123;</span><br><span class="line">            User u = <span class="keyword">new</span> User(userId);</span><br><span class="line">            userMap.put(userId, u);</span><br><span class="line">        &#125;</span><br><span class="line">        userMap.get(userId).post(tweetId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Best part of this.</span></span><br><span class="line">    <span class="comment">// first get all tweets lists from one user including itself and all people it followed.</span></span><br><span class="line">    <span class="comment">// Second add all heads into a max heap. Every time we poll a tweet with </span></span><br><span class="line">    <span class="comment">// largest time stamp from the heap, then we add its next tweet into the heap.</span></span><br><span class="line">    <span class="comment">// So after adding all heads we only need to add 9 tweets at most into this </span></span><br><span class="line">    <span class="comment">// heap before we get the 10 most recent tweet.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getNewsFeed</span><span class="params">(<span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!userMap.containsKey(userId))   <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        Set&lt;Integer&gt; users = userMap.get(userId).followed;</span><br><span class="line">        PriorityQueue&lt;Tweet&gt; q = <span class="keyword">new</span> PriorityQueue&lt;Tweet&gt;(users.size(), (a,b)-&gt;(b.time-a.time));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> user: users)&#123;</span><br><span class="line">            Tweet t = userMap.get(user).tweet_head;</span><br><span class="line">            <span class="comment">// very imporant! If we add null to the head we are screwed.</span></span><br><span class="line">            <span class="keyword">if</span>(t!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                q.add(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty() &amp;&amp; n&lt;<span class="number">10</span>)&#123;</span><br><span class="line">          Tweet t = q.poll();</span><br><span class="line">          res.add(t.id);</span><br><span class="line">          n++;</span><br><span class="line">          <span class="keyword">if</span>(t.next!=<span class="keyword">null</span>)</span><br><span class="line">            q.add(t.next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Follower follows a followee. If the operation is invalid, it should be a no-op. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">follow</span><span class="params">(<span class="keyword">int</span> followerId, <span class="keyword">int</span> followeeId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!userMap.containsKey(followerId))&#123;</span><br><span class="line">            User u = <span class="keyword">new</span> User(followerId);</span><br><span class="line">            userMap.put(followerId, u);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!userMap.containsKey(followeeId))&#123;</span><br><span class="line">            User u = <span class="keyword">new</span> User(followeeId);</span><br><span class="line">            userMap.put(followeeId, u);</span><br><span class="line">        &#125;</span><br><span class="line">        userMap.get(followerId).follow(followeeId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Follower unfollows a followee. If the operation is invalid, it should be a no-op. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unfollow</span><span class="params">(<span class="keyword">int</span> followerId, <span class="keyword">int</span> followeeId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!userMap.containsKey(followerId) || followerId==followeeId)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        userMap.get(followerId).unfollow(followeeId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Twitter object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Twitter obj = new Twitter();</span></span><br><span class="line"><span class="comment"> * obj.postTweet(userId,tweetId);</span></span><br><span class="line"><span class="comment"> * List&lt;Integer&gt; param_2 = obj.getNewsFeed(userId);</span></span><br><span class="line"><span class="comment"> * obj.follow(followerId,followeeId);</span></span><br><span class="line"><span class="comment"> * obj.unfollow(followerId,followeeId);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;设计一个简化版的推特(Twitter)，可以让用户实现发送推文，关注/取消关注其他用户，能够看见关注人（包括自己）的最近十条推文。&lt;/p&gt;
    
    </summary>
    
      <category term="Medium" scheme="https://www.blogs.rhsphere.com/categories/Medium/"/>
    
    
      <category term="Hash Table" scheme="https://www.blogs.rhsphere.com/tags/Hash-Table/"/>
    
      <category term="Heap" scheme="https://www.blogs.rhsphere.com/tags/Heap/"/>
    
      <category term="Design" scheme="https://www.blogs.rhsphere.com/tags/Design/"/>
    
  </entry>
  
  <entry>
    <title>594. Longest Harmonious Subsequence</title>
    <link href="https://www.blogs.rhsphere.com/2019/03/11/594.html"/>
    <id>https://www.blogs.rhsphere.com/2019/03/11/594.html</id>
    <published>2019-03-11T06:59:48.000Z</published>
    <updated>2019-05-25T07:28:06.542Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Easy" scheme="https://www.blogs.rhsphere.com/categories/Easy/"/>
    
    
      <category term="Hash Table" scheme="https://www.blogs.rhsphere.com/tags/Hash-Table/"/>
    
  </entry>
  
  <entry>
    <title>散列集合</title>
    <link href="https://www.blogs.rhsphere.com/2019/03/10/HashSet.html"/>
    <id>https://www.blogs.rhsphere.com/2019/03/10/HashSet.html</id>
    <published>2019-03-10T14:40:17.000Z</published>
    <updated>2019-05-25T07:28:06.554Z</updated>
    
    <content type="html"><![CDATA[<p class="description">Set注重独一无二的性质，该体系集合用于存储无序元素（存入和取出的顺序不一定相同），值不能重复。对象相等性本质是对象hashCode值（java十一局对象的内存地址计算出来的此序号）判断的，如果想要两个不同的对象视为相等的，就必须覆盖Object的hashCode方法和equals方法。</p><a id="more"></a><h2 id="使用散列实现集合"><a href="#使用散列实现集合" class="headerlink" title="使用散列实现集合"></a>使用散列实现集合</h2><p>Java集合框架定义了java.util.Set接口来对集合建模。三种具体的实现是HashSet、LinkedHashSet和TreeSet，HashSet采用散列实现，LinkedHashSet采用LinkedList实现，TreeSet采用红黑树实现。</p><h3 id="MyMap接口"><a href="#MyMap接口" class="headerlink" title="MyMap接口"></a>MyMap接口</h3><figure class="highlight java"><figcaption><span>MySet接口</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MySet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Iterable</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(E e)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(E e)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="MyHashSet实现类"><a href="#MyHashSet实现类" class="headerlink" title="MyHashSet实现类"></a>MyHashSet实现类</h3><figure class="highlight java"><figcaption><span>链地址实现MyHashSet</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHashSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">MySet</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">float</span> DEFAULT_MAX_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">float</span> loadFactorThreshold;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> LinkedList&lt;E&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyHashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_MAX_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyHashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>(initialCapacity, DEFAULT_MAX_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyHashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactorThreshold)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line"><span class="keyword">this</span>.capacity = MAXIMUM_CAPACITY;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">this</span>.capacity = trimToPowerOf2(initialCapacity);</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.loadFactorThreshold = loadFactorThreshold;</span><br><span class="line">table = <span class="keyword">new</span> LinkedList[capacity];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span> <span class="comment">/** Remove all elements from this set */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">size = <span class="number">0</span>;</span><br><span class="line">removeElements();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span> <span class="comment">/** Return true if the element is in the set */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> bucketIndex = hash(e.hashCode());</span><br><span class="line"><span class="keyword">if</span> (table[bucketIndex] != <span class="keyword">null</span>) &#123;</span><br><span class="line">LinkedList&lt;E&gt; bucket = table[bucketIndex];</span><br><span class="line"><span class="keyword">for</span> (E element : bucket)</span><br><span class="line"><span class="keyword">if</span> (element.equals(e))</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span> <span class="comment">/** Add an element to the set */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (contains(e)) <span class="comment">// Duplicate element not stored</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (size + <span class="number">1</span> &gt; capacity * loadFactorThreshold) &#123;</span><br><span class="line"><span class="keyword">if</span> (capacity == MAXIMUM_CAPACITY)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Exceeding maximum capacity"</span>);</span><br><span class="line"></span><br><span class="line">rehash();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> bucketIndex = hash(e.hashCode());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a linked list for the bucket if it is not created</span></span><br><span class="line"><span class="keyword">if</span> (table[bucketIndex] == <span class="keyword">null</span>) &#123;</span><br><span class="line">table[bucketIndex] = <span class="keyword">new</span> LinkedList&lt;E&gt;();</span><br><span class="line">&#125;</span><br><span class="line">table[bucketIndex].add(e);</span><br><span class="line">size++; <span class="comment">// Increase size</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span> <span class="comment">/** Remove the element from the set */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!contains(e))</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> bucketIndex = hash(e.hashCode());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a linked list for the bucket if it is not created</span></span><br><span class="line"><span class="keyword">if</span> (table[bucketIndex] != <span class="keyword">null</span>) &#123;</span><br><span class="line">LinkedList&lt;E&gt; bucket = table[bucketIndex];</span><br><span class="line"><span class="keyword">for</span> (E element : bucket)</span><br><span class="line"><span class="keyword">if</span> (e.equals(element)) &#123;</span><br><span class="line">bucket.remove(element);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">size--; <span class="comment">// Decrease size</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span> <span class="comment">/** Return true if the set contains no elements */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span> <span class="comment">/** Return the number of elements in the set */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span> <span class="comment">/** Return an iterator for the elements in this set */</span></span><br><span class="line"><span class="keyword">public</span> java.util.<span class="function">Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> MyHashSetIterator(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Inner class for iterator */</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHashSetIterator</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">util</span>.<span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"><span class="comment">// Store the elements in a list</span></span><br><span class="line"><span class="keyword">private</span> java.util.ArrayList&lt;E&gt; list;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> current = <span class="number">0</span>; <span class="comment">// Point to the current element in list</span></span><br><span class="line"><span class="keyword">private</span> MyHashSet&lt;E&gt; set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Create a list from the set */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyHashSetIterator</span><span class="params">(MyHashSet&lt;E&gt; set)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.set = set;</span><br><span class="line">list = setToList();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span> <span class="comment">/** Next element for traversing? */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (current &lt; list.size())</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span> <span class="comment">/** Get current element and move cursor to the next */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> list.get(current++);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span> <span class="comment">/** Remove the current element and refresh the list */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// Delete the current element from the hash set</span></span><br><span class="line">set.remove(list.get(current));</span><br><span class="line">list.remove(current); <span class="comment">// Remove current element from the list</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Hash function */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> hashCode)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> supplementalHash(hashCode) &amp; (capacity - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Ensure the hashing is evenly distributed */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">supplementalHash</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line"><span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Return a power of 2 for initialCapacity */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">trimToPowerOf2</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> capacity = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (capacity &lt; initialCapacity) &#123;</span><br><span class="line">capacity &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> capacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Remove all e from each bucket */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeElements</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; capacity; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (table[i] != <span class="keyword">null</span>) &#123;</span><br><span class="line">table[i].clear();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Rehash the set */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">java.util.ArrayList&lt;E&gt; list = setToList(); <span class="comment">// Copy to a list</span></span><br><span class="line">capacity &lt;&lt;= <span class="number">1</span>; <span class="comment">// Double capacity</span></span><br><span class="line">table = <span class="keyword">new</span> LinkedList[capacity]; <span class="comment">// Create a new hash table</span></span><br><span class="line">size = <span class="number">0</span>; <span class="comment">// Reset size</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (E element : list) &#123;</span><br><span class="line">add(element); <span class="comment">// Add from the old table to the new table</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Copy elements in the hash set to an array list */</span></span><br><span class="line"><span class="keyword">private</span> java.util.<span class="function">ArrayList&lt;E&gt; <span class="title">setToList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">java.util.ArrayList&lt;E&gt; list = <span class="keyword">new</span> java.util.ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; capacity; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (table[i] != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (E e : table[i]) &#123;</span><br><span class="line">list.add(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">java.util.ArrayList&lt;E&gt; list = setToList();</span><br><span class="line">StringBuilder builder = <span class="keyword">new</span> StringBuilder(<span class="string">"["</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add the elements except the last one to the string builder</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">builder.append(list.get(i) + <span class="string">", "</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add the last element in the list to the string builder</span></span><br><span class="line"><span class="keyword">if</span> (list.size() == <span class="number">0</span>)</span><br><span class="line">builder.append(<span class="string">"]"</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">builder.append(list.get(list.size() - <span class="number">1</span>) + <span class="string">"]"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> builder.toString();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试程序"><a href="#测试程序" class="headerlink" title="测试程序"></a>测试程序</h3><figure class="highlight java"><figcaption><span>TestMyHashSet.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMyHashSet</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// Create a MyHashSet</span></span><br><span class="line">MySet&lt;String&gt; set = <span class="keyword">new</span> MyHashSet&lt;&gt;();</span><br><span class="line">set.add(<span class="string">"Smith"</span>);</span><br><span class="line">set.add(<span class="string">"Anderson"</span>);</span><br><span class="line">set.add(<span class="string">"Lewis"</span>);</span><br><span class="line">set.add(<span class="string">"Cook"</span>);</span><br><span class="line">set.add(<span class="string">"Smith"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"Elements in set: "</span> + set);</span><br><span class="line">System.out.println(<span class="string">"Number of elements in set: "</span> + set.size());</span><br><span class="line">System.out.println(<span class="string">"Is Smith in set? "</span> + set.contains(<span class="string">"Smith"</span>));</span><br><span class="line"></span><br><span class="line">set.remove(<span class="string">"Smith"</span>);</span><br><span class="line">System.out.print(<span class="string">"Names in set in uppercase are "</span>);</span><br><span class="line"><span class="keyword">for</span> (String s : set)</span><br><span class="line">System.out.print(s.toUpperCase() + <span class="string">" "</span>);</span><br><span class="line"></span><br><span class="line">set.clear();</span><br><span class="line">System.out.println(<span class="string">"\nElements in set: "</span> + set);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;Set注重独一无二的性质，该体系集合用于存储无序元素（存入和取出的顺序不一定相同），值不能重复。对象相等性本质是对象hashCode值（java十一局对象的内存地址计算出来的此序号）判断的，如果想要两个不同的对象视为相等的，就必须覆盖Object的hashCode方法和equals方法。&lt;/p&gt;
    
    </summary>
    
      <category term="HashSet" scheme="https://www.blogs.rhsphere.com/categories/HashSet/"/>
    
    
      <category term="HashSet" scheme="https://www.blogs.rhsphere.com/tags/HashSet/"/>
    
  </entry>
  
  <entry>
    <title>散列表</title>
    <link href="https://www.blogs.rhsphere.com/2019/03/09/HashMap.html"/>
    <id>https://www.blogs.rhsphere.com/2019/03/09/HashMap.html</id>
    <published>2019-03-09T08:52:03.000Z</published>
    <updated>2019-05-25T07:28:06.554Z</updated>
    
    <content type="html"><![CDATA[<p class="description">在一个良好平衡的查找树中，可以在O(logn)时间内找到一个元素。 使用散列来实现一个映射表或集合，从而在O(1)时间内查找、插入和删除一个元素。</p><a id="more"></a><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>java.util.HashMap</p><p>public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable</p><p>HashMap和Hashtable有什么区别？</p><ul><li>HashMap是Hashtable的轻量级实现（非线程安全的实现），都实现了Map接口，主要区别是HashMap允许key为null(但只允许一条null)，而后者不行。</li><li>HashMap把contains方法去掉，改为containsKey()和containsValue()。 Hashtable继承自Dictionary，而HashMap实现了Map接口，继承自AbstractMap。</li><li>Hashtable使用Enumeration遍历，而HashMap使用Iterator遍历。</li><li>使用的hash/rehash算法几乎一致，性能差别不大</li><li>Hashtable的hash数组默认大小是11,增加方式是2*old + 1。 HashMap中，hash数组默认大小是16，一定是2的指数。</li></ul><p>一般在不需要并发的时候使用HashMap，并发的时候使用锁粒度更细的ConcurrentHashMap。<br>迭代HashMap使用了快速失败机制，fail-fast，是Java集合的一种错误检测机制。当多个线程对集合进行结构上的改变操作时，就有可能产生fail-fast事件。假如线程1和线程2，当线程1通过iterator遍历集合A中的元素时，如果线程2修改了集合A的结构（删除、增加新元素），程序就会抛出ConcurrentModificationException异常，从而产生fail-fast事件。</p><p>遍历HashMap的四种方法：<br>keySet需要首先把key转换成itaretor，然后根据key在map中取出value，需要两个操作，而entrySet只一次操作就把key和value都取到entry中来，效率更高。foreach和itaretor是等价的。</p><ol><li>foreach map.entrySet()</li></ol><figure class="highlight java"><figcaption><span>foreach map.entrySet()</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">traversal</span><span class="params">(Map&lt;String, String&gt; map)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (Entry&lt;String, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">System.out.print(entry.getKey() + <span class="string">", "</span> + entry.getValue());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>显示调用map.entrySet集合迭代器 </li></ol><figure class="highlight java"><figcaption><span>显示调用map.entrySet集合迭代器 </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">traversal</span><span class="params">(Map&lt;String, Integer&gt; map)</span> </span>&#123;</span><br><span class="line">Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; iterator =</span><br><span class="line"> map.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">Map.Entry&lt;String, Integer&gt; entry = iterator.next();</span><br><span class="line">System.out.println(entry.getKey() + <span class="string">", "</span> + entry.getValue());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>foreach map.keySet(), 再调用get方法<br>本方法多调用一次get，效率会降低，只适合只遍历key的情况。</li></ol><figure class="highlight java"><figcaption><span>foreach map.keySet(), 再调用get方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">traversal</span><span class="params">(Map&lt;String, String&gt; map)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">System.out.println(key + <span class="string">", "</span> + map.get(key));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>foreach map.entrySet(), 再临时变量保存map.entrySet()</li></ol><figure class="highlight java"><figcaption><span>foreach map.entrySet(), 再临时变量保存map.entrySet()</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">traversal</span><span class="params">(Map&lt;String, String&gt; map)</span> </span>&#123;</span><br><span class="line">Set&lt;Entry&lt;String, String&gt;&gt; entrySet = map.entrySet();</span><br><span class="line"><span class="keyword">for</span> (Entry&lt;String, String&gt; enty : entrySet) &#123;</span><br><span class="line">System.out.println(entry.getKey() + <span class="string">", "</span> + entry.getValue());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="散列函数和散列码"><a href="#散列函数和散列码" class="headerlink" title="散列函数和散列码"></a>散列函数和散列码</h2><h3 id="折叠法"><a href="#折叠法" class="headerlink" title="折叠法"></a>折叠法</h3><p>byte、short、int、char类型的搜索键，简单地转换为int。<br>long类型的散列码： hashCode = (int)(key ^ (key &gt;&gt; 32));<br>double类型： long bits = Double.doubleToLongBits(key);<br>            int hashCode = (int)(bits ^ (bits &gt;&gt; 32));</p><h3 id="除余法-压缩"><a href="#除余法-压缩" class="headerlink" title="除余法(压缩)"></a>除余法(压缩)</h3><p>假设散列表的索引处于0~N-1 之间。设N为2的幂值。</p><p>h(hashCode) = hashCode % N;<br>h(hashCode) = hashCode &amp; (N - 1);<br>为了保证散列码是均匀分布的，java.util.HashMap采用了补充的散列函数与主散列函数一起使用。</p><h3 id="字符串类型的散列码"><a href="#字符串类型的散列码" class="headerlink" title="字符串类型的散列码"></a>字符串类型的散列码</h3><p>(…((s0 * b) + s1)b + s2)b + … + sn-2)b + sn-1<br>在String中，b取值31，来计算上述多项式，以达到最小化冲突，其中si = s.charAt(i)。</p><p>除此之外，还有平方取中法，数字分析法等等。</p><h2 id="使用链地址法处理冲突"><a href="#使用链地址法处理冲突" class="headerlink" title="使用链地址法处理冲突"></a>使用链地址法处理冲突</h2><p>当两个键映射到散列表中的同一个索引上时，冲突发生。链地址法将具有同样的散列索引的条目都放在同一个位置，而不是寻找一个新位置。链地址法的每个位置使用一个桶来放置多个条目。<br>可以使用数组，ArrayList或LinkedList来实现一个桶。<br>使用LinkedListl来实现一个映射表。 此处实现与jdk中的实现不同，只是为了演示理解。</p><h3 id="MyMap接口"><a href="#MyMap接口" class="headerlink" title="MyMap接口"></a>MyMap接口</h3><figure class="highlight java"><figcaption><span>MyMap接口 </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"><span class="comment">//删除映射表中所有条目</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//映射表是否包含键的条目</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(K key)</span></span>;</span><br><span class="line"><span class="comment">//如果映射表将一个或多个键映射到指定的值 返回true</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(V value)</span></span>;</span><br><span class="line"><span class="comment">//返回包含该映射表中所有条目的集合</span></span><br><span class="line">Set&lt;Entry&lt;K, V&gt;&gt; entrySet();</span><br><span class="line"><span class="comment">//指定键对应的值</span></span><br><span class="line"><span class="function">V <span class="title">get</span><span class="params">(K key)</span></span>;</span><br><span class="line"><span class="comment">//是否包含映射条目</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//映射表所有键的集合</span></span><br><span class="line"><span class="function">Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//将一个映射置于映射表中</span></span><br><span class="line"><span class="function">V <span class="title">put</span><span class="params">(K key, V value)</span></span>;</span><br><span class="line"><span class="comment">//移除指定键的条目</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(K key)</span></span>;</span><br><span class="line"><span class="comment">//映射条目数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//映射表值的集合</span></span><br><span class="line"><span class="function">Set&lt;V&gt; <span class="title">values</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//映射条目的内部静态类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">K key;</span><br><span class="line">V value;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Entry</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.key = key;</span><br><span class="line"><span class="keyword">this</span>.value = value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> K <span class="title">getKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> key;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"["</span> + key + <span class="string">", "</span> + value + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="MyHashMap类的实现"><a href="#MyHashMap类的实现" class="headerlink" title="MyHashMap类的实现"></a>MyHashMap类的实现</h3><figure class="highlight java"><figcaption><span>MyHashMap类链地址法处理冲突的实现</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHashMap</span>&lt;<span class="title">K</span> ,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">MyMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">float</span>  DEFAULT_MAX_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">float</span> loadFactorThreshold;</span><br><span class="line"><span class="comment">//映射表条目数，只有执行一次方法put(key, value)后，size才会增加一次</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">LinkedList&lt;MyMap.Entry&lt;K, V&gt;&gt;[] table; </span><br><span class="line"><span class="comment">//散列表是一个数组，数组中的每个单元是一个链表</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_MAX_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>(initialCapacity, DEFAULT_MAX_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactorThreshold)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line"><span class="keyword">this</span>.capacity = MAXIMUM_CAPACITY;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.capacity = trimToPowerOf2(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.loadFactorThreshold = loadFactorThreshold;</span><br><span class="line">table = <span class="keyword">new</span> LinkedList[capacity];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">size = <span class="number">0</span>;</span><br><span class="line">removeEntries();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeEntries</span><span class="params">()</span> </span>&#123; <span class="comment">//耗费时间为O(capacity)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; capacity; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (table[i] != <span class="keyword">null</span>) &#123;</span><br><span class="line">table[i].clear();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(K key)</span> </span>&#123; <span class="comment">//耗费时间也为O(1)</span></span><br><span class="line"><span class="keyword">if</span> (get(key) != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(V value)</span> </span>&#123; </span><br><span class="line">LinkedList&lt;Entry&lt;K, V&gt;&gt; bucket;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; capacity; i++）&#123;</span><br><span class="line"><span class="keyword">if</span> (table[i] != <span class="keyword">null</span>) &#123;</span><br><span class="line">bucket = table[i];</span><br><span class="line"><span class="keyword">for</span> (Entry&lt;K, V&gt; entry : bucket) &#123;</span><br><span class="line"><span class="keyword">if</span> (entry.getValue().equals(value))</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Set&lt;Entry&lt;K, V&gt;&gt; entrySet() &#123;</span><br><span class="line">Set&lt;MyMap.Entry&lt;K, V&gt;&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">LinkedList&lt;Entry&lt;K, V&gt;&gt; bucket;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; capacity; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (table[i] != <span class="keyword">null</span>) &#123;</span><br><span class="line">bucket = table[i];</span><br><span class="line"><span class="keyword">for</span> (Entry&lt;K ,V&gt; entry : bucket)</span><br><span class="line">set.add(entry);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> set;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key)</span> </span>&#123; <span class="comment">//耗费O(1)的时间</span></span><br><span class="line"><span class="keyword">int</span> bucketIndex = hash(key.hashCode());</span><br><span class="line">LinkedList&lt;Entry&lt;K, V&gt;&gt; bucket;</span><br><span class="line"><span class="keyword">if</span> (table[bucketIndex] != <span class="keyword">null</span>) &#123;</span><br><span class="line">bucket = table[bucketIndex];</span><br><span class="line"><span class="keyword">for</span> (Entry&lt;K, V&gt; entry : bucket) &#123;</span><br><span class="line"><span class="keyword">if</span> (entry.getKey().equals(key))</span><br><span class="line"><span class="keyword">return</span> entry.getValue();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Set&lt;K&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; capacity; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (table[i] != <span class="keyword">null</span>) &#123;</span><br><span class="line">LinkedList&lt;Entry&lt;K, V&gt;&gt; bucket = table[i];</span><br><span class="line"><span class="keyword">for</span> (Entry&lt;K, V&gt; entry: bucket) &#123;</span><br><span class="line">set.add(entry.getKey());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> set;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (get(key) != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> bucketIndex = hash(key.hashCode());</span><br><span class="line">LinkedList&lt;Entry&lt;K, V&gt;&gt; entry = table[bucketIndex];</span><br><span class="line"><span class="keyword">for</span> (Entry&lt;K, V&gt; entry : bucket) &#123;</span><br><span class="line"><span class="keyword">if</span> (entry.getKey().equals(key)) &#123;</span><br><span class="line">V oldValue = entry.getValue();</span><br><span class="line">entry.value = value;</span><br><span class="line"><span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (size &gt;= capacity * loadFactorThreshold) &#123;</span><br><span class="line"><span class="keyword">if</span> (capacity == MAXIMUM_CAPACITY)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Exceeding maximum capacity"</span>);</span><br><span class="line">rehash();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> bucketIndex = hash(key.hashCode());</span><br><span class="line"><span class="keyword">if</span> (table[bucketIndex] == <span class="keyword">null</span>) &#123;</span><br><span class="line">table[bucketIndex] = <span class="keyword">new</span> LinkedList&lt;Entry&lt;K, V&gt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line">table[bucketIndex].add(<span class="keyword">new</span> MyMap.Enty&lt;K, V&gt;(key, value));</span><br><span class="line">size++;</span><br><span class="line"><span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> bucketIndex = hash(key.hashCode());</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (table[bucketIndex] != <span class="keyword">null</span>) &#123;</span><br><span class="line">LinkedList&lt;Entry&lt;K, V&gt;&gt; bucket = table[bucketIndex];</span><br><span class="line"><span class="keyword">for</span> (Entry&lt;K, V&gt; entry : bucket) &#123;</span><br><span class="line"><span class="keyword">if</span> (entry.getKey().equals(key)) &#123;</span><br><span class="line">bucket.remove(entry);</span><br><span class="line">size--;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;V&gt; <span class="title">values</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Set&lt;V&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; capacity; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (table[i] != <span class="keyword">null</span>) &#123;</span><br><span class="line">LinkedList&lt;Entry&lt;K, V&gt;&gt; bucket = table[i];</span><br><span class="line"><span class="keyword">for</span> (Entry&lt;K, V&gt; entry : bucket) &#123;</span><br><span class="line">set.add(entry.getValue());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> set;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> hashCode)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> supplementalHash(hashCode) &amp; (capacity - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">supplementalHash</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line"><span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">trimToPowerOf2</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> capacity = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (capacity &lt; initialCapacity) &#123;</span><br><span class="line">capacity &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> capacity;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Set&lt;Entry&lt;K, V&gt;&gt; set = entrySet();</span><br><span class="line">capacity &lt;&lt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">table = <span class="keyword">new</span> LinkedList[capacity];</span><br><span class="line">size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Entry&lt;K, V&gt; entry : set) &#123;</span><br><span class="line">put(entry.getKey(), entry.getValue());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; capacity; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (table[i] != <span class="keyword">null</span> &amp;&amp; table[i].size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (Entry&lt;K, V&gt; entry: table[i]) &#123;</span><br><span class="line">builder.append(entry);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">builder.append(<span class="string">"]"</span>);</span><br><span class="line"><span class="keyword">return</span> builder.toString();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用开放地址法处理冲突"><a href="#使用开放地址法处理冲突" class="headerlink" title="使用开放地址法处理冲突"></a>使用开放地址法处理冲突</h2><p>开放地址法（open addressing）是在冲突发生时，在散列表中找到一个开放位置的过程。</p><h3 id="线性探测法"><a href="#线性探测法" class="headerlink" title="线性探测法"></a>线性探测法</h3><p>按照顺序找到下一个可用的位置，如果冲突发生在hashTable[k % N]，则检查hashTable[(k+1) % N]，依次类推。<br>查找时，依次检查k，k+1，…，直到达到一个空单元，或者找到。<br>缺点：会形成一次簇（cluster），从而降低查找时间。</p><figure class="highlight java"><figcaption><span>线性探测法处理冲突</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">MyMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>  MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">float</span> DEFAULT_MAX_LOAD_FACTOR = <span class="number">0.5f</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">float</span> loadFactorThreshold;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">ArrayList&lt;MyMap.Entry&lt;K, V&gt;&gt; table;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_MAX_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>(initialCapacity, DEFAULT_MAX_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactorThreshold)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line"><span class="keyword">this</span>.capacity = MAXIMUM_CAPACITY;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">this</span>.capacity = trimToPowerOf2(initialCapacity);</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.loadFactorThreshold = loadFactorThreshold;</span><br><span class="line">table = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; capacity; i++)</span><br><span class="line">table.add(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">size = <span class="number">0</span>;</span><br><span class="line">removeEntries();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (get(key) != <span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; capacity; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (table.get(i) != <span class="keyword">null</span> &amp;&amp; table.get(i).getValue() == value)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="keyword">public</span> java.util.Set&lt;MyMap.Entry&lt;K,V&gt;&gt; entrySet() &#123;</span><br><span class="line">java.util.Set&lt;MyMap.Entry&lt;K, V&gt;&gt; set = </span><br><span class="line"><span class="keyword">new</span> java.util.HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; capacity; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (table.get(i) != <span class="keyword">null</span>) &#123;</span><br><span class="line">set.add(table.get(i));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> set;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> index = hash(key.hashCode());</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(table.get(index) != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (table.get(index).getKey().equals(key)) &#123;</span><br><span class="line"><span class="keyword">return</span> table.get(index).getValue();</span><br><span class="line">&#125;</span><br><span class="line">index++;</span><br><span class="line">index %= capacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="keyword">public</span> java.util.<span class="function">Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">java.util.Set&lt;K&gt; set = <span class="keyword">new</span> java.util.HashSet&lt;K&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; capacity; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (table.get(i) != <span class="keyword">null</span>)</span><br><span class="line">set.add(table.get(i).getKey());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> set;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span> <span class="comment">/** Add an entry (key, value) into the map */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> index = hash(key.hashCode());</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (table.get(index) != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// The key is already in the map</span></span><br><span class="line"><span class="keyword">if</span> (table.get(index).getKey().equals(key)) &#123;</span><br><span class="line">Entry&lt;K, V&gt; entry = table.get(index);</span><br><span class="line">V oldvalue = entry.getValue();</span><br><span class="line"><span class="comment">// Replace old value with new value</span></span><br><span class="line">entry.value = value;</span><br><span class="line">table.set(index, entry);</span><br><span class="line"><span class="comment">// Return the old value for the key</span></span><br><span class="line"><span class="keyword">return</span> oldvalue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Collision check if the next index is available</span></span><br><span class="line">index++; </span><br><span class="line">index %= capacity;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Check load factor</span></span><br><span class="line"><span class="keyword">if</span> (size &gt;= capacity * loadFactorThreshold) &#123;</span><br><span class="line"><span class="keyword">if</span> (capacity == MAXIMUM_CAPACITY)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Exceeding maximum capacity"</span>);</span><br><span class="line">rehash();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Add a new entry (key, value) to hashtable</span></span><br><span class="line">table.set(index, <span class="keyword">new</span> MyMap.Entry&lt;K, V&gt;(key, value));</span><br><span class="line">size++; <span class="comment">// Increase size</span></span><br><span class="line"><span class="keyword">return</span> value;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span> <span class="comment">/** Remove the entry for the specified key */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> index = hash(key.hashCode());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Remove the entry that matches the key</span></span><br><span class="line"><span class="keyword">while</span> (table != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (table.get(index).getKey().equals(key)) &#123;</span><br><span class="line">table.remove(index);</span><br><span class="line">size--; <span class="comment">// Decrease size</span></span><br><span class="line"><span class="keyword">break</span>; <span class="comment">// Remove just one entry that matches the key</span></span><br><span class="line">&#125;</span><br><span class="line">index++;</span><br><span class="line">index %= capacity;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span> <span class="comment">/** Return the number of entries in this map */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span> <span class="comment">/** Return a set consisting of values in this map */</span></span><br><span class="line"><span class="keyword">public</span> java.util.<span class="function">Set&lt;V&gt; <span class="title">values</span><span class="params">()</span> </span>&#123;</span><br><span class="line">java.util.Set&lt;V&gt; set = <span class="keyword">new</span> java.util.HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; capacity; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (table.get(i) != <span class="keyword">null</span>)</span><br><span class="line">set.add(table.get(i).getValue());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> set;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Hash function */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> hashCode)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> supplementalHash(hashCode) &amp; (capacity - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Ensure the hashing is evenly distributed */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">supplementalHash</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line"><span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Return a power of 2 for initialCapacity */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">trimToPowerOf2</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> capacity = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (capacity &lt; initialCapacity) &#123;</span><br><span class="line">capacity &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> capacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeEntries</span><span class="params">()</span> </span>&#123;</span><br><span class="line">table.clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Rehash the map */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">java.util.Set&lt;Entry&lt;K, V&gt;&gt; set = entrySet();</span><br><span class="line">capacity &lt;&lt;= <span class="number">1</span>; <span class="comment">// Same as capacity *= 2. &lt;= is more efficient</span></span><br><span class="line">size = <span class="number">0</span>; <span class="comment">// Reset size to 0</span></span><br><span class="line">table.clear(); <span class="comment">// Clear the hash table</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; capacity; i++)</span><br><span class="line">table.add(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Entry&lt;K, V&gt; entry : set) &#123;</span><br><span class="line">put(entry.getKey(), entry.getValue());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span> <span class="comment">/** Return a string repesentation for this map */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">StringBuilder builder = <span class="keyword">new</span> StringBuilder(<span class="string">"["</span>);</span><br><span class="line"><span class="keyword">for</span> (Entry&lt;K, V&gt; entry: table) &#123;</span><br><span class="line"><span class="keyword">if</span> (entry != <span class="keyword">null</span> &amp;&amp; table.size() &gt; <span class="number">0</span>)</span><br><span class="line">builder.append(entry);</span><br><span class="line">&#125;</span><br><span class="line">builder.append(<span class="string">"]"</span>);</span><br><span class="line"><span class="keyword">return</span> builder.toString();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二次探测法"><a href="#二次探测法" class="headerlink" title="二次探测法"></a>二次探测法</h3><p>二次探测法从索引 (k + j*j) % N位置的单元开始审查。</p><figure class="highlight java"><figcaption><span>二次探测法处理冲突</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">MyMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">float</span> DEFAULT_MAX_LOAD_FACTOR = <span class="number">0.5f</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">float</span> loadFactorThreshold;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">ArrayList&lt;MyMap.Entry&lt;K, V&gt;&gt; table;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_MAX_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>(initialCapacity, DEFAULT_MAX_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactorThreshold)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line"><span class="keyword">this</span>.capacity = MAXIMUM_CAPACITY;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">this</span>.capacity = trimToPowerOf2(initialCapacity);</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.loadFactorThreshold = loadFactorThreshold;</span><br><span class="line">table = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; capacity; i++) &#123;</span><br><span class="line">table.add(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span> <span class="comment">/** Remove all of the entries from this map */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">size = <span class="number">0</span>;</span><br><span class="line">removeEntries();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span> <span class="comment">/** Return true if the specified key is in the map */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (get(key) != <span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span> <span class="comment">/** Return true if this map contains the value */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; capacity; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (table.get(i) != <span class="keyword">null</span> &amp;&amp; table.get(i).getValue() == value)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span> <span class="comment">/** Return a set of entries in the map */</span></span><br><span class="line"><span class="keyword">public</span> java.util.Set&lt;MyMap.Entry&lt;K, V&gt;&gt; entrySet() &#123;</span><br><span class="line">java.util.Set&lt;MyMap.Entry&lt;K, V&gt;&gt; set = </span><br><span class="line"><span class="keyword">new</span> java.util.HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; capacity; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (table.get(i) != <span class="keyword">null</span>) &#123;</span><br><span class="line">set.add(table.get(i));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> set;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span> <span class="comment">/** Return the value that matches the specified key */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> index = hash(key.hashCode());</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (table.get(index) != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (table.get(index).getKey().equals(key)) &#123;</span><br><span class="line"><span class="keyword">return</span> table.get(index).getValue();</span><br><span class="line">&#125;</span><br><span class="line">index += Math.pow(j++, <span class="number">2</span>);</span><br><span class="line">index %= capacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span> <span class="comment">/** Return true if this map contains no entries */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span> <span class="comment">/** Return a set consisting of the keys in this map */</span></span><br><span class="line"><span class="keyword">public</span> java.util.<span class="function">Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">java.util.Set&lt;K&gt; set = <span class="keyword">new</span> java.util.HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; capacity; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (table.get(i) != <span class="keyword">null</span>) &#123;</span><br><span class="line">set.add(table.get(i).getKey());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> set;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span> <span class="comment">/** Add an entry (key, value) into the map */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> index = hash(key.hashCode());</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (table.get(index) != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// The key is already in the map</span></span><br><span class="line"><span class="keyword">if</span> (table.get(index).getKey().equals(key)) &#123;</span><br><span class="line">Entry&lt;K, V&gt; entry = table.get(index);</span><br><span class="line">V oldValue = entry.getValue();</span><br><span class="line"><span class="comment">// Replace old value with new value</span></span><br><span class="line">entry.value = value;</span><br><span class="line">table.set(index, entry);</span><br><span class="line"><span class="comment">// Return the old value for the key</span></span><br><span class="line"><span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line">index += Math.pow(j++, <span class="number">2</span>);</span><br><span class="line">index %= capacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check load factor</span></span><br><span class="line"><span class="keyword">if</span> (size &gt;= capacity * loadFactorThreshold) &#123;</span><br><span class="line"><span class="keyword">if</span> (capacity == MAXIMUM_CAPACITY)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Exceeding maximum capacity"</span>);</span><br><span class="line">rehash();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add a new entry(key, value) to hashtable</span></span><br><span class="line">table.set(index, <span class="keyword">new</span> MyMap.Entry&lt;K, V&gt;(key, value));</span><br><span class="line">size++; <span class="comment">// Increase size</span></span><br><span class="line"><span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span> <span class="comment">/** Remove the entry for the specified key */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> index = hash(key.hashCode());</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// Remove the first entry that matches the key</span></span><br><span class="line"><span class="keyword">while</span> (table.get(index) != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (table.get(index).getKey().equals(key)) &#123;</span><br><span class="line">table.remove(index);</span><br><span class="line">size--; <span class="comment">// Decrease size</span></span><br><span class="line"><span class="keyword">break</span>; <span class="comment">// Remove just one entry that matches key</span></span><br><span class="line">&#125;</span><br><span class="line">index += Math.pow(j++, <span class="number">2</span>);</span><br><span class="line">index %= capacity;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span> <span class="comment">/** Return the number of entries in this map */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span> <span class="comment">/** Return a set consisting of values in this map */</span></span><br><span class="line"><span class="keyword">public</span> java.util.<span class="function">Set&lt;V&gt; <span class="title">values</span><span class="params">()</span> </span>&#123;</span><br><span class="line">java.util.Set&lt;V&gt; set = <span class="keyword">new</span> java.util.HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; capacity; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (table.get(i) != <span class="keyword">null</span>)</span><br><span class="line">set.add(table.get(i).getValue());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> set;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** Hash function */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> hashCode)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> supplementalHash(hashCode) &amp; (capacity - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Ensure the hashing is evenly distributed */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">supplementalHash</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line"><span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Return a power of 2 for initialCapacity */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">trimToPowerOf2</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> capacity = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (capacity &lt; initialCapacity) &#123;</span><br><span class="line">capacity &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> capacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Remove all entries from map */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeEntries</span><span class="params">()</span> </span>&#123;</span><br><span class="line">table.clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Rehash the map */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">java.util.Set&lt;Entry&lt;K, V&gt;&gt; set = entrySet();</span><br><span class="line">capacity &lt;&lt;= <span class="number">1</span>; <span class="comment">// Same as capacity *= 2. &lt;= is more efficient</span></span><br><span class="line">size = <span class="number">0</span>;</span><br><span class="line">table.clear();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; capacity; i++) </span><br><span class="line">table.add(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Entry&lt;K, V&gt; entry : set) &#123;</span><br><span class="line">put(entry.getKey(), entry.getValue());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span> <span class="comment">/** Return a string repersentation for this map */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">StringBuilder builder = <span class="keyword">new</span> StringBuilder(<span class="string">"["</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Entry&lt;K, V&gt; entry: table) &#123;</span><br><span class="line"><span class="keyword">if</span> (entry != <span class="keyword">null</span> &amp;&amp; table.size() &gt; <span class="number">0</span>)</span><br><span class="line">builder.append(entry);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">builder.append(<span class="string">"]"</span>);</span><br><span class="line"><span class="keyword">return</span> builder.toString();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="再哈希法"><a href="#再哈希法" class="headerlink" title="再哈希法"></a>再哈希法</h3><figure class="highlight java"><figcaption><span>再哈希法处理冲突</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">MyMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> MAMIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">float</span> DEFAULT_MAX_LOAD_FACTOR = <span class="number">0.5f</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">float</span> loadFactorThreshold;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> ArrayList&lt;MyMap.Entry&lt;K, V&gt;&gt; table;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_MAX_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>(initialCapacity, DEFAULT_MAX_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactorThreshold)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (initialCapacity &gt; MAMIMUM_CAPACITY)</span><br><span class="line"><span class="keyword">this</span>.capacity = MAMIMUM_CAPACITY;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">this</span>.capacity = trimToPowerOf2(initialCapacity);</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.loadFactorThreshold = loadFactorThreshold;</span><br><span class="line">table = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; capacity; i++) &#123;</span><br><span class="line">table.add(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">size = <span class="number">0</span>;</span><br><span class="line">removeEntries();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (get(key) != <span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; capacity; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (table.get(i) != <span class="keyword">null</span> &amp;&amp; </span><br><span class="line"> table.get(i).getValue() == value)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="keyword">public</span> java.util.Set&lt;Entry&lt;K, V&gt;&gt; entrySet() &#123;</span><br><span class="line">java.util.Set&lt;Entry&lt;K, V&gt;&gt; set = <span class="keyword">new</span> java.util.HashSet&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; capacity; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (table.get(i) != <span class="keyword">null</span>) &#123;</span><br><span class="line">set.add(table.get(i));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> set;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> hash1 = hash(key.hashCode());</span><br><span class="line"><span class="keyword">int</span> index = hash1;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (table.get(index) != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (table.get(index).getKey().equals(key)) &#123;</span><br><span class="line"><span class="keyword">return</span> table.get(index).getValue();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Secondary hash: (k + j * h'(key)) % N</span></span><br><span class="line">index = hash1 + j++ * hash2(hash1); </span><br><span class="line">index %= capacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span> <span class="comment">/** Return true if this map contains no entries */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span> <span class="comment">/** Return a set consisting of the keys in this map */</span></span><br><span class="line"><span class="keyword">public</span> java.util.<span class="function">Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">java.util.Set&lt;K&gt; set = <span class="keyword">new</span> java.util.HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; capacity; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (table.get(i) != <span class="keyword">null</span>)</span><br><span class="line">set.add(table.get(i).getKey());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> set;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span> <span class="comment">/** Add an entry (key, value) into the map */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> hash1 = hash(key.hashCode());</span><br><span class="line"><span class="keyword">int</span> index = hash1;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (table.get(index) != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// The key is already in the map</span></span><br><span class="line"><span class="keyword">if</span> (table.get(index).getKey().equals(key)) &#123;</span><br><span class="line">Entry&lt;K, V&gt; entry = table.get(index);</span><br><span class="line">V oldValue = entry.getValue();</span><br><span class="line"><span class="comment">// Replace old value with new value</span></span><br><span class="line">entry.value = value;</span><br><span class="line">table.set(index, entry);</span><br><span class="line"><span class="comment">// Return the old value for the key</span></span><br><span class="line"><span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Secondary hash: (k + j * h'(key)) % N</span></span><br><span class="line">index = hash1 + j++ * hash2(hash1); </span><br><span class="line">index %= capacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check load factor</span></span><br><span class="line"><span class="keyword">if</span> (size &gt;= capacity * loadFactorThreshold) &#123;</span><br><span class="line"><span class="keyword">if</span> (capacity == MAMIMUM_CAPACITY)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Exceeding maximum capacity"</span>);</span><br><span class="line">rehash();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add a new entry(key, value) to hashtable</span></span><br><span class="line">table.set(index, <span class="keyword">new</span> MyMap.Entry&lt;K, V&gt;(key, value));</span><br><span class="line"></span><br><span class="line">size++;</span><br><span class="line"><span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span> <span class="comment">/** Remove the entry for the specified key */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> hash1 = hash(key.hashCode());</span><br><span class="line"><span class="keyword">int</span> index = hash1;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Remove the first entry that matched the key</span></span><br><span class="line"><span class="keyword">while</span> (table.get(index) != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (table.get(index).getKey().equals(key)) &#123;</span><br><span class="line">table.remove(index);</span><br><span class="line">size--; <span class="comment">// Decrease size</span></span><br><span class="line"><span class="keyword">break</span>; <span class="comment">// Remove just one entry that matches the key</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Secondary hash: (k + j * h'(key)) % N</span></span><br><span class="line">index = hash1 + j++ * hash2(hash1); </span><br><span class="line">index %= capacity;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span> <span class="comment">/** Return the number of entries in this map */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span> <span class="comment">/** Return a set consisting of values in this map */</span></span><br><span class="line"><span class="keyword">public</span> java.util.<span class="function">Set&lt;V&gt; <span class="title">values</span><span class="params">()</span> </span>&#123;</span><br><span class="line">java.util.Set&lt;V&gt; set = <span class="keyword">new</span> java.util.HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; capacity; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (table.get(i) != <span class="keyword">null</span>)</span><br><span class="line">set.add(table.get(i).getValue());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> set;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Hash function */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> hashCode)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> supplementalHash(hashCode) &amp; (capacity - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Ensure the hashing is evenly distributed */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">supplementalHash</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line"><span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Secondary hash function */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash2</span><span class="params">(<span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="number">7</span> - hash) &amp; (<span class="number">7</span> - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Return a power of 2 for initialCapacity */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">trimToPowerOf2</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> capacity = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (capacity &lt; initialCapacity) &#123;</span><br><span class="line">capacity &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> capacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Remove all entries from map */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeEntries</span><span class="params">()</span> </span>&#123;</span><br><span class="line">table.clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Rehash the map */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">java.util.Set&lt;Entry&lt;K, V&gt;&gt; set = entrySet();</span><br><span class="line">capacity &lt;&lt;= <span class="number">1</span>; <span class="comment">// Same as capacity *= 2. &lt;= is more efficient</span></span><br><span class="line">size = <span class="number">0</span>; <span class="comment">// Reset size</span></span><br><span class="line">table.clear();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; capacity; i++) </span><br><span class="line">table.add(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Entry&lt;K, V&gt; entry : set) &#123;</span><br><span class="line">put(entry.getKey(), entry.getValue());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span> <span class="comment">/** Return a string repersentation of this map */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">StringBuilder builder = <span class="keyword">new</span> StringBuilder(<span class="string">"["</span>);</span><br><span class="line"><span class="keyword">for</span> (Entry&lt;K, V&gt; entry : table) &#123;</span><br><span class="line"><span class="keyword">if</span> (entry != <span class="keyword">null</span> &amp;&amp; table.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">builder.append(entry);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">builder.append(<span class="string">"]"</span>);</span><br><span class="line"><span class="keyword">return</span> builder.toString();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;在一个良好平衡的查找树中，可以在O(logn)时间内找到一个元素。 使用散列来实现一个映射表或集合，从而在O(1)时间内查找、插入和删除一个元素。&lt;/p&gt;
    
    </summary>
    
      <category term="HashMap" scheme="https://www.blogs.rhsphere.com/categories/HashMap/"/>
    
    
      <category term="HashMap" scheme="https://www.blogs.rhsphere.com/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>345. Reverse Volwels of a String</title>
    <link href="https://www.blogs.rhsphere.com/2019/03/08/345.html"/>
    <id>https://www.blogs.rhsphere.com/2019/03/08/345.html</id>
    <published>2019-03-08T02:40:16.000Z</published>
    <updated>2019-05-25T07:28:06.541Z</updated>
    
    <content type="html"><![CDATA[<p class="description">编写一个函数，以字符串作为输入，反转该字符串中的元音字母。</p><a id="more"></a><ul><li>错误点有两处，看代码注释</li></ul><figure class="highlight java"><figcaption><span>345. 反转字符串中的元音字母</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseVowels</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] res = s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = res.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isVowels(res[start]) &amp;&amp; isVowels(res[end])) &#123;</span><br><span class="line">                <span class="keyword">char</span> tmp = res[start];</span><br><span class="line">                res[start] = res[end];</span><br><span class="line">                res[end] = tmp;</span><br><span class="line">                start++;</span><br><span class="line">                end--;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isVowels(res[start])) &#123;</span><br><span class="line">                start++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(!isVowels(res[end])) &#123;</span><br><span class="line">                end--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这里return一个字符串的方法要注意</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(res);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isVowels</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//犯错的地方</span></span><br><span class="line">        <span class="comment">//前面忘了写 ch=  ch+32 和 ch+=32的区别</span></span><br><span class="line">        ch = ch &gt;= <span class="string">'A'</span> &amp;&amp; ch &lt;= <span class="string">'Z'</span> ? ch += <span class="number">32</span> : ch;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ch == <span class="string">'a'</span> || ch == <span class="string">'e'</span> || ch == <span class="string">'i'</span> || ch == <span class="string">'o'</span> || ch == <span class="string">'u'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;编写一个函数，以字符串作为输入，反转该字符串中的元音字母。&lt;/p&gt;
    
    </summary>
    
      <category term="Easy" scheme="https://www.blogs.rhsphere.com/categories/Easy/"/>
    
    
      <category term="Two Pointers" scheme="https://www.blogs.rhsphere.com/tags/Two-Pointers/"/>
    
      <category term="String" scheme="https://www.blogs.rhsphere.com/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>344. Reverse String</title>
    <link href="https://www.blogs.rhsphere.com/2019/03/08/344.html"/>
    <id>https://www.blogs.rhsphere.com/2019/03/08/344.html</id>
    <published>2019-03-08T02:26:37.000Z</published>
    <updated>2019-05-25T07:28:06.541Z</updated>
    
    <content type="html"><![CDATA[<p class="description">编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组char[]的形式给出。不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用O(1)的额外空间解决这一问题。</p><a id="more"></a><ul><li>头尾两个指针</li></ul><figure class="highlight java"><figcaption><span>344. 反转字符串</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverseString</span><span class="params">(<span class="keyword">char</span>[] s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = s.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">            <span class="keyword">char</span> tmp = s[start];</span><br><span class="line">            s[start] = s[end];</span><br><span class="line">            s[end] = tmp;</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组char[]的形式给出。不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用O(1)的额外空间解决这一问题。&lt;/p&gt;
    
    </summary>
    
      <category term="Easy" scheme="https://www.blogs.rhsphere.com/categories/Easy/"/>
    
    
      <category term="Two Pointers" scheme="https://www.blogs.rhsphere.com/tags/Two-Pointers/"/>
    
      <category term="String" scheme="https://www.blogs.rhsphere.com/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>828. Unique Letter String</title>
    <link href="https://www.blogs.rhsphere.com/2019/03/07/828.html"/>
    <id>https://www.blogs.rhsphere.com/2019/03/07/828.html</id>
    <published>2019-03-07T07:59:33.000Z</published>
    <updated>2019-05-25T07:28:06.543Z</updated>
    
    <content type="html"><![CDATA[<p class="description">如果一个字符在字符串S中有且仅有出现一次，那么我们称其为独特字符。对于给定字符串S，计算其所有非空子串的独特字符的个数，即 UNIQ(substring)。如果出现两个或者多个相同的子串，将其认为是不同的两个子串。</p><a id="more"></a><p>In each loop, We caculate cur[i], which represent the sum of Uniq() for all substrings whose last char is S.charAt(i).</p><p>For example,<br>S = ‘ABCBD’<br>When i = 2, cur[2] = Uniq(‘ABC’) + Uniq(‘BC’) + Uniq(‘C’)<br>When i = 3, cur[3] = Uniq(‘ABCB’) + Uniq(‘BCB’) + Uniq(‘CB’) + Uniq(‘B’)</p><p>Notice, we append char ‘B’ into each previous substrings. Only in substrings ‘CB’ and ‘B’, the char ‘B’ can be identified as uniq. The contribution of ‘B’ from cur[2] to cur[3] is i - showLastPosition[‘B’]. At the same time, in substrings ‘ABCB’, ‘BCB’, the char ‘B’ can‘t’ be identified as uniq any more, the previous contribution of ‘B’ should be removed.</p><p>So we have’cur[i] = cur[i - 1] - contribution[S.charAt(i)] + (i - showLastPosition[S.charAt(i)])<br>Then the new contribution[S.charAt(i)] = i - showLastPosition[S.charAt(i)]</p><p>The final result is the sum of all cur[i].</p><figure class="highlight java"><figcaption><span>828. 独特字符串</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniqueLetterString</span><span class="params">(String S)</span> </span>&#123;             </span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (S == <span class="keyword">null</span> || S.length() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> res;    </span><br><span class="line">        <span class="keyword">int</span>[] showLastPosition = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>];</span><br><span class="line">        <span class="keyword">int</span>[] contribution = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>];</span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> x = S.charAt(i);</span><br><span class="line">            cur -= contribution[x]; </span><br><span class="line">            contribution[x] = (i - (showLastPosition[x] - <span class="number">1</span>));</span><br><span class="line">            cur += contribution[x]; </span><br><span class="line">            showLastPosition[x] = i + <span class="number">1</span>;</span><br><span class="line">            res += cur;</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">return</span> res;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;如果一个字符在字符串S中有且仅有出现一次，那么我们称其为独特字符。对于给定字符串S，计算其所有非空子串的独特字符的个数，即 UNIQ(substring)。如果出现两个或者多个相同的子串，将其认为是不同的两个子串。&lt;/p&gt;
    
    </summary>
    
      <category term="Hard" scheme="https://www.blogs.rhsphere.com/categories/Hard/"/>
    
    
      <category term="Math" scheme="https://www.blogs.rhsphere.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>91. Decode Ways</title>
    <link href="https://www.blogs.rhsphere.com/2019/03/07/91.html"/>
    <id>https://www.blogs.rhsphere.com/2019/03/07/91.html</id>
    <published>2019-03-07T05:56:30.000Z</published>
    <updated>2019-05-25T07:28:06.543Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Medium" scheme="https://www.blogs.rhsphere.com/categories/Medium/"/>
    
    
      <category term="String" scheme="https://www.blogs.rhsphere.com/tags/String/"/>
    
      <category term="Dynamic Programming" scheme="https://www.blogs.rhsphere.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>栈、队列和优先队列</title>
    <link href="https://www.blogs.rhsphere.com/2019/03/06/stack-queue-priorityQueue.html"/>
    <id>https://www.blogs.rhsphere.com/2019/03/06/stack-queue-priorityQueue.html</id>
    <published>2019-03-06T12:23:16.000Z</published>
    <updated>2019-05-25T07:28:06.555Z</updated>
    
    <content type="html"><![CDATA[<p class="description">可以使用数组线性表实现栈，使用链表实现队列。</p><a id="more"></a><h2 id="栈-Stack"><a href="#栈-Stack" class="headerlink" title="栈(Stack)"></a>栈(Stack)</h2><p>将数组线性表定义为栈类中的数据域，而不是使用继承ArrayList的方法是因为，一般来说加强或扩展类的功能时才使用继承的方式。<br>AbstractList &lt;— Vector &lt;— Stack<br>ArrayList和Vector类是一样的。如果不需要同步使用ArrayList类。<br>Stack方法：</p><ul><li>peak() 返回栈顶元素而不移除它</li><li>pop()  返回并移除栈顶元素</li><li>push(e) 添加元素到栈里</li><li>search(e) 检测指定元素是否在栈中</li></ul><h3 id="组合的方式实现栈"><a href="#组合的方式实现栈" class="headerlink" title="组合的方式实现栈"></a>组合的方式实现栈</h3><figure class="highlight java"><figcaption><span>GenericStack.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Generictack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;E&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.get(getSize() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        list.add(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        E e = list.get(getSize() -<span class="number">1</span>);</span><br><span class="line">        list.remove(getSize() -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"stack: "</span> + list.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="用栈存储素数"><a href="#用栈存储素数" class="headerlink" title="用栈存储素数"></a>用栈存储素数</h3><figure class="highlight java"><figcaption><span>TestGenericStack.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestGenericStack</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GenericStack&lt;Integer&gt; stack = <span class="keyword">new</span> GenericStack&lt;&gt;();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> NUMBER_OF_PRIMES = <span class="number">50</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; count &lt; NUMBER_OF_PRIMES; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isPrime(i)) &#123;</span><br><span class="line">                stack.push(i);</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"The first 50 prime numbers in descending order: "</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; !stack.isEmpty(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">10</span> == <span class="number">0</span>)</span><br><span class="line">                System.out.printf(<span class="string">"%3d\n"</span>, stack.pop());</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                System.out.printf(<span class="string">"%3d "</span>, stack.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n / <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n % i == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="队列-Queue"><a href="#队列-Queue" class="headerlink" title="队列(Queue)"></a>队列(Queue)</h2><p>java API中java.util.Queue是一个接口<br>可以用Queue作为父类引用，LinkedList作为实例<br>java.util.Queue&lt;TreeNode<e>&gt; queue = new java.util.LinkedList&lt;&gt;();</e></p><p>Queue是LinkedList的父类接口<br>继承关系：<br>Collection &lt;— Queue &lt;— Deque &lt;— LinkedList<br>                Queue &lt;— AbstractQueue &lt;— PriorityQueue<br>Queue的方法：</p><ul><li>offer(e) 插入元素e到队列中</li><li>poll() 获取并移除队头(front)元素，，队为空返回null</li><li>remove() 获取并移除队头(front)元素，队为空抛出异常</li><li>peek() 获取但不移除对头元素，队为空返回null</li><li>element() 获取但不移除对头元素，队为空抛出异常</li></ul><p>使用继承和组合的方式实现队列和栈都是可行的，但是组合更好一点，因为可以定义一个全新的栈类和队列类，而不需要继承ArrayList和LinkedList中不必要和不合适的方法。</p><p><span style="color:#5073b8;">类仅在它们需要被加强或修改时，才会使用继承！！！！</span></p><h3 id="使用组合的方式实现队列"><a href="#使用组合的方式实现队列" class="headerlink" title="使用组合的方式实现队列"></a>使用组合的方式实现队列</h3><figure class="highlight java"><figcaption><span>组合的方式实现Queue</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericQueue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;E&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        list.addFirst(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">dequeu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.removeFirst();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Queue: "</span> + list.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="继承关系实现Queue"><a href="#继承关系实现Queue" class="headerlink" title="继承关系实现Queue"></a>继承关系实现Queue</h3><figure class="highlight java"><figcaption><span>继承关系实现Queue</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">util</span>.<span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        addLast(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> removeFirst();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优先队列-PriorityQueue"><a href="#优先队列-PriorityQueue" class="headerlink" title="优先队列(PriorityQueue)"></a>优先队列(PriorityQueue)</h2><p>对于使用Comparable和Comparator实现的Heap类见文章<a href="https://blogs.rhsphere.com/leetcode/2019/03/14/heap-sort.html" target="_blank" rel="noopener">堆排序</a></p><h3 id="用堆实现优先队列"><a href="#用堆实现优先队列" class="headerlink" title="用堆实现优先队列"></a>用堆实现优先队列</h3><p>普通队列是一种先进先出的数据结构，元素在rear添加，在front删除。在优先队列中，元素被赋予优先级，当访问元素时，具有最高优先级的元素最先删除。<br>Largest-in, first-Out 高进先出<br>在java API中继承顺序如下：<br>Queue &lt;— AbstractQueue &lt;— PriorityQueue </p><p>可以使用堆实现优先队列，其中根节点是队列中具有最高优先级的对象。</p><p>使用Comparable接口</p><figure class="highlight java"><figcaption><span>用Comparable实现泛型PriorityQueue</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPriorityQueue</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">E</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Heap&lt;E&gt; heap = <span class="keyword">new</span> Heap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E newOject)</span> </span>&#123;</span><br><span class="line">        heap.add(newObject);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> heap.remove();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> heap.getSize();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="用Comparator实现泛型PriorityQueue"><a href="#用Comparator实现泛型PriorityQueue" class="headerlink" title="用Comparator实现泛型PriorityQueue"></a>用Comparator实现泛型PriorityQueue</h3><figure class="highlight java"><figcaption><span>用Comparator实现泛型PriorityQueue</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPriorityQueue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Comparator&lt;? <span class="keyword">super</span> E&gt; comparator;</span><br><span class="line">    <span class="keyword">private</span> Heap&lt;E&gt; heap;</span><br><span class="line">    </span><br><span class="line">    MyPriorityQueue(Comparator&lt;? <span class="keyword">super</span> E&gt; comparator) &#123;</span><br><span class="line">        <span class="keyword">this</span>.comparator = comparator;</span><br><span class="line">        <span class="keyword">this</span>.heap = <span class="keyword">new</span> Heap&lt;&gt;(comparator);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E newObject)</span> </span>&#123;</span><br><span class="line">        heap.add(newObject);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> heap.remove();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> heap.getSize();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;可以使用数组线性表实现栈，使用链表实现队列。&lt;/p&gt;
    
    </summary>
    
      <category term="List" scheme="https://www.blogs.rhsphere.com/categories/List/"/>
    
    
      <category term="Stack" scheme="https://www.blogs.rhsphere.com/tags/Stack/"/>
    
      <category term="Queue" scheme="https://www.blogs.rhsphere.com/tags/Queue/"/>
    
      <category term="PriorityQueue" scheme="https://www.blogs.rhsphere.com/tags/PriorityQueue/"/>
    
  </entry>
  
  <entry>
    <title>链表</title>
    <link href="https://www.blogs.rhsphere.com/2019/03/05/LinkedList.html"/>
    <id>https://www.blogs.rhsphere.com/2019/03/05/LinkedList.html</id>
    <published>2019-03-05T08:47:01.000Z</published>
    <updated>2019-05-25T07:28:06.556Z</updated>
    
    <content type="html"><![CDATA[<p class="description">LinkedList是用链表结构存储数据的，很适合数据的动态插入和删除，而随机访问和遍历的速度则较慢。另外，它还提供了List接口中没有定义的方法，专门用于操作表头和表尾元素，可以当作堆栈、队列和双向队列使用。</p><a id="more"></a><h2 id="链表LinkedList"><a href="#链表LinkedList" class="headerlink" title="链表LinkedList"></a>链表LinkedList</h2><p>由于ArrayList是用数组实现的，所以 get(int index) 和 set(int index, E e) 方法可以通过下标访问和修改元素，也可以用 add(E e) 方法在线性表末尾添加元素，它们是高效的。但是 add(int index, E e) 和 remove(int index) 方法的效率很低，因为需要移动潜在的大量元素。<br>为了提高在表中开始位置添加和删除元素的效率，可以采用链式结构来实现线性表。</p><h3 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h3><p>每个节点都包含元素和一个名为next的数据域，next指向下一个元素。如果节点是线性表中的最后一个，那么它的指针数据域next所包含的值是null。</p><figure class="highlight java"><figcaption><span>LinkedList节点类</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// This class is only used in LinkedList, so it is private.</span></span><br><span class="line"><span class="comment">// This class does not need to access any</span></span><br><span class="line"><span class="comment">// instance members of LinkedList, so it is defined static.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">E element;</span><br><span class="line">Node&lt;E&gt; next;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(E element)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.element = element;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现addFirst-E-e-方法"><a href="#实现addFirst-E-e-方法" class="headerlink" title="实现addFirst(E e)方法"></a>实现addFirst(E e)方法</h3><figure class="highlight java"><figcaption><span>addFirst(E e)方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(e);</span><br><span class="line">newNode.next = head;</span><br><span class="line">head = newNode;</span><br><span class="line">size++;</span><br><span class="line"><span class="keyword">if</span> (tail == <span class="keyword">null</span>)</span><br><span class="line">tail = head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现addLast-E-e-方法"><a href="#实现addLast-E-e-方法" class="headerlink" title="实现addLast(E e)方法"></a>实现addLast(E e)方法</h3><figure class="highlight java"><figcaption><span>addLast(E e)方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(e);</span><br><span class="line"><span class="keyword">if</span> (tail == <span class="keyword">null</span>) &#123;</span><br><span class="line">head = tail = newNode;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">tail.next = newNode;</span><br><span class="line">tail = tail.next;</span><br><span class="line">&#125;</span><br><span class="line">size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现add-int-index-E-e-方法"><a href="#实现add-int-index-E-e-方法" class="headerlink" title="实现add(int index, E e)方法"></a>实现add(int index, E e)方法</h3><figure class="highlight java"><figcaption><span>add(int index, E e)方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E e)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">//addFirst &amp;&amp; addLast contains size++</span></span><br><span class="line">addFirst(e);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (index &gt;= size) &#123;</span><br><span class="line">addLast(e);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">Node&lt;E&gt; current = head;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; index; i++) &#123;</span><br><span class="line">current = current.next;</span><br><span class="line">&#125;</span><br><span class="line">Node&lt;E&gt; tmp = current.next;</span><br><span class="line">current.next = <span class="keyword">new</span> Node&lt;&gt;(e);</span><br><span class="line">(current.next).next = tmp;</span><br><span class="line">size++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现removeFirst-方法"><a href="#实现removeFirst-方法" class="headerlink" title="实现removeFirst()方法"></a>实现removeFirst()方法</h3><figure class="highlight java"><figcaption><span>removeFirst()方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">Node&lt;E&gt; tmp = head;</span><br><span class="line">head = head.next;</span><br><span class="line">size--;</span><br><span class="line"><span class="keyword">return</span> tmp.element;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现removeLast-方法"><a href="#实现removeLast-方法" class="headerlink" title="实现removeLast()方法"></a>实现removeLast()方法</h3><figure class="highlight java"><figcaption><span>removeLast()方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (size == <span class="number">1</span>) &#123;</span><br><span class="line">Node&lt;E&gt; tmp = head;</span><br><span class="line">head = tail = <span class="keyword">null</span>;</span><br><span class="line">size = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> tmp.element;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">Node&lt;E&gt; current = head;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size - <span class="number">2</span>; i++) </span><br><span class="line">current = current.next;</span><br><span class="line">Node&lt;E&gt; tmp = tail;</span><br><span class="line">tail.next = <span class="keyword">null</span>;</span><br><span class="line">size--;</span><br><span class="line"><span class="keyword">return</span> tmp.element;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现remove-int-index-方法"><a href="#实现remove-int-index-方法" class="headerlink" title="实现remove(int index)方法"></a>实现remove(int index)方法</h3><figure class="highlight java"><figcaption><span>remove(int index)方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> removeFirst();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (index == size -<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> removeLast();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">Node&lt;E&gt; previous = head;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; index; i++)</span><br><span class="line">previous = previous.next;</span><br><span class="line">Node&lt;E&gt; current = previous.next;</span><br><span class="line">previous.next = current.next;</span><br><span class="line">size--;</span><br><span class="line"><span class="keyword">return</span> current.element;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="MyLinkedList具体实现"><a href="#MyLinkedList具体实现" class="headerlink" title="MyLinkedList具体实现"></a>MyLinkedList具体实现</h2><figure class="highlight java"><figcaption><span>MyLinkedList具体实现</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLinkedList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">MyAbstractList</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> Node&lt;E&gt; head, tail;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyLinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyLinkedList</span><span class="params">(E[] objects)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(objects);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> head.element;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> tail.element;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(e);</span><br><span class="line">newNode.next = head;</span><br><span class="line">head = newNode;</span><br><span class="line">size++;</span><br><span class="line"><span class="keyword">if</span> (tail == <span class="keyword">null</span>)</span><br><span class="line">tail = head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(e);</span><br><span class="line"><span class="keyword">if</span> (tail == <span class="keyword">null</span>) &#123;</span><br><span class="line">head = tail = newNode;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">tail.next = newNode;</span><br><span class="line">tail = tail.next;</span><br><span class="line">&#125;</span><br><span class="line">size++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E e)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">//addFirst &amp;&amp; addLast contains size++</span></span><br><span class="line">addFirst(e);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (index &gt;= size) &#123;</span><br><span class="line">addLast(e);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">Node&lt;E&gt; current = head;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; index; i++) &#123;</span><br><span class="line">current = current.next;</span><br><span class="line">&#125;</span><br><span class="line">Node&lt;E&gt; tmp = current.next;</span><br><span class="line">current.next = <span class="keyword">new</span> Node&lt;&gt;(e);</span><br><span class="line">(current.next).next = tmp;</span><br><span class="line">size++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">size = <span class="number">0</span>;</span><br><span class="line">head = tail = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">Node&lt;E&gt; current = head;</span><br><span class="line"><span class="keyword">while</span> (current != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (current.element == e)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">current = current.next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> getFirst();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (index == size -<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> getLast();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">Node&lt;E&gt; current = head.next;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; index; i++)</span><br><span class="line">current = current.next;</span><br><span class="line"><span class="keyword">return</span> current.element;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (head.element == e) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (tail.element == e) &#123;</span><br><span class="line"><span class="keyword">return</span> size - <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">Node&lt;E&gt; current = head.next;</span><br><span class="line"><span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (current != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (current.element == e)</span><br><span class="line"><span class="keyword">return</span> index;</span><br><span class="line">current = current.next;</span><br><span class="line">index++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line">Node&lt;E&gt; current = head;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (current.element == e)</span><br><span class="line">index = i;</span><br><span class="line">current = current.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">Node&lt;E&gt; tmp = head;</span><br><span class="line">head = head.next;</span><br><span class="line">size--;</span><br><span class="line"><span class="keyword">return</span> tmp.element;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (size == <span class="number">1</span>) &#123;</span><br><span class="line">Node&lt;E&gt; tmp = head;</span><br><span class="line">head = tail = <span class="keyword">null</span>;</span><br><span class="line">size = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> tmp.element;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">Node&lt;E&gt; current = head;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size - <span class="number">2</span>; i++) </span><br><span class="line">current = current.next;</span><br><span class="line">Node&lt;E&gt; tmp = tail;</span><br><span class="line">tail.next = <span class="keyword">null</span>;</span><br><span class="line">size--;</span><br><span class="line"><span class="keyword">return</span> tmp.element;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> removeFirst();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (index == size -<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> removeLast();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">Node&lt;E&gt; previous = head;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; index; i++)</span><br><span class="line">previous = previous.next;</span><br><span class="line">Node&lt;E&gt; current = previous.next;</span><br><span class="line">previous.next = current.next;</span><br><span class="line">size--;</span><br><span class="line"><span class="keyword">return</span> current.element;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E e)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size -<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">Node&lt;E&gt; current = head;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">current = current.next;</span><br><span class="line"></span><br><span class="line">current.element = e;</span><br><span class="line"><span class="keyword">return</span> current.element;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">StringBuilder res = <span class="keyword">new</span> StringBuilder(<span class="string">"["</span>);</span><br><span class="line">Node&lt;E&gt; current = head;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">res.append(current.element);</span><br><span class="line">current = current.next;</span><br><span class="line"><span class="keyword">if</span> (current != <span class="keyword">null</span>) &#123;</span><br><span class="line">res.append(<span class="string">", "</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">res.append(<span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> LinkedListIterator();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> Node&lt;E&gt; current = head;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (current != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">E e = current.element;</span><br><span class="line">current = current.next;</span><br><span class="line"><span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This class is only used in LinkedList, so it is private.</span></span><br><span class="line"><span class="comment">// This class does not need to access any</span></span><br><span class="line"><span class="comment">// instance members of LinkedList, so it is defined static.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">E element;</span><br><span class="line">Node&lt;E&gt; next;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(E element)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.element = element;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="抽象类和接口"><a href="#抽象类和接口" class="headerlink" title="抽象类和接口"></a>抽象类和接口</h2><h3 id="MyList接口"><a href="#MyList接口" class="headerlink" title="MyList接口"></a>MyList接口</h3><figure class="highlight java"><figcaption><span>MyList接口</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Iterable</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E e)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(E e)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(E e)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(E e)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(E e)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Object <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E e)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="MyAbstractList抽象类"><a href="#MyAbstractList抽象类" class="headerlink" title="MyAbstractList抽象类"></a>MyAbstractList抽象类</h3><figure class="highlight java"><figcaption><span>MyAbstractList抽象类</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAbstractList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">MyList</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">int</span> size = <span class="number">0</span> ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">MyAbstractList</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">MyAbstractList</span><span class="params">(E[] objects)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; objects.length; i++)</span><br><span class="line">add(objects[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">add(size, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (indexOf(e) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">remove(indexOf(e));</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;LinkedList是用链表结构存储数据的，很适合数据的动态插入和删除，而随机访问和遍历的速度则较慢。另外，它还提供了List接口中没有定义的方法，专门用于操作表头和表尾元素，可以当作堆栈、队列和双向队列使用。&lt;/p&gt;
    
    </summary>
    
      <category term="List" scheme="https://www.blogs.rhsphere.com/categories/List/"/>
    
    
      <category term="LinkedList" scheme="https://www.blogs.rhsphere.com/tags/LinkedList/"/>
    
      <category term="List" scheme="https://www.blogs.rhsphere.com/tags/List/"/>
    
  </entry>
  
  <entry>
    <title>数组线性表</title>
    <link href="https://www.blogs.rhsphere.com/2019/03/04/ArrayList.html"/>
    <id>https://www.blogs.rhsphere.com/2019/03/04/ArrayList.html</id>
    <published>2019-03-04T05:46:03.000Z</published>
    <updated>2019-05-25T07:28:06.555Z</updated>
    
    <content type="html"><![CDATA[<p class="description">ArrayList是最常用的List实现类，内部是通过数组实现的，它允许对元素进行快速随机访问。数组的缺点是每个元素之间不能有间隔，当数组大小不满足时，需要增加存储能力，就要将已经有数组的数据复制到新的存储空间中。当从ArrayList的中间位置插入或者删除元素时，需要对数组进行复制、移动时，代价比较高。因此，它适合随机查找和遍历，不适合插入和删除。</p><a id="more"></a><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>常用的List方法：</p><ul><li>add  在最后或特定位置加入新的元素</li><li>clear  清除所有元素</li><li>contains  是否含有指定元素</li><li>get  获取特定索引元素</li><li>indexOf  返回特定元素第一次出现的索引，没有则返回-1</li><li>lastIndexOf  返回特定元素最后一次出现的索引，没有则返回-1</li><li>isEmpty  判断是否为空</li><li>iterator  返回迭代器</li><li>remove  移除特定元素</li><li>size  返回List大小</li><li>subList  根据传入的两个索引返回子列表</li></ul><p>常用的List实现类有:</p><ol><li>ArrayList： 擅长随机访问的列表</li><li>LinkedList： 擅长插入和删除操作的列表</li><li>Vector： 与ArrayList类似，线程安全的列表</li></ol><h2 id="MyArrayList和MyLinkedList"><a href="#MyArrayList和MyLinkedList" class="headerlink" title="MyArrayList和MyLinkedList"></a>MyArrayList和MyLinkedList</h2><p>可以使用ArrayList和LinkedList来存储线性表。使用数组实现ArrayList，使用链表实现LinkedList，前者开销比后者小。但是如果需要在线性表的开始位置插入和删除元素，那么LinkedList的效率会高一点。下表总结了ArrayList和LinkedList中方法的时间复杂度。</p><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:center">ArrayList</th><th style="text-align:center">LinkedList</th></tr></thead><tbody><tr><td style="text-align:center">add(e: E)</td><td style="text-align:center">O(1)</td><td style="text-align:center">O(1)</td></tr><tr><td style="text-align:center">add(index: int, e: E)</td><td style="text-align:center">O(n)</td><td style="text-align:center">O(n)</td></tr><tr><td style="text-align:center">clear()</td><td style="text-align:center">O(1)</td><td style="text-align:center">O(1)</td></tr><tr><td style="text-align:center">contains(e: E)</td><td style="text-align:center">O(n)</td><td style="text-align:center">O(n)</td></tr><tr><td style="text-align:center">get(index: int)</td><td style="text-align:center">O(1)**</td><td style="text-align:center">O(n)</td></tr><tr><td style="text-align:center">indexOf(e: E)</td><td style="text-align:center">O(n)</td><td style="text-align:center">O(n)</td></tr><tr><td style="text-align:center">isEmpty()</td><td style="text-align:center">O(1)</td><td style="text-align:center">O(1)</td></tr><tr><td style="text-align:center">lastIndexOf(e: E)</td><td style="text-align:center">O(n)</td><td style="text-align:center">O(n)</td></tr><tr><td style="text-align:center">remove(e: E)</td><td style="text-align:center">O(n)</td><td style="text-align:center">O(n)</td></tr><tr><td style="text-align:center">size()</td><td style="text-align:center">O(1)</td><td style="text-align:center">O(1)</td></tr><tr><td style="text-align:center">remove(index: int)</td><td style="text-align:center">O(n)</td><td style="text-align:center">O(n)</td></tr><tr><td style="text-align:center">set(index: int, e: E)</td><td style="text-align:center">O(n)</td><td style="text-align:center">O(n)</td></tr><tr><td style="text-align:center">addFirst(e: E)</td><td style="text-align:center">O(n)</td><td style="text-align:center">O(1)**</td></tr><tr><td style="text-align:center">removeFirst()</td><td style="text-align:center">O(n)</td><td style="text-align:center">O(1)**</td></tr></tbody></table><h2 id="ArrayList部分细节"><a href="#ArrayList部分细节" class="headerlink" title="ArrayList部分细节"></a>ArrayList部分细节</h2><p>使用数组来实现动态数据结构，处理方法是：当数组不能再存储线性表的新元素时，创建一个更大的新数组来替换当前数组。</p><h3 id="add-int-index-E-e"><a href="#add-int-index-E-e" class="headerlink" title="add(int index, E e)"></a>add(int index, E e)</h3><figure class="highlight java"><figcaption><span>添加元素到指定位置</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacity();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt;= index; i--) &#123;</span><br><span class="line">        data[i + <span class="number">1</span>] = data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    data[index] = e;</span><br><span class="line">    size++;     </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size &gt;= data.length) &#123;</span><br><span class="line">        E[] newData = (E[]) <span class="keyword">new</span> Object[<span class="number">2</span> * size + <span class="number">1</span>];</span><br><span class="line">        System.arraycopy(data, <span class="number">0</span>, newData, <span class="number">0</span>, size);</span><br><span class="line">        data = newData;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="clear"><a href="#clear" class="headerlink" title="clear()"></a>clear()</h3><p>通过创建一个新数组并且将其复制给data，老的数组和保存在数组中的数据变成垃圾，将自动被JVM回收。<br><figure class="highlight java"><figcaption><span>clear方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    data = (E[]) <span class="keyword">new</span> Object[INITIAL_CAPACITY];</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="remove-int-index"><a href="#remove-int-index" class="headerlink" title="remove(int index)"></a>remove(int index)</h3><p>最后一个元素不再使用，设置为null。<br><figure class="highlight java"><figcaption><span>remove方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkIndex(index);</span><br><span class="line">    E e = data[index];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = index; j &lt; size - <span class="number">1</span>; j++)</span><br><span class="line">        data[j] = data[j + <span class="number">1</span>];</span><br><span class="line">    data[size - <span class="number">1</span>] = <span class="keyword">null</span>;</span><br><span class="line">    size--;     </span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="ArrayList具体实现"><a href="#ArrayList具体实现" class="headerlink" title="ArrayList具体实现"></a>ArrayList具体实现</h2><p>采用集合的实现模式，在MyList接口中提供通用的操作，抽象类部分实现了包括集合操作的addAll、removeAll和containsAll等方法，最后在MyArrayList类中实现了数组线性表。<br>为了便于手机查看，采用倒序的显示方式。将接口、抽象类和测试用例放在最后。</p><figure class="highlight java"><figcaption><span>MyArrayList实现类</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> algorithms.arrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">MyAbstractList</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>  INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">private</span> E[] data = (E[]) <span class="keyword">new</span> Object[INITIAL_CAPACITY];  </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyArrayList</span><span class="params">()</span> </span>&#123;      </span><br><span class="line">        </span><br><span class="line">    &#125;;      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyArrayList</span><span class="params">(E[] objects)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; objects.length; i++)</span><br><span class="line">            add(objects[i]);</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E e)</span> </span>&#123;</span><br><span class="line">        ensureCapacity();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt;= index; i--) &#123;</span><br><span class="line">            data[i + <span class="number">1</span>] = data[i];</span><br><span class="line">        &#125;</span><br><span class="line">        data[index] = e;</span><br><span class="line">        size++;     </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        data = (E[]) <span class="keyword">new</span> Object[INITIAL_CAPACITY];</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.equals(data[i]))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;       </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        checkIndex(index);</span><br><span class="line">        <span class="keyword">return</span> data[index];</span><br><span class="line">    &#125;   </span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.equals(data[i]))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.equals(data[i]))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        checkIndex(index);</span><br><span class="line">        E e = data[index];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = index; j &lt; size - <span class="number">1</span>; j++)</span><br><span class="line">            data[j] = data[j + <span class="number">1</span>];</span><br><span class="line">        data[size - <span class="number">1</span>] = <span class="keyword">null</span>;</span><br><span class="line">        size--;     </span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E e)</span> </span>&#123;</span><br><span class="line">        checkIndex(index);</span><br><span class="line">        E old = data[index];</span><br><span class="line">        data[index] = e;</span><br><span class="line">        <span class="keyword">return</span> old;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder(<span class="string">"["</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            res.append(data[i]);</span><br><span class="line">            <span class="keyword">if</span> (i &lt; size - <span class="number">1</span>)</span><br><span class="line">                res.append(<span class="string">", "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString() + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size != data.length) &#123;</span><br><span class="line">            E[] newData = (E[]) <span class="keyword">new</span> Object[size];</span><br><span class="line">            System.arraycopy(data, <span class="number">0</span>, newData, <span class="number">0</span>, size);</span><br><span class="line">            data = newData;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayListIterator();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size &gt;= data.length) &#123;</span><br><span class="line">            E[] newData = (E[]) <span class="keyword">new</span> Object[<span class="number">2</span> * size + <span class="number">1</span>];</span><br><span class="line">            System.arraycopy(data, <span class="number">0</span>, newData, <span class="number">0</span>, size);</span><br><span class="line">            data = newData;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"index "</span> + index + <span class="string">" ouf of bounds"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayListIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> current = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (current &lt; size);</span><br><span class="line">        &#125;       </span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> data[current++];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            MyArrayList.<span class="keyword">this</span>.remove(current);</span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="接口、抽象类和测试用例"><a href="#接口、抽象类和测试用例" class="headerlink" title="接口、抽象类和测试用例"></a>接口、抽象类和测试用例</h2><h3 id="MyList接口"><a href="#MyList接口" class="headerlink" title="MyList接口"></a>MyList接口</h3><figure class="highlight java"><figcaption><span>MyList接口</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> algorithms.arrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Iterable</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E e)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(E e)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(E e)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(E e)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(E e)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Object <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E e)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(MyList&lt;E&gt; otherList)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(MyList&lt;E&gt; otherList)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(MyList&lt;E&gt; otherList)</span></span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="MyAbstractList抽象类"><a href="#MyAbstractList抽象类" class="headerlink" title="MyAbstractList抽象类"></a>MyAbstractList抽象类</h3><figure class="highlight java"><figcaption><span>MyAbstractList抽象类</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> algorithms.arrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAbstractList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">MyList</span>&lt;<span class="title">E</span>&gt; </span>&#123;  </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> size = <span class="number">0</span> ;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">MyAbstractList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;;  </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">MyAbstractList</span><span class="params">(E[] objects)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; objects.length; i++)</span><br><span class="line">            add(objects[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        add(size, e);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (indexOf(e) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            remove(indexOf(e));</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(MyList&lt;E&gt; otherList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> changed = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; otherList.size(); i++) &#123;</span><br><span class="line">            E e = otherList.get(i);</span><br><span class="line">            <span class="keyword">if</span> (!contains(e)) &#123;</span><br><span class="line">                add(e);</span><br><span class="line">                changed = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> changed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(MyList&lt;E&gt; otherList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> changed = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; otherList.size(); i++) &#123;</span><br><span class="line">            E e = otherList.get(i);</span><br><span class="line">            <span class="keyword">if</span> (contains(e)) &#123;</span><br><span class="line">                remove(e);</span><br><span class="line">                changed = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> changed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(MyList&lt;E&gt; otherList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> changed = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            E e = otherList.get(i);</span><br><span class="line">            <span class="keyword">if</span> (!otherList.contains(e)) &#123;</span><br><span class="line">                remove(e);</span><br><span class="line">                changed = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> changed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="MyArrayList测试用例"><a href="#MyArrayList测试用例" class="headerlink" title="MyArrayList测试用例"></a>MyArrayList测试用例</h3><figure class="highlight java"><figcaption><span>MyArrayList测试用例</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> algorithms.arrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMyArrayList</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] array1 = &#123;<span class="string">"Tom"</span>, <span class="string">"George"</span>, <span class="string">"Peter"</span>, <span class="string">"Jean"</span>, <span class="string">"Jane"</span>&#125;;</span><br><span class="line">        MyList&lt;String&gt; list1 = <span class="keyword">new</span> MyArrayList&lt;&gt;(array1);</span><br><span class="line"></span><br><span class="line">        String[] array2 = &#123;<span class="string">"Tom"</span>, <span class="string">"George"</span>, <span class="string">"Michael"</span>, <span class="string">"Michelle"</span>, <span class="string">"Daniel"</span>&#125;;</span><br><span class="line">        MyList&lt;String&gt; list2 = <span class="keyword">new</span> MyArrayList&lt;&gt;(array2);</span><br><span class="line">        System.out.println(<span class="string">"Create two MyArrayLists:"</span>);</span><br><span class="line">        print(list1, list2);        </span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"Invoke list1.addAll(list2):"</span>);</span><br><span class="line">        list1.addAll(list2);</span><br><span class="line">        print(list1, list2);</span><br><span class="line">        System.out.println(<span class="string">"Recreate list1 and list2 with the same initial values,"</span></span><br><span class="line">         + <span class="string">"\ninvoke list1.removeAll(list2), and displays list1 and list2:"</span>);</span><br><span class="line">        list1.clear();</span><br><span class="line">        list1.addAll(<span class="keyword">new</span> MyArrayList&lt;&gt;(array1));</span><br><span class="line">        list1.removeAll(list2);</span><br><span class="line">        print(list1, list2);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"Recreate list1 and list2 with the same initial values,"</span> </span><br><span class="line">        + <span class="string">"\ninvokes list1.retainAll(list2), and displays list1 and list2:"</span>);</span><br><span class="line">        list1.clear();</span><br><span class="line">        list1.addAll(<span class="keyword">new</span> MyArrayList&lt;&gt;(array1));</span><br><span class="line">        list1.retainAll(list2);</span><br><span class="line">        print(list1, list2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(MyList&lt;String&gt; list1, MyList&lt;String&gt; list2)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"List1: "</span> + list1);</span><br><span class="line">        System.out.println(<span class="string">"List2: "</span> + list2);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;ArrayList是最常用的List实现类，内部是通过数组实现的，它允许对元素进行快速随机访问。数组的缺点是每个元素之间不能有间隔，当数组大小不满足时，需要增加存储能力，就要将已经有数组的数据复制到新的存储空间中。当从ArrayList的中间位置插入或者删除元素时，需要对数组进行复制、移动时，代价比较高。因此，它适合随机查找和遍历，不适合插入和删除。&lt;/p&gt;
    
    </summary>
    
      <category term="List" scheme="https://www.blogs.rhsphere.com/categories/List/"/>
    
    
      <category term="ArrayList" scheme="https://www.blogs.rhsphere.com/tags/ArrayList/"/>
    
      <category term="List" scheme="https://www.blogs.rhsphere.com/tags/List/"/>
    
  </entry>
  
  <entry>
    <title>第一讲|先想后写——TCS三步构思法</title>
    <link href="https://www.blogs.rhsphere.com/2019/02/26/tone-content-structure.html"/>
    <id>https://www.blogs.rhsphere.com/2019/02/26/tone-content-structure.html</id>
    <published>2019-02-26T15:15:25.000Z</published>
    <updated>2019-02-27T14:34:43.935Z</updated>
    
    <content type="html"><![CDATA[<p class="description">职场写作最忌讳打开电脑就写，请你先想再写。TCS法三个步骤完成构思过程，即tone、content和structure，对应基调、内容和结构。</p><a id="more"></a><h2 id="基调为王，七种文案的标志性语气"><a href="#基调为王，七种文案的标志性语气" class="headerlink" title="基调为王，七种文案的标志性语气"></a>基调为王，七种文案的标志性语气</h2><p>第一步，基调，文章以基调为“王”。基调对了，事半功倍；基调错了，哪怕你传递的信息再重要，我也不会关注。<br>正确的基调能传递出文章真正的价值，也就是你的价值。职场写作可以分成四大类，那么每一类都需要传递你的什么价值呢？</p><ul><li>第一，总结类，写的是<span style="color:#bf91e8;">成绩</span>，呈现的是<span style="color:#FF0033;">你的潜力</span>；</li><li>第二，调查报告类，写的是<span style="color:#bf91e8;">调查结果</span>，呈现的是<span style="color:#FF0033;">你求实的态度</span>；</li><li>第三，申请类，内容是<span style="color:#bf91e8;">提问</span>，呈现的是<span style="color:#FF0033;">你主动的思考方式</span>；</li><li>第四，计划类，写的是<span style="color:#bf91e8;">阶段任务</span>，呈现的是<span style="color:#FF0033;">你的责任感</span>。</li></ul><p>如果明白了要呈现自己什么价值，那你拿捏起文章的基调来，正确的概率就会很高。</p><p><em>以常见的六种具体文案为例，探讨一下它们的标志性的基调。</em></p><h3 id="年终总结，基调要求：有深度"><a href="#年终总结，基调要求：有深度" class="headerlink" title="年终总结，基调要求：有深度"></a>年终总结，基调要求：有深度</h3><p>不要写成一份业绩的流水账——因为你的工作结果，领导在看你的总结之前就知道。可他为什么还要看？<br>他要读到你的分析能力；他希望你能从对工作感性的认知，上升到理性的规律性的总结；他需要你协助他，对未来做出更正确的决定。<br><span style="color:#5073b8;">由此来看，年终总结不是回顾，而是行动指南。</span>好的年终总结应该：</p><ul><li>会将工作成果写出意义，会提供难得的一线经验、不同的视角；</li><li>会在罗列了贡献之后，找出问题或机遇，以及怎样解决这个问题，或抓住这个机遇。<br>这就是“有深度”。</li></ul><h3 id="进展汇报，基调要求：不讨教"><a href="#进展汇报，基调要求：不讨教" class="headerlink" title="进展汇报，基调要求：不讨教"></a>进展汇报，基调要求：不讨教</h3><p>在进展汇报里，不能只提问题，向领导讨教，而应该给出方案，向领导汇报。讨教的公式是：您告诉我该怎么做。<span style="color:#5073b8;">汇报的公式是：我这样做，您同意吗？<br>这里我想提醒你，哪怕领导没有要求你写进展汇报，你也要养成定期向他汇报的习惯。</span><br>你需要将解决问题过程中的一些重要发现、关键结论、阶段性成果等小胜利，实时呈现给他，让他读出你的认真，让他看到你不断提高工作能力的过程。</p><h3 id="调查报告，基调要求：实事求是"><a href="#调查报告，基调要求：实事求是" class="headerlink" title="调查报告，基调要求：实事求是"></a>调查报告，基调要求：实事求是</h3><p>在收集充分的事实资料后，你的措辞是“资料显示、数字表明”，而不是“我认为、我估计”。这种报告才能展现事情的真相，才会有让人惊喜的收获。</p><h3 id="请示，基调要求：有主见"><a href="#请示，基调要求：有主见" class="headerlink" title="请示，基调要求：有主见"></a>请示，基调要求：有主见</h3><p>有的人这么写：</p><p><blockquote>“客户投诉如下，请指示。”</blockquote><br>不管是找领导要人、要钱，或其他任何资源，一定要有清晰的主见。<br>比如申请款项，你要给一个量化的标准让领导来裁决，不能模糊不清，让他无据可依、无处下手。<span style="color:#5073b8;">让他做选择题的时候，你也需要提供最佳选项。</span><br>另外，部门主管向上级递交请示的时候，不能采用传声筒的语气。<br>不要写“他们抱怨”或“他们声称”，要写“我注意到” “我相信我的团队会……”，这才是有担当、有主见的语气。</p><h3 id="批复，基调要求：态度明确"><a href="#批复，基调要求：态度明确" class="headerlink" title="批复，基调要求：态度明确"></a>批复，基调要求：态度明确</h3><p>不能出现这样的措辞：“似属可行” “酌情办理”。</p><h3 id="项目计划，基调要求：“可交付”"><a href="#项目计划，基调要求：“可交付”" class="headerlink" title="项目计划，基调要求：“可交付”"></a>项目计划，基调要求：“可交付”</h3><p>不能仅仅写行为。一个项目的成功，不是行动了就可以，而是众多可交付结果的总和。</p><ul><li>比如：“选择外部供应商”，这是写行为，改为可交付的结果：<strong>“确定外部供应商”</strong>。</li><li>又比如：“草拟消费者调查报告”，这又是写行为，改为可交付结果：<strong>“递交消费者调查报告”</strong>。</li></ul><p>这里我再和你多说一点。最好的项目计划书，是按照 <strong>OKR目标管理工具</strong>来写的。O：Objective 目标，KR：Key Results 关键结果。<br>简单地说，计划就是由目标和关键结果构成。其中，大目标可以分解成小目标，关键结果是用来衡量这些目标有没有完成的。按照这个工具来写，你的基调自然就是可交付的结果。<br><span style="background-color: #f0ad4e;">  以上就是构思的第一步——基调。</span></p><h2 id="从“作者逻辑”切换到“读者逻辑”"><a href="#从“作者逻辑”切换到“读者逻辑”" class="headerlink" title="从“作者逻辑”切换到“读者逻辑”"></a>从“作者逻辑”切换到“读者逻辑”</h2><p>TCS的第二步，C：content，内容。<br>你意识到了吗？我们在学校里的写作，读者是教授，他读你的文章的时候是有薪水拿的。在职场上的写作，可不是这样。<br><strong>职场上的读者，大多是“甲方读者”，比如领导、客户、重要合作伙伴，等等。也就是说，他们没有义务读完你的文章，他们可以随时终止阅读。</strong><br>怎么才能让这些甲方读者被你的内容吸引呢？请遵照这个原则：</p><p><blockquote>先从“作者逻辑”切换到“读者逻辑”，提供“所有必需信息”，然后按照“要话先说”的顺序排列。<br></blockquote><br>也就是说， 你的文章每个部分都要对读者有价值。<br>你写第一句话，是为了让他继续看第二句话；你写第二句话，是为了让他继续看第三句话。</p><p>举个例子，如果要写一份给投资人的商业计划书，俗称项目BP(Business Plan)。我们先做发散思维，想一想在初次接触时，投资人需要哪些信息来判断是否对项目有信心，是否愿意投资参与该项目？然后，为这些信息排序。<br>我最担心你一上来就急着展示自己公司有多厉害，这是作者逻辑。没搭好台就展示自己，操之过急。相反，文章应该从分析整个行业下手，彰显市场空缺。搭建好舞台后，才有机会介绍自己。<br>风险投资人也是要最大限度地规避风险的。而先选择行业，再选择个体，是他规避风险的方式，是读者逻辑。<br>按照这个逻辑，文章怎样写呢？</p><p><span style="background:#eee;"><em>第一部分</em></span>，写 <strong>“项目愿景”</strong>。 也就是，你要做一件什么样的大事。<br>这部分需要有一句高度精炼的话，比如黄太吉的“打造以煎饼果子为核心的中式时尚快餐连锁品牌”。<br>对方会问，这件事为什么值得做？于是你给出 <strong>“市场痛点”</strong>。<br>比如，摩拜单车是为了解决最后一公里的交通痛点。如果投资人根本不认为这是个痛点，后面一切都白写了。<br><span style="background:#eee;"><em>再往下</em></span>，是 <strong>“解决方案”</strong>。<br>论证的是，我们正在做的这个事业，真正能解决得了这个痛点，这把钥匙能开得了这把锁。OK,读者表示认同。<br><span style="background:#eee;"><em>然后</em></span>，他会想，<strong>“市场潜力”</strong>大吗？<br><span style="background:#eee;"><em>这时</em></span>，你该展示市场调查结果了，包括市场规模、用户画像、竞品分析等等。<br>那他会接着问，为什么要投你们，而不是别人呢？<br>你要阐述自己的 <strong>“独特优势”</strong>。包括行业经验、核心技术、牛人团队，等等。<br>OK, 这时读者对你有点儿感觉了。</p><p><span style="background:#eee;"><em>下一部分</em></span>，趁他对你有感觉的时候，拉着他一块儿画饼，你要写 <strong>“发展规划”</strong>了。<br>写清楚盈利模式和发展路径。也许你觉得奇怪，为什么这个内容现在才写？其实投资人很有经验，他只要决定和你一块儿干，他会在后期帮你一起完善盈利模式，清晰发展路径。</p><p><span style="background:#eee;"><em>最后</em></span>，做 <strong>“财务分析”</strong>，告诉他，你们缺多少钱。<br>为什么把融资额度放最后写呢？<br>你想想看，有经验的销售想把东西卖给你的时候，通常不会一上来就报价的。他们都是把商品的价值点全部讲完以后，才把价格说出来，这个时候出现的数字，会让对方觉得是个合理的数字。<br>至于 <strong>“退出机制” “利润分红”</strong>这些内容，在初次接触中并不重要，它们都有谈判的空间，所以可以不写。<br><span style="background-color: #f0ad4e;">在<strong>“要话先说”</strong>的顺序下，文章环环相扣，你前一部分阐述得精彩，读者才有兴趣问下一个问题，了解下一个部分。</span></p><h2 id="“向下想三层”，假设变结论"><a href="#“向下想三层”，假设变结论" class="headerlink" title="“向下想三层”，假设变结论"></a>“向下想三层”，假设变结论</h2><p>进入构思的第三步，TCS的S，structure结构。在你的文章里，可以用向下想三层的逻辑搭建金字塔结构。<span style="color:#5073b8;">金字塔的塔尖，是你鲜明的观点或建议，而下面两层，是证据。</span><br>在这个金字塔里，塔尖，<span style="color:#5073b8;">你鲜明的观点或建议</span>，是 <strong>“投钱给我们吧”</strong>。<br>读者自然会问：为什么？<br>金字塔第二层，两方面：因为有市场，因为我们强。<br>读者又问：有市场？——哪块市场？你们强？——强在哪里？<br>金字塔进入第三层的阐述。<br>这种顺序，让读者先读到塔尖，这样，不仅他能理解你更快，甚至认同你都更快。<br><span style="color:#5073b8;">因为塔尖就像一个熠熠生辉的宝石，抢先占据了他的阅读记忆，也许他会惴惴不安，也许他会兴奋不已，于是，在他接下来的阅读中，他会自己有意无意地将下面的证据与塔尖做链接，这个被说服过程由他自己来完成了。</span><br>这就是先想再写的TCS构思法。如果不这么做，文章可能会一点一点地偏离方向，最后主张模糊、脉络不明。而修改一份粗糙的文案，花费时间和力气更多。</p><h2 id="压缩三分之一的文字"><a href="#压缩三分之一的文字" class="headerlink" title="压缩三分之一的文字"></a>压缩三分之一的文字</h2><p>写完以后，还有一个步骤，<span style="color:#5073b8;">压缩，删掉三分之一的文字。</span>相信我，你可以做得到。 商务写作谨遵KISS原则：<span style="color:#5073b8;">keep it short and simple。</span> 句中不能有多余的词，段落中不能有多余的句子。<br>你可能会问我：文章到底是要简洁还是详实呢？<br><span style="color:#5073b8;">文字表达要简洁，内容提供要详实。</span><br>深度阐述和实例细节，会让文章更长，但不是冗长。 <strong>“用最少的字表达最多的意思”</strong>，这是我们追求的语言审美境界。<br>可以用这三个方法来做到 <strong>“减无可减”</strong>：</p><ul><li>把注水的文字压缩掉：“大概”、“一般来说”、“话说回来”，等等。</li><li>把“在我看来、我认为、我相信”之类的短语删掉，这是你写的文章，没有必要反复提醒读者这是你的观点。</li><li>把意思重复的句子压缩掉：相信读者是聪明人。</li></ul><p>简洁的文字体现自律。</p><h2 id="本讲小结"><a href="#本讲小结" class="headerlink" title="本讲小结"></a>本讲小结</h2><p>第一讲要结束了。在这一讲中，你要养成先想再写，然后再删的写作习惯。<br>写之前，做好TCS三步构思——基调、内容、结构。</p><p><span style="background:#EFF890;">第一步， 基调为王，用正确的基调传递出4类文案的真正价值；<br>第二步， 内容，提供“所有必需信息”，从“作者逻辑”切换到“读者逻辑”，并要话先说；<br>第三步， 结构，用向下想三层的金字塔结构，把你的假设，变成结论，用结论去说服他人。<br>最后， 商务写作的KISS原则要求我们压缩文章，我教了你三个方法。</span></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;职场写作最忌讳打开电脑就写，请你先想再写。TCS法三个步骤完成构思过程，即tone、content和structure，对应基调、内容和结构。&lt;/p&gt;
    
    </summary>
    
      <category term="得到" scheme="https://www.blogs.rhsphere.com/categories/%E5%BE%97%E5%88%B0/"/>
    
    
      <category term="得到，职场写作，软技能" scheme="https://www.blogs.rhsphere.com/tags/%E5%BE%97%E5%88%B0%EF%BC%8C%E8%81%8C%E5%9C%BA%E5%86%99%E4%BD%9C%EF%BC%8C%E8%BD%AF%E6%8A%80%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>得到|怎样提升你的职场写作能力</title>
    <link href="https://www.blogs.rhsphere.com/2019/02/24/improve-writing-skills-in-workplace.html"/>
    <id>https://www.blogs.rhsphere.com/2019/02/24/improve-writing-skills-in-workplace.html</id>
    <published>2019-02-24T09:21:59.000Z</published>
    <updated>2019-02-25T10:15:10.219Z</updated>
    
    <content type="html"><![CDATA[<p class="description">本文源自得到课程《有效提升你的职场写作能力》。作者戴愫老师，一名跨文化研究者，也是一名企业培训师。本系列共6讲和1个小结，干货满满，由思路清晰，思维缜密的戴愫老师娓娓道来。<br><b>前两讲是基础课</b>。养成正确的写作习惯——先想再写，然后删。写之前要“想”，想什么呢？用TCS三步构思法——基调、内容、结构。在基础课里，你会学到，在看似人人都会写的邮件里，蕴藏着怎样的高级套路。<b>第三讲和第四讲</b>，教你怎样给文章组织结构。当需要写复杂的文案时，怎样用四大思维能力组织一个高价值的文章，并且怎样写第一段，让文章的价值最大化。<b>最后两讲</b>，带你润色语言，为文章锦上添花——如何写出有权威性，又有亲和力的措辞，也就是让语言有质感、有温度。<b><em>版权归得到App所有，本文及相关内容仅供我个人总结和学习。</em></b></p><a id="more"></a><h2 id="三类职场人士的困惑是什么？"><a href="#三类职场人士的困惑是什么？" class="headerlink" title="三类职场人士的困惑是什么？"></a>三类职场人士的困惑是什么？</h2><p>戴愫老师和很多学员做过深度交流，有三类职场人士：</p><ul><li><span style="color:#5073b8;">第一类，职场小兵。他们专业技能强，需要简洁有力地从专业视角影响读者；他们经常需要写一些文章分享信息、阐述观点，比如项目进度报告、会议纪要、工作计划、可行性报告等。</span></li><li>第二类，职场老兵。他们需要通过写营运类报告，列出工作过程和结果，并把“成果”变成“功劳”，证明自己是未来的管理人才。</li><li>第三类，职场管理层。需要用高层的故事线来组织文章逻辑。比如说经常需要书写管理类报告，描述清楚商业逻辑，以便公司做出战略决策。</li></ul><p>很多人有以下困惑：</p><ul><li>因为工作太忙，需要快速成文的方法；</li><li>因为没有受过专门的商务写作的训练，分不清商务写作、文学写作、学术写作的清晰界线；</li><li>不知道如何从工作中收集一手资料，并从资料上构筑观点；</li><li>不知道如何以公司战略为风向标，提出自己的诉求，争取资源；</li><li>不知道怎样通过写作，把自己从“做事”的模式，调整为“做贡献”的心态；</li><li>写作时 <strong>容易用空洞的言辞，缺乏实质内容</strong>。</li></ul><h2 id="书面沟通到底是一项什么样的技能？"><a href="#书面沟通到底是一项什么样的技能？" class="headerlink" title="书面沟通到底是一项什么样的技能？"></a>书面沟通到底是一项什么样的技能？</h2><h3 id="书面沟通的形式是什么？单向，还是双向？"><a href="#书面沟通的形式是什么？单向，还是双向？" class="headerlink" title="书面沟通的形式是什么？单向，还是双向？"></a>书面沟通的形式是什么？单向，还是双向？</h3><p>书面沟通是一种单向沟通。你写，发给他，他读；或他写，发给你，你读。这是它最大的缺陷！<br>没有一个正常成年人喜欢“被通知、被命令”，大家都喜欢“被商量、被探讨”。这意味着，<span style="color:#5073b8;">我们作为作者，要通过“单向沟通的形式”，让读者读出“双向沟通的幻觉”。</span><br>制造这种幻觉很重要。为什么？我们来看第二点。</p><h3 id="判断一次沟通是不是100分，标准是什么？"><a href="#判断一次沟通是不是100分，标准是什么？" class="headerlink" title="判断一次沟通是不是100分，标准是什么？"></a>判断一次沟通是不是100分，标准是什么？</h3><p>这个标准是：<br>你明白我的意思了，或者我明白你的意思了？不，这只是60分的沟通。<br>我们把这件事儿办成了？这是80分。为什么只是80分，如果说这件事情是办成了，但我以后再也不想与你合作了，这就是赢了这场战役，失去了整个战争嘛，不行的。<br>那怎么做到100分呢？100分沟通的标准是，我和你理性、感性都达成一致了。注意，感性也要求达成一致。<br>职场上永远不要以为把事情搞定有多么难，真正难搞定的是“人”。哪怕是个纯技术问题，也是“人”的作为和不作为。</p><h3 id="达成一次100分沟通的基本前提是什么？"><a href="#达成一次100分沟通的基本前提是什么？" class="headerlink" title="达成一次100分沟通的基本前提是什么？"></a>达成一次100分沟通的基本前提是什么？</h3><p>是“信任”。 <span style="color:#5073b8;">信任是超越一切沟通形式、一切沟通技巧最基础的前提。</span><br>汉字的“信”，左边一个人，右边一个言，我们正常的顺序是，先相信这个人，再相信他说的话。这个顺序有可能放在每次书面沟通中吗？<br>没可能。很多时候，你和读者没有见过面，哪怕你们见过面，他对你的人格也不一定了解。<br>所以，我们需要学习：怎样在文章中大量使用信息化语言，在文字上与读者建立起信任，让他在不认识你，不熟知你的前提下，直接相信你写的话。</p><h3 id="书面沟通这项技能的本质"><a href="#书面沟通这项技能的本质" class="headerlink" title="书面沟通这项技能的本质"></a>书面沟通这项技能的本质</h3><p>作为写作者的你要用大量的信息化语言，在文字上与读者建立起信任（这是基本前提），并且，让读者通过单向沟通的形式，读出双向沟通的幻觉（这可以通过写作内容和文字表达来实现），最后，双方理性、感性都达成一致（这是100分沟通的衡量标准）。</p><p>重复一遍，书面沟通这项技能本质上就是：<br><span style="color:#5073b8;">作为写作者的你要用大量的信息化语言，在文字上与读者建立起信任，让读者通过单向沟通的形式，读出双向沟通的幻觉，最后双方理性、感性都达成一致。</span></p><h2 id="学完这门课，你能学到那些？"><a href="#学完这门课，你能学到那些？" class="headerlink" title="学完这门课，你能学到那些？"></a>学完这门课，你能学到那些？</h2><p>戴愫老师曾经用这门课，在线下教授了上万名职场人士，他们反馈：</p><ul><li>不仅会写了，而且写得更快了；</li><li>这堂写作课还帮助他们重塑了个人品牌；</li><li>他们通过写作打开了工作思维，写作为他们赢得了信任和尊重，从而，他们在公司里承担了更多的责任，职场道路开阔了。</li></ul><p>在写作时，有效表达只是最基本的层次，有效沟通才是终极目标。<br>每一次写作，并不是自己做了一次信息传递，每一次写作，你都在为读者创造一次阅读体验。<br>一篇好文章，不会让读者读完后困惑地问“so what”<strong>(所以呢?)</strong>，而是发出“wow”<strong>(diao a!)</strong>的赞叹。</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;本文源自得到课程《有效提升你的职场写作能力》。作者戴愫老师，一名跨文化研究者，也是一名企业培训师。本系列共6讲和1个小结，干货满满，由思路清晰，思维缜密的戴愫老师娓娓道来。&lt;br&gt;&lt;b&gt;前两讲是基础课&lt;/b&gt;。养成正确的写作习惯——先想再写，然后删。写之前要“想”，想什么呢？用TCS三步构思法——基调、内容、结构。在基础课里，你会学到，在看似人人都会写的邮件里，蕴藏着怎样的高级套路。&lt;b&gt;第三讲和第四讲&lt;/b&gt;，教你怎样给文章组织结构。当需要写复杂的文案时，怎样用四大思维能力组织一个高价值的文章，并且怎样写第一段，让文章的价值最大化。&lt;b&gt;最后两讲&lt;/b&gt;，带你润色语言，为文章锦上添花——如何写出有权威性，又有亲和力的措辞，也就是让语言有质感、有温度。&lt;b&gt;&lt;em&gt;版权归得到App所有，本文及相关内容仅供我个人总结和学习。&lt;/em&gt;&lt;/b&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="得到" scheme="https://www.blogs.rhsphere.com/categories/%E5%BE%97%E5%88%B0/"/>
    
    
      <category term="得到，职场写作，软技能" scheme="https://www.blogs.rhsphere.com/tags/%E5%BE%97%E5%88%B0%EF%BC%8C%E8%81%8C%E5%9C%BA%E5%86%99%E4%BD%9C%EF%BC%8C%E8%BD%AF%E6%8A%80%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>认识SSM框架和Redis</title>
    <link href="https://www.blogs.rhsphere.com/2018/10/26/SSM-framework-Redis.html"/>
    <id>https://www.blogs.rhsphere.com/2018/10/26/SSM-framework-Redis.html</id>
    <published>2018-10-26T06:09:31.000Z</published>
    <updated>2019-02-25T10:02:52.445Z</updated>
    
    <content type="html"><![CDATA[<p class="description">文章对以下要点进行总结和归纳：1)了解Spring IoC和Spring AOP的基础概念；2)了解MyBatis的特点；3)了解Spring MVC的特点；4)了解为什么要使用NoSQL(Redis)及Redis的优点；5)掌握SSM和Redis的基本结构框图和各种技术的作用。</p><a id="more"></a><h2 id="Spring框架"><a href="#Spring框架" class="headerlink" title="Spring框架"></a>Spring框架</h2><p>Spring框架是Java应用最广的框架，它优秀的理念包括 <strong>IoC</strong> (Inversion of Control， 控制反转)和 <strong>AOP</strong> (Aspect Oriented Programming， 面向切面编程)。</p><h3 id="Spring-IoC简介"><a href="#Spring-IoC简介" class="headerlink" title="Spring IoC简介"></a>Spring IoC简介</h3><p>Spring IoC（Inversion of Control，控制反转）承担了一个资源管理、整合、即插即拔的功能。举个例子，在Java中我们为国家插座设计两种接口，那我们就可以为两种插座分别new两个对象，但是如果要更改上千次这种插座，难道要new很多对象吗？所以不用new的方式创建对象，而是使用配置的方式，然后使用配置的方式，然后让Spring IoC容器自己通过配置去找到插座。<br>不需要去找资源(Bean)，只要向Spring IoC容器描述所需资源，Spring IoC自己会找到你所需要的资源，这就是Spring IoC的理念。这样就把Bean之间的依赖关系解耦了，更容易写出结构清晰的程序。除此之外，Spring IoC还提供对Java Bean生命周期的管理，可以延迟加载，可以在其生命周期内定义一些行为等，更加有效地使用和管理Java资源。<br>如果使用new的方式来使用插座，代码如下。<br><figure class="highlight java"><figcaption><span>使用插座1</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">User user = <span class="keyword">new</span> User();</span><br><span class="line">Socket socket = <span class="keyword">new</span> Socket1();</span><br><span class="line">user.setSocket(socket);</span><br><span class="line">user.useSocket();</span><br></pre></td></tr></table></figure></p><p>这样会有一个弊端，如果使用其他插座，就需要修改代码。可以使用配置的方式代替new的方式创建对象，让Spring IoC容器通过配置去找到插座。<br><figure class="highlight xml"><figcaption><span>使用Spring IoC注入插座1个用户</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"socket"</span> <span class="attr">class</span>=<span class="string">"Socket1"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"xxx.User"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spanroperty</span> <span class="attr">name</span>=<span class="string">"socket"</span> <span class="attr">ref</span>=<span class="string">"socket"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>只需要修改XML配置文件，就可以切换：<br><figure class="highlight diff"><figcaption><span>切换插座的实现类</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">- &lt;bean id="socket" class="Socket1" /&gt;</span></span><br><span class="line"><span class="addition">+ &lt;bean id="socket" class="Socket2" /&gt;</span></span><br><span class="line">&lt;bean id="user" class="xxx.User"&gt;</span><br><span class="line">    &lt;spanroperty name="socket" ref="socket" /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p><p>显然，IoC的目标就是为了管理Bean而存在的。</p><h3 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h3><p>IoC的目标就是为了管理Bean，而Bean是Java面向对象(OOP)的基础设计，比如声明一个用户类、插座类等都是基于面向对象的概念。<br>有些情况是面向对象没办法处理的。<br>举个例子，生产部门的订单、生产部门、财务部门三者符合OOP的设计理念。订单发出，生产部门审批通过准备付款，但是财务部门发现订单的价格超支了，需要取消订单。 显然超支限定已经不只是影响财务部门了，还会影响生产部门之前所做的审批，需要把它们作废。把预算超支这个条件称为切面，它影响了订单、生产部门和财务部门3个OOP对象。在现实中，这样的切面条件跨越了3个甚至更多的对象，并且影响了它们的协作。所以只用OOP并不完善，还需要面向切面的编程，通过它去管理在切面上的某些对象之间的协作。<br>Spring AOP常用于数据库事务的编程，很多情况都如同上而的例子，我们在做完第一步数据库数据更新后，不知道下一步是否会成功，如果下一步失收，会使用数据库事务的回滚功能去回滚事务，使得第一步的数据库更新也作废。<br>在Spring AOP实现的数据库事务管理中，是以异常作为消息的。在默认的情况下(可以通过Spring的配置修改)，只要Spring接收到了异常信息，它就会将数据库的事务回滚，从而保证数据的一致性。这样我们就知道在Spring的事务管理中只要让它接收到异常信息，它就会回滚事务，而不需要通过代码来实现这个过程。<br>比如上面的例子，可用一段伪代码来进行一些必要的说明。<br><figure class="highlight java"><figcaption><span>Spring AOP处理订单伪代码</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">proceed</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断生产部门是否通过订单，数据库记录订单</span></span><br><span class="line">    <span class="keyword">boolean</span> pflag = productionDept.isPass(order);</span><br><span class="line">    <span class="keyword">if</span>(pflag) &#123;<span class="comment">//如果生产部门通过进行财务部门审批</span></span><br><span class="line">        <span class="keyword">if</span> (financialDept.isOverBudget(order)) &#123;<span class="comment">//财务审批是否超限</span></span><br><span class="line">            <span class="comment">//抛出异常回滚事务，之前的订单操作也会被回滚</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"预算超限！！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Spring AOP的编程屏蔽了数据库代码，只需关注业务代码，知道只要发生了一场异常，Spring会回滚事务就足够了。</p><h2 id="MyBatis简介"><a href="#MyBatis简介" class="headerlink" title="MyBatis简介"></a>MyBatis简介</h2><p>MyBatis的前身是Apache的开源项目iBatis，是一个基于 Java的持久层框架。2010年这个项目由Apache software foundation迁移到Google code，并更名为MyBatis。2013年11月，MyBatis迁移到GitHub上，目前由GitHub提供维护。<br>MyBatis的优势在于灵活，它几乎可以代替JDBC，同时提供了接口编程。目前MyBatis的数据访问层 DAO(Data Access Objects)是不需要实现类的，它只需要一个接口和XML(或者注解)。MyBatis提供自动映射、动态SQL、级联、缓存、注解、代码和SQL分离等特性，使用方便，同时也可以对SQL进行优化。因为其具有封装少、映射多样化、支持存储过程、可以进行SQL优化等特点，使得它取代了Hibernate成为了Java互联网中首选的持久框架。<br>Hibernate作为一种十分流行的框架，它有其无可替代的优势，这里我们有必要讨论一下它和MyBatis的区别。由于MyBatis和Hibernate都是持久层框架，都会涉及数据库，所以首先定义一个数据库表一角色表(t_role)。<br><figure class="highlight sql"><figcaption><span>角色表的sql语句</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t_role(</span><br><span class="line">    编号 <span class="built_in">int</span>(<span class="number">12</span>) primary <span class="keyword">key</span>，</span><br><span class="line">    角色名称 <span class="built_in">varchar</span>(<span class="number">60</span>)，</span><br><span class="line">    备注 <span class="built_in">varchar</span>(<span class="number">1024</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>用一个POJO(Plain Ordinary Java Object)和这张表定义的字段对应起来。<br><figure class="highlight java"><figcaption><span>定义角色POJO</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.learn.chapter1.pojo;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Role</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String roleName;</span><br><span class="line">    <span class="keyword">private</span> String note;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * setter and getter</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>无论是MyBatis还是Hibernate都是依靠某种方法，将数据库的表和POJO映射起来的，这样就可以操作POJO来完成相关的逻辑了。</p><h3 id="Hibernate简介"><a href="#Hibernate简介" class="headerlink" title="Hibernate简介"></a>Hibernate简介</h3><p>映射规则</p><table><thead><tr><th style="text-align:left">语言</th><th style="text-align:left">映射方法</th></tr></thead><tbody><tr><td style="text-align:left">MyBatis</td><td style="text-align:left">使用注解方式会受到一定的限制，通常使用XML方式实现映射关系</td></tr><tr><td style="text-align:left">Hibernate</td><td style="text-align:left">XML和注解提供映射规则</td></tr></tbody></table><p>把POJO对象和数据库表相互映射的框架称为对象关系映射(Object Relational Mapping，ORM，或O/RM，或O/R mapping)框架。Hibernate的设计理念是完全面向POJO的，不需要编写SQL就可以通过映射关系来操作数据库，是一种全表映射的体现；MyBatis需要提供SQL去运行。<br><figure class="highlight xml"><figcaption><span>Hibernate映射文件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN"</span></span><br><span class="line"><span class="meta">  "http://www.hibernate.rg/dtd/hibernate-mapping-3.0.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"com.learn.chapter1.pojo.Role"</span> <span class="attr">tbale</span>=<span class="string">"t_role"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">type</span>=<span class="string">"java.lang.Integer"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"id"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"identity"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">spanroperty</span> <span class="attr">name</span>=<span class="string">"roleName"</span> <span class="attr">type</span>=<span class="string">"string"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"role_name"</span> <span class="attr">length</span>=<span class="string">"60"</span> <span class="attr">not-null</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">spanroperty</span> <span class="attr">name</span>=<span class="string">"note"</span> <span class="attr">type</span>=<span class="string">"string"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"note"</span> <span class="attr">length</span>=<span class="string">"512"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>首先，对POJO和表t_role进行了映射配置，把两者映射起来了。然后，对POJO进行操作，从而影响t_role表的数据，比如对其增删改查可以按照如下操作。<br><figure class="highlight java"><figcaption><span>Hibernate通过Session操作数据库数据</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Session session = <span class="keyword">null</span>;</span><br><span class="line">Transaction tx = <span class="keyword">null</span>;        </span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//打开Session</span></span><br><span class="line">    session = HibernateUtil.getSessionFactory().openSession();</span><br><span class="line">    <span class="comment">//事务</span></span><br><span class="line">    tx = session.beginTransaction();</span><br><span class="line">    <span class="comment">//POJO</span></span><br><span class="line">    Role role = <span class="keyword">new</span> Role();</span><br><span class="line">    role.setId(<span class="number">1</span>);</span><br><span class="line">    role.setRoleName(<span class="string">"rolename1"</span>);</span><br><span class="line">    role.setNote(<span class="string">"note1"</span>);  <span class="comment">//保存</span></span><br><span class="line">    Role role2 = (Role) session.get(Role.class， <span class="number">1</span>); <span class="comment">//查询</span></span><br><span class="line">    role2.setNote(<span class="string">"修改备注"</span>);</span><br><span class="line">    session.update(role2); <span class="comment">//更新</span></span><br><span class="line">    System.err.println(role2.getRoleName());</span><br><span class="line">    session.delete(role2); <span class="comment">//删除</span></span><br><span class="line">    tx.commit(); <span class="comment">//提交事务</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">    <span class="keyword">if</span> (tx != <span class="keyword">null</span> &amp;&amp; tx.isActive()) &#123;</span><br><span class="line">        tx.rollback(); <span class="comment">//回滚事务</span></span><br><span class="line">    &#125;</span><br><span class="line">    ex.printStackTrace();</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (session != <span class="keyword">null</span> &amp;&amp; session.isOpen()) &#123;</span><br><span class="line">        session.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里没有SQL，因为Hibernate会根据映射关系来生成对应的SQL。</p><h3 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h3><p>可以自己拟定SQL规则，能精确定义SQL，从而符合移动互联网高并发、大数据、高性能、高响应的需求。MyBatis也需要映射文件把POJO和数据库的表对应起来。<br><figure class="highlight xml"><figcaption><span>MyBatis映射文件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE mapper   PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"</span></span><br><span class="line"><span class="meta">  "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.learn.chapter1.mapper.RoleMapper"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"roleMap"</span> <span class="attr">type</span>=<span class="string">"com.learn.chaper1.pojo.Role"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"id"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"roleName"</span> <span class="attr">column</span>=<span class="string">"role_name"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"note"</span> <span class="attr">column</span>=<span class="string">"note"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getRole"</span> <span class="attr">resultMap</span>=<span class="string">"roleMap"</span>&gt;</span></span><br><span class="line">        select id， role_name， note from t_rle where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">"deleteRole"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span>&gt;</span></span><br><span class="line">        delete from t_role where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insertRole"</span> <span class="attr">parameterType</span>=<span class="string">"com.learn.chapter1.pojo.Role"</span>&gt;</span></span><br><span class="line">        insert into t_role(role_name， note) values(#&#123;roleName&#125;， #&#123;note&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"updateRole"</span> <span class="attr">parameterType</span>=<span class="string">"com.learn.chapter1.pojo.Role"</span>&gt;</span></span><br><span class="line">        update t_role set</span><br><span class="line">        role_name = #&#123;roleName&#125;，</span><br><span class="line">        note = #&#123;note&#125;</span><br><span class="line">        where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>这里的resultMap元素用于定义映射规则，而实际上MyBatis在满足一定的规则下，完成自动映射，而增删改查对应着insert、delete、select、update四个元素。mapper元素中的namespace属性，要和一个接口的全限定名保持一致，而里面的SQL的id也需要和接口定义的方法完全保持一致，定义MyBatis映射文件。<br><figure class="highlight java"><figcaption><span>定义MyBatis映射文件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.learn.chapter1.mapper;</span><br><span class="line"><span class="keyword">import</span> com.learn.chapter1.pojo.Role;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RoleMapper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Role <span class="title">getRole</span><span class="params">(Integer id)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteRole</span><span class="params">(Integer id)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">insertROle</span><span class="params">(Role role)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">updateROle</span><span class="params">(Role role)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>定义了MyBatis映射文件，不需要定义一个实现类。<br><span style="color:#5073b8;">显然MyBatis在业务逻辑上和Hibernate是大同小异的。其区别在于，MyBatis需要提供接口和SQL，这意味着工作量会比较大，但是由于自定义SQL、映射关系，所以灵活性、可优化性超过了Hibernate。互联网可优化性、灵活性是十分重要的，因为一条SQL的性能可能相差十几倍到几十倍。</span></p><h3 id="Hibernate和MyBatis的区别"><a href="#Hibernate和MyBatis的区别" class="headerlink" title="Hibernate和MyBatis的区别"></a>Hibernate和MyBatis的区别</h3><p>Hibernate和MyBatis的增、删、改、查，对于业务逻辑层来说大同小异，对于映射层而言Hibernate的配置不需要接口和SQL，相反MyBatis是需要的。对于Hibernate而言，不需要编写大量的SQL，就可以完全映射，同时提供了日志、缓存、级联(级联比MyBatis强大)等特性，此外还提供HQL( Hibernate Query Language)对POJO进行操作，使用十分方便，但是它也有致命的缺陷。<br>由于无须SQL，当多表关联超过3个的时候，通过Hibernate的级联会造成太多性能的丢失，又或者我现在访问一个财务的表，然后它会关联财产信息表，财产又分为机械、原料等，显然机械和原料的字段是不一样的，这样关联字段只能根据特定的条件变化而变化而Hibernate无法支持这样的变化。遇到存储过程，Hibernate只能作罢。更为关键的是性能，在管理系统的时代，对于性能的要求不是那么苛刻，但是在互联网时代性能就是系统的根本，响应过慢就会丧失客户，试想一下谁会去用一个经常需要等待超过10秒以上的应用呢?<br>以上的问题MyBatis都可以解决，MyBatis可以自由书写SQL、支持动态SQL、处理列表、动态生成表名、支持存储过程。这样就可以灵活地定义查询语句，满足各类需求和性能优化的需要，这些在互联网系统中是十分重要的。<br>但MyBatis也有缺陷。首先，它要编写SQL和映射规则，其工作量稍微大于Hibernate。 其次，它支持的工具也很有限，不能像Hibernate那样有许多的插件可以帮助生成映射代码和关联关系，而即使使用生成工具，往往也需要开发者进一步简化，MyBatis通过手工编码，工作量相对大些。所以对于性能要求不太苛刻的系统，比如管理系统、ERP等推荐使用Hibernate;而对于性能要求高、响应快、灵活的系统则推荐使用MyBatis。</p><h2 id="Spring-MVC简介"><a href="#Spring-MVC简介" class="headerlink" title="Spring MVC简介"></a>Spring MVC简介</h2><p>也许你还在问为什么使用Spring MVC，Struts 2.x不才是主流吗？看SSH的概念多火!其实很多初学者都混淆了一个概念，SSH时间上指的是Struts 1.x + Spring + Hibernate，这个概念已经有十几年的历史了。在Structs 1.x的时代，Structs1.x是当之无愧的MVC框架的霸主，但是在新的MVC框架涌现的时代，形式已经完全不是这样的了，Structs 2.x借助了Structs 1.x的好名声，让国内开发者认为Structs 2.x是霸主继任者（其实两者在技术上没有任何关系），导致国内的很多程序员大多数学习基于Structs 2.x的框架，有一个貌似很火的概念出来了S2SH(Struts 2.x + Spring + Hibernate)整合开发。<br>根据JRebel厂商统计，Spring MVC的市场占有率是40%，而Structs 2.x只有可怜的6%。<span style="color:#5073b8;">Spring MVC是目前Java Web框架当之无愧的霸主。</span><br>Spring MVC和三层架构是什么关系，可能很多读者会抢答：<br>MVC：Model + View + Controller (数据模型+视图+控制器)<br>三层架构：Prensentation tier + Application tier + Data tier（展现层+应用层+数据访问层）<br>那MVC和三层架构有什么关系呢？但是实际上MVC只存在三层架构的展现层，M实际上是数据模型，是包含数据的对象。在Spring MVC里，有一个专门的类叫Model，用来和V之间的数据交互、传值；V指的是视图页面，包含JSP、freeMarker、Velocity、Thymeleaf、Tile等；C当然就是控制器（Spring MVC的注解@Controller的类）。<br>而三层架构是整个应用的架构，是由Spring框架负责管理的。一般项目中会有Service层、DAO层，这两个反馈在应用层和数据访问层。</p><h3 id="Java-EE应用的分层模型"><a href="#Java-EE应用的分层模型" class="headerlink" title="Java EE应用的分层模型"></a>Java EE应用的分层模型</h3><p>经典的Java EE架构大致上都可以分为如下几层：</p><ul><li><strong>Domain Object(领域对象)层</strong>。此层有一系列的POJO(Plain Object Java Object，普通的传统的Java对象)组成，这些对象是该系统的Domain Object(领域对象)，往往包含了各自所需实现的业务逻辑方法。</li><li><strong>DAO(Data Access Object，数据访问对象)层</strong>。此层由一系列的DAO组件组成，这些DAO实现了对数据库的创建、查询、更新和删除（CRUD）等原子操作。</li><li><strong>Service(业务逻辑)层</strong>。此层由一系列的业务逻辑对象组成，这些业务逻辑对象实现了系统所需的业务逻辑方法。这些业务逻辑方法可能仅仅用于暴露Domain Object对象所实现的业务逻辑方法，也可能是依赖DAO组件实现的业务逻辑方法。</li><li><strong>Controller(控制器)层</strong>。此层由一系列控制器组成，这些控制器用于拦截用户请求，并调用业务逻辑组件的业务逻辑方法，处理用户请求，并根据处理结果向不同的表现层组件转发。</li><li><strong>View(表现)层</strong>。此层由一系列的JSP页面、Velocity页面、PDF文档视图组件组成，负责手机用户请求，并显示处理结果。<h3 id="Java-EE应用的组件"><a href="#Java-EE应用的组件" class="headerlink" title="Java EE应用的组件"></a>Java EE应用的组件</h3>总体而言，Java EE应用应该大致包括如下几类组件：</li><li><strong>表现层组件</strong>。主要负责收集用户输入数据，或者想客户显示系统状态。最常用的表现层技术是JSP，但JSP并不是唯一的表现层技术。表现层还可以由Velocity、FreeMarker和Tapestry等技术完成，或者使用普通的应用程序充当表现层组件，甚至可以是小型智能设备。</li><li><strong>控制器组件</strong>。关于Java EE的MVC框架，其提供了一个前端核心控制器，核心控制器负责拦截用户请求，并将请求转发给用户实现的控制器组件。这些用户实现的控制器组件则负责调用业务逻辑方法，处理用户请求。</li><li><strong>业务逻辑组件</strong>。这是系统的核心组件，实现系统的业务逻辑。通常，一个业务逻辑方法对应一次用户操作。一个业务逻辑方法应该是一个整体，因此要求对业务逻辑方法增加事务性。业务逻辑方法仅仅实现也呜呜逻辑，不应该进行数据库访问。因此，业务逻辑组件中不应该出现原始的MyBatis、Hibernate和JDBC等API。<span style="color:#5073b8;">最重要的原因是：保证业务逻辑方法的实现与具体的持久层访问技术分离。当系统需要在不同持久层技术之间切换时，系统的业务逻辑组件无序任何改变。</span></li><li><strong>DAO组件</strong>。这个类型的对象比较缺乏变化，每个DAO组件都提供Domain Object对象基本的创建、查询、更新和删除等操作，这些操作对应于数据库的CRUD（创建、查询、更新和删除）等原子操作。当然，如果采用不同的持久层访问技术，DAO组件的会完全不同。为了实现业务逻辑组件的实现与DAO组件的实现分离，程序应该为每个DAO组件都提供接口，业务逻辑组件面向DAO接口编程，这样才能提供更好的解耦。</li><li><strong>领域对象组件</strong>。领域对象（Doamin Object）抽象了系统的对象模型。通常而言，这些领域对象的状态都必须保存在数据库里。因此，每个领域对象通常对应一个或多个数据表，领域对象通常需要提供对数据记录的访问方式。</li></ul><h2 id="最流行的NoSQL-–-Redis"><a href="#最流行的NoSQL-–-Redis" class="headerlink" title="最流行的NoSQL – Redis"></a>最流行的NoSQL – Redis</h2><p>NoSQL(Not Only SQL)存储的数据是半结构化的，Redis成为主要的NoSQL工具。</p><ol><li>响应速度快。</li><li>支持6种数据类型：字符串、哈希结构、列表、集合、可排序集合和基数。比如字符串可以存储Java基础数据类型，哈希可以存储对象，列表可以存储List对象等。</li><li>操作都是原子的。</li><li>MultiUtility工具：Redis可以再如缓存、、消息传递队列中使用（Reids支持“发布+订阅”的消息模式），在应用程序如Web应用程序绘画、网站页面点击数等任何短暂的数据中使用。</li></ol><h2 id="SSM-Redis结构框图及概述"><a href="#SSM-Redis结构框图及概述" class="headerlink" title="SSM+Redis结构框图及概述"></a>SSM+Redis结构框图及概述</h2><p>在Java Web中，以Spring + Spring MVC + MyBatis（SSM）作为主流框架，SSM+Redis的结构框图如下：<br><img src="/images/JavaEE/SSM-Redis-architecture.png" alt="SSM+Redis结构示意图"></p><ul><li>Spring IoC承担了一个资源管理、整合、即插即拔的功能。</li><li>Spring AOP可以提供切面管理，特别是书U哭事务管理的功能。</li><li>Spring MVC用于把模型、视图和控制器分层，组合成了一个有机灵活的系统。</li><li>MyBatis提供了一个数据库访问的持久层，通过MyBatis-Spring项目，它便能和Spring无缝对接。</li><li>Redis作为缓存工具，它提供了高速度处理数据和缓存数据的功能，使得系统大部分只需要访问缓存，而无须从数据库磁盘中重复读/写；在一些需要高速运算的场合中，也可以先用它来完成运算，再把数据批量存入数据库，这样便能极大地提升互联网系统的性能和响应能力。</li></ul><p>在后面会讲解这些技术的使用方法、原理和优化方法。</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;文章对以下要点进行总结和归纳：1)了解Spring IoC和Spring AOP的基础概念；2)了解MyBatis的特点；3)了解Spring MVC的特点；4)了解为什么要使用NoSQL(Redis)及Redis的优点；5)掌握SSM和Redis的基本结构框图和各种技术的作用。&lt;/p&gt;
    
    </summary>
    
      <category term="Java EE" scheme="https://www.blogs.rhsphere.com/categories/Java-EE/"/>
    
    
      <category term="Spring， Spring MVC， MyBatis， Redis" scheme="https://www.blogs.rhsphere.com/tags/Spring%EF%BC%8C-Spring-MVC%EF%BC%8C-MyBatis%EF%BC%8C-Redis/"/>
    
  </entry>
  
</feed>
