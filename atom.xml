<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Depeng&#39;s Blog</title>
  
  <subtitle>北京邮电大学研究生在读</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.blogs.rhsphere.com/"/>
  <updated>2019-02-27T14:34:43.935Z</updated>
  <id>https://www.blogs.rhsphere.com/</id>
  
  <author>
    <name>Depeng Lu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>第一讲|先想后写——TCS三步构思法</title>
    <link href="https://www.blogs.rhsphere.com/2019/02/26/tone-content-structure.html"/>
    <id>https://www.blogs.rhsphere.com/2019/02/26/tone-content-structure.html</id>
    <published>2019-02-26T15:15:25.000Z</published>
    <updated>2019-02-27T14:34:43.935Z</updated>
    
    <content type="html"><![CDATA[<p class="description">职场写作最忌讳打开电脑就写，请你先想再写。TCS法三个步骤完成构思过程，即tone、content和structure，对应基调、内容和结构。</p><a id="more"></a><h2 id="基调为王，七种文案的标志性语气"><a href="#基调为王，七种文案的标志性语气" class="headerlink" title="基调为王，七种文案的标志性语气"></a>基调为王，七种文案的标志性语气</h2><p>第一步，基调，文章以基调为“王”。基调对了，事半功倍；基调错了，哪怕你传递的信息再重要，我也不会关注。<br>正确的基调能传递出文章真正的价值，也就是你的价值。职场写作可以分成四大类，那么每一类都需要传递你的什么价值呢？</p><ul><li>第一，总结类，写的是<span style="color:#bf91e8;">成绩</span>，呈现的是<span style="color:#FF0033;">你的潜力</span>；</li><li>第二，调查报告类，写的是<span style="color:#bf91e8;">调查结果</span>，呈现的是<span style="color:#FF0033;">你求实的态度</span>；</li><li>第三，申请类，内容是<span style="color:#bf91e8;">提问</span>，呈现的是<span style="color:#FF0033;">你主动的思考方式</span>；</li><li>第四，计划类，写的是<span style="color:#bf91e8;">阶段任务</span>，呈现的是<span style="color:#FF0033;">你的责任感</span>。</li></ul><p>如果明白了要呈现自己什么价值，那你拿捏起文章的基调来，正确的概率就会很高。</p><p><em>以常见的六种具体文案为例，探讨一下它们的标志性的基调。</em></p><h3 id="年终总结，基调要求：有深度"><a href="#年终总结，基调要求：有深度" class="headerlink" title="年终总结，基调要求：有深度"></a>年终总结，基调要求：有深度</h3><p>不要写成一份业绩的流水账——因为你的工作结果，领导在看你的总结之前就知道。可他为什么还要看？<br>他要读到你的分析能力；他希望你能从对工作感性的认知，上升到理性的规律性的总结；他需要你协助他，对未来做出更正确的决定。<br><span style="color:#5073b8;">由此来看，年终总结不是回顾，而是行动指南。</span>好的年终总结应该：</p><ul><li>会将工作成果写出意义，会提供难得的一线经验、不同的视角；</li><li>会在罗列了贡献之后，找出问题或机遇，以及怎样解决这个问题，或抓住这个机遇。<br>这就是“有深度”。</li></ul><h3 id="进展汇报，基调要求：不讨教"><a href="#进展汇报，基调要求：不讨教" class="headerlink" title="进展汇报，基调要求：不讨教"></a>进展汇报，基调要求：不讨教</h3><p>在进展汇报里，不能只提问题，向领导讨教，而应该给出方案，向领导汇报。讨教的公式是：您告诉我该怎么做。<span style="color:#5073b8;">汇报的公式是：我这样做，您同意吗？<br>这里我想提醒你，哪怕领导没有要求你写进展汇报，你也要养成定期向他汇报的习惯。</span><br>你需要将解决问题过程中的一些重要发现、关键结论、阶段性成果等小胜利，实时呈现给他，让他读出你的认真，让他看到你不断提高工作能力的过程。</p><h3 id="调查报告，基调要求：实事求是"><a href="#调查报告，基调要求：实事求是" class="headerlink" title="调查报告，基调要求：实事求是"></a>调查报告，基调要求：实事求是</h3><p>在收集充分的事实资料后，你的措辞是“资料显示、数字表明”，而不是“我认为、我估计”。这种报告才能展现事情的真相，才会有让人惊喜的收获。</p><h3 id="请示，基调要求：有主见"><a href="#请示，基调要求：有主见" class="headerlink" title="请示，基调要求：有主见"></a>请示，基调要求：有主见</h3><p>有的人这么写：</p><p><blockquote>“客户投诉如下，请指示。”</blockquote><br>不管是找领导要人、要钱，或其他任何资源，一定要有清晰的主见。<br>比如申请款项，你要给一个量化的标准让领导来裁决，不能模糊不清，让他无据可依、无处下手。<span style="color:#5073b8;">让他做选择题的时候，你也需要提供最佳选项。</span><br>另外，部门主管向上级递交请示的时候，不能采用传声筒的语气。<br>不要写“他们抱怨”或“他们声称”，要写“我注意到” “我相信我的团队会……”，这才是有担当、有主见的语气。</p><h3 id="批复，基调要求：态度明确"><a href="#批复，基调要求：态度明确" class="headerlink" title="批复，基调要求：态度明确"></a>批复，基调要求：态度明确</h3><p>不能出现这样的措辞：“似属可行” “酌情办理”。</p><h3 id="项目计划，基调要求：“可交付”"><a href="#项目计划，基调要求：“可交付”" class="headerlink" title="项目计划，基调要求：“可交付”"></a>项目计划，基调要求：“可交付”</h3><p>不能仅仅写行为。一个项目的成功，不是行动了就可以，而是众多可交付结果的总和。</p><ul><li>比如：“选择外部供应商”，这是写行为，改为可交付的结果：<strong>“确定外部供应商”</strong>。</li><li>又比如：“草拟消费者调查报告”，这又是写行为，改为可交付结果：<strong>“递交消费者调查报告”</strong>。</li></ul><p>这里我再和你多说一点。最好的项目计划书，是按照 <strong>OKR目标管理工具</strong>来写的。O：Objective 目标，KR：Key Results 关键结果。<br>简单地说，计划就是由目标和关键结果构成。其中，大目标可以分解成小目标，关键结果是用来衡量这些目标有没有完成的。按照这个工具来写，你的基调自然就是可交付的结果。<br><span style="background-color: #f0ad4e;">  以上就是构思的第一步——基调。</span></p><h2 id="从“作者逻辑”切换到“读者逻辑”"><a href="#从“作者逻辑”切换到“读者逻辑”" class="headerlink" title="从“作者逻辑”切换到“读者逻辑”"></a>从“作者逻辑”切换到“读者逻辑”</h2><p>TCS的第二步，C：content，内容。<br>你意识到了吗？我们在学校里的写作，读者是教授，他读你的文章的时候是有薪水拿的。在职场上的写作，可不是这样。<br><strong>职场上的读者，大多是“甲方读者”，比如领导、客户、重要合作伙伴，等等。也就是说，他们没有义务读完你的文章，他们可以随时终止阅读。</strong><br>怎么才能让这些甲方读者被你的内容吸引呢？请遵照这个原则：</p><p><blockquote>先从“作者逻辑”切换到“读者逻辑”，提供“所有必需信息”，然后按照“要话先说”的顺序排列。<br></blockquote><br>也就是说， 你的文章每个部分都要对读者有价值。<br>你写第一句话，是为了让他继续看第二句话；你写第二句话，是为了让他继续看第三句话。</p><p>举个例子，如果要写一份给投资人的商业计划书，俗称项目BP(Business Plan)。我们先做发散思维，想一想在初次接触时，投资人需要哪些信息来判断是否对项目有信心，是否愿意投资参与该项目？然后，为这些信息排序。<br>我最担心你一上来就急着展示自己公司有多厉害，这是作者逻辑。没搭好台就展示自己，操之过急。相反，文章应该从分析整个行业下手，彰显市场空缺。搭建好舞台后，才有机会介绍自己。<br>风险投资人也是要最大限度地规避风险的。而先选择行业，再选择个体，是他规避风险的方式，是读者逻辑。<br>按照这个逻辑，文章怎样写呢？</p><p><span style="background:#eee;"><em>第一部分</em></span>，写 <strong>“项目愿景”</strong>。 也就是，你要做一件什么样的大事。<br>这部分需要有一句高度精炼的话，比如黄太吉的“打造以煎饼果子为核心的中式时尚快餐连锁品牌”。<br>对方会问，这件事为什么值得做？于是你给出 <strong>“市场痛点”</strong>。<br>比如，摩拜单车是为了解决最后一公里的交通痛点。如果投资人根本不认为这是个痛点，后面一切都白写了。<br><span style="background:#eee;"><em>再往下</em></span>，是 <strong>“解决方案”</strong>。<br>论证的是，我们正在做的这个事业，真正能解决得了这个痛点，这把钥匙能开得了这把锁。OK,读者表示认同。<br><span style="background:#eee;"><em>然后</em></span>，他会想，<strong>“市场潜力”</strong>大吗？<br><span style="background:#eee;"><em>这时</em></span>，你该展示市场调查结果了，包括市场规模、用户画像、竞品分析等等。<br>那他会接着问，为什么要投你们，而不是别人呢？<br>你要阐述自己的 <strong>“独特优势”</strong>。包括行业经验、核心技术、牛人团队，等等。<br>OK, 这时读者对你有点儿感觉了。</p><p><span style="background:#eee;"><em>下一部分</em></span>，趁他对你有感觉的时候，拉着他一块儿画饼，你要写 <strong>“发展规划”</strong>了。<br>写清楚盈利模式和发展路径。也许你觉得奇怪，为什么这个内容现在才写？其实投资人很有经验，他只要决定和你一块儿干，他会在后期帮你一起完善盈利模式，清晰发展路径。</p><p><span style="background:#eee;"><em>最后</em></span>，做 <strong>“财务分析”</strong>，告诉他，你们缺多少钱。<br>为什么把融资额度放最后写呢？<br>你想想看，有经验的销售想把东西卖给你的时候，通常不会一上来就报价的。他们都是把商品的价值点全部讲完以后，才把价格说出来，这个时候出现的数字，会让对方觉得是个合理的数字。<br>至于 <strong>“退出机制” “利润分红”</strong>这些内容，在初次接触中并不重要，它们都有谈判的空间，所以可以不写。<br><span style="background-color: #f0ad4e;">在<strong>“要话先说”</strong>的顺序下，文章环环相扣，你前一部分阐述得精彩，读者才有兴趣问下一个问题，了解下一个部分。</span></p><h2 id="“向下想三层”，假设变结论"><a href="#“向下想三层”，假设变结论" class="headerlink" title="“向下想三层”，假设变结论"></a>“向下想三层”，假设变结论</h2><p>进入构思的第三步，TCS的S，structure结构。在你的文章里，可以用向下想三层的逻辑搭建金字塔结构。<span style="color:#5073b8;">金字塔的塔尖，是你鲜明的观点或建议，而下面两层，是证据。</span><br>在这个金字塔里，塔尖，<span style="color:#5073b8;">你鲜明的观点或建议</span>，是 <strong>“投钱给我们吧”</strong>。<br>读者自然会问：为什么？<br>金字塔第二层，两方面：因为有市场，因为我们强。<br>读者又问：有市场？——哪块市场？你们强？——强在哪里？<br>金字塔进入第三层的阐述。<br>这种顺序，让读者先读到塔尖，这样，不仅他能理解你更快，甚至认同你都更快。<br><span style="color:#5073b8;">因为塔尖就像一个熠熠生辉的宝石，抢先占据了他的阅读记忆，也许他会惴惴不安，也许他会兴奋不已，于是，在他接下来的阅读中，他会自己有意无意地将下面的证据与塔尖做链接，这个被说服过程由他自己来完成了。</span><br>这就是先想再写的TCS构思法。如果不这么做，文章可能会一点一点地偏离方向，最后主张模糊、脉络不明。而修改一份粗糙的文案，花费时间和力气更多。</p><h2 id="压缩三分之一的文字"><a href="#压缩三分之一的文字" class="headerlink" title="压缩三分之一的文字"></a>压缩三分之一的文字</h2><p>写完以后，还有一个步骤，<span style="color:#5073b8;">压缩，删掉三分之一的文字。</span>相信我，你可以做得到。 商务写作谨遵KISS原则：<span style="color:#5073b8;">keep it short and simple。</span> 句中不能有多余的词，段落中不能有多余的句子。<br>你可能会问我：文章到底是要简洁还是详实呢？<br><span style="color:#5073b8;">文字表达要简洁，内容提供要详实。</span><br>深度阐述和实例细节，会让文章更长，但不是冗长。 <strong>“用最少的字表达最多的意思”</strong>，这是我们追求的语言审美境界。<br>可以用这三个方法来做到 <strong>“减无可减”</strong>：</p><ul><li>把注水的文字压缩掉：“大概”、“一般来说”、“话说回来”，等等。</li><li>把“在我看来、我认为、我相信”之类的短语删掉，这是你写的文章，没有必要反复提醒读者这是你的观点。</li><li>把意思重复的句子压缩掉：相信读者是聪明人。</li></ul><p>简洁的文字体现自律。</p><h2 id="本讲小结"><a href="#本讲小结" class="headerlink" title="本讲小结"></a>本讲小结</h2><p>第一讲要结束了。在这一讲中，你要养成先想再写，然后再删的写作习惯。<br>写之前，做好TCS三步构思——基调、内容、结构。</p><p><span style="background:#EFF890;">第一步， 基调为王，用正确的基调传递出4类文案的真正价值；<br>第二步， 内容，提供“所有必需信息”，从“作者逻辑”切换到“读者逻辑”，并要话先说；<br>第三步， 结构，用向下想三层的金字塔结构，把你的假设，变成结论，用结论去说服他人。<br>最后， 商务写作的KISS原则要求我们压缩文章，我教了你三个方法。</span></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;职场写作最忌讳打开电脑就写，请你先想再写。TCS法三个步骤完成构思过程，即tone、content和structure，对应基调、内容和结构。&lt;/p&gt;
    
    </summary>
    
      <category term="得到" scheme="https://www.blogs.rhsphere.com/categories/%E5%BE%97%E5%88%B0/"/>
    
    
      <category term="得到，职场写作，软技能" scheme="https://www.blogs.rhsphere.com/tags/%E5%BE%97%E5%88%B0%EF%BC%8C%E8%81%8C%E5%9C%BA%E5%86%99%E4%BD%9C%EF%BC%8C%E8%BD%AF%E6%8A%80%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>得到|怎样提升你的职场写作能力</title>
    <link href="https://www.blogs.rhsphere.com/2019/02/24/improve-writing-skills-in-workplace.html"/>
    <id>https://www.blogs.rhsphere.com/2019/02/24/improve-writing-skills-in-workplace.html</id>
    <published>2019-02-24T09:21:59.000Z</published>
    <updated>2019-02-25T10:15:10.219Z</updated>
    
    <content type="html"><![CDATA[<p class="description">本文源自得到课程《有效提升你的职场写作能力》。作者戴愫老师，一名跨文化研究者，也是一名企业培训师。本系列共6讲和1个小结，干货满满，由思路清晰，思维缜密的戴愫老师娓娓道来。<br><b>前两讲是基础课</b>。养成正确的写作习惯——先想再写，然后删。写之前要“想”，想什么呢？用TCS三步构思法——基调、内容、结构。在基础课里，你会学到，在看似人人都会写的邮件里，蕴藏着怎样的高级套路。<b>第三讲和第四讲</b>，教你怎样给文章组织结构。当需要写复杂的文案时，怎样用四大思维能力组织一个高价值的文章，并且怎样写第一段，让文章的价值最大化。<b>最后两讲</b>，带你润色语言，为文章锦上添花——如何写出有权威性，又有亲和力的措辞，也就是让语言有质感、有温度。<b><em>版权归得到App所有，本文及相关内容仅供我个人总结和学习。</em></b></p><a id="more"></a><h2 id="三类职场人士的困惑是什么？"><a href="#三类职场人士的困惑是什么？" class="headerlink" title="三类职场人士的困惑是什么？"></a>三类职场人士的困惑是什么？</h2><p>戴愫老师和很多学员做过深度交流，有三类职场人士：</p><ul><li><span style="color:#5073b8;">第一类，职场小兵。他们专业技能强，需要简洁有力地从专业视角影响读者；他们经常需要写一些文章分享信息、阐述观点，比如项目进度报告、会议纪要、工作计划、可行性报告等。</span></li><li>第二类，职场老兵。他们需要通过写营运类报告，列出工作过程和结果，并把“成果”变成“功劳”，证明自己是未来的管理人才。</li><li>第三类，职场管理层。需要用高层的故事线来组织文章逻辑。比如说经常需要书写管理类报告，描述清楚商业逻辑，以便公司做出战略决策。</li></ul><p>很多人有以下困惑：</p><ul><li>因为工作太忙，需要快速成文的方法；</li><li>因为没有受过专门的商务写作的训练，分不清商务写作、文学写作、学术写作的清晰界线；</li><li>不知道如何从工作中收集一手资料，并从资料上构筑观点；</li><li>不知道如何以公司战略为风向标，提出自己的诉求，争取资源；</li><li>不知道怎样通过写作，把自己从“做事”的模式，调整为“做贡献”的心态；</li><li>写作时 <strong>容易用空洞的言辞，缺乏实质内容</strong>。</li></ul><h2 id="书面沟通到底是一项什么样的技能？"><a href="#书面沟通到底是一项什么样的技能？" class="headerlink" title="书面沟通到底是一项什么样的技能？"></a>书面沟通到底是一项什么样的技能？</h2><h3 id="书面沟通的形式是什么？单向，还是双向？"><a href="#书面沟通的形式是什么？单向，还是双向？" class="headerlink" title="书面沟通的形式是什么？单向，还是双向？"></a>书面沟通的形式是什么？单向，还是双向？</h3><p>书面沟通是一种单向沟通。你写，发给他，他读；或他写，发给你，你读。这是它最大的缺陷！<br>没有一个正常成年人喜欢“被通知、被命令”，大家都喜欢“被商量、被探讨”。这意味着，<span style="color:#5073b8;">我们作为作者，要通过“单向沟通的形式”，让读者读出“双向沟通的幻觉”。</span><br>制造这种幻觉很重要。为什么？我们来看第二点。</p><h3 id="判断一次沟通是不是100分，标准是什么？"><a href="#判断一次沟通是不是100分，标准是什么？" class="headerlink" title="判断一次沟通是不是100分，标准是什么？"></a>判断一次沟通是不是100分，标准是什么？</h3><p>这个标准是：<br>你明白我的意思了，或者我明白你的意思了？不，这只是60分的沟通。<br>我们把这件事儿办成了？这是80分。为什么只是80分，如果说这件事情是办成了，但我以后再也不想与你合作了，这就是赢了这场战役，失去了整个战争嘛，不行的。<br>那怎么做到100分呢？100分沟通的标准是，我和你理性、感性都达成一致了。注意，感性也要求达成一致。<br>职场上永远不要以为把事情搞定有多么难，真正难搞定的是“人”。哪怕是个纯技术问题，也是“人”的作为和不作为。</p><h3 id="达成一次100分沟通的基本前提是什么？"><a href="#达成一次100分沟通的基本前提是什么？" class="headerlink" title="达成一次100分沟通的基本前提是什么？"></a>达成一次100分沟通的基本前提是什么？</h3><p>是“信任”。 <span style="color:#5073b8;">信任是超越一切沟通形式、一切沟通技巧最基础的前提。</span><br>汉字的“信”，左边一个人，右边一个言，我们正常的顺序是，先相信这个人，再相信他说的话。这个顺序有可能放在每次书面沟通中吗？<br>没可能。很多时候，你和读者没有见过面，哪怕你们见过面，他对你的人格也不一定了解。<br>所以，我们需要学习：怎样在文章中大量使用信息化语言，在文字上与读者建立起信任，让他在不认识你，不熟知你的前提下，直接相信你写的话。</p><h3 id="书面沟通这项技能的本质"><a href="#书面沟通这项技能的本质" class="headerlink" title="书面沟通这项技能的本质"></a>书面沟通这项技能的本质</h3><p>作为写作者的你要用大量的信息化语言，在文字上与读者建立起信任（这是基本前提），并且，让读者通过单向沟通的形式，读出双向沟通的幻觉（这可以通过写作内容和文字表达来实现），最后，双方理性、感性都达成一致（这是100分沟通的衡量标准）。</p><p>重复一遍，书面沟通这项技能本质上就是：<br><span style="color:#5073b8;">作为写作者的你要用大量的信息化语言，在文字上与读者建立起信任，让读者通过单向沟通的形式，读出双向沟通的幻觉，最后双方理性、感性都达成一致。</span></p><h2 id="学完这门课，你能学到那些？"><a href="#学完这门课，你能学到那些？" class="headerlink" title="学完这门课，你能学到那些？"></a>学完这门课，你能学到那些？</h2><p>戴愫老师曾经用这门课，在线下教授了上万名职场人士，他们反馈：</p><ul><li>不仅会写了，而且写得更快了；</li><li>这堂写作课还帮助他们重塑了个人品牌；</li><li>他们通过写作打开了工作思维，写作为他们赢得了信任和尊重，从而，他们在公司里承担了更多的责任，职场道路开阔了。</li></ul><p>在写作时，有效表达只是最基本的层次，有效沟通才是终极目标。<br>每一次写作，并不是自己做了一次信息传递，每一次写作，你都在为读者创造一次阅读体验。<br>一篇好文章，不会让读者读完后困惑地问“so what”<strong>(所以呢?)</strong>，而是发出“wow”<strong>(diao a!)</strong>的赞叹。</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;本文源自得到课程《有效提升你的职场写作能力》。作者戴愫老师，一名跨文化研究者，也是一名企业培训师。本系列共6讲和1个小结，干货满满，由思路清晰，思维缜密的戴愫老师娓娓道来。&lt;br&gt;&lt;b&gt;前两讲是基础课&lt;/b&gt;。养成正确的写作习惯——先想再写，然后删。写之前要“想”，想什么呢？用TCS三步构思法——基调、内容、结构。在基础课里，你会学到，在看似人人都会写的邮件里，蕴藏着怎样的高级套路。&lt;b&gt;第三讲和第四讲&lt;/b&gt;，教你怎样给文章组织结构。当需要写复杂的文案时，怎样用四大思维能力组织一个高价值的文章，并且怎样写第一段，让文章的价值最大化。&lt;b&gt;最后两讲&lt;/b&gt;，带你润色语言，为文章锦上添花——如何写出有权威性，又有亲和力的措辞，也就是让语言有质感、有温度。&lt;b&gt;&lt;em&gt;版权归得到App所有，本文及相关内容仅供我个人总结和学习。&lt;/em&gt;&lt;/b&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="得到" scheme="https://www.blogs.rhsphere.com/categories/%E5%BE%97%E5%88%B0/"/>
    
    
      <category term="得到，职场写作，软技能" scheme="https://www.blogs.rhsphere.com/tags/%E5%BE%97%E5%88%B0%EF%BC%8C%E8%81%8C%E5%9C%BA%E5%86%99%E4%BD%9C%EF%BC%8C%E8%BD%AF%E6%8A%80%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>认识SSM框架和Redis</title>
    <link href="https://www.blogs.rhsphere.com/2018/10/26/SSM-framework-Redis.html"/>
    <id>https://www.blogs.rhsphere.com/2018/10/26/SSM-framework-Redis.html</id>
    <published>2018-10-26T06:09:31.000Z</published>
    <updated>2019-02-25T10:02:52.445Z</updated>
    
    <content type="html"><![CDATA[<p class="description">文章对以下要点进行总结和归纳：1)了解Spring IoC和Spring AOP的基础概念；2)了解MyBatis的特点；3)了解Spring MVC的特点；4)了解为什么要使用NoSQL(Redis)及Redis的优点；5)掌握SSM和Redis的基本结构框图和各种技术的作用。</p><a id="more"></a><h2 id="Spring框架"><a href="#Spring框架" class="headerlink" title="Spring框架"></a>Spring框架</h2><p>Spring框架是Java应用最广的框架，它优秀的理念包括 <strong>IoC</strong> (Inversion of Control， 控制反转)和 <strong>AOP</strong> (Aspect Oriented Programming， 面向切面编程)。</p><h3 id="Spring-IoC简介"><a href="#Spring-IoC简介" class="headerlink" title="Spring IoC简介"></a>Spring IoC简介</h3><p>Spring IoC（Inversion of Control，控制反转）承担了一个资源管理、整合、即插即拔的功能。举个例子，在Java中我们为国家插座设计两种接口，那我们就可以为两种插座分别new两个对象，但是如果要更改上千次这种插座，难道要new很多对象吗？所以不用new的方式创建对象，而是使用配置的方式，然后使用配置的方式，然后让Spring IoC容器自己通过配置去找到插座。<br>不需要去找资源(Bean)，只要向Spring IoC容器描述所需资源，Spring IoC自己会找到你所需要的资源，这就是Spring IoC的理念。这样就把Bean之间的依赖关系解耦了，更容易写出结构清晰的程序。除此之外，Spring IoC还提供对Java Bean生命周期的管理，可以延迟加载，可以在其生命周期内定义一些行为等，更加有效地使用和管理Java资源。<br>如果使用new的方式来使用插座，代码如下。<br><figure class="highlight java"><figcaption><span>使用插座1</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">User user = <span class="keyword">new</span> User();</span><br><span class="line">Socket socket = <span class="keyword">new</span> Socket1();</span><br><span class="line">user.setSocket(socket);</span><br><span class="line">user.useSocket();</span><br></pre></td></tr></table></figure></p><p>这样会有一个弊端，如果使用其他插座，就需要修改代码。可以使用配置的方式代替new的方式创建对象，让Spring IoC容器通过配置去找到插座。<br><figure class="highlight xml"><figcaption><span>使用Spring IoC注入插座1个用户</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"socket"</span> <span class="attr">class</span>=<span class="string">"Socket1"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"xxx.User"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spanroperty</span> <span class="attr">name</span>=<span class="string">"socket"</span> <span class="attr">ref</span>=<span class="string">"socket"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>只需要修改XML配置文件，就可以切换：<br><figure class="highlight diff"><figcaption><span>切换插座的实现类</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">- &lt;bean id="socket" class="Socket1" /&gt;</span></span><br><span class="line"><span class="addition">+ &lt;bean id="socket" class="Socket2" /&gt;</span></span><br><span class="line">&lt;bean id="user" class="xxx.User"&gt;</span><br><span class="line">    &lt;spanroperty name="socket" ref="socket" /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p><p>显然，IoC的目标就是为了管理Bean而存在的。</p><h3 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h3><p>IoC的目标就是为了管理Bean，而Bean是Java面向对象(OOP)的基础设计，比如声明一个用户类、插座类等都是基于面向对象的概念。<br>有些情况是面向对象没办法处理的。<br>举个例子，生产部门的订单、生产部门、财务部门三者符合OOP的设计理念。订单发出，生产部门审批通过准备付款，但是财务部门发现订单的价格超支了，需要取消订单。 显然超支限定已经不只是影响财务部门了，还会影响生产部门之前所做的审批，需要把它们作废。把预算超支这个条件称为切面，它影响了订单、生产部门和财务部门3个OOP对象。在现实中，这样的切面条件跨越了3个甚至更多的对象，并且影响了它们的协作。所以只用OOP并不完善，还需要面向切面的编程，通过它去管理在切面上的某些对象之间的协作。<br>Spring AOP常用于数据库事务的编程，很多情况都如同上而的例子，我们在做完第一步数据库数据更新后，不知道下一步是否会成功，如果下一步失收，会使用数据库事务的回滚功能去回滚事务，使得第一步的数据库更新也作废。<br>在Spring AOP实现的数据库事务管理中，是以异常作为消息的。在默认的情况下(可以通过Spring的配置修改)，只要Spring接收到了异常信息，它就会将数据库的事务回滚，从而保证数据的一致性。这样我们就知道在Spring的事务管理中只要让它接收到异常信息，它就会回滚事务，而不需要通过代码来实现这个过程。<br>比如上面的例子，可用一段伪代码来进行一些必要的说明。<br><figure class="highlight java"><figcaption><span>Spring AOP处理订单伪代码</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">proceed</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断生产部门是否通过订单，数据库记录订单</span></span><br><span class="line">    <span class="keyword">boolean</span> pflag = productionDept.isPass(order);</span><br><span class="line">    <span class="keyword">if</span>(pflag) &#123;<span class="comment">//如果生产部门通过进行财务部门审批</span></span><br><span class="line">        <span class="keyword">if</span> (financialDept.isOverBudget(order)) &#123;<span class="comment">//财务审批是否超限</span></span><br><span class="line">            <span class="comment">//抛出异常回滚事务，之前的订单操作也会被回滚</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"预算超限！！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Spring AOP的编程屏蔽了数据库代码，只需关注业务代码，知道只要发生了一场异常，Spring会回滚事务就足够了。</p><h2 id="MyBatis简介"><a href="#MyBatis简介" class="headerlink" title="MyBatis简介"></a>MyBatis简介</h2><p>MyBatis的前身是Apache的开源项目iBatis，是一个基于 Java的持久层框架。2010年这个项目由Apache software foundation迁移到Google code，并更名为MyBatis。2013年11月，MyBatis迁移到GitHub上，目前由GitHub提供维护。<br>MyBatis的优势在于灵活，它几乎可以代替JDBC，同时提供了接口编程。目前MyBatis的数据访问层 DAO(Data Access Objects)是不需要实现类的，它只需要一个接口和XML(或者注解)。MyBatis提供自动映射、动态SQL、级联、缓存、注解、代码和SQL分离等特性，使用方便，同时也可以对SQL进行优化。因为其具有封装少、映射多样化、支持存储过程、可以进行SQL优化等特点，使得它取代了Hibernate成为了Java互联网中首选的持久框架。<br>Hibernate作为一种十分流行的框架，它有其无可替代的优势，这里我们有必要讨论一下它和MyBatis的区别。由于MyBatis和Hibernate都是持久层框架，都会涉及数据库，所以首先定义一个数据库表一角色表(t_role)。<br><figure class="highlight sql"><figcaption><span>角色表的sql语句</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t_role(</span><br><span class="line">    编号 <span class="built_in">int</span>(<span class="number">12</span>) primary <span class="keyword">key</span>，</span><br><span class="line">    角色名称 <span class="built_in">varchar</span>(<span class="number">60</span>)，</span><br><span class="line">    备注 <span class="built_in">varchar</span>(<span class="number">1024</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>用一个POJO(Plain Ordinary Java Object)和这张表定义的字段对应起来。<br><figure class="highlight java"><figcaption><span>定义角色POJO</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.learn.chapter1.pojo;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Role</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String roleName;</span><br><span class="line">    <span class="keyword">private</span> String note;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * setter and getter</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>无论是MyBatis还是Hibernate都是依靠某种方法，将数据库的表和POJO映射起来的，这样就可以操作POJO来完成相关的逻辑了。</p><h3 id="Hibernate简介"><a href="#Hibernate简介" class="headerlink" title="Hibernate简介"></a>Hibernate简介</h3><p>映射规则</p><table><thead><tr><th style="text-align:left">语言</th><th style="text-align:left">映射方法</th></tr></thead><tbody><tr><td style="text-align:left">MyBatis</td><td style="text-align:left">使用注解方式会受到一定的限制，通常使用XML方式实现映射关系</td></tr><tr><td style="text-align:left">Hibernate</td><td style="text-align:left">XML和注解提供映射规则</td></tr></tbody></table><p>把POJO对象和数据库表相互映射的框架称为对象关系映射(Object Relational Mapping，ORM，或O/RM，或O/R mapping)框架。Hibernate的设计理念是完全面向POJO的，不需要编写SQL就可以通过映射关系来操作数据库，是一种全表映射的体现；MyBatis需要提供SQL去运行。<br><figure class="highlight xml"><figcaption><span>Hibernate映射文件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN"</span></span><br><span class="line"><span class="meta">  "http://www.hibernate.rg/dtd/hibernate-mapping-3.0.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"com.learn.chapter1.pojo.Role"</span> <span class="attr">tbale</span>=<span class="string">"t_role"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">type</span>=<span class="string">"java.lang.Integer"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"id"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"identity"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">spanroperty</span> <span class="attr">name</span>=<span class="string">"roleName"</span> <span class="attr">type</span>=<span class="string">"string"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"role_name"</span> <span class="attr">length</span>=<span class="string">"60"</span> <span class="attr">not-null</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">spanroperty</span> <span class="attr">name</span>=<span class="string">"note"</span> <span class="attr">type</span>=<span class="string">"string"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"note"</span> <span class="attr">length</span>=<span class="string">"512"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>首先，对POJO和表t_role进行了映射配置，把两者映射起来了。然后，对POJO进行操作，从而影响t_role表的数据，比如对其增删改查可以按照如下操作。<br><figure class="highlight java"><figcaption><span>Hibernate通过Session操作数据库数据</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Session session = <span class="keyword">null</span>;</span><br><span class="line">Transaction tx = <span class="keyword">null</span>;        </span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//打开Session</span></span><br><span class="line">    session = HibernateUtil.getSessionFactory().openSession();</span><br><span class="line">    <span class="comment">//事务</span></span><br><span class="line">    tx = session.beginTransaction();</span><br><span class="line">    <span class="comment">//POJO</span></span><br><span class="line">    Role role = <span class="keyword">new</span> Role();</span><br><span class="line">    role.setId(<span class="number">1</span>);</span><br><span class="line">    role.setRoleName(<span class="string">"rolename1"</span>);</span><br><span class="line">    role.setNote(<span class="string">"note1"</span>);  <span class="comment">//保存</span></span><br><span class="line">    Role role2 = (Role) session.get(Role.class， <span class="number">1</span>); <span class="comment">//查询</span></span><br><span class="line">    role2.setNote(<span class="string">"修改备注"</span>);</span><br><span class="line">    session.update(role2); <span class="comment">//更新</span></span><br><span class="line">    System.err.println(role2.getRoleName());</span><br><span class="line">    session.delete(role2); <span class="comment">//删除</span></span><br><span class="line">    tx.commit(); <span class="comment">//提交事务</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">    <span class="keyword">if</span> (tx != <span class="keyword">null</span> &amp;&amp; tx.isActive()) &#123;</span><br><span class="line">        tx.rollback(); <span class="comment">//回滚事务</span></span><br><span class="line">    &#125;</span><br><span class="line">    ex.printStackTrace();</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (session != <span class="keyword">null</span> &amp;&amp; session.isOpen()) &#123;</span><br><span class="line">        session.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里没有SQL，因为Hibernate会根据映射关系来生成对应的SQL。</p><h3 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h3><p>可以自己拟定SQL规则，能精确定义SQL，从而符合移动互联网高并发、大数据、高性能、高响应的需求。MyBatis也需要映射文件把POJO和数据库的表对应起来。<br><figure class="highlight xml"><figcaption><span>MyBatis映射文件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE mapper   PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"</span></span><br><span class="line"><span class="meta">  "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.learn.chapter1.mapper.RoleMapper"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"roleMap"</span> <span class="attr">type</span>=<span class="string">"com.learn.chaper1.pojo.Role"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"id"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"roleName"</span> <span class="attr">column</span>=<span class="string">"role_name"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"note"</span> <span class="attr">column</span>=<span class="string">"note"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getRole"</span> <span class="attr">resultMap</span>=<span class="string">"roleMap"</span>&gt;</span></span><br><span class="line">        select id， role_name， note from t_rle where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">"deleteRole"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span>&gt;</span></span><br><span class="line">        delete from t_role where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insertRole"</span> <span class="attr">parameterType</span>=<span class="string">"com.learn.chapter1.pojo.Role"</span>&gt;</span></span><br><span class="line">        insert into t_role(role_name， note) values(#&#123;roleName&#125;， #&#123;note&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"updateRole"</span> <span class="attr">parameterType</span>=<span class="string">"com.learn.chapter1.pojo.Role"</span>&gt;</span></span><br><span class="line">        update t_role set</span><br><span class="line">        role_name = #&#123;roleName&#125;，</span><br><span class="line">        note = #&#123;note&#125;</span><br><span class="line">        where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>这里的resultMap元素用于定义映射规则，而实际上MyBatis在满足一定的规则下，完成自动映射，而增删改查对应着insert、delete、select、update四个元素。mapper元素中的namespace属性，要和一个接口的全限定名保持一致，而里面的SQL的id也需要和接口定义的方法完全保持一致，定义MyBatis映射文件。<br><figure class="highlight java"><figcaption><span>定义MyBatis映射文件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.learn.chapter1.mapper;</span><br><span class="line"><span class="keyword">import</span> com.learn.chapter1.pojo.Role;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RoleMapper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Role <span class="title">getRole</span><span class="params">(Integer id)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteRole</span><span class="params">(Integer id)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">insertROle</span><span class="params">(Role role)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">updateROle</span><span class="params">(Role role)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>定义了MyBatis映射文件，不需要定义一个实现类。<br><span style="color:#5073b8;">显然MyBatis在业务逻辑上和Hibernate是大同小异的。其区别在于，MyBatis需要提供接口和SQL，这意味着工作量会比较大，但是由于自定义SQL、映射关系，所以灵活性、可优化性超过了Hibernate。互联网可优化性、灵活性是十分重要的，因为一条SQL的性能可能相差十几倍到几十倍。</span></p><h3 id="Hibernate和MyBatis的区别"><a href="#Hibernate和MyBatis的区别" class="headerlink" title="Hibernate和MyBatis的区别"></a>Hibernate和MyBatis的区别</h3><p>Hibernate和MyBatis的增、删、改、查，对于业务逻辑层来说大同小异，对于映射层而言Hibernate的配置不需要接口和SQL，相反MyBatis是需要的。对于Hibernate而言，不需要编写大量的SQL，就可以完全映射，同时提供了日志、缓存、级联(级联比MyBatis强大)等特性，此外还提供HQL( Hibernate Query Language)对POJO进行操作，使用十分方便，但是它也有致命的缺陷。<br>由于无须SQL，当多表关联超过3个的时候，通过Hibernate的级联会造成太多性能的丢失，又或者我现在访问一个财务的表，然后它会关联财产信息表，财产又分为机械、原料等，显然机械和原料的字段是不一样的，这样关联字段只能根据特定的条件变化而变化而Hibernate无法支持这样的变化。遇到存储过程，Hibernate只能作罢。更为关键的是性能，在管理系统的时代，对于性能的要求不是那么苛刻，但是在互联网时代性能就是系统的根本，响应过慢就会丧失客户，试想一下谁会去用一个经常需要等待超过10秒以上的应用呢?<br>以上的问题MyBatis都可以解决，MyBatis可以自由书写SQL、支持动态SQL、处理列表、动态生成表名、支持存储过程。这样就可以灵活地定义查询语句，满足各类需求和性能优化的需要，这些在互联网系统中是十分重要的。<br>但MyBatis也有缺陷。首先，它要编写SQL和映射规则，其工作量稍微大于Hibernate。 其次，它支持的工具也很有限，不能像Hibernate那样有许多的插件可以帮助生成映射代码和关联关系，而即使使用生成工具，往往也需要开发者进一步简化，MyBatis通过手工编码，工作量相对大些。所以对于性能要求不太苛刻的系统，比如管理系统、ERP等推荐使用Hibernate;而对于性能要求高、响应快、灵活的系统则推荐使用MyBatis。</p><h2 id="Spring-MVC简介"><a href="#Spring-MVC简介" class="headerlink" title="Spring MVC简介"></a>Spring MVC简介</h2><p>也许你还在问为什么使用Spring MVC，Struts 2.x不才是主流吗？看SSH的概念多火!其实很多初学者都混淆了一个概念，SSH时间上指的是Struts 1.x + Spring + Hibernate，这个概念已经有十几年的历史了。在Structs 1.x的时代，Structs1.x是当之无愧的MVC框架的霸主，但是在新的MVC框架涌现的时代，形式已经完全不是这样的了，Structs 2.x借助了Structs 1.x的好名声，让国内开发者认为Structs 2.x是霸主继任者（其实两者在技术上没有任何关系），导致国内的很多程序员大多数学习基于Structs 2.x的框架，有一个貌似很火的概念出来了S2SH(Struts 2.x + Spring + Hibernate)整合开发。<br>根据JRebel厂商统计，Spring MVC的市场占有率是40%，而Structs 2.x只有可怜的6%。<span style="color:#5073b8;">Spring MVC是目前Java Web框架当之无愧的霸主。</span><br>Spring MVC和三层架构是什么关系，可能很多读者会抢答：<br>MVC：Model + View + Controller (数据模型+视图+控制器)<br>三层架构：Prensentation tier + Application tier + Data tier（展现层+应用层+数据访问层）<br>那MVC和三层架构有什么关系呢？但是实际上MVC只存在三层架构的展现层，M实际上是数据模型，是包含数据的对象。在Spring MVC里，有一个专门的类叫Model，用来和V之间的数据交互、传值；V指的是视图页面，包含JSP、freeMarker、Velocity、Thymeleaf、Tile等；C当然就是控制器（Spring MVC的注解@Controller的类）。<br>而三层架构是整个应用的架构，是由Spring框架负责管理的。一般项目中会有Service层、DAO层，这两个反馈在应用层和数据访问层。</p><h3 id="Java-EE应用的分层模型"><a href="#Java-EE应用的分层模型" class="headerlink" title="Java EE应用的分层模型"></a>Java EE应用的分层模型</h3><p>经典的Java EE架构大致上都可以分为如下几层：</p><ul><li><strong>Domain Object(领域对象)层</strong>。此层有一系列的POJO(Plain Object Java Object，普通的传统的Java对象)组成，这些对象是该系统的Domain Object(领域对象)，往往包含了各自所需实现的业务逻辑方法。</li><li><strong>DAO(Data Access Object，数据访问对象)层</strong>。此层由一系列的DAO组件组成，这些DAO实现了对数据库的创建、查询、更新和删除（CRUD）等原子操作。</li><li><strong>Service(业务逻辑)层</strong>。此层由一系列的业务逻辑对象组成，这些业务逻辑对象实现了系统所需的业务逻辑方法。这些业务逻辑方法可能仅仅用于暴露Domain Object对象所实现的业务逻辑方法，也可能是依赖DAO组件实现的业务逻辑方法。</li><li><strong>Controller(控制器)层</strong>。此层由一系列控制器组成，这些控制器用于拦截用户请求，并调用业务逻辑组件的业务逻辑方法，处理用户请求，并根据处理结果向不同的表现层组件转发。</li><li><strong>View(表现)层</strong>。此层由一系列的JSP页面、Velocity页面、PDF文档视图组件组成，负责手机用户请求，并显示处理结果。<h3 id="Java-EE应用的组件"><a href="#Java-EE应用的组件" class="headerlink" title="Java EE应用的组件"></a>Java EE应用的组件</h3>总体而言，Java EE应用应该大致包括如下几类组件：</li><li><strong>表现层组件</strong>。主要负责收集用户输入数据，或者想客户显示系统状态。最常用的表现层技术是JSP，但JSP并不是唯一的表现层技术。表现层还可以由Velocity、FreeMarker和Tapestry等技术完成，或者使用普通的应用程序充当表现层组件，甚至可以是小型智能设备。</li><li><strong>控制器组件</strong>。关于Java EE的MVC框架，其提供了一个前端核心控制器，核心控制器负责拦截用户请求，并将请求转发给用户实现的控制器组件。这些用户实现的控制器组件则负责调用业务逻辑方法，处理用户请求。</li><li><strong>业务逻辑组件</strong>。这是系统的核心组件，实现系统的业务逻辑。通常，一个业务逻辑方法对应一次用户操作。一个业务逻辑方法应该是一个整体，因此要求对业务逻辑方法增加事务性。业务逻辑方法仅仅实现也呜呜逻辑，不应该进行数据库访问。因此，业务逻辑组件中不应该出现原始的MyBatis、Hibernate和JDBC等API。<span style="color:#5073b8;">最重要的原因是：保证业务逻辑方法的实现与具体的持久层访问技术分离。当系统需要在不同持久层技术之间切换时，系统的业务逻辑组件无序任何改变。</span></li><li><strong>DAO组件</strong>。这个类型的对象比较缺乏变化，每个DAO组件都提供Domain Object对象基本的创建、查询、更新和删除等操作，这些操作对应于数据库的CRUD（创建、查询、更新和删除）等原子操作。当然，如果采用不同的持久层访问技术，DAO组件的会完全不同。为了实现业务逻辑组件的实现与DAO组件的实现分离，程序应该为每个DAO组件都提供接口，业务逻辑组件面向DAO接口编程，这样才能提供更好的解耦。</li><li><strong>领域对象组件</strong>。领域对象（Doamin Object）抽象了系统的对象模型。通常而言，这些领域对象的状态都必须保存在数据库里。因此，每个领域对象通常对应一个或多个数据表，领域对象通常需要提供对数据记录的访问方式。</li></ul><h2 id="最流行的NoSQL-–-Redis"><a href="#最流行的NoSQL-–-Redis" class="headerlink" title="最流行的NoSQL – Redis"></a>最流行的NoSQL – Redis</h2><p>NoSQL(Not Only SQL)存储的数据是半结构化的，Redis成为主要的NoSQL工具。</p><ol><li>响应速度快。</li><li>支持6种数据类型：字符串、哈希结构、列表、集合、可排序集合和基数。比如字符串可以存储Java基础数据类型，哈希可以存储对象，列表可以存储List对象等。</li><li>操作都是原子的。</li><li>MultiUtility工具：Redis可以再如缓存、、消息传递队列中使用（Reids支持“发布+订阅”的消息模式），在应用程序如Web应用程序绘画、网站页面点击数等任何短暂的数据中使用。</li></ol><h2 id="SSM-Redis结构框图及概述"><a href="#SSM-Redis结构框图及概述" class="headerlink" title="SSM+Redis结构框图及概述"></a>SSM+Redis结构框图及概述</h2><p>在Java Web中，以Spring + Spring MVC + MyBatis（SSM）作为主流框架，SSM+Redis的结构框图如下：<br><img src="/images/JavaEE/SSM-Redis-architecture.png" alt="SSM+Redis结构示意图"></p><ul><li>Spring IoC承担了一个资源管理、整合、即插即拔的功能。</li><li>Spring AOP可以提供切面管理，特别是书U哭事务管理的功能。</li><li>Spring MVC用于把模型、视图和控制器分层，组合成了一个有机灵活的系统。</li><li>MyBatis提供了一个数据库访问的持久层，通过MyBatis-Spring项目，它便能和Spring无缝对接。</li><li>Redis作为缓存工具，它提供了高速度处理数据和缓存数据的功能，使得系统大部分只需要访问缓存，而无须从数据库磁盘中重复读/写；在一些需要高速运算的场合中，也可以先用它来完成运算，再把数据批量存入数据库，这样便能极大地提升互联网系统的性能和响应能力。</li></ul><p>在后面会讲解这些技术的使用方法、原理和优化方法。</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;文章对以下要点进行总结和归纳：1)了解Spring IoC和Spring AOP的基础概念；2)了解MyBatis的特点；3)了解Spring MVC的特点；4)了解为什么要使用NoSQL(Redis)及Redis的优点；5)掌握SSM和Redis的基本结构框图和各种技术的作用。&lt;/p&gt;
    
    </summary>
    
      <category term="Java EE" scheme="https://www.blogs.rhsphere.com/categories/Java-EE/"/>
    
    
      <category term="Spring， Spring MVC， MyBatis， Redis" scheme="https://www.blogs.rhsphere.com/tags/Spring%EF%BC%8C-Spring-MVC%EF%BC%8C-MyBatis%EF%BC%8C-Redis/"/>
    
  </entry>
  
</feed>
