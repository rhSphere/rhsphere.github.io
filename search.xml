<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SQL学习笔记]]></title>
    <url>%2Funcategorized%2F2019%2F01%2F14%2FSQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</url>
    <content type="text"><![CDATA[#SQL语句基础Structured Query Language操作和检索关系型数据库的标准语言，标准的SQL语句可以用于操作任何关系数据库。一般程序员负责： 在数据库中检索信息 对数据库的信息进行更新 改变数据库的结构DBA负责： 更改系统的安全设置 增加或回收用户对数据库、表的许可权限 行：表中的一个记录 有时也被称为记录主键：一列或者一组列，其值能够唯一标识表中的每一行。便于更新和删除特定的行。 ##SQL语句类型 查询语句:主要是由select关键字完成，查询语句是SQL语句中最复杂、功能最丰富的语句 DML（Data Manipulation L, 数据操作语言）语句：主要有insert、update和delete三个关键字完成 DDL（Data Defination L，数据定义语言）语句：主要由create、alter、drop和truncate四个关键字完成 DCL（Data Control L, 数据控制语言）语句：主要由grant和revoke两个关键字完成 为数据库用户授权，或者访问指定用户的权限 事务控制语句：主要有commit、rollback和savepoint三个关键字完成 ##DDL语句 创建表 12345678910111213141516create table [SchemaName.]tableName( columnName datatype [default expr]);create table test ( test_id int, test_price decimal, test_name varchar(255) default 'xxx', test_desc text, test_img blob, test_date datetime);create table thesame as select * from user_inf;#选中和user_inf完全相同的字段和数据建表 修改表 1234567891011121314151617181920212223242526#增加列定义alter table tableNameadd( column_name datatype [default expr],);alter table hehe add hehe_id int;alter table hehe add( aaa varchar(255) default 'xxx', bbb varchar(255) );#修改列定义alter table hehemodify hehe_id varchar(255);#同时修改列名alter table hehechange hehe_id abc int;#将表重命名alter table heherename to wawa;#修改列名alter table TABLENAME change old_ColNAME new_ColNAME char(int ect..); 删除表 1drop table wawa; ##数据库约束 5种完整性约束 NOT NULL:非空约束，指定某列不能为空 UNIQUE:唯一约束，制定某列或某几列不能重复 PRIMARY KEY:主键，指定该列的值可以唯一地标识该记录 FOREIGN KEY:外键，指定该行记录从属于主表中的一条记录，主要用于保证参照完整性 CHECK: 约束分类 单列约束 多列约束-指定约束的两个时机 建表的同时为相应的数据制定约束 以修改表的方式来增加约束 NOT NULL约束 123456789101112131415create table hehe( id int not null, name varchar(255) defalut 'ldp' not null, gender varchar(2) null );alter table hehemodify gender varchar(2) not null;alter table hehemodify name varchar(2) null;alter table hehemodify name varchar(255) default 'abc' null; UNIQUE约束保证指定列或者指定列组合不允许出现重复值 123456789101112131415161718192021222324252627#列级约束语法建立约束，create table unique_test( id int not null, name varchar(255) unique );create table test( id int not null, name varchar(255). pass varchar(255), unique （name)， constraint uk unique(pass));create table test1( id not null, name varchar(255), pass varchar(255), constraint uk1 unique(name, pass));alter table test1 drop index uk1;alter table test1 add unique(name, pass);alter table test1 modify name varchar(255) unique; PRIMARY KEY约束主键约束相当于非空约束和唯一约束，即主键约束的列即不允许出现重复值，也不允许出现null值；如果对多列组合建立主键约束，则多列里包含的每一列都不能为空，但只要求这些列组合不能重复。主键列的值用于唯一标识表中的一条记录。建表时使用列级约束 12345create table primary_test( id int primary key, name varchar(255)); 建表时创建主键约束，使用表级约束法12345678create table primary_test1( id int not null, name varchar(255), pass varchar(255), #对于MySQL而言，test1_pk主键约束名无效，PRIMARY是主键约束名 constraint test1_pk primary key(id) ); 建表时以多列建立组合主键，使用表级约束1234567891011121314create table primary_test2( name varchar(255), pass varchar(255));alter table primary_test2drop primary key;alter table primary_test2add primary key(name, pass);alter table primary_test2modify name varchar(255) primary key; 建立自增长的主键约束123456create table primary_test3( id int auto_increment primary key, name varchar(255), pass varchar(255))； FOREIGEN KEY约束MySQL会为该外键约束命名为tableName_ibfk_n从表的外键参照的只能是主表的主键列或者唯一键列。主表记录不允许被删除。外键约束通常用于定义两个实体之间的一对多、一对一的关联关系。对于一对多的关联关系，通常再多的一端增加外键列；一对一的关联关系，选择任意一方来增加外键列，被增加外键列的表被称为从表；对于多对多的关联关系，需要额外增加一个连接表来记录他们的关联关系。列级约束法建立外键约束直接使用references关键字1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#列级约束法create table teacher_table( teacher_id int auto_increment, teacher_name varchar(255), primary key(teacher_id));create table student_table( student_id int auto_increment primary key, student_name varchar(255), java_teacher int references teacher_table(teacher_id));#表级约束法create table teacher_table1( teacher_id int auto_increment, teacher_name varchar(255), primary key(teacher_id));create table student_table1( student_id int auto_increment primary key, student_name varchar(255), java_teacher int， foreign key(java_teacher) references teacher_table1(teacher_id));#表级约束法,显示指定外键约束的名字create table teacher_table2( teacher_id int auto_increment, teacher_name varchar(255), primary key(teacher_id));create table student_table2( student_id int auto_increment primary key, student_name varchar(255), java_teacher int， constraint student_teacher_fk foreign key(java_teacher) references teacher_table2(teacher_id));#多列组合的外键约束，则必须使用表级约束法create table teacher_table3( teacher_name varchar(255), teacher_pass varchar(255) primary key(teacher_name, teacher_pass));create table student_table3( student_id int auto_increment primary key, student_name varchar(255), java_teacher_name varchar(255)， java_teacher_pass varchar(255), foreign key(java_teache_name, java_teacher_pass) references teacher_table3(teacher_name, teacher_pass));#删除alter table student_table3drop foreign key student_table3_ibfk_1;#修改alter table student_table3add foreign key(java_teacher_name, java_teacher_pass) references teacher_table3(teacher_name, teacher_pass); 自关联1234567create table foreign_test( foreign_id int auto_increment primary key, foreign_name varchar(255), refer_id int, foreign key(refer_id) references foreign_test(foreign_id)); 级联删除、或者从表都设置为null123456789101112131415create table teacher_table4( teacher_id int auto_increment, teacher_name varchar(255), primary key(teacher_id));create table student_table4( student_id int auto_increment primary key, student_name varchar(255), java_teacher int, foreign key(java_teacher) references teacher_table4(teacher_id) on delete cascade #或者用on delete set null); 索引创建方式： 定义主键约束、唯一约束、和外键约束是，系统自动创建索引 手动删除方式： 数据表被删除时，自动 手动 1234567891011create index index_name on tableName (colum[, column]...);create index emp_last_name_idxon emplees(last_name);create index emp_last_name_idx1on emplees(first_name, last_name);drop index emp_last)name_idx2on emplees;show index from tableName; ##DML完成三个任务： 插入新数据 修改已有数据 删除不需要的数据 insert into语句插入语句，每次只能插入一条记录 1234insert into tableName(column) values(value);insert into student_table2(student_name)select techer_name from tescher_table2; update 语句修改多条记录 12update table_name set column1 = value[, column2 = value2]where condition; delete from语句整行的删除 12delete from tableNamewhere teacher_id &gt; 2; ##表单查询*表示所有列12345678910select * from teacher_table;select student_name from student_tablewhere java_teacher &gt; 3;select teacher_id + 5 from teacher_table;select * from teacher_tablewhere teacher_id * 3 &gt; 4; select 需要指明选择什么，以及在哪里选择数据格式是表示问题，而不是检索问题检索不同的值 select distinct id from tableNmae;检索前五个select prod_name from Products limit 5 offset 5;捷径select prod_name from Products limit 5, 5; 排序select prod_name from Productsorder by prod_name;多列排序select prod_id, prod_price, prod_namefrom Productsorder by prod_price, prod_name;按列位置排序select prod_id, prod_price, prod_namefrom Productsorder by 2, 3; 降序排序select prod_id, prod_price, prod_namefrom Productsorder by prod_price desc; 多列降序排序：必须对每一个列指定desc关键字select prod_id, prod_price, prod_namefrom Productsorder by prod_price desc, prod_name; 过滤数据只检索所需数据需要指定搜索条件（search criteria),搜索条件也叫过滤条件（filter condition)select prod_name, prod_pricefrom Productswhere prod_price = 3.49; 同时使用order by和where时，应该让order by在where后面 select prod_name, prod_price from Productswhere prod_price &lt; 10; select vend_id, prod_name from Productswhere vend_id &lt;&gt; ‘DLL01’; select prod_name, prod_price from Productswhere prod_price between 5 and 10; select prod_name from Products where prod_price is null; select cust_name from Customers where cust_email is null; 组合where子句 and操作符select prod_id, prod_price, prod_namefrom Productswhere vend_id = ‘DLL01’ and prod_price &lt;= 4; orselect prod_name, prod_price from Productswhere vend_id = ‘DLL01’ or vend_id = ‘BRS01’; and的优先级比or更高，使用圆括号分组select prod_name, prod_price from Productswhere (vend_id = ‘DLL01’ or vend_id = ‘BRS01’) and prod_price &gt;= 10; in有很多合法选项时，in更加清楚、直观select prod_name, prod_pricefrom Productswhere vend_id in (‘DLL01’, ‘BRS01’)order by prod_price; notnot否定in、between、exists子句select prod_name from Productswhere not vend_id = ‘DLL01’order by prod_name desc; ##通配符过滤 likeselect prod_id, prod_namefrom Productswhere prod_name like ‘Fish%’; select prod_id, prod_name from Productswhere prod_name like ‘%bean bag%’; select prod_id, prod_namefrom Productswhere prod_name like ‘__ inch teddy bear’; %字符匹配多个字符，_只匹配一个字符 select cust_contact from Customerswhere cust_contact like ‘J%’order by cust_contact; select cust_contact from Customerswhere cust_contact like ‘[^JM]%’order by cust_contact; select concat(vend_name, vend_country) from vendorsorder by vend_name;select concat(rtrim(vend_name), rtrim(vend_country))from vendors order by vend_name; select concat(vend_name, vend_country) as vend_titlefrom Vendors order by vend_name; select concat(vend_name, ‘( ‘, vend_country, ‘)’)as vend_title from Vendors order by vend_name;123select prod_id, quantity, item_price, quantity*item_price as expanded_pricefrom OrderItemswhere order_num = 20008; select order_num from Orders where year(order_date) = 2012; ##汇总数据select avg(prod_price) as avg_price from Products;select avg(prod_price) as avg_pricefrom Productswhere vend_id = ‘DLL01’; count()函数 确定行中的数目或符合特定条件的行的数目。1select count(*) as num_cust from Customers; select count(cust_email) as num_cust from Customers; select sum(quantity) as items_ordered from OrderItemswhere order_num = 20005; 12select sum(quantity*item_price) as total_price from OrderItemswhere order_num = 20005; select sum(quantity) as items_ordered from OrderItemswhere order_num = 20005; select avg(distinct prod_price) as avg_price from Products where vend_id = ‘DLL01’; 123select vend_id, count(*) as num_prods from productsgroup by vend_idhaving count(*) &gt;= 3; where过滤行，having过滤分组 12345678select cust_id, count(*) as order from Ordersgroup by cust_idhaving count(*) &gt;= 2;select cust_id, count(*) as ordersfrom Ordersgroup by cust_idhaving count(*) &gt; 1; where在分组前行过滤，having在分组后 12345678910select vend_id, count(*) as num_prodsfrom Productswhere prod_price &gt;= 4group by vend_idhaving count(*) &gt;= 2;select vend_id, count(*) as num_prodsfrom Productsgroup by vend_idhaving count(*) &gt;= 2; order by group by 对产生的输出排序 对行分组，但输出可能不是分组的排序，只可能使用选择列或者表达式列 12345678select order_num, count(*) as items from OrderItemsgroup by order_numhaving count(*) &gt;= 3;select order_num, count(*) as items from OrderItemsgroup by order_numhaving count(*) &gt;= 3order by items, order_num; ##子查询查询（query）一般指的是select语句子查询（subquery)嵌套的查询,总是从内向外嵌套 1234#查询订单号select order_num from OrderItems where prod_id ='RGAN01';select cust_id from Orders where order_num in(select order_num from OrderItems where prod_id ='RGAN01'); 避免硬编码顾客id，使用子查询12345select cust_name, cust_contact from Customers where cust_id in (select cust_id from Orders where order_num in (select order_num from OrderItems where prod_id = 'RGAN01')); 作为子查询的select语句只能查询单个列使用子查询并不总是执行这类数据检索的最有效方法。 123456#检索特定顾客的订单数目select count(*) as orders from Orders where cust_id = '1000000001';#全检索所有顾客的订单数，并按照顾客姓名排序select cust_name, cust_state, (select count(*) from Orders where Orders.cust_id = Customers.cust_id) as ordersfrom Customers order by cust_name; 完全限定列名：指定表名和列名，告诉SQL语言，比较Orders表中的cust_id和当前正从Customers表中检索的cust_id。如果不这样写DBMS会认为是要对Orders表中的cust_id自身进行比较。 ##联结表创建联结表，指定要联结的所有表以及关联他们的方式123select vend_name, prod_name, prod_pricefrom Vendors, Productswhere Vendors.vend_id = Products.vend_id; 笛卡尔积（cartesian product)没有联结条件的关系返回的结果为笛卡尔积。检索出来的行的树木将是第一个表中的行数乘以第二个表中的行数。select vend_name, prod_name, prod_pricefrom Vendors, Products; 内联结（inner join)等值联结（equijoin），基于两个表之间的相等测试 select vend_name, prod_name, prod_pricefrom Vendors inner join Productson Vendors.vend_id = Products.vend_id; 连接多个表select prod_name, vend_name, prod_price, quantityfrom OrderItems, Products, Vendorswhere Products.vend_id = Vendors.vend_id and OrderItems.prod_id = Products.prod_idand order_num = 20007; select cust_name, cust_contact from Customers where cust_id in (select cust_id from Orders where order_num in (select order_num from OrderItems where prod_id = ‘RGAN01’));使用联结表改写上面的语句：select cust_name, cust_contactfrom Customers, Orders, OrderItemswhere Customers.cust_id = Orders.cust_idand Orders.order_num = OrderItems.order_numand prod_id = ‘RGAN01’; 联结是SQL中一个中重要、最强大的特性，有效使用联结需要对挂系数据库有基本的了解。 ##创建使用高级联结使用表别名：缩短SQL语句；允许在一条select语句中多次使用相同的表。 select cust_name, cust_contact from Customers as C, Orders as O, OrderItems as OIwhere C.cust_id = O.cust_id and OI.order_num = O.order_numand prod_id = ‘RGAN01’; 使用不同联结：自联结（self-join)、自然联结（naturanl join)、外联结(outer join) 自联结 要给Jim Jones同一公司的所有顾客发送一封信件。首先找出Jim Jones工作的公司，然后找到该公司的所有顾客。select cust_id, cust_name, cust_contactfrom Customers where cust_name = (select cust_name from Customers where cust_contact = ‘Jim Jones’);等价方法select c1.cust_id, c1.cust_name, c1.cust_contactfrom Customers as c1, Customers as c2 where c1.cust_name = c2.cust_nameand c2.cust_contact = ‘Jim Jones’; 自然联结12345678910111213select C.*, O.order_num, O.order_date, OI.prod_id, OI.quantity, OI.item_pricefrom Customers as C, Orders as O, OrderItems as OIwhere C.cust_id = O.cust_id and OI.order_num = O.order_numand prod_id = 'RGAN01';select Customers.cust_id, Orders.order_numfrom Customers inner join Orders on Customers.cust_id = Orders.cust_id;select Customers.cust_id, Orders.order_num from CUstomers left outer join Orderson Customers.cust_id = Orders.cust_id;select Customers.cust_id, Orders.order_num from Customers right outer join Orderson Orders.cust_id = Customers.cust_id; SQL聚集函数1234avg() count() max() min() sum()select Customers.cust_id, count(Orders.order_num) as num_ord from Customers inner join Orders on Customers.cust_id = Orders.cust_id group by Customers.cust_id;select Customers.cust_id, count(Orders.order_num) as num_ord from Customers left outer join Orders on Customers.cust_id = Orders.cust_id group by Customers.cust_id; select into 语句从一个表复制到另一个表create table CustCopy as select * from Customers; 更新和删除数据使用UPDATE时一定要细心，因为稍有不注意，就会更新表中的所有行。基本的update语句：1）需要更新的表，2）列名和他们的新值，3）确定要更新那些行的过滤条件update Customers set cust_email = &#39;kim@thetoystore.com‘ where cust_id = ‘1000000005’;update Customers set cust_email = &#39;kim@thetoystore.com‘, cust_contact = ‘Sam Roberts’ where cust_id = ‘1000000005’; SQL中空字符串用’’表示，是一个值，而NULL表示没有值。 alter table Vendors drop column vend_phone; 删除表的内容可以用：delete from custcopy; 和 truncate custcopy;删除表 drop table custcopy; 视图不包含任何列或数据，包含的是一个查询，被封装起来。视图： 重用SQL语句。 简化复杂的SQL操作 使用表的一部分而不是整个表。 保护数据。 更改数据格式和表示。create view 只能创建不存在的视图drop view viewName 删除视图 create view ProductCustomers as select cust_name, cust_contact, prod_id from Customers, Orders, OrderItems where Customers.cust_id = Orders.cust_id and OrderItems.order_num = Orders.order_num; select cust_name, cust_contact from ProductCustomers where prod_id = ‘RGAN01’;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Funcategorized%2F2019%2F01%2F13%2Fhello-world.html</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
