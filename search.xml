<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[108. 将有序数组转换成二叉搜索树]]></title>
    <url>%2F2019%2F11%2F05%2FConvert-Sorted-Array-to-BST.html</url>
    <content type="text"><![CDATA[将有序数组转换成二叉搜索树LeetCode 108 英文版 中文版 本题是用的树的中序遍历，和剑指offer中 剑指Offer(33) 二叉搜索树的后续遍历序列 类似，不过本题用的是后续遍历，但都是递归思想。 Java代码123456789101112131415161718192021222324252627282930313233/** * @description: * @author: rhsphere * @since: 2019-11-05 18:35 by jdk 1.8 */public class SortedArrayToBST &#123; public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125; &#125; public TreeNode sortedArrayToBST(int[] nums) &#123; if (nums == null || nums.length &lt;= 0) return null; return sortedArrayToBST(nums, 0, nums.length-1); &#125; private TreeNode sortedArrayToBST(int[] nums, int start, int end) &#123; int mid = (start + end) / 2; TreeNode root = new TreeNode(nums[mid]); if(start &lt; mid) root.left = sortedArrayToBST(nums, start, mid-1); if (mid &lt; end) root.right = sortedArrayToBST(nums, mid + 1, end); return root; &#125;&#125; 题目]]></content>
      <categories>
        <category>Easy</category>
      </categories>
      <tags>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[112. 路径总和]]></title>
    <url>%2F2019%2F11%2F05%2Fpath-sum.html</url>
    <content type="text"><![CDATA[路径总和比较难的 二叉树和为某一值的路径 本题使用递归来实现。 做为树的递归题目是非常有套路可循的，因为树有两个分支，所以在递归里也有两个分支，一般是通过 递归 A（||，&amp;&amp;）递归 B 来实现分支的。只要明白了这一点，递归函数就不会很难设计。 Java代码1234567891011121314151617181920212223242526/** * @description: 路径的总和 * @author: rhsphere * @since: 2019-11-05 18:23 by jdk 1.8 */public class PathSum &#123; public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125; &#125; public boolean hasPathSum(TreeNode root, int sum) &#123; if (root == null) return false; if (root.left == null &amp;&amp; root.right == null) return sum - root.val == 0; return hasPathSum(root.left, sum-root.val) || hasPathSum(root.right, sum-root.val); &#125;&#125; 题目给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。 说明: 叶子节点是指没有子节点的节点。 示例: 给定如下二叉树，以及目标和 sum = 22， 5 / \ 4 8 / / \ 11 13 4 / \ \ 7 2 1 返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5-&gt;4-&gt;11-&gt;2。]]></content>
      <categories>
        <category>Easy</category>
      </categories>
      <tags>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[103. 二叉树的锯齿层次遍历]]></title>
    <url>%2F2019%2F11%2F05%2F103-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86.html</url>
    <content type="text"><![CDATA[二叉树的锯齿层次遍历LeetCode 103 英文版 中文版 或者叫 剑指offer第三题 之字形打印二叉树 题目给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。 例如： 给定二叉树 [3,9,20,null,null,15,7], 3 / \ 9 20 / \ 15 7返回锯齿形层次遍历如下： [ [3], [20,9], [15,7]] 注意 List&lt;List&gt; list = new ArrayList&lt;List&gt;();的声明方式； levelList在第二个for循环之前要清空； 最后一次的list.add(levelList) 要进行判空。 Java代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * @description: * @author: rhsphere * @since: 2019-11-05 15:51 by jdk 1.8 */public class ZigzagLevelOrder &#123; public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125; &#125; public List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;List&lt;Integer&gt;&gt;(); if (root == null) return list; Stack&lt;TreeNode&gt; stack1 = new Stack&lt;&gt;(); Stack&lt;TreeNode&gt; stack2 = new Stack&lt;&gt;(); TreeNode node; stack1.push(root); while (!stack1.empty() || !stack2.empty()) &#123; List&lt;Integer&gt; levelList = new ArrayList&lt;&gt;(); while (!stack1.empty()) &#123; node = stack1.pop(); levelList.add(node.val); if (node.left != null) stack2.push(node.left); if (node.right != null) stack2.push(node.right); &#125; list.add(levelList); levelList = new ArrayList&lt;&gt;(); while (!stack2.empty()) &#123; node = stack2.pop(); levelList.add(node.val); if (node.right != null) stack1.push(node.right); if (node.left != null) stack1.push(node.left); &#125; if (!levelList.isEmpty()) list.add(levelList); &#125; return list; &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[114. 二叉树展开为链表]]></title>
    <url>%2F2019%2F11%2F05%2Fflatten-tree-to-linkedlist.html</url>
    <content type="text"><![CDATA[二叉树展开为链表 LeetCode 114 英文版 中文版 本题还有其他两种解法 @windliang，我使用先序遍历，用栈存储右孩子节点的方法避免，右指针丢失。 解法1变体的先序遍历，这题如果用正常的先序遍历的话，会丢失右孩子，为了更好的控制算法，用先序遍历的迭代形式，正常的先序遍历代码如下： 123456789101112131415public static void preOrderStack(TreeNode root) &#123; if (root == null) &#123; return; &#125; Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;(); while (root != null || !stack.isEmpty()) &#123; while (root != null) &#123; System.out.println(root.val); stack.push(root); root = root.left; &#125; root = stack.pop(); root = root.right; &#125;&#125; 还有一种特殊的先序遍历，提前将右孩子保存到栈中，我们利用这种遍历方式就可以防止右孩子的丢失了。由于栈是先进后出，所以我们先将右节点入栈。 12345678910111213141516public void preorder(TreeNode root) &#123; if (root == null) return; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); stack.push(root); while (!stack.empty()) &#123; TreeNode node = stack.pop(); System.out.println(node.val + " "); if (node.right != null) stack.push(node.right); if (node.left != null) stack.push(node.left); &#125;&#125; 之前我们的思路如下： 题目其实就是将二叉树通过右指针，组成一个链表。1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6 我们知道题目给定的遍历顺序其实就是先序遍历的顺序，所以我们可以利用先序遍历的代码，每遍历一个节点，就将上一个节点的右指针更新为当前节点。 先序遍历的顺序是 1 2 3 4 5 6。 遍历到 2，把 1 的右指针指向 2。1 -&gt; 2 3 4 5 6。 遍历到 3，把 2 的右指针指向 3。1 -&gt; 2 -&gt; 3 4 5 6。 因为我们用栈保存了右孩子，所以不需要担心右孩子丢失了。用一个 pre 变量保存上次遍历的节点。修改的代码如下： Java代码12345678910111213141516171819202122232425262728293031323334353637383940414243/** * @description: 将二叉树展开成linkedlist * @author: rhsphere * @since: 2019-11-05 14:42 by jdk 1.8 */public class FlattenBinaryTreeToList &#123; public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125; &#125; public void flatten(TreeNode root) &#123; if (root == null) return; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode pre = null; stack.push(root); while (!stack.empty()) &#123; TreeNode node = stack.pop(); /***********修改的地方*************/ if (pre != null) &#123; pre.right = node; pre.left = null; &#125; if (node.right != null) stack.push(node.right); if (node.left != null) stack.push(node.left); /***********修改的地方*************/ pre = node; &#125; &#125;&#125; 题目给定一个二叉树，原地将它展开为链表。 例如，给定二叉树 1 / \ 2 5 / \ \3 4 6将其展开为： 1 \ 2 \ 3 \ 4 \ 5 \ 6]]></content>
      <categories>
        <category>Medium</category>
      </categories>
      <tags>
        <tag>Tree</tag>
        <tag>mark</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[109. 有序链表转换二叉查找树]]></title>
    <url>%2F2019%2F11%2F05%2FConvert-Sorted-List-to-Binary-Search-Tree.html</url>
    <content type="text"><![CDATA[有序链表转换二叉查找树LeetCode 109 英文版 中文版 使用中序遍历，递归的方法 方法 3：中序遍历模拟 遍历整个链表获得它的长度，我们用两个指针标记结果数组的开始和结束，记为 start 和 end，他们的初始值分别为 0 和 length - 1。记住，我们当前需要模拟中序遍历，找到中间元素 (start + end) / 注意这里并不需要在链表中找到确定的元素是哪个，只需要用一个变量告诉我们中间元素的下标。我们只需要递归调用这两侧。 递归左半边，其中开始和结束的值分别为 start, mid - 1。 在这个算法中，每当我们构建完二叉搜索树的左半部分时，链表中的头指针将指向根节点或中间节点（它成为根节点）。 因此，我们只需使用头指针指向的当前值作为根节点，并将指针后移一位，即 head = head.next。 我们在递归右半部分 mid + 1, end。 Java代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * @description: * @author: rhsphere * @since: 2019-11-05 10:50 by jdk 1.8 */public class SortedListToBST &#123; public class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x; &#125; &#125; public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125; &#125; private ListNode head; public TreeNode sortedListToBST(ListNode head) &#123; int size = this.size(head); this.head = head; return this.convertListToBST(0, size-1); &#125; private int size(ListNode head) &#123; ListNode cur = head; int count = 0; while (cur != null) &#123; cur = cur.next; count++; &#125; return count; &#125; private TreeNode convertListToBST(int low, int high) &#123; if (low &gt; high) return null; int mid = (low + high) / 2; TreeNode left = this.convertListToBST(low, mid-1); TreeNode node = new TreeNode(this.head.val); node.left = left; this.head = this.head.next; node.right = this.convertListToBST(mid+1, high); return node; &#125;&#125; 题目给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。 本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。 示例: 给定的有序链表： [-10, -3, 0, 5, 9], 一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树： 0 / \ -3 9 / / -10 5]]></content>
      <categories>
        <category>Medium</category>
      </categories>
      <tags>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[098. 验证二叉查找树]]></title>
    <url>%2F2019%2F11%2F05%2Fvalid-binary-search-tree.html</url>
    <content type="text"><![CDATA[验证二叉查找树英文版中文版 这里使用树的中序遍历方法，参考树的中序-非递归遍历 注意一个错误 else分支中 cur = cur.right 是错误的！！！ Java代码12345678910111213141516171819202122232425262728293031/** * @description: 验证二叉搜索树 * @author: rhsphere * @since: 2019-11-05 09:37 by jdk 1.8 */public class IsValidBST &#123; public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125; &#125; public boolean isValidBST(TreeNode root) &#123; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode cur = root; double inorder = -Double.MAX_VALUE; while (!stack.empty() || cur != null) &#123; if (cur != null) &#123; stack.push(cur); cur = cur.left; &#125; else &#123; TreeNode node = stack.pop(); if (node.val &lt;= inorder) return false; inorder = node.val; cur = node.right; &#125; &#125; return true; &#125;&#125; 题目给定一个二叉树，判断其是否是一个有效的二叉搜索树。 假设一个二叉搜索树具有如下特征： 节点的左子树只包含小于当前节点的数。 节点的右子树只包含大于当前节点的数。 所有左子树和右子树自身必须也是二叉搜索树。 示例 1: 输入: 2 / \ 1 3输出: true示例 2: 输入: 5 / \ 1 4 / \ 3 6输出: false解释: 输入为: [5,1,4,null,null,3,6]。 根节点的值为 5 ，但是其右子节点值为 4 。]]></content>
      <categories>
        <category>Medium</category>
      </categories>
      <tags>
        <tag>Tree</tag>
        <tag>Inorder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0-1背包问题(回溯法)]]></title>
    <url>%2F2019%2F11%2F04%2F0-1-packages.html</url>
    <content type="text"><![CDATA[0-1背包有一个背包，背包的总承载重量是Wkg，现在有n个物品，每个物品的重量不等，并且不可分割。我们期望选择几件物品，装载到背包中。在不超过背包所能装载重量的前提下，如何让背包中物品的总重量最大？ 0-1背包问题的回溯实现技巧：第 13 行的递归调用表示不选择当前物品，直接考虑下一个（第 i+1 个），故 cw 不更新 第 15 行的递归调用表示选择了当前物品，故考虑下一个时，cw 通过入参更新为 cw + items[i] 函数入口处的 if 分支表明递归结束条件，并保证 maxW 跟踪所有选择中的最大值 123456789101112131415161718public class PkgDemo &#123; public int maxW = Integer.MIN_VALUE; // 存储背包中物品总重量的最大值 // cw 表示当前已经装进去的物品的重量和；i 表示考察到哪个物品了； // w 背包重量；items 表示每个物品的重量；n 表示物品个数 // 假设背包可承受重量 100，物品个数 10，物品重量存储在数组 a 中，那可以这样调用函数： // f(0, 0, a, 10, 100) public void f(int i, int cw, int[] items, int n, int w) &#123; if (cw == w || i == n) &#123; // cw==w 表示装满了 ;i==n 表示已经考察完所有的物品 if (cw &gt; maxW) maxW = cw; return; &#125; f(i + 1, cw, items, n, w); //当前物品不装进背包 if (cw + items[i] &lt;= w) &#123; // 已经超过可以背包承受的重量的时候，就不要再装了 f(i + 1, cw + items[i], items, n, w); //当前物品装进背包 &#125; &#125;&#125; Java代码0-1背包最大重量问题1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.ludepeng.datastruct.algorithm.backtrackingAlgorithm.packageZeroOne;/** * @description: 使用回溯的思想来解决0-1背包的问题 * * &lt;p&gt;解决的主要思路是通过回溯 * * &lt;p&gt;重点，对于每个物品来说，有装入背包与不装入背包两种选择，也就是需要考察每个有加入背包的情况与不加入的情况 * @author: rhsphere * @since: 2019-11-04 15:45 by jdk 1.8 */public class Package &#123; /** 背包中物品总重量的最大值 */ public int maxW = Integer.MIN_VALUE; /** * 计算最大放入的信息 * * &lt;p&gt;1，物品不能分隔 * * &lt;p&gt;2，在包中放入的数量不能超过maxNum * * &lt;p&gt;3，包装的总重量不能超过maxWeight * * @param index 当前物品索引 * @param sum 当前的总重量 * @param items 物品 * @param maxNum 最大的数物品的个数 * @param maxWeight */ public void countMaxPkg(int index, int sum, int[] items, int maxNum, int maxWeight) &#123; // 1. 如果当前重量到达最大总重量，或者数量达到最达限制，则设置当前最大值 if (index == maxNum || sum == maxWeight) &#123; // 检查当前是否已经超过了总上一个值 if (maxW &lt; sum) &#123; maxW = sum; &#125; return; &#125; //当前物品不装进背包里面 countMaxPkg(index + 1, sum, items, maxNum, maxWeight); // 如果当前还未超过最大值，则继续循环 if (sum + items[index] &lt;= maxWeight) &#123; countMaxPkg(index + 1, sum + items[index], items, maxNum, maxWeight); //当前物品装到背包里面 &#125; &#125;&#125; 0-1背包最大价值问题12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package com.ludepeng.datastruct.algorithm.backtrackingAlgorithm.packageZeroOne;/** * 使用回溯的思想来解决0-1背包的问题 * * &lt;p&gt;每个物品的重量不同，价值也不相同，在重量不超过背包重量的前提下，让背包的总价值最大化 * * &lt;p&gt;解决的主要思路是通过回溯 * * &lt;p&gt;重点，对于每个物品来说，有装入背包与不装入背包两种选择，也就是需要考察每个有加入背包的情况与不加入的情况 * @description: * @author: rhsphere * @since: 2019-11-04 16:09 by jdk 1.8 */public class PackageValue &#123; /** 背包中物品总重量的最大值 */ public int maxValue = Integer.MIN_VALUE; /** 当前背包的最大总重量 */ public int sumMaxWeight = Integer.MIN_VALUE; /** * 计算最大放入的信息 * * &lt;p&gt;1，物品不能分隔 * * &lt;p&gt;2，在包中放入的数量不能超过maxNum * * &lt;p&gt;3，包装的总重量不能超过maxWeight * * @param index 当前物品索引 * @param sumValue 当前的总重量 * @param items 物品 * @param maxNum 最大的数物品的个数 * @param maxWeight */ public void countMaxPkg( int index, int sumValue, int sumWeight, PkgValue[] items, int maxNum, int maxWeight) &#123; // 1,如果当前重量到达最大总重量，或者数量达到最达限制，则设置当前最大值 if (index == maxNum || sumWeight == maxWeight) &#123; // 检查总重量是否更重 if (sumMaxWeight &lt; sumWeight) &#123; sumMaxWeight = sumWeight; &#125; // 检查当前价值是否更大 if (maxValue &lt; sumValue) &#123; maxValue = sumValue; &#125; return; &#125; // 针对每个物品，有当前不加入背包中计算价值 countMaxPkg(index + 1, sumValue, sumWeight, items, maxNum, maxWeight); // 当前的最大总重量还是要小于限制值 if (sumWeight + items[index].getWeight() &lt;= maxWeight) &#123; // 针对每个物品，有当前加入背包计算价值 countMaxPkg( index + 1, sumValue + items[index].getValue(), sumWeight + items[index].getWeight(), items, maxNum, maxWeight); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Backtracking</category>
      </categories>
      <tags>
        <tag>Backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[八皇后问题]]></title>
    <url>%2F2019%2F11%2F04%2F8-queens.html</url>
    <content type="text"><![CDATA[八皇后问题一些笔记「为了有规律地枚举所有可能的解，避免遗漏和重复，把问题求解的过程分为多个阶段。每个阶段，都会面对一个岔路口，先随意选择一条路走，当发现这条路走不通的时候（不符合期望的解），就回退到上一个岔路口，另一种走法继续走。」 反复理解下：递归是一种栈结构的形式，最后一个入栈的最先执行完，然后返回上一层栈桢继续执行（对照八皇后的代码实现）。 八皇后是怎么打印出所有的解的？？ 理解是 首先是深度有点搜索找到最优的一组解，这时候打印输出，然后递归会返回到棋盘的倒数第二行（找到解后返回和遇到错误后是一样的）。 然后找到下一个可能的位置，一个位置能够放置ok，那么再到下一行，找可放置的位置，如果ok，就能输出第二种解； 直到第七行找完，就依次找第六行，知道最后一行都找不到了，即所有解都已经找到。 代码可以看成 第一行的循环*第二行的循环*第三行的循环* … *第八行的循环 下面代码中回溯算法非常隐蔽，其实是在 result[row] = col; 这一步，每次之前的值都会被替换。 Java代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182/** * @description: 八皇后问题 * @author: rhsphere * @since: 2019-11-04 10:52 by jdk 1.8 */public class MyEightQueen &#123; /** 八皇后问题的数 */ private static final int QUEEN_SIZE = 8; /** 用来进行队列结果的存储 */ private int[] result = new int[QUEEN_SIZE]; private int count = 1; /** * 八皇后问题求解 * @param row 行号 */ public void call8Queens(int row) &#123; // 如果当前已经到行的末尾，则打印当前的结果 if (row == QUEEN_SIZE) &#123; System.out.println(count++); print(result); return; &#125; // 进行当前列的遍历 for (int col = 0; col &lt; QUEEN_SIZE; col++) &#123; // 检查当前是否满足要求,如果满足，则设置result，并进行下一轮的遍历 if (isOK(row, col)) &#123; result[row] = col; call8Queens(row+1); &#125; &#125; &#125; /** * 检查当前行列是否满足要求 * * @param row 行信息 * @param col 列信息 * @return true 满足要求 false 不满足要求 */ private boolean isOK(int row, int col) &#123; int leftup = col - 1; int rightup = col + 1; // 按行逐行向上进行遍历 for (int i = row - 1; i &gt;= 0; i--) &#123; // 1，检查当前行是否已经设置 if (result[i] == col) return false; // 2，检查左上部分是否被放置了棋子 if (leftup &gt;= 0 &amp;&amp; result[i] == leftup) return false; // 进行右上部分的检查是否被放置了棋子 if (rightup &lt; QUEEN_SIZE &amp;&amp; result[i] == rightup) retrun false; // 左上部分继续向左上 leftup++; rightup++; &#125; &#125; /** * 打印当前匹配的结果 * * @param result */ private void print(int[] result) &#123; for (int row = 0; row &lt; QUEEN_SIZE; row++) &#123; for (int col = 0; col &lt; QUEEN_SIZE; col++) &#123; if (result[row] == col) &#123; System.out.print("Q "); &#125; else &#123; System.out.print("* "); &#125; &#125; System.out.println(); &#125; System.out.println(); &#125;&#125; 代码更加显式地展现回溯https://www.geeksforgeeks.org/n-queen-problem-backtracking-3/ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109/* Java program to solve N Queen Problem using backtracking */public class NQueenProblem &#123; final int N = 4; /* A utility function to print solution */ void printSolution(int board[][]) &#123; for (int i = 0; i &lt; N; i++) &#123; for (int j = 0; j &lt; N; j++) System.out.print(" " + board[i][j] + " "); System.out.println(); &#125; &#125; /* A utility function to check if a queen can be placed on board[row][col]. Note that this function is called when "col" queens are already placeed in columns from 0 to col -1. So we need to check only left side for attacking queens */ boolean isSafe(int board[][], int row, int col) &#123; int i, j; /* Check this row on left side */ for (i = 0; i &lt; col; i++) if (board[row][i] == 1) return false; /* Check upper diagonal on left side */ for (i = row, j = col; i &gt;= 0 &amp;&amp; j &gt;= 0; i--, j--) if (board[i][j] == 1) return false; /* Check lower diagonal on left side */ for (i = row, j = col; j &gt;= 0 &amp;&amp; i &lt; N; i++, j--) if (board[i][j] == 1) return false; return true; &#125; /* A recursive utility function to solve N Queen problem */ boolean solveNQUtil(int board[][], int col) &#123; /* base case: If all queens are placed then return true */ if (col &gt;= N) return true; /* Consider this column and try placing this queen in all rows one by one */ for (int i = 0; i &lt; N; i++) &#123; /* Check if the queen can be placed on board[i][col] */ if (isSafe(board, i, col)) &#123; /* Place this queen in board[i][col] */ board[i][col] = 1; /* recur to place rest of the queens */ if (solveNQUtil(board, col + 1) == true) return true; /* If placing queen in board[i][col] doesn't lead to a solution then remove queen from board[i][col] */ board[i][col] = 0; // BACKTRACK &#125; &#125; /* If the queen can not be placed in any row in this colum col, then return false */ return false; &#125; /* This function solves the N Queen problem using Backtracking. It mainly uses solveNQUtil () to solve the problem. It returns false if queens cannot be placed, otherwise, return true and prints placement of queens in the form of 1s. Please note that there may be more than one solutions, this function prints one of the feasible solutions.*/ boolean solveNQ() &#123; int board[][] = &#123; &#123; 0, 0, 0, 0 &#125;, &#123; 0, 0, 0, 0 &#125;, &#123; 0, 0, 0, 0 &#125;, &#123; 0, 0, 0, 0 &#125; &#125;; if (solveNQUtil(board, 0) == false) &#123; System.out.print("Solution does not exist"); return false; &#125; printSolution(board); return true; &#125; // driver program to test above function public static void main(String args[]) &#123; NQueenProblem Queen = new NQueenProblem(); Queen.solveNQ(); &#125; &#125; // This code is contributed by Abhishek Shankhadhar]]></content>
      <categories>
        <category>Backtracking</category>
      </categories>
      <tags>
        <tag>Backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[03. Longest Substring Without Repeating Character]]></title>
    <url>%2F2019%2F10%2F29%2Flongest-substring-without-repeating-characters.html</url>
    <content type="text"><![CDATA[无重复字符的最长子串剑指offer中的实现，最长不含重复字符的子字符串，采用的是动态规划。 这里用另一种思路，哈希表存储最后出现的字符的下标。用ascii码值来当做key。 开始使用 长度为26的数组当做哈希表，但是发现这里还有空格，所以使用了 长度为256的数组。 Java代码–动态规划1234567891011121314151617181920212223242526272829303132333435/** * @description: * @author: rhsphere * @since: 2019-10-29 12:36 by jdk 1.8 */public class LongestSubString &#123; public static int maxLength(String s) &#123; if (s == null || s.length() &lt;= 0) //总是会把字符串的长度写错 return 0; int[] hash = new int[256]; for (int i = 0; i &lt; 256; i++) hash[i] = -1; int pre = 0; int cur = 0; int max = 0; for (int i = 0; i &lt; s.length(); i ++) &#123; char ch = s.charAt(i); if (hash[ch] &lt; 0 || i - hash[ch] &gt; pre) &#123; cur = pre + 1; &#125; else &#123; cur = i - hash[ch]; &#125; hash[ch] = i; if (cur &gt; max) max = cur; pre = cur; &#125; return max; &#125;&#125; Java代码123456789101112131415161718192021222324252627282930/** * @description: * @author: rhsphere * @since: 2019-10-29 15:13 by jdk 1.8 */public class LongestSubString2 &#123; public int lengthOfLongestSubstring(String s) &#123; if(s == null || s.length() &lt;= 0) return 0; int[] hash = new int[256]; for(int i = 0;i &lt; 256; i++) hash[i] = -1; int max = 0; int start=0; for(int i = 0; i &lt; s.length(); i++) &#123; char ch = s.charAt(i); if(hash[ch] &gt;= start) start = hash[ch] + 1; max = Math.max(i - start + 1, max); hash[ch] = i; &#125; return max; &#125;&#125;]]></content>
      <categories>
        <category>Medium</category>
      </categories>
      <tags>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer(67) 把字符串转换成整数]]></title>
    <url>%2F2019%2F10%2F29%2Fstring-to-int-atoi.html</url>
    <content type="text"><![CDATA[把字符串转换成整数 请你写一个函数StrToInt，实现把字符串转换成整数这个功能。当然，不能使用atoi或者其他类似的库函数。 参考leetcode 008 Java 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * @description: 参考leetcode008，这里放上牛客网的代码 * @author: rhsphere * @since: 2019-10-29 12:15 by jdk 1.8 */public class StringToInteger &#123; public int strToInt(String str) &#123; if (str == null || str.length() &lt;= 0) return 0; String tmp = str.trim(); if (tmp == "" || tmp.length() &lt;= 0) return 0; char[] chars = tmp.toCharArray(); int i = 0; int res = 0; int digit; boolean isPos = true; if (chars[i] == '-') isPos = false; if (chars[i] == '-' || chars[i] == '+') i++; for (; i &lt; chars.length; i++) &#123; //这里的i++，如果用while循环容易遗漏 if (chars[i] &gt;= '0' &amp;&amp; chars[i] &lt;= '9') &#123; digit = chars[i] - '0'; &#125; else &#123; return 0; &#125; //超过最大值，和leetcode008对比 if (res &gt; Integer.MAX_VALUE/10 || (res == Integer.MAX_VALUE/10 &amp;&amp; digit &gt; 7)) &#123; if (!isPos &amp;&amp; digit == 8) &#123; //但如果是负数最大值，返回 return Integer.MIN_VALUE; &#125; else &#123; //正数最大值返回0 return 0; &#125; &#125; res = res * 10 + digit; &#125; return isPos ? res : -res; &#125;&#125; 总结 记住int类型最大正整数为0x7FFFFFFF，最小负整数为0x80000000。]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[008. String to Integer(atoi)]]></title>
    <url>%2F2019%2F10%2F29%2Fstring-to-integer.html</url>
    <content type="text"><![CDATA[字符串转换整数 (atoi)LeetCode 8 英文版 中文版 题目请你来实现一个 atoi 函数，使其能将字符串转换成整数。 首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。 当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。 该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。 注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。 在任何情况下，若函数不能进行有效的转换时，请返回 0。 说明： 假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231, 231 − 1]。如果数值超过这个范围，请返回 INT_MAX (2^31 − 1) 或 INT_MIN (−2^31) 。 示例 1: 输入: “42”输出: 42示例 2: 输入: “ -42”输出: -42解释: 第一个非空白字符为 ‘-‘, 它是一个负号。 我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。示例 3: 输入: “4193 with words”输出: 4193解释: 转换截止于数字 ‘3’ ，因为它的下一个字符不为数字。示例 4: 输入: “words and 987”输出: 0解释: 第一个非空字符是 ‘w’, 但它不是数字或正、负号。 因此无法执行有效的转换。示例 5: 输入: “-91283472332”输出: -2147483648解释: 数字 “-91283472332” 超过 32 位有符号整数范围。 因此返回 INT_MIN (−231) 。 Java代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package algo09.string.leetcode_008;/** * @description: * @author: rhsphere * @since: 2019-10-29 10:52 by jdk 1.8 */public class MyAtoi &#123; public static int myAtoi(String str) &#123; if (str == null || str.length() &lt;= 0) return 0; String tmp = str.trim(); if (tmp == "" || tmp.length() == 0) return 0; boolean isPos = true; char[] chars = tmp.toCharArray(); int i = 0; int res = 0; int num = 0; if (chars[0] == '-') isPos = false; if (chars[0] == '+' || chars[0] == '-') i++; while (i &lt; chars.length) &#123; //这样写 很容易忘掉 i++ 所以建议写成 for循环 if (chars[i] &gt;= '0' &amp;&amp; chars[i] &lt;= '9') &#123; num = chars[i] - '0'; &#125; else &#123; break; &#125; if (res &gt; Integer.MAX_VALUE/10 || (res == Integer.MAX_VALUE/10 &amp;&amp; num &gt; 7)) &#123; return isPos ? Integer.MAX_VALUE : Integer.MIN_VALUE; &#125; res = res * 10 + num; i++; //这里的条件一定要加上 &#125; return isPos ? res : -res; &#125; public static void main(String[] args) &#123; String string = " -91283472 like you"; System.out.println(myAtoi(string)); &#125;&#125; 总结 很容易忘记 i++的条件，所以这种while 循环 也建议写成for循环 123456789101112for (; i &lt; chars.length; i++) &#123; if (chars[i] &gt;= '0' &amp;&amp; chars[i] &lt;= '9') &#123; digit = chars[i] - '0'; &#125; else &#123; break; &#125; if (res &gt; Integer.MAX_VALUE/10 || (res == Integer.MAX_VALUE/10 &amp;&amp; digit &gt; 7)) &#123; return isPos ? Integer.MAX_VALUE : Integer.MIN_VALUE; &#125; res = res*10 + digit; &#125;]]></content>
      <categories>
        <category>008</category>
      </categories>
      <tags>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[151. Reverse Words in a String]]></title>
    <url>%2F2019%2F10%2F29%2F151.html</url>
    <content type="text"><![CDATA[翻转字符串里的单词LeetCode 151 英文版 中文 题目给定一个字符串，逐个翻转字符串中的每个单词。 示例: 输入: “the sky is blue”,输出: “blue is sky the”.说明: 无空格字符构成一个单词。 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。 进阶: 请选用C语言的用户尝试使用 O(1) 空间复杂度的原地解法。 Java代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package algo09.string.leetcode_151;/** * @description: 翻转字符串，这里需要三步， *第一步把整个句子翻转，第二步把每个单词翻转，第三步删除多余的空格 * @author: rhsphere * @since: 2019-10-28 23:54 by jdk 1.8 */public class ReverseWords &#123; public String reverseWords(String s) &#123; if (s == null || s.length() &lt;= 0) return s; char[] chars = s.toCharArray(); //第一步把整个句子翻转 reverse(chars, 0, chars.length - 1); int start = 0; int end = 0; // 第二步把每个单词翻转 while (start &lt; chars.length) &#123; while (end &lt; chars.length &amp;&amp; chars[end] != ' ') end++; reverse(chars, start, end - 1); //这里是end-1 start = ++end; &#125; // 第三步删除多余的空格 return cleanSpace(chars); &#125; private void reverse(char[] chars, int start, int end) &#123; while (start &lt; end) &#123; char tmp = chars[start]; chars[start] = chars[end]; chars[end] = tmp; start++; end--; &#125; &#125; private String cleanSpace(char[] chars) &#123; int i = 0; int j = 0; while (j &lt; chars.length) &#123; while (j &lt; chars.length &amp;&amp; chars[j] == ' ') j++; while (j &lt; chars.length &amp;&amp; chars[j] != ' ') chars[i++] = chars[j++]; while (j &lt; chars.length &amp;&amp; chars[j] == ' ') j++; if (j &lt; chars.length) chars[i++] = ' '; &#125; return new String(chars).substring(0, i); //不是 subString &#125;&#125;]]></content>
      <categories>
        <category>Medium</category>
      </categories>
      <tags>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AC自动机]]></title>
    <url>%2F2019%2F10%2F28%2Faho-corasick.html</url>
    <content type="text"><![CDATA[AC自动机多模式串匹配算法AC自动机适合大量文本中多模式串的精确匹配查找，可以到O(n) AC自动机实际上就是在Trie树之上，加了类似KMP的next数组，只不过此处的next数组是构建在树上罢了。 12345678910public class AcNode &#123; public char data; public AcNode[] children = new AcNode[26]; //z字符集只包含a~z这26个字符 public boolean isEndingChar = false; //结尾字符为true public int length = -1; //当isEndingChar为true时，记录模式串长度 public AcNode fail; //失败指针 public AcNode(char data) &#123; this.data = data; &#125;&#125; AC自动机的构建，包含两个操作： 将多个模式串构建成Trie树； 在Trie树上构建失败指针（相当于KMP中的失效函数next数组）。 Java代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216package com.ludepeng.datastruct.base.datastruct.charMath.ahoCorasick;import java.util.LinkedList;import java.util.Queue;/** * @description: ac自动机的实现 * 只是简单的阅读了源码和debug，需要回顾ac自动机和kmp * @author: rhsphere * @since: 2019-10-28 23:26 by jdk 1.8 */public class AhoCorasick &#123; private static final char CHARA = 'a'; private static final int CHAR_LENGTH = 26; public class AcNode &#123; public char data; public AcNode[] children = new AcNode[CHAR_LENGTH]; /** 结尾字符为true */ public boolean isEndingChar = false; /** 当isEndingChar为true时，记录模式串长度 */ public int length; /** 失败指针 */ public AcNode fail; public AcNode(char data) &#123; this.data = data; &#125; @Override public String toString() &#123; final StringBuilder sb = new StringBuilder("AcNode&#123;"); sb.append("data=").append(data); sb.append('&#125;'); return sb.toString(); &#125; &#125; private AcNode root = new AcNode('/'); /** * 构建Ac自动机的节点，即插入数据 * * @param values 值信息 */ public void add(String values) &#123; char[] charValues = values.toCharArray(); AcNode procNode = root; for (int i = 0; i &lt; charValues.length; i++) &#123; int ascIndex = charValues[i] - CHARA; if (procNode.children[ascIndex] == null) &#123; AcNode childArrays = new AcNode(charValues[i]); procNode.children[ascIndex] = childArrays; &#125; procNode = procNode.children[ascIndex]; &#125; procNode.length = charValues.length; procNode.isEndingChar = true; &#125; /** 自己构建失败的节点关联关系 */ public void buildFailNode() &#123; Queue&lt;AcNode&gt; queue = new LinkedList&lt;&gt;(); queue.add(root); while (!queue.isEmpty()) &#123; AcNode queuOneNode = queue.remove(); // 遍成子节点，找出与之对应的失败节点 for (int i = 0; i &lt; CHAR_LENGTH; i++) &#123; AcNode nodeTwo = queuOneNode.children[i]; // 当前子节点为空，直接跳过 if (null == nodeTwo) &#123; continue; &#125; // 如果当前节点为根节点，直接写失败节点信息 if (queuOneNode == root) &#123; nodeTwo.fail = root; &#125; // 遍历查找子节点为其设置根节点 else &#123; AcNode currFail = queuOneNode.fail; while (currFail != null) &#123; // 检查在子节点中是否匹配当前的子节点信息 int ascIndex = nodeTwo.data - CHARA; AcNode twoNode = currFail.children[ascIndex]; // 如果在子节点信息中被找到，则设置当前子节的失败节点为找到的节点 if (twoNode != null) &#123; nodeTwo.fail = twoNode; break; &#125; currFail = currFail.fail; &#125; // 如果查找到最后也没有找到，则设置为根节点 if (null == currFail) &#123; nodeTwo.fail = root; &#125; &#125; queue.add(nodeTwo); &#125; &#125; &#125; public void match(String src) &#123; char[] srcChars = src.toCharArray(); int length = srcChars.length; AcNode node = root; for (int i = 0; i &lt; length; i++) &#123; int ascInx = srcChars[i] - CHARA; // 当当前节点中不存在此索引下标，并且不等于root节点 while (node.children[ascInx] == null &amp;&amp; node != root) &#123; node = node.fail; &#125; node = node.children[ascInx]; // 如果未发生匹配，则从root节点开始进行匹配 if (node == null) &#123; node = root; &#125; AcNode matchNode = node; while (matchNode != root) &#123; if (matchNode.isEndingChar == true) &#123; int pos = i - matchNode.length + 1; System.out.println("匹配开始下标:" + pos + ";长度" + matchNode.length); &#125; matchNode = matchNode.fail; &#125; &#125; &#125; public void myMatch(String src) &#123; char[] srcArrays = src.toCharArray(); // 从根节点开始检查 AcNode currNode = root; for (int i = 0; i &lt; srcArrays.length; i++) &#123; // 计算在数据中的下标位置 int currAscIndex = srcArrays[i] - CHARA; // 首先检查前一个节点下是否可以匹配当前节点,不能匹配，则查找前一节点的失败节点 while (currNode.children[currAscIndex] == null &amp;&amp; currNode != root) &#123; currNode = currNode.fail; &#125; // 将处理节点指向能匹配的的节点 currNode = currNode.children[currAscIndex]; // 如果节点为空，则默认使用root节点 if (currNode == null) &#123; currNode = root; &#125; AcNode pringNode = currNode; // 进行匹配打印 while (pringNode != root) &#123; if (pringNode.isEndingChar) &#123; int index = i - pringNode.length + 1; System.out.println("计算得到的当前的节点索引为:" + index + "，字符中为" + pringNode.length); &#125; pringNode = pringNode.fail; &#125; &#125; &#125; public void printFailNode() &#123; AcNode node = root; Queue&lt;AcNode&gt; queue = new LinkedList&lt;&gt;(); queue.add(root); AcNode nodeItem = null; while (!queue.isEmpty()) &#123; nodeItem = queue.remove(); if (nodeItem != null) &#123; AcNode[] childs = nodeItem.children; for (int i = 0; i &lt; childs.length; i++) &#123; if (childs[i] != null) &#123; queue.add(childs[i]); &#125; &#125; &#125; System.out.println("当前节点为:" + nodeItem.data + "，失败指针为:" + nodeItem.fail); &#125; &#125;&#125;]]></content>
      <categories>
        <category>String</category>
      </categories>
      <tags>
        <tag>String</tag>
        <tag>Char Match</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Trie树]]></title>
    <url>%2F2019%2F10%2F28%2Ftrie.html</url>
    <content type="text"><![CDATA[Trie树Trie树 单模式串匹配有 BF、RK、naive-BM和KMP这四种算法。 本节实现的是一种 naive-TrieTrie树适合多模式串公共前缀较多的匹配（O(n*k)）或者 根据公共前缀进行查找 O(k)的经典场景，比如搜索框的自动补全提示。 针对一组字符串中查找字符串的问题，在工程中，更倾向于用散列表或者红黑树。Trie树不适合精确匹配查找。Trie树比较适合的是查找前缀匹配的字符串。 Java代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149package com.ludepeng.datastruct.base.datastruct.charMath.trie;import java.util.ArrayList;import java.util.HashSet;import java.util.List;import java.util.Set;/** * @description: * @author: rhsphere * @since: 2019-10-28 10:51 by jdk 1.8 */public class MyTrie &#123; /** 字符a的asc码值 */ private static final char CHARA = 'a'; private TrieNode root = new TrieNode('/'); /** trie 树的基本节点信息 */ public class TrieNode &#123; /** 当前节点的值 */ public char data; /** 子节点的信息 */ public TrieNode[] children = new TrieNode[26]; /** 用来标识当前是否被全完匹配 */ public boolean isEndChar = false; public TrieNode(char data) &#123; this.data = data; &#125; &#125; /** * 向trie树中插入一个字符 * @param addVal 字符信息 */ public void insert(String addVal) &#123; char[] charData = addVal.toCharArray(); TrieNode procNode = root; for (int i = 0; i &lt; charData.length; i++) &#123; //计算当前字符的asc码值 int ascVal = charData[i] - CHARA; if (procNode.children[ascVal] == null) &#123; TrieNode newNode = new TrieNode(charData[i]); procNode.children[ascVal] = newNode; &#125; procNode = procNode.children[ascVal]; &#125; procNode.isEndChar = true; &#125; /** * 查找一个trie树 * * @param pat 字符信息 * @return 是否能被查找到 */ public boolean search(String pat) &#123; char[] charsData = pat.toCharArray(); TrieNode procNode = root; for (int i = 0; i &lt; charsData.length; i++) &#123; int ascVal = charsData[i] - CHARA; if (procNode.children[ascVal].data != charsData[i]) &#123; return false; &#125; procNode = procNode.children[ascVal]; &#125; if (!procNode.isEndChar) &#123; return false; &#125; else &#123; return true; &#125; &#125; public Set&lt;String&gt; search2(String pat) &#123; char[] charsData = pat.toCharArray(); TrieNode proc = root; for (int i = 0; i &lt; charsData.length; i++) &#123; int index = charsData[i] - CHARA; if (proc.children[index] == null) &#123; return null; &#125; proc = proc.children[index]; &#125; List&lt;Character&gt; matchOthers = new ArrayList&lt;&gt;(); for (int i = 0; i &lt;= charsData.length - 1; i++) &#123; matchOthers.add(charsData[i]); &#125; Set&lt;String&gt; mvalueSet = new HashSet&lt;&gt;(); addMatches(matchOthers, mvalueSet, proc); return mvalueSet; &#125; public void addMatches(List&lt;Character&gt; matchOthers, Set&lt;String&gt; matchValue, TrieNode node) &#123; if (node != null) &#123; matchOthers.add(node.data); //检查是否是最后一级 boolean isLast = true; for (int i = 0; i &lt; node.children.length; i++) &#123; if (node.children[i] != null) isLast = false; &#125; if (isLast) &#123; char[] msgChars = new char[matchOthers.size()]; for (int i = 0; i &lt; matchOthers.size(); i++) &#123; msgChars[i] = matchOthers.get(i); &#125; matchValue.add(new String(msgChars)); return; &#125; &#125; else &#123; return; &#125; for (TrieNode nodeItem : node.children) &#123; int befSize = matchOthers.size(); addMatches(matchOthers, matchValue, nodeItem); int afterSize = matchOthers.size(); if (afterSize &gt; befSize) &#123; // 完成后需要移除最后一次添加的内容，数据，防止数据重复 matchOthers.remove(matchOthers.size() - 1); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>String</category>
      </categories>
      <tags>
        <tag>Tree</tag>
        <tag>String</tag>
        <tag>Char Match</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[KMP算法]]></title>
    <url>%2F2019%2F10%2F28%2Fkmp.html</url>
    <content type="text"><![CDATA[KMP算法KMP算法 文章讲的比较系统了。 next函数，这个文章有助于看懂next函数是怎么一回事。 适合所有场景，整体实现起来也比BM简单，O(n+m)，仅需要一个next数组的O(n)额外空间；但统计意义下似乎BM更快，原因不明。 匹配失败时，总能够让pat回退到某个位置，而不是全部回退，而src不用回退。 在字符串比较时，pat提供的信息越多，计算复杂度越低。 最难理解的地方是k = next[k]因为前一个的最长串的下一个字符不与最后一个相等，需要找前一个的次长串，问题就变成了求0到next[k]的最长串，如果下个字符与最后一个不等，也就是下一个next[k]，直到找到，或者完全没有。 Java代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package com.ludepeng.datastruct.base.datastruct.charMath.diffculty.kmp;/** * @description: kmp算法 * @author: rhsphere * @since: 2019-10-28 10:31 by jdk 1.8 */public class Kmp &#123; /** * 使用kmp算法进行字符串的查找 * @param src 主串 * @param pat 模式串 * @return 模式串在主串中的下标 */ public int kmp(String src, String pat) &#123; char[] srcCharArr = src.toCharArray(); char[] patCharArr = pat.toCharArray(); int n = srcCharArr.length; int m = patCharArr.length; int location = -1; //通过模式串构建next数组 int[] nexts = this.getNext(patCharArr); int j = 0; for (int i = 0; i &lt; n; i++) &#123; //从前向后匹配，当发生不匹配的时候，将模式串回退到合适的位置 //模式串不是回退到0，而是回退到 次最长可匹配前缀子串 whlie (j &gt; 0 &amp;&amp; srcCharArr[i] != patCharArr[j]) &#123; j = nexts[j-1] + 1; &#125; if (srcCharArr[i] == patCharArr[j]) j++; if (j == m) return i - m + 1; &#125; return location; &#125; /** * 对模式串预处理，获得一个存储模式串中每个前缀的最长可匹配前缀子串的结尾字符的下标 * @param patCharArr 模式串 * @return next数组，或失效函数 */ public int[] getNext(char[] patCharArr) &#123; int m = patCharArr.length; int[] next = new int[m]; next[0] = -1; int k = -1; for (int i = 1; i &lt; m; i++) &#123; while (k &gt;= 0 &amp;&amp; patCharArr[k+1] != patCharArr[i]) &#123; k = next[k]; //找到次最长可匹配前缀子串 &#125; if (patCharArr[i] == patCharArr[k+1]) k++; next[k] = k; &#125; return next; &#125;&#125; 总结 getNext的代码并不难理解，但是由于 文字描述比较绕口，所以看文字很难一下子体会到，仍然建议使用单元测试来debug 调试跟踪内存，多打断点就能体会到妙处。 放上单元测试的代码 1234567891011121314151617181920212223242526272829package com.ludepeng.datastruct.base.datastruct.charMath.diffculty.kmp.demo;/** * @description: 测试getnext函数 * @author: rhsphere * @since: 2019-10-28 17:37 by jdk 1.8 */public class GetNext &#123; public int[] getNext(char[] patCharArr) &#123; int m = patCharArr.length; int[] next = new int[m]; next[0] = -1; int k = -1; //k为前缀最长可匹配前缀子串的结尾字符下标 for (int i = 1; i &lt; m; i++) &#123; while (k &gt;= 0 &amp;&amp; patCharArr[k+1] != patCharArr[i]) &#123; k = next[k]; &#125; if (patCharArr[i] == patCharArr[k+1]) &#123; k++; //找到次最长可匹配前缀子串 &#125; next[i] = k; &#125; return next; &#125;&#125; 12345678910111213141516171819202122232425262728293031package com.ludepeng.datastruct.base.datastruct.charMath.diffculty.kmp.demo;import org.junit.Test;import java.util.Arrays;/** * @description: 测试next函数 * @author: rhsphere * @since: 2019-10-28 17:45 by jdk 1.8 */public class TestGetNext &#123; @Test public void testGetNext() &#123; GetNext instance = new GetNext(); String pat1 = "ababacd"; char[] patCharArr1 = pat1.toCharArray(); int[] next1 = instance.getNext(patCharArr1); System.out.println(Arrays.toString(next1)); String pat2 = "abababzabababa"; char[] patCharArr2 = pat2.toCharArray(); int[] next2 = instance.getNext(patCharArr2); System.out.println(Arrays.toString(next2)); &#125;&#125;]]></content>
      <categories>
        <category>String</category>
      </categories>
      <tags>
        <tag>String</tag>
        <tag>Char Match</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BM算法]]></title>
    <url>%2F2019%2F10%2F28%2Fboyer-moore.html</url>
    <content type="text"><![CDATA[BM算法native-BM 模式串最好不要太长（因为预处理较重），比如IDE编辑器里的查找场景；预处理O(m*m)，匹配O(n)，实现较复杂，需要较多额外空间。 坏字符规则从后往前逐位比较模式串与主串的字符，当找到不匹配的坏字符时，记录模式串的下标值 si ，并找到坏字符在模式串中，位于下标 si前的最近位置 xi （若无则记为-1），si - xi 即为向后滑动距离。 但是坏字符规则向后滑动的步幅还不够大，于是需要好后缀规则。 将模式串中的每个字符及其下标都存在 哈希表中，这样可以快速找到坏字符在模式串的位置下标。相同的模式串字符，仅记录最后的位置。 好后缀规则从后往前逐位比较模式串和主串的字符，当出现坏字符时停止。 若已经存在匹配成功的子串 {u}, 那么模式串的 {u} 前面找到最近的 {u}，记为 {u’}。 再将模式串后裔，是的模式串的 {u’} 与主串的 {u} 重叠。若不存在 {u’}，则直接把模式串移到主串的 {u} 后面。为了没有遗漏，还需要找到最长的、能够跟模式串的最长前缀子串匹配的，好后缀的后缀子串（同时也是模式串的后缀子串）。然后把模式串向后移动到其左边界，与这个好后缀个后缀子串在主串的中的左边界对齐。 好后缀的处理规则中最核心的内容： 在模式串中，查找跟好后缀匹配的另一个子串； 在好后缀的后缀子串中，查找最长的、能跟模式串前缀子串匹配的后缀子串。 技巧： 每次执行好后缀原则时，都会计算多次能够与模式串前缀子串相匹配的好后缀的最长后缀子串。为了提高效率，可以预先计算模式串的所有后缀子串，在模式串与之匹配的另一个子串的位置。同时预计算模式串中（同长度）后缀子串与前缀子串是否匹配并记录。在具体操作中直接使用，大大提高效率。 如何快速记录模式串后缀子串匹配的另一个子串位置，以及模式串（相同长度）前缀与后缀子串是否匹配呢？ 先用一个suffix数组，下标值k为后缀子串的长度，从模式串下标为i （0 ~ m-2）的字符为最后一个字符，查找这个子串是否与后缀子串匹配，若匹配则将子串起始位置的下标值j赋给suffix[k]。 若j为0，说明这个匹配子串的起始位置为模式串的起始位置，则用一个数组prefix，将prefix[k]设为true，否则设为false。k从0到m（模式串的长度）于是就得到了模式串所有前缀与后缀子串的匹配情况。 Java代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142package com.ludepeng.datastruct.base.datastruct.charMath.diffculty.bm;/** * @description: bm 算法，用来进行高效的字符串查找 * @author: rhsphere * @since: 2019-10-28 09:41 by jdk 1.8 */public class BoyerMoore &#123; private static final int BYTE_SIZE = 256； public int bm(String src, String pat) &#123; int location = -1; char[] srcCharArr = src.toCharArray(); char[] patCharArr = pat.toCharArray(); int n = srcCharArr.length; int m = patCharArr.length; //构建模式串哈希，记录每一个字符最后出现的位置 int[] bcCodes = this.generateCode(patCharArr); //tag. 填充suffix和preffix数组 int[] suffix = new int[m]; boolean[] prefix = new boolean[m]; //进行前缀数组和后缀数组所需的运算 this.generateGS(patCharArr, suffix, prefix); // 主串与模式串对齐的第一个字符 int i = 0; while (i &lt;= n - m) &#123; int j; for (j = m - 1; j &gt;= 0; j--) &#123; if (srcCharArr[i + j] != patCharArr[j]) break; &#125; if (j &lt; 0) return i; // 1.srcCharArr[i+j] 标识当前1坏字符的位置 // 2.把坏字符串在模式串的起始位置记为 si，当前使用j标识 // 3. 然后去模式串查找坏字符串最后出现的位置 xi，当前为bcCodes[srcCharArr[i+j]] // 4.命名用 si - xi，即为需要移动的位数，所以 j - bcCodes[srcCharArr[i+j]] // 计算向后滑动的位数，先不考虑为负的情况 int badCount = j - bcCodes[srcCharArr[i+j]]; int y = 0; if (j &lt; m-1) &#123; y = moveGS(j, m, suffix, prefix); //在tag。处预处理pat串得到 suffix和prefix数组 &#125; i = i + Math.max(badCount, y); &#125; return location; &#125; /** * 生成哈希表，记录模式串每一个字符最后出现的位置 * @param patCharArr pat串 * @return 生成的模式串所对应的hashcode表 */ private int[] generateCode(Char[] patCharArr) &#123; int[] bcCode = new int[BYTE_SIZE]; for (int i = 0; i &lt; BYTE_SIZE; i++) &#123; bcCode[i] = -1; &#125; for (int i = 0; i &lt; patCharArr.length; i++) bcCode[patCharArr[i]] = i; return bcCode; &#125; /** * 用来计算suffix 结合 prefix数组的信息 * 在模式串 中，查找跟好后缀匹配的另一个子串 * 在好后缀中，查找最长的，能跟模式串前缀子串匹配的后缀子串 * @param patCharArr 模式串信息 * @param suffix 后缀子串在前缀子串中的起始下标 * @param prefix 后缀子串是否能匹配前缀子串 */ private void generateGS(char[] patCharArr, int[] suffix, boolean[] prefix) &#123; // 初始化两个数组 int len = patCharArr.length; for (int i = 0; i &lt; len; i++) &#123; suffix[i] = -1; prefix[i] = false; &#125; // 计算填充两个模式串中的信息 for (int i = 0; i &lt; len - 1; i++) &#123; //patCharArr[0 ... i] int j = i; int k = 0; while (j &gt;= 0 &amp;&amp; patCharArr[j] == patCharArr[len - k - 1]) &#123; j--; k++; &#125; if (k != 0) &#123; // j+1表示公共后缀子串在 patCharArr[0,i]中的起始下标 suffix[k] = j + 1; &#125; //如果是公共后缀子串，也是模式后缀串的前缀子串 if (j == -1) prefix[k] = true; &#125; &#125; /** * @param j 坏字符在模式串的位置 * @param m 模式串的长度 * @param suffix 好后缀长度对应的起始索引 * @param prefix 是否与前缀字符匹配 * @return 移动的长度 */ private int moveGS(int j, int m, int[] suffix, int[] prefix) &#123; //好后缀的长度 int k = m - 1 -j; //规则1. 在模式串中，查找跟好后缀匹配的另一个子串 if (suffix[k] != -1) return j - suffix[k] + 1; //规则2. 在好后缀的后缀子串中，查找最长的、能跟模式串前缀子串匹配的后缀子串 // j 为坏字符串的位置 j+1为好后缀的位置 j+2为好后缀的子串开始位置 for (int i = j + 2; i &lt; m-1; i++) &#123; if (prefix[m-i+1]) &#123; return i; &#125; &#125; return j+1; &#125;&#125; 12345678910111213141516171819202122232425package com.ludepeng.datastruct.base.datastruct.charMath.diffculty.bm;import org.junit.Test;/** * @description: * @author: rhsphere * @since: 2019-10-28 10:23 by jdk 1.8 */public class TestBoyerMoore &#123; @Test public void testBm() &#123; String src = "this ludepeng"; String find = "ludepeng"; BoyerMoore instance = new BoyerMoore(); int index = instance.bm(src, find); System.out.println(index); if (index != -1) &#123; System.out.println("截取后:" + src.substring(index, index + find.length())); &#125; &#125;&#125; 总结 对于一段代码不理解，可以使用Test进行debug，看看如何执行的，极大提高对这段代码执行流程的理解！！！！ 比如生成suffix和prefix数组的这段代码的测试 123456789101112131415161718192021222324252627282930package com.ludepeng.datastruct.base.datastruct.charMath.diffculty.bm.demo;/** * @description: 生成suffix和prefix字符串的代码 * @author: rhsphere * @since: 2019-10-28 14:51 by jdk 1.8 */public class GenerateGS &#123; // b表示模式串，m表示长度，suffix，prefix数组事先申请好了 public void generateGS(char[] b, int m, int[] suffix, boolean[] prefix) &#123; for (int i = 0; i &lt; m; i++) &#123; suffix[i] = -1; prefix[i] = false; &#125; for (int i = 0; i &lt; m - 1; i++) &#123; //b[0 i] int j = i; int k = 0; while (j &gt;= 0 &amp;&amp; b[j] == b[m - 1 -k]) &#123; //与b[0, m-1] 求公共子串 j--; k++; &#125; if (k != 0) suffix[k] = j + 1; // j+1 表示公共后缀子串在 b[0, i] 中的起始下标 if (j == -1) prefix[k] = true; // 如果公共后缀子串也是模式串的前缀子串 &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233package com.ludepeng.datastruct.base.datastruct.charMath.diffculty.bm.demo;import org.junit.Test;import java.util.Arrays;/** * @description: 测试生成 suffix和prefix数组 * @author: rhsphere * @since: 2019-10-28 15:17 by jdk 1.8 */public class TestGenerateGS &#123; @Test public void testGenerateGs() &#123; GenerateGS instance = new GenerateGS(); String find = "feife"; int length = find.length(); int[] suffix = new int[length]; boolean[] prefix = new boolean[length]; //这里单步调试 看suffix和prefix是如何生成的 instance.generateGS(find.toCharArray(), length, suffix, prefix); System.out.println(Arrays.toString(suffix)); System.out.println(Arrays.toString(prefix)); &#125;&#125;]]></content>
      <categories>
        <category>String</category>
      </categories>
      <tags>
        <tag>String</tag>
        <tag>Char Match</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RK算法]]></title>
    <url>%2F2019%2F10%2F28%2Frabin-karp.html</url>
    <content type="text"><![CDATA[RK算法RK算法 通过对主串中 n-m+1 个子串分别求hash值，然后逐个与模式串的哈希值比较大小。 在对主串构建的时候，就对比是不是一样的，一样就不继续计算后面的hash值。 一种简单的hash算法，a~z这26个英文字母，对应的数字相加，得到的和作为hash值，为了解决hash碰撞的问题在，哈希值相等的时候，再对比一下子串和模式串本身。 字符集范围不要太长且模式串不要太长，否则hash值可能冲突，O(n) Java代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100package com.ludepeng.datastruct.base.datastruct.charMath.simple.rk;import java.util.HashMap;import java.util.Map;/** * @description: rk算法，BF算法的升级版，加入了hash散列计算，使时间复杂度降低到了O(N) * @author: rhsphere * @since: 2019-10-27 17:22 by jdk 1.8 */public class RabinKarp2 &#123; private static final char[] RK_STR = &#123; 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', ' ' &#125;; /** 字符串对照表 */ private static final Map&lt;Character, Integer&gt; CHAR_MAP = new HashMap&lt;&gt;(RK_STR.length); static &#123; for (int i = 0; i &lt; RK_STR.length; i++) CHAR_MAP.put(RK_STR[i], i+1); &#125; /** * 进行字符串查找的函数 * @param src 主串 * @param pat 模式字符串 * @return 返回索引的下标位置，-1为未查询到 */ public int search(String src, String pat) &#123; int location = -1; if (src == null || pat == null) return location; char[] srcCharArr = src.toCharArray(); char[] patCharArr = pat.toCharArray(); long pathash = countHash(patCharArr); int srcStartIndex = 0; while (srcStartIndex &lt; srcCharArr.length) &#123; if (srcStartIndex + patCharArr.length &gt; srcCharArr.length) return location; int end = srcStartIndex + patCharArr.length; long hash2 = countHash2(srcCharArr, srcStartIndex, end); if (pathash == hash2) &#123; if (match(patCharArr, srcCharArr, srcStartIndex)) return srcStartIndex; &#125; srcStartIndex++; &#125; return location; &#125; private boolean match(char[] pat, char[] src, int start) &#123; for (int i = 0; i &lt; pat.length; i++) &#123; if (pat[i] != src[i + start]) return false; &#125; return true; &#125; /** * 计算hash值2的方法 * * @param arr 原始字符串1 * @param start 起始位置 * @param end 结束位置 * @return 查找到索引位置 */ private long countHash2(char[] srcCharArr, int start, int end) &#123; long res = 0L; for (int i = end - 1; i &gt;= start; i--) res += CHAR_MAP.get(arr[i]); return res; &#125; /** * 计算模式串hash值的方法 * @param arr 模式串 * @return hash */ private long countHash(char[] arr) &#123; long res = 0L; for (int i = arr.length - 1; i &gt;= 0; i--) res += CHAR_MAP.get(arr[i]); return res; &#125;&#125; 1234567891011121314151617181920212223242526package com.ludepeng.datastruct.base.datastruct.charMath.simple.rk;import org.junit.Test;/** * @description: * @author: rhsphere * @since: 2019-10-27 18:32 by jdk 1.8 */public class TestRabinKarp2 &#123; @Test public void testFind() &#123; String src = "my name is ludepeng THIS NAME IS LKR"; String pat = "NAME"; RabinKarp2 findInstance = new RabinKarp2(); int location = findInstance.search(src, pat); System.out.println("查找的索引号为 ：" + location); if (-1 != location) &#123; System.out.println("截取字符串为:" + src.substring(location, location + pat.length())); &#125; &#125;&#125; Java代码 – 复杂的hash12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697package com.ludepeng.datastruct.base.datastruct.charMath.simple.rk;import org.omg.PortableInterceptor.INACTIVE;import java.util.HashMap;import java.util.Map;/** * @description: rk算法，BF算法的升级版，加入了hash散列计算，使时间复杂度降低到了O(N) * @author: rhsphere * @since: 2019-10-27 17:22 by jdk 1.8 */public class RabinKarp &#123; private static final char[] RK_STR = &#123; 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', ' ' &#125;; private static final int SCALE = RK_STR.length; /** 字符串的对照表 */ private static final Map&lt;Character, Integer&gt; CHAR_MAP = new HashMap&lt;&gt;(RK_STR.length); static &#123; for (int i = 0; i &lt; RK_STR.length; i++) &#123; CHAR_MAP.put(RK_STR[i], i + 1); &#125; &#125; /** * 进行字符串查找的函数 * @param src 主串 * @param pat 模式字符串 * @return 返回索引的下标位置，-1为未查询到 */ public int search(String src, String pat) &#123; int location = -1; if (src == null || pat == null) return location; char[] srcCharArr = src.toCharArray(); char[] patCharArr = pat.toCharArray(); int srcStartIndex = 0; // 1.计算查找字符串的hash long patHash = countHash(patCharArr); while (srcStartIndex &lt; srcCharArr.length) &#123; if (srcStartIndex + patCharArr.length &gt; src.length()) return location; int end = srcStartIndex + patCharArr.length; long hash2 = countHash2(srcCharArr, srcStartIndex, end); if (hash2 == patHash) return srcStartIndex; srcStartIndex++; &#125; return location; &#125; /** * 计算hash值2的方法 * * @param arr 原始字符串1 * @param start 起始位置 * @param end 结束位置 * @return 查找到索引位置 */ private long countHash2(char[] arr, int start, int end) &#123; long res = 0L; //1.进行模式串的计算 for (int i = end - 1; i &gt;= start; i--) &#123; double val = Math.pow(SCALE, CHAR_MAP.get(arr[i])); res += val; &#125; return res; &#125; /** * 计算模式串hash值的方法 * @param arr 模式串 * @return hash */ private long countHash(char[] arr) &#123; long res = 0L; //1. 进行模式串的CHAR_MAP计算 for (int i = arr.length - 1; i &gt;= 0; i--) &#123; double val = Math.pow(SCALE, CHAR_MAP.get(arr[i])); res += val; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>String</category>
      </categories>
      <tags>
        <tag>String</tag>
        <tag>Char Match</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BF算法]]></title>
    <url>%2F2019%2F10%2F28%2Fbrute-force.html</url>
    <content type="text"><![CDATA[BF算法暴力匹配算法/朴素匹配算法 简单场景，主串和模式串都不太长，O(m*n) Java代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * @description: BF字符串匹配算法，也叫暴力匹配算法 时间复杂度为 O(m*N) m为pat串长度，N为主串长度 * * @author: rhsphere * @since: 2019-10-26 21:59 by jdk 1.8 */public class BructForce &#123; /** * 使用bf算法进进行字符串匹配搜索， * * @param src 源字符串，主串 * @param pat 匹配的字符串，模式字符串 * @return 返回查找字符串开始的下标，如果未找到返回-1 */ public int search(String src, String pat) &#123; int location = -1; if (src == null || pat == null) return location; char[] srcCharArr = src.toCharArray(); char[] patCharArr = pat.toCharArray(); int srcStartIdx = 0; // 遍历主串 while (srcStartIdx &lt; srcCharArr.length) &#123; //如果遍历到尾部都没有找到，则结束返回 if (srcStartIdx + patCharArr.length &gt; srcCharArr.length) break; //模式串的匹配 for (int i = 0; i &lt; patCharArr.length; i++) &#123; if (srcCharArr[i +srcStartIdx] == patCharArr[i]) &#123; if (location == -1) location = i; continue; &#125; else &#123; location = -1; break; &#125; &#125; //如果索引被找到则直接返回 if (location != -1) return location; // 跟踪主串的指针指向本次匹配开始位置的下一个字符 srcStartIdx++; &#125; return location; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334package com.ludepeng.datastruct.base.datastruct.charMath.simple.bf;import org.junit.Test;/** * @description: 测试BF算法 * @author: rhsphere * @since: 2019-10-26 22:20 by jdk 1.8 */public class TestBructForce &#123; @Test public void testBructForce() &#123; BructForce instance = new BructForce(); String src = "my first test class ever"; String pat = "class"; int location = instance.search(src, pat); System.out.println("查找的位置索引为: " + location); String sub = src.substring(location); System.out.println("截取后的字符串为: " + sub); &#125; @Test public void testBructForceNot() &#123; BructForce instance = new BructForce(); String src = "my first test class ever"; String pat = "clazz"; int location = instance.search(src, pat); System.out.println("查找的位置索引为: " + location); &#125;&#125;]]></content>
      <categories>
        <category>String</category>
      </categories>
      <tags>
        <tag>String</tag>
        <tag>Char Match</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[遍历HashMap的方法]]></title>
    <url>%2F2019%2F10%2F23%2Ftranverse-hashmap.html</url>
    <content type="text"><![CDATA[遍历HashMap最近看源码比较多，从源码中收获很多。 其中Iterator 的方法建议忘记了再跟一些源码，看看是怎么来的。 不废话，直接上代码。 Java代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package algo09.hashmap;import java.util.HashMap;import java.util.Iterator;import java.util.Map;/** * @description: 遍历hashMap的方法 * @author: rhsphere * @since: 2019-10-23 13:52 by jdk 1.8 */public class TraverseHashMap &#123; /**1.遍历键值对，使用Map.Entry map.entrySet() public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() */ public static void tranverse1(Map&lt;String, Integer&gt; map) &#123; for (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) &#123; System.out.println("Key:" + entry.getKey()); System.out.println("Value:" + entry.getValue()); &#125; &#125; /** 2.显示调用 map.entrySet() 的集合迭代器 EntrySet的 iterator */ public static void tranverse2(Map&lt;String, Integer&gt; map) &#123; Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; iterator = map.entrySet().iterator(); while (iterator.hasNext()) &#123; Map.Entry&lt;String, Integer&gt; entry = iterator.next(); System.out.println("Key:" + entry.getKey()); System.out.println("Value:" + entry.getValue()); &#125; &#125; /** 3.遍历Key,使用map.keySet() */ public static void tranverse3(Map&lt;String, Integer&gt; map) &#123; for (String key : map.keySet()) &#123; System.out.println("Key:" + key); System.out.println("Value:" + map.get(key)); &#125; &#125; /** 4.遍历Value,使用map.values() */ public static void tranverse4(Map&lt;String, Integer&gt; map) &#123; for (int v : map.values()) System.out.println("Value:" + v); &#125; public static void main(String[] args) &#123; HashMap&lt;String, Integer&gt; map = new HashMap&lt;String, Integer&gt;(); map.put("一", 1); map.put("二", 2); map.put("三", 3); System.out.println("=====遍历键值对====="); tranverse1(map); System.out.println("=====遍历键值对====="); tranverse2(map); System.out.println("=====遍历键值对====="); tranverse3(map); System.out.println("=====遍历键值对====="); tranverse4(map); &#125;&#125;]]></content>
      <categories>
        <category>HashMap</category>
      </categories>
      <tags>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[递归、动规、分治、贪婪算法的一些总结]]></title>
    <url>%2F2019%2F10%2F10%2Fconclusions-for-some-algos.html</url>
    <content type="text"><![CDATA[递归和动态规划的比较动态规划(Dynamic Programming, DP)是一项虽简单但较难掌握的技术，一个容易识别和求解DP问题的方法时通过求解尽可能多的问题。“Programming”一词并不是指编程，而是填充表格（类似线性规划）。 递归尽管递归问题五花八门，但题型大都类似。一个问题是不是递归的，就看它能不能分解成子问题进行求解。 当你听到问题是这么开头的：“设计一个算法，计算第n个……”，“编写代码列出前n个……”，“实现一个方法，计算所有……”等等，那么这个问题基本就是一个递归问题。 递归的解法，根据定义，就是从较小的子问题逐渐逼近原始问题。很多时候，只要在f(n-1)的解法中 加入、移除某些东西或者稍作修改就能计算出f(n)。而在其他情况下，答案可能更为复杂。 你应该双管齐下，自下而上和自上而下两种递归解法都要考虑。简单构造法对递归问题就很奏效。 自下而上的递归自下而上的递归往往最为直观。首先要知道如何解决简单情况下的问题，比如，只有一个元素的列表，找出有两个、三个元素的列表的解法，依此类推。这种接法的关键在于，如何从先前解出来的答案，构建出后续情况的答案。 自上而下的递归自上而下的递归可能比较复杂，不过对某些问题很有必要。遇到此类问题时，我们要思考如何才能将情况N下的问题分解成多个子问题。同时注意子问题是否重叠了。 分治分治（Divide and Conquer）法递归地将问题分解成两个或多个同类型的子问题，直到这些子问题简单到能够直接求解，然后将这些子问题的解合成为原始问题的解。 分治一般包括如下步骤： 分（divide）： 将初始问题分割成多个子问题，这些子问题是与初始问题同类型的规模更小的实例。 递归（recursion）： 递归求解子问题。 治（conquer）：合理地组合子问题的解。 分治法递归地求解子问题，所有问题一般按照递归进行定义，用 主定理（Master theorem） 容易求得这些递归问题的时间复杂度。 分治法的应用 二分查找 归并排序 快速排序 中间值查找 最大最小值查找 矩阵乘法 最近点对问题 动态规划如果听到问题是求一个最优解（通常是求最大值或最小值），而且该问题能够分解成若干子问题，并且子问题之间还有重叠的更小的子问题，就可以考虑用动态规划来解决这个问题。 动态规划的四个特点（剑指Offer总结） 求一个问题的最优解； 整体问题的最优解是依赖各个子问题的最优解； 把大问题分解成若干小问题，这些小问题之间还有相互重叠的更小的子问题； 由于子问题在分解大问题的过程中重复出现，为了避免重复求解子问题，用从下往上的顺序先计算小问题的最优解并存储下来，再以此为基础求取大问题的最优解。 从上往下分析问题，从下往上求解问题。 动态规划的四个特点 最优子结构 子问题重叠 有边界 子问题独立 动态规划和分治法的主要区别对于分治法，子问题是相互独立的，而在动态规划中子问题可能是重叠的，通过使用备忘录（用一个表来保存已解决子问题的答案），对于大部分问题，动态规划能够将待求解问题的复杂度由指数级降低为多项式级。 动态规划主要包含以下两个部分： 递归： 递归求解子问题。 备忘录： 将已计算的值存储在表中。 动态规划 = 递归 + 备忘录 动态规划算法例子 许多字符串算法，如最长公共子序列、最长递增子序列、最长公共子串、编辑距离等 关于图的有效求解算法，如寻找图中最短距离的Bellman-Ford算法、Floyd的所有定点间最短路径算法等 链矩阵乘法 子集和 0/1背包问题 旅行商问题等 贪婪算法贪婪算法将问题分为多个阶段。在每一个阶段，选取当前状态下的最优决策，而不考虑对后续决策的影响。这意味着算法在执行过程中会选取某些 局部最优解。贪婪算法假设通过局部最优解可以获得全局最优解。 贪婪算法的要素 贪婪选择性质 最优子结构 贪婪选择性质全局最优解可以通过寻找局部最优解获得（贪婪），局部最优解的选择可能依赖于之前的决策。通过迭代方式算法进行一个个贪婪选择，将原问题简化为规模更小的问题。 最优子结构如果原问题的最优解包含子问题的最优解，则认为该问题具有最优子结构。这意味着可以对子问题求解并构建规模更大的解。 贪婪算法的优缺点优点：直观，易于理解和编程实现。当前的决策不会对已经计算出的结果有任何影响，因此不需要再对已有的局部解进行检查。 缺点：选择局部最优不是对于所有问题都是用，所以贪婪算法并不总能得到最优解。在许多情况下，无法保证最优解能够产生局部最优解。 通常需要用数学的方式来证明贪婪选择是正确的。 贪婪算法的应用 排序问题，选择排序、拓扑排序 优先队列，堆排序 哈夫曼编码 Prim和Kruskal算法 加权图的最短路径算法（Dijkstra算法） 硬币找零问题 分数背包问题 并查集的按大小或高度合并问题（或排名） 任务调度算法 求解复杂问题的近似算法]]></content>
      <categories>
        <category>Sum-up</category>
      </categories>
      <tags>
        <tag>Sum-up</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[110. Balanced Binary Tree]]></title>
    <url>%2F2019%2F08%2F29%2Fbalanced-binary-tree.html</url>
    <content type="text"><![CDATA[平衡二叉树参考剑指Offer(55) 题目二 平衡二叉树判定的思路。 LeetCode 110 英文版LeetCode 110 中文版 Java代码12345678910111213141516171819202122232425262728293031/** * @description: leetcode 110 * @author: rhsphere * @since: 2019-08-29 01:08 by jdk 1.8 */public class BalancedBinaryTree &#123; public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125; &#125; public boolean isBalanced(TreeNode root) &#123; return getDepth(root) != -1; &#125; private int getDepth(TreeNode root) &#123; if (root == null) return 0; int left = getDepth(root.left); if (left == -1) return -1; int right = getDepth(root.right); if (right == -1) return -1; return Math.abs(left - right) &gt; 1 ? -1 : Math.max(left + 1, right + 1); &#125;&#125; 题目给定一个二叉树，判断它是否是高度平衡的二叉树。 本题中，一棵高度平衡二叉树定义为： 一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。 示例 1: 给定二叉树 [3,9,20,null,null,15,7] 3 / \ 9 20 / \ 15 7返回 true 。 示例 2: 给定二叉树 [1,2,2,3,3,null,null,4,4] 1 / \ 2 2 / \ 3 3 / \ 4 4返回 false 。]]></content>
      <categories>
        <category>Easy</category>
      </categories>
      <tags>
        <tag>Recursive</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[104. Maximum Depth of Binary Tree]]></title>
    <url>%2F2019%2F08%2F29%2Fmax-depth-of-binary-tree.html</url>
    <content type="text"><![CDATA[二叉树的最大深度参考剑指Offer(55) 题目一 二叉树的深度的思路。 英文版中文版 debug跟踪通过debug跟踪发现，对于树 0 1 2 3 4 5 67一直递归计算left_height，直到7的左右子节点，然后返回0，然后递归栈向上返回一层，计算3的左右子树高度，于是得到 max{1, 0}=1；然后递归栈返回计算1的左右子树，左子树已经计算出来了，递归计算右子树4的高度，依次类推。。。 可以用 com.ludepeng.datastruct.base.datastruct.tree.leetcode104.DepthOfTree 进行查看。 Java代码1234567891011121314151617181920212223242526/** * @description: leetcode 104 * @author: rhsphere * @since: 2019-08-29 00:46 by jdk 1.8 */public class MaxDepthOfBinaryTree &#123; public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125; &#125; public int maxDepth(TreeNode root) &#123; if (root == null) &#123; return 0; &#125; else &#123; int left_height = maxDepth(root.left); int right_height = maxDepth(root.right); return Math.max(left_height, right_height) + 1; &#125; &#125;&#125; 题目给定一个二叉树，找出其最大深度。 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。 说明: 叶子节点是指没有子节点的节点。 示例： 给定二叉树 [3,9,20,null,null,15,7]， 3 / \ 9 20 / \ 15 7返回它的最大深度 3 。 思路时间复杂度：我们每个结点只访问一次，因此时间复杂度为 O(N)其中 N 是结点的数量。空间复杂度：在最糟糕的情况下，树是完全不平衡的，例如每个结点只剩下左子结点，递归将会被调用 N 次（树的高度），因此保持调用栈的存储将是 O(N) 但在最好的情况下（树是完全平衡的），树的高度将是 log(N)。因此，在这种情况下的空间复杂度将是 O(log(N))。]]></content>
      <categories>
        <category>Easy</category>
      </categories>
      <tags>
        <tag>Recursive</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[226. Invert Binary Tree]]></title>
    <url>%2F2019%2F08%2F28%2Finvert-binary-tree.html</url>
    <content type="text"><![CDATA[翻转二叉树注意区分和剑指Offer(27) 二叉树的镜像的区别，另一种迭代解法待完成。 英文版 中文版 Java代码12345678910111213141516171819202122/** * @description: * @author: rhsphere * @since: 2019-08-28 01:06 by jdk 1.8 */public class InvertBinaryTree &#123; public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125; &#125; public TreeNode invertTree(TreeNode root) &#123; if (root == null) return null; //这里的left、right顺序注意 TreeNode left = invertTree(root.left); TreeNode right = invertTree(root.right); root.left = right; root.right = left; return root; &#125;&#125; 题目翻转一棵二叉树。 示例： 输入： 4 / \ 2 7 / \ / \1 3 6 9 输出： 4 / \ 7 2 / \ / \9 6 3 1备注: 这个问题是受到 Max Howell 的 原问题 启发的 ： 谷歌：我们90％的工程师使用您编写的软件(Homebrew)，但是您却无法在面试时在白板上写出翻转二叉树这道题，这太糟糕了。 思路既然树中的每个节点都只被访问一次，那么时间复杂度就是 O(n)，其中 n 是树中节点的个数。在反转之前，不论怎样我们至少都得访问每个节点至少一次，因此这个问题无法做地比 O(n)更好了。 本方法使用了递归，在最坏情况下栈内需要存放 O(h)个方法调用，其中 h 是树的高度。由于 h\in O(n)h∈O(n)，可得出空间复杂度为 O(n)。]]></content>
      <categories>
        <category>Easy</category>
      </categories>
      <tags>
        <tag>Recursive</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[101. Symmetric Tree]]></title>
    <url>%2F2019%2F08%2F28%2FSymmetric-tree.html</url>
    <content type="text"><![CDATA[对称二叉树本题和 剑指Offer(28) 对称的二叉树 相似，请完成迭代解法。 英文版 中文版 Java代码12345678910111213141516171819202122/** * @description: leetcode 101 使用递归 * @author: rhsphere * @since: 2019-08-28 00:53 by jdk 1.8 */public class StmmetricTree &#123; public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125; &#125; public boolean isSymmetric(TreeNode root) &#123; return isMirror(root, root); &#125; private boolean isMirror(TreeNode p, TreeNode q) &#123; if (p == null &amp;&amp; q == null) return true; if (p == null || q == null) return false; return p.val == q.val &amp;&amp; isMirror(p.left, q.right) &amp;&amp; isMirror(p.right, q.left); &#125;&#125; 题目给定一个二叉树，检查它是否是镜像对称的。 例如，二叉树 [1,2,2,3,4,4,3] 是对称的。 1 / \ 2 2 / \ / \3 4 4 3 但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的: 1 / \ 2 2 \ \ 3 3 说明: 如果你可以运用递归和迭代两种方法解决这个问题，会很加分。 思路如果一个树的左子树与右子树镜像对称，那么这个树是对称的。 因此，该问题可以转化为：两个树在什么情况下互为镜像？ 如果同时满足下面的条件，两个树互为镜像： 它们的两个根结点具有相同的值。 每个树的右子树都与另一个树的左子树镜像对称。 时间复杂度：O(n)，因为我们遍历整个输入树一次，所以总的运行时间为 O(n)，其中 n 是树中结点的总数。 空间复杂度：递归调用的次数受树的高度限制。在最糟糕情况下，树是线性的，其高度为 O(n)。因此，在最糟糕的情况下，由栈上的递归调用造成的空间复杂度为 O(n))。]]></content>
      <categories>
        <category>Easy</category>
      </categories>
      <tags>
        <tag>Recursive</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[100. Same Tree]]></title>
    <url>%2F2019%2F08%2F28%2Fsame-tree.html</url>
    <content type="text"><![CDATA[相同的树思考：本题使用迭代法如何做？ 英文版中文版 Java代码1234567891011121314151617181920212223** * @description: leetcode 100 使用递归 * @author: rhsphere * @since: 2019-08-28 00:33 by jdk 1.8 */public class SameTree &#123; public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125; &#125; public boolean isSameTree(TreeNode p, TreeNode q) &#123; if (p == null &amp;&amp; q == null) return true; if (p == null || q == null) return false; if (p.val != q.val) return false; return isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right); &#125;&#125; 题目给定两个二叉树，编写一个函数来检验它们是否相同。 如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。 示例 1: 输入: 1 1 / \ / \ 2 3 2 3 [1,2,3], [1,2,3] 输出: true示例 2: 输入: 1 1 / \ 2 2 [1,2], [1,null,2] 输出: false示例 3: 输入: 1 1 / \ / \ 2 1 1 2 [1,2,1], [1,1,2] 输出: false 思路最简单的策略是使用递归。首先判断 p 和 q 是不是 null，然后判断它们的值是否相等。 时间复杂度 : O(N)O(N)，其中 N 是树的结点数，因为每个结点都访问一次。 空间复杂度 : 最优情况（完全平衡二叉树）时为 O(\log(N))O(log(N))，最坏情况下（完全不平衡二叉树）时为 {O}(N)O(N)，用于维护递归栈。]]></content>
      <categories>
        <category>Easy</category>
      </categories>
      <tags>
        <tag>Recursive</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【目录】 《剑指Offer》Java思路与实现]]></title>
    <url>%2F2019%2F08%2F27%2Fcatalog-of-swording-offers.html</url>
    <content type="text"><![CDATA[剑指Offer目录 2) 实现Singleton模式 3) 找出数组中重复的数字/不修改数组找出重复的数字 4) 二维数组中的查找 5) 替换空格/无序字母排序 6) 从尾到头打印链表 7) 重建二叉树 7) 二叉树的下一个结点 8) 用两个栈实现队列 9) 斐波那契数列及青蛙跳台阶问题 10) 旋转数组的最小数字 11) 矩阵中的路径 12) 机器人的运动范围 13) 剪绳子 14) 二进制中1的个数 15) 数值的整数次方 16) 打印1到最大的n位数 17) 在O(1)时间删除链表结点 18) 删除链表中重复的结点 19) 正则表达式匹配 20) 表示数值的字符串 21) 调整数组顺序使奇数位于偶数前面 22) 链表中倒数第k个结点 23) 链表中环的入口结点 24) 反转链表 25) 合并两个排序的链表 26) 树的子结构 27) 二叉树的镜像 28) 对称的二叉树 29) 顺时针打印矩阵 30) 包含min函数的栈 31) 栈的压入、弹出序列 32) 从上往下打印二叉树 33) 二叉搜索树的后序遍历序列 34) 二叉树中和为某一值的路径 35) 复杂链表的复制 36) 二叉搜索树与双向链表 37) 序列化二叉树 38) 字符串的排列 39) 数组中出现次数超过一半的数字 40) 最小的k个数 41) 数据流中的中位数 42) 连续子数组的最大和 43) 从1到n整数中1出现的次数 44) 数字序列中某一位的数字 45) 把数组排成最小的数 46) 把数字翻译成字符串 47) 礼物的最大价值 48) 最长不含重复字符的子字符串 50-1) 字符串中第一个只出现一次的字符 50-2) 字符流中第一个只出现一次的字符 51)数组中的逆序对 52) 两个链表的第一个公共结点 53-1) 数字在排序数组中出现的次数 53-2) 0到n-1中缺失的数字 53-3) 数组中数值和下标相等的元素 54) 二叉搜索树的第k个结点 55-1) 二叉树的深度 55-2) 平衡二叉树 56-1) 数组中只出现一次的两个数字 56-2) 数组中唯一只出现一次的数字 57-1) 和为s的两个数字 57-2) 为s的连续正数序列 58-1) 翻转单词顺序 58-2) 左旋转字符串 59-1) 滑动窗口的最大值 59-2) 队列的最大值 60) n个骰子的点数 61) 扑克牌的顺子 62) 圆圈中最后剩下的数字 63) 股票的最大利润 64) 求1+2+…+n 65) 不用加减乘除做加法 66) 构建乘积数组 67) 把字符串转换成整数 68) 树中两个结点的最低公共祖先]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>catalog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Scanner类的几个方法]]></title>
    <url>%2F2019%2F08%2F13%2Fscanner.html</url>
    <content type="text"><![CDATA[Scanner类的几个方法通过Scanner类可以后去用户输入，创建Scanner对象的基本语法如下： Scanner sc = new Scanner(System.in); System.in代表标准输入，即键盘输入，但这个标准输入流是 InputStream 类的实例，使用不太方便，而且键盘输入内容都是文本内容，所以可以使用 InputStreamReader 将其转换为字符输入流，普通的 Reader 读取输入内容依然不太方便，可以将普通的 Reader 再次包装成BufferedReader，利用 BufferedReader 的 readLine() 方法可以一次读取一行内容。 123456789101112131415public class KeyInTest &#123; public static void main(String[] args) &#123; try (InputStreamReader reader = new InputStreamReader(System.in); BufferedReader br = new BufferedReader(reader)) &#123; String line = null; while ((line = br.readLine()) != null) &#123; if (line.equals("exit")) System.exit(1); System.out.println("输入内容为：" + line); &#125; &#125; catch (IOException ioe) &#123; ioe.printStackTrace(); &#125; &#125;&#125; nextInt()、next()和nextLine(): nextInt(): it only reads the int value, nextInt() places the cursor（光标） in the same line after reading the input. nextInt()只读取数值，剩下”\n”还没有读取，并将cursor放在本行中。 next(): read the input only till the space. It can’t read two words separated by space. Also, next() places the cursor in the same line after reading the input.（next()只读空格之前的数据，并且cursor指向本行） next() 方法遇见第一个有效字符（非空格，非换行符）时，开始扫描，当遇见第一个分隔符或结束符(空格或换行符)时，结束扫描，获取扫描到的内容，即获得第一个扫描到的不含空格、换行符的单个字符串。 nextLine(): reads input including space between the words (that is, it reads till the end of line \n). Once the input is read, nextLine() positions the cursor in the next line. nextLine()时，则可以扫描到一行内容并作为一个字符串而被获取到。 3]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态代理(二)]]></title>
    <url>%2F2019%2F08%2F13%2Fdynamic-proxy-more.html</url>
    <content type="text"><![CDATA[JDK动态代理涉及java.lang.reflect包中的两个类，Proxy和InvocationHandler。Proxy利用InvocationHandler动态创建一个符合某一接口的实例，生成目标类的代理对象。InvocationHandler可以实现接口定义横切逻辑，并通过反射机制调用目标类的代码，动态地将横切逻辑和业务逻辑编织在一起。 JDK动态代理下面摘自：《疯狂java讲义 第四版》 p857 当程序使用反射方式为指定接口生成系列动态代理对象时，这些动态代理对象的实现类实现了一个或多个接口。动态代理对象就需要实现一个或多个接口里定义的所有方法，但问题是：系统怎么知道如何实现这些方法？ 这个时候就轮到 InvocationHandler 对象登场了，当执行动态代理对象里的方法时，实际上会替换成调用 InvocationHandler 对象的 invoke 方法。 在 Java 中，动态代理类的生成主要涉及对 ClassLoader 的使用。以 CGLIB 为例，使用 CGLIB 生成动态代理，首先需要生成 Enhancer 类实例，并指定用于处理代理业务的回调类。在 Enhancer.create() 方法中，会使用 DefaultGeneratorStrategy.Generate() 方法生成动态代理类的字节码，并保存在 byte 数组中。接着使用 ReflectUtils.defineClass() 方法，通过反射，调用 ClassLoader.defineClass() 方法，将字节码装载到 ClassLoader 中，完成类的加载。最后使用 ReflectUtils.newInstance() 方法，通过反射，生成动态类的实例，并返回该实例。基本流程是根据指定的回调类生成 Class 字节码—通过 defineClass() 将字节码定义为类—使用反射机制生成该类的实例。 程序中可以采用先生成一个动态代理类，然后通过动态代理类来创建代理对象的方式生成一个动态代理对象。代码如下： 12345678// 创建一个InvocationHandler对象InvocationHandler handler = new MyInvocationHandler(...);//使用Proxy生成一个动态代理类 proxyClassClass proxyClass = Proxy.getProxyClass(Foo.class.getClassLoader(), new Class[] &#123;Foo.class&#125;);//获取proxyClass类中带一个InvocationHandler参数的构造器Constructor ctor = proxyClass.getConstructor(new Class[] &#123;InvocationHandler.class&#125;);//调用ctor的newInstance方法来创建动态实例Foo f = (Foo) ctor.newInstance(new Object[] &#123;handler&#125;); 上面的代码也可以简化成如下代码： 12345// 创建一个InvocationHandler对象InvocationHandler handler = new MyInvocationHandler(...);//使用Proxy直接生成一个动态代理对象Foo f = (Foo) Proxy.newProxyInstance(Foo.class.getClassLoader(), new Class[] &#123;Foo.class&#125;, handler); 下面的代码来自于《精通Spring 4.x企业应用开发实战》 P224 业务逻辑横切代码业务逻辑实现类的代码，省去ForumService接口类和PerformanceMonitor的代码。 12345678910111213141516171819202122232425public class ForumServiceImpl implements ForumService &#123; public void removeTopic(int topicId) &#123; // 横切逻辑 // PerformanceMonitor.begin(); System.out.println("模拟删除Topic记录" + topicId); try &#123; Thread.currentThread().sleep(20); &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; // PerformanceMonitor.end() &#125; public void removeForum(int forumId) &#123; // PerformanceMonitor.begin(); System.out.println("模拟删除Topic记录" + forumId); try &#123; Thread.currentThread().sleep(20); &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; // PerformanceMonitor.end(); &#125;&#125; 横切逻辑将业务类中性能监视横切代码移除后，放置到InvocationHandler中，代码如下。 123456789101112131415161718192021import java.lang.reflect.Method;import java.lang.reflect.InvocationHandler;public class PerformanceHandler implements InvocationHandler &#123; private Object target; public PerformanceHandler(Object target) &#123; this.target = target; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; // 横切逻辑代码定义在PerformanceMonitor中 PerformanceMonitor.begin(target.getClass().getName() + "." + method.getName()); // 使用反射方法调用业务类的目标方法 Object obj = method.invoke(target, args); // 横切逻辑 PerformanceMonitor.end(); return obj; &#125;&#125; invoke(Object proxy, Method method, Object[] args)方法，其中，proxy是最终生成的代理实例，一般不会用到；method是被代理目标实例的某个具体方法，通过它可以发起目标实例方法的反射调用；args是被代理实例某个方法的入参，在方法反射时调用。其次，在构造参数里通过target传入希望被代理的目标对象，在接口方法invoke(Object proxy, Method method, Object[] args)里，将目标实例传递给method.invoke()方法，并调用目标实例的方法。 proxy代表动态代理对象，method代表正在执行的方法，args代表调用目标方法是传入的实参。 下面通过Proxy结合PerformanceHandler创建ForumService接口的代理实例。 创建代理实例123456789101112131415161718192021import java.lang.reflect.Proxy;public class ForumServiceTest &#123; public void proxy() &#123; // 希望被代理的目标业务类 ForumService target = new ForumServiceImpl(); // 将目标业务类和横切代码编织到一起 PerformanceHandler handler = new PerformanceHandler(target); // 根据编织了目标业务类逻辑和性能监视横切逻辑的 // InvocationHandler实例创建代理实例 ForumService proxy = (ForumService) Proxy.newProxyInstance( target.getClass().getClassLoader(), target.getClass().getInterface(), handler); // 调用代理实例 proxy.removeForum(10); proxy.removeTopic(1024); &#125;&#125; Proxy.newProxyInstance() 方法的第一个入参为类加载器；第二个入参为创建代理实例所需实现的一组接口；第三个入参是整合了业务逻辑和横切逻辑的编织器对象。 JDK动态代理另一种简洁写法以下代码来自于 Java EE 互联网轻量级框架整合开发 接口类和实现类的定义在动态代理中必须使用接口，CGLib不需要。下面的代码分别是简单的接口和被代理类的定义。 123456789101112// 接口public interface Service &#123; public void sayHello();&#125;// 实现类public class ServiceImpl implements Service &#123; @Override public void sayHello() &#123; System.out.println("Hello world"); &#125;&#125; 动态代理绑定和代理逻辑实现要实现动态代理要两个步骤，首先，建立起代理对象和被代理对象的关系（将目标业务类和横切代码编织到一起），然后实现代理逻辑。 1234567891011121314151617181920212223242526import java.lang.reflect.Proxy;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;public class JdkProxyExample implements InvocationHandler &#123; private Object target = null; public Object bind(Object target) &#123; this.target = target; return Proxy.newProxyInstance( target.getClass().getClassLoader(), target.getClass().gerInterfaces(), this); &#125; public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println("before..."); Object obj = method.invoke(target, args); System.out.println("after..."); return obj; &#125;&#125; 测试动态代理类1234567public class JdkProxyExampleTest &#123; JdkProxyExample jdk = new JdkProxyExample(); Service proxy = (Service) jdk.bind(new ServiceImpl()); proxy.sayHello();&#125; bind方法同时完成了两步。 CGLib动态代理使用JDK创建代理有一个限制，即只能为接口创建代理。Proxy的接口方法中newProxyInstance(ClassLoader loder, Class[] interfaces, InvocationHandler hander)，第二个入参就是需要代理实例实现的接口列表。假如对一个简单业务表的操作也需要创建5个类（领域对象、DAO接口、DAO实现类、Service接口和Service实现类）吗？对于没有通过接口定义业务方法的类，可以使用CGLib动态创建代理实例。 CGLib采用底层的字节码技术，可以为一个类创建子类，在子类中采用方法拦截的技术拦截父类方法的调用并顺势织入横切逻辑。 值得一提的是，由于CGLib采用动态创建子类的方式生成代理对象，所以不能对目标类中的final或private方法进行代理。 CglibProxy下面代码可以创建，为任何类织入性能监视横切逻辑代理对象的代理创建器。 12345678910111213141516171819202122232425262728293031323334353637383940import java.lang.reflect.Method;import net.sf.cglib.proxy.Enhancer;import net.sf.cglib.proxy.MethodInterceptor;import net.sf.cglib.proxy.MethodProxy;public class CglibProxy implemets MethodInterceptor &#123; // 增强类对象 private Enhancer enhancer = new Enhancer(); public Object getProxy(Class cls) &#123; // 设置需要创建子类的类 enhancer.setSuperClass(cls); /* 定义代理逻辑对象为当前对象，要求当前对象实现 * MethodInterceptor方法 */ enhancer.setCallback(this); // 通过字节码技术动态创建子类实例 return enhancer.create(); &#125; /* *代理逻辑方法，拦截父类所有方法的调用 * obj 目标类的实例 * method 目标类方法的反射对象 * args 方法的动态入参 * proxy 代理类实例 * result 代理逻辑方法返回 */ @Override public Object intercept(Objcet obj, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123; PerformanceMonitor.begin(obj.getClass().getName() + "." + method.getName()); // CGLib反射调用父类中的方法 Objcet result = proxy.invokeSuper(obj, args); PerformanceMonitor.end(); return result; &#125;&#125; 用户可以通过getProxy(Class cla)方法动态创建一个动态代理类。 Cglib测试代码123456789101112131415import java.lang.reflect.Proxy;import org.testg.annotations.*;public class ForumServiceTest &#123; @Test public void proxy() &#123; CglibProxy proxy = new CglibProxy(); // 通过动态生成子类的方式创建代理类 ForumServiceImpl forumService = (ForumServiceImpl) proxy.getProxy(ForumServiceImpl.class); forumService.removeForum(10); forumService.removeTopic(1024); &#125;&#125; 拦截器拦截器接口1234567public interface Interceptor &#123; boolean before(Object proxy, Object target, Method method, Objcet[] args); void around(Object proxy, Object target, Method method, Objcet[] args); void after(Object proxy, Object target, Method method, Objcet[] args);&#125; Interceptor实现类123456789101112131415161718public class MyInterceptor implements Interceptor &#123; @Override public boolean before(Object proxy, Object target, Method method, Objcet[] args) &#123; System.err.println("反射方法前逻辑"); return false; &#125; @Override public void after(Object proxy, Object target, Method method, Objcet[] args) &#123; System.err.println("反射方法后逻辑"); &#125; @Override public boolean around(Object proxy, Object target, Method method, Objcet[] args) &#123; System.err.println("取代了目标实例的方法"); &#125;&#125; 在JDK动态代理中使用拦截器123456789101112131415161718192021222324252627282930313233343536373839public class InterceptorJdkProxy implements InvocationHandler &#123; // 目标实例 private Objcet target; // 拦截器全限定名 private String interceptorClass = null; public InterceptorJdkProxy(Objcet target, String interceptorClass) &#123; this.target = target; this.interceptorClass = interceptorClass; &#125; public static Object bind(Object target, String interceptorClass) &#123; return Proxy.newProxyInstance( target.getClass().getClassLoader(), target.getClass().getInterfaces(), new InterceptorJdkProxy(target, interceptorClass)); &#125; public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; if (interceptorClass == null) &#123; return method.invoke(target, args); &#125; Object result = null; Interceptor inceptor = (Interceptor) Class.forName(interceptorClass).newInstance(); if (interceptor.before(proxy, target, method, args)) &#123; result = method.invoke(target, args); &#125; else &#123; inceptor.around(proxy, target, method, args); &#125; interceptor.after(proxy, target, method, args); return result; &#125;&#125;]]></content>
      <categories>
        <category>动态代理</category>
      </categories>
      <tags>
        <tag>动态代理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer(31) 栈的压入、弹出序列]]></title>
    <url>%2F2019%2F08%2F03%2Fstack-push-pop-order.html</url>
    <content type="text"><![CDATA[栈的压入、弹出序列题目输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1、2、3、4、5是某栈的压栈序列，序列4、5、3、2、1是该压栈序列对应的一个弹出序列，但4、3、5、1、2就不可能是该压栈序列的弹出序列。 思路建立一个栈，按照压栈序列依次进行入栈操作，按出栈序列的顺序依次弹出数字。在出栈时，若下一个要出栈的数字与栈顶数字相同则弹出。如果压栈序列中的所有数字都入栈后没有完全出栈成功则代表两个序列不匹配，返回false。 测试用例 功能测试（两个数组长度不同；两个数组对应；两个数组不对应） 特殊测试（数组为空；null；一个数字的数组） java代码1234567891011121314151617181920212223242526272829303132/** * @description: * @author: rhsphere * @since: 2019-08-03 21:06 by jdk 1.8 */public class StackPushPopOrder &#123; public boolean isPopOrder(int[] pushA, int[] popA) &#123; if (pushA == null || popA == null) return false; if (pushA.length != popA.length || popA.length == 0) return false; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); int popIndex = 0; for (int pushIndex = 0; pushIndex &lt; pushA.length; pushIndex++) &#123; stack.push(pushA[pushIndex]); while (!stack.empty() &amp;&amp; stack.peek() == popA[popIndex]) &#123; stack.pop(); popIndex++; &#125; &#125; return stack.empty(); &#125; public static void main(String[] args) &#123; int[] pushA = &#123;1, 2, 3, 4, 5&#125;; int[] popA = &#123;4, 3, 5, 1, 2&#125;; StackPushPopOrder demo = new StackPushPopOrder(); System.out.println(demo.isPopOrder(pushA, popA)); &#125;&#125; 总结 弄清楚栈的出栈逻辑。]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer(30) 包含min函数的栈]]></title>
    <url>%2F2019%2F08%2F03%2Fstack-with-min.html</url>
    <content type="text"><![CDATA[包含min函数的栈题目 定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的min函数。在该栈中，调用min、push及pop的时间复杂度都是O(1)。 思路最初想法是定义一个成员变量min来存放最小元素，但是当最小元素弹出后，min就需要相应改变，所以必须把每次的最小值都存储下来。考虑采用一个辅助栈来存放最小值： 栈 3，4，2，5，1 辅助栈 3， 3，2，2，1（压入时，把每次的最小元素（之前最小元素与新入栈元素的较小值）保存起来放到辅助栈中） 测试用例 新压入数字更大 新压入数字最小 弹出数字最小 弹出数字不是最小 java代码1234567891011121314151617181920212223242526272829/** * @description: 剑指offer30 * @author: rhsphere * @since: 2019-08-03 20:35 by jdk 1.8 */public class StackWithMin &#123; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); Stack&lt;Integer&gt; aux = new Stack&lt;&gt;(); public void push(int node) &#123; stack.push(node); if (aux.empty() || aux.peek() &gt; node) &#123; aux.push(node); &#125; else &#123; aux.push(stack.peek()); &#125; &#125; public void pop() &#123; if (!stack.empty()) &#123; stack.pop(); aux.pop(); &#125; &#125; public int min() &#123; return aux.peek(); &#125;&#125; 总结 构造辅助栈用来装数据。]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer(60) n个骰子的点数]]></title>
    <url>%2F2019%2F08%2F03%2Fdices-probability.html</url>
    <content type="text"><![CDATA[n个骰子的点数题目把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。 思路对于n个骰子，要计算出每种点数和的概率，我们知道投掷n个骰子的总情况一共有6^n种，因此只需要计算出某点数和的情况一共有几种，即可求出该点数之和的概率。 方法一：基于递归的方法，效率较低 易知，点数之和s的最小值为n，最大值为6n，因此我们考虑用一个大小为（6n-n+1）的数组存放不同点数之和的情况个数，那么，如果点数之和为x，那么把它出现的情况总次数放入数组种下标为x-n的元素里。 确定如何存放不同点数之和的次数后，我们要计算出这些次数。我们把n个骰子分为1个骰子和n-1个骰子，这1 个骰子可能出现1~6个点数，由该骰子的点数与后面n-1个骰子的点数可以计算出总点数；而后面的n-1个骰子又可以分为1个和n-2个，把上次的点数，与现在这个骰子的点数相加，再和剩下的n-2个骰子的点数相加可以得到总点数……，即可以用递归实现。在获得最后一个骰子的点数后可以计算出几个骰子的总点数，令数组中该总点数的情况次数+1，即可结束遍历。 方法二：基于循环求骰子点数，时间性能好 用数组存放每种骰子点数和出现的次数。令数组中下标为n的元素存放点数和为n的次数。我们设置循环，每个循环多投掷一个骰子，假设某一轮循环中，我们已知了各种点数和出现的次数；在下一轮循环时，我们新投掷了一个骰子，那么此时点数和为n的情况出现的次数就等于上一轮点数和为n-1,n-2,n-3,n-4,n-5,n-6的情况出现次数的总和。从第一个骰子开始，循环n次，就可以求得第n个骰子时各种点数和出现的次数。 我们这里用两个数组来分别存放本轮循环与下一轮循环的各种点数和出现的次数，不断交替使用。 测试用例 功能测试（1，2，3，4个骰子） 特殊测试（0个） 性能测试（11个） java代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111import java.text.NumberFormat;/** * @description: * @author: rhsphere * @since: 2019-08-03 17:08 by jdk 1.8 */public class DicesProbability &#123; private static final int MAX_VALUE = 6; // 方法一：递归解法 public static void printProbability1(int number) &#123; if (number &lt;= 0) return; int[] prob = new int[MAX_VALUE * number - number + 1]; //下标为1，对应的值代表点数之和为i+number总共出现的情况次数 //点数从 number ~ MAX_VALUE * number, 所以数组大小为6 * number - number + 1 for (int i = 0; i &lt; prob.length; i++) prob[i] = 0; for (int i = 1; i &lt;= MAX_VALUE; i++) calProb(prob, number, number - 1, i); //第一次掷筛子，总点数只能是1~6 int totalProb = (int) Math.pow(MAX_VALUE, number); for (int i = 0; i &lt; prob.length; i++) &#123; double ratio = (double) prob[i] / totalProb; NumberFormat format = NumberFormat.getPercentInstance(); format.setMaximumFractionDigits(2); //设置保留几位小数 System.out.println("点数和为" + (i + number) + "的概率为：" + format.format(ratio)); &#125; &#125; /** * 计算每种点数出现的次数 * @param number:骰子总个数 * @param curNumber:当前剩余骰子个数 * @param sum:各个骰子加起来的总点数 */ public static void calProb(int[] prob, int number, int curNumber, int sum) &#123; if (curNumber == 0) &#123; prob[sum - number]++; //总数为sum的情况存放在sum-number下标中 return; &#125; for (int i = 1; i &lt;= MAX_VALUE; i++) calProb(prob, number, curNumber-1,sum+i); //相当于剩余的骰子少一个，总点数增加。 &#125; //方法二：基于循环求骰子点数，时间性能好 public static void printProbability2(int number) &#123; if(number&lt;=0) return; //错误 int[][] probabilities = new int[2][number*MAX_VALUE+1]; //[2]代表用两个数组交替保存，[number*maxValue+1]是指点数为所在下标时，该点数出现的总次数。 //probabilities[*][0]是没用的，只是为了让下标对应点数 for(int i=0;i&lt;2;i++) &#123; for(int j=0;j&lt;number*MAX_VALUE;j++) &#123; probabilities[i][j]=0; &#125; &#125; for(int i=1;i&lt;=6;i++) probabilities[0][i]=1; //第一个骰子出现的情况 int flag=0; for(int curNumber=2;curNumber&lt;=number;curNumber++) &#123; //当前是第几个骰子 for(int i=0;i&lt;curNumber;i++) probabilities[1-flag][i]=0; //前面的数据清零 for(int i=curNumber;i&lt;=curNumber*MAX_VALUE;i++) &#123; for(int j=1;j&lt;=6 &amp;&amp; j&lt;=i ;j++) &#123; probabilities[1-flag][i]+=probabilities[flag][i-j]; &#125; &#125; flag=1-flag; &#125; int totalP = (int) Math.pow(MAX_VALUE, number); //所有情况总共出现的次数 for( int i=number;i&lt;= number*6;i++) &#123; double ratio = (double)probabilities[flag][i]/totalP; NumberFormat format = NumberFormat.getPercentInstance(); format.setMaximumFractionDigits(8);//设置保留几位小数 System.out.println("点数和为"+(i+number)+"的概率为:"+format.format(ratio)); &#125; &#125; public static void main(String[] args) &#123; System.out.println("=========方法一============"); for(int i=0;i&lt;=3;i++) &#123; System.out.println("-----骰子数为"+i+"时-----"); printProbability1(i); &#125; System.out.println("-----骰子数为"+11+"时-----"); printProbability1(11); System.out.println("=========方法二============"); for(int i=0;i&lt;=3;i++) &#123; System.out.println("-----骰子数为"+i+"时-----"); printProbability2(i); &#125; System.out.println("-----骰子数为"+11+"时-----"); printProbability1(11); &#125;&#125; 总结 int类型相除，要得到double类型，需要提前将其中一个变成double类型 例如：double ratio = (double)probabilities[i]/totalP; 输出百分数的方法，利用NumberFormat 123NumberFormat format = NumberFormat.getPercentInstance();format.setMaximumFractionDigits(8);//设置保留几位小数System.out.println("点数和为"+(i+number)+"的概率为:"+format.format(ratio)); 第二种方法，不是骰子点数的角度出发，而是从点数之和出发，点数之和有：f(n)=f(n-1)+……f(n-6)，非常巧妙。 用两个数组交替存放，学会使用变量flag，flag=1-flag。 代码中没有把骰子的最大点数硬编码为6，而是用变量maxValue来表示，具有可拓展性。以后自己编程时也要注意这些量是否可以不用硬编码，从而提高扩展性。 提高数学建模能力，不管采取哪种思路，都要先想到用数组来存放n个骰子的每个点数和出现的次数。]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer(59-2) 队列的最大值]]></title>
    <url>%2F2019%2F08%2F03%2Fqueue-with-max.html</url>
    <content type="text"><![CDATA[队列的最大值题目请定义一个队列并实现函数max得到队列里的最大值，要求函数max、push_back和pop_front的时间复杂度都是O(1)。 思路与滑动窗口的最大值一题相似，利用一个双端队列来存储当前队列里的最大值以及之后可能的最大值。 在定义题目要求功能的队列时，除了定义一个队列data存储数值，还需额外用一个队列maxmium存储可能的最大值；此外，还要定义一个数据结构，用于存放数据以及当前的index值，用于删除操作时确定是否删除maxmium中最大值。 测试用例 尾部插入不同大小数字，删除头部数字。插入删除同时获取最大值。 java代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * @description: * @author: rhsphere * @since: 2019-08-03 16:52 by jdk 1.8 */public class QueueWithMax &#123; private ArrayDeque&lt;InternalData&gt; data = new ArrayDeque&lt;&gt;(); private ArrayDeque&lt;InternalData&gt; maximum = new ArrayDeque&lt;&gt;(); private class InternalData &#123; int number; int index; public InternalData(int number, int index) &#123; this.number = number; this.index = index; &#125; &#125; private int curIndex; public void pushBack(int number) &#123; InternalData curData = new InternalData(number, curIndex); data.addLast(curData); while (!maximum.isEmpty() &amp;&amp; maximum.getLast().number &lt; number) maximum.removeLast(); maximum.addLast(curData); curIndex++; &#125; public void popFront() &#123; if (data.isEmpty()) &#123; System.out.println("队列为空，无法删除"); return; &#125; InternalData curData = data.removeFirst(); if (curData.index == maximum.getFirst().index) maximum.removeFirst(); &#125; public int max() &#123; if (maximum == null) &#123; System.out.println("队列为空，无法删除"); return 0; &#125; return maximum.getFirst().number; &#125;&#125;]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Deque</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer(59-1) 滑动窗口的最大值]]></title>
    <url>%2F2019%2F08%2F03%2Fmax-in-window.html</url>
    <content type="text"><![CDATA[滑动窗口的最大值题目给定一个数组和滑动窗口的大小，请找出所有滑动窗口里的最大值。例如，如果输入数组{2, 3, 4, 2, 6, 2, 5, 1}及滑动窗口的大小3，那么一共存在6个滑动窗口，它们的最大值分别为{4, 4, 6, 6, 6, 5} 思路 蛮力直接在每个滑动窗口依次比较找出最大值，时间复杂度太高。 我们考虑把每个可能成为最大值的数字记录下来，就可以快速的得到最大值。 思路：建立一个两端开口的队列，放置所有可能是最大值的数字（存放的其实是对应的下标），且最大值位于队列开头。从头开始扫描数组， 如果遇到的数字比队列中所有的数字都大，那么它就是最大值，其它数字不可能是最大值了，将队列中的所有数字清空，放入该数字，该数字位于队列头部； 如果遇到的数字比队列中的所有数字都小，那么它还有可能成为之后滑动窗口的最大值，放入队列的末尾； 如果遇到的数字比队列中最大值小，最小值大，那么将比它小数字不可能成为最大值了，删除较小的数字，放入该数字。 由于滑动窗口有大小，因此，队列头部的数字如果其下标离滑动窗口末尾的距离大于窗口大小，那么也删除队列头部的数字。 注：队列中存放的是下标，以上讲的 队列头部的数字 均指 队列头部的下标所指向的数字。写代码时不要弄混了。 测试用例 功能测试（数组数字递增、递减、无序） 边界值测试（滑动窗口大小位0、1、大于或者等于数组长度） 特殊输入测试（null） java代码12345678910111213141516171819202122232425262728293031/** * @description: * @author: rhsphere * @since: 2019-08-03 11:47 by jdk 1.8 */public class MaxInWindow &#123; public ArrayList&lt;Integer&gt; maxInWindow(int[] num, int size) &#123; ArrayList&lt;Integer&gt; max = new ArrayList&lt;&gt;(); if (num == null || num.length &lt;= 0 || size &lt;= 0 || size &gt; num.length) return max; ArrayDeque&lt;Integer&gt; indexDeque = new ArrayDeque&lt;&gt;(); for (int i = 0; i &lt; size - 1; i++) &#123; while (!indexDeque.isEmpty() &amp;&amp; num[i] &gt; num[indexDeque.getLast()]) indexDeque.removeLast(); indexDeque.addLast(i); &#125; for (int i = size - 1; i &lt; num.length - 1; i++) &#123; while (!indexDeque.isEmpty() &amp;&amp; num[i] &gt; num[indexDeque.getLast()]) indexDeque.removeLast(); if (!indexDeque.isEmpty &amp;&amp; (i - indexDeque.getFirst()) &gt;= size) indexDeque.removeFirst(); indexDeque.addLast(i); max.add(num[indexDeque.getFirst()]); &#125; return max; &#125;&#125; 总结 关于ArrayDeque 的方法总结：待总结]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Deque</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer(58) 翻转字符串]]></title>
    <url>%2F2019%2F08%2F03%2Freverse-words.html</url>
    <content type="text"><![CDATA[翻转单词顺序题目一输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串”I am a student. “，则输出”student. a am I”。 思路一开始自己觉得要用split()方法，但这要开辟新的数组，占内存空间，不行。 首先实现翻转整个句子：只需要在首尾两端各放置一个指针，交换指针所指的数字，两端指针往中间移动即可。之后根据空格的位置，对每个单词使用同样的方法翻转即可。 测试用例 功能测试（句子中有一个/多个单词，空格在开头、中间、结尾） 边界值测试（null，空字符串，句子全为空格） java代码1234567891011121314151617181920212223242526272829303132333435/** * @description: 翻转字符串，第一步使用左右指针交换，翻转句子中所有的字符。第二步，再翻转每个单词中字符的顺序。 * @author: rhsphere * @since: 2019-08-03 10:53 by jdk 1.8 */public class ReverseWordsInSentence &#123; public String reverseSetence(char[] chars) &#123; if (chars == null || chars.length &lt;= 0) return String.valueOf(chars); //翻转整个句子 reverseSub(chars, 0, chars.length-1); //翻转单词（指针指向单词的第一个和最后一个） int start = 0; int end = 0; while (start &lt; chars.length) &#123; while (end &lt; chars.length &amp;&amp; chars[end] != ' ') end++; reverseSub(chars, start, end - 1); //注意这里不是end 因为end是空格的index start = ++end; &#125; return String.valueOf(chars); &#125; public void reverseSub(char[] chars, int start, int end) &#123; while (start &lt; end) &#123; char tmp = chars[start]; chars[start] = chars[end]; chars[end] = tmp; start++; end--; &#125; &#125;&#125; reverseSub(chars, start, end - 1); 注意这里不是end 因为end是空格的index 左旋字符串题目二字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如输入字符串”abcdefg”和数字2，该函数将返回左旋转2位得到的结果”cdefgab”。 思路本题思路和上一道题翻转单词顺序的原理一模一样，只是上一道题有空格，这道题没空格，其实这道题还更简单。先分别翻转前半部分字符串和后半部分字符串，最后翻转整个字符串即可。 测试用例 功能测试（对长度为n的字符串，左旋转-1,0,1,2,n-1,n,n+1位） 边界值测试（null） java代码123456789101112131415161718192021222324252627282930/** * @description: * @author: rhsphere * @since: 2019-08-03 11:33 by jdk 1.8 */public class LeftRotateString &#123; public String leftRotateString(char[] chars, int n) &#123; if (chars == null || chars.length &lt;= 0) return String.valueOf(chars); if (n &lt;= 0 || n &gt; chars.length) return String.valueOf(chars); reverseSub(chars, 0, n-1); reverseSub(chars, n, chars.length - 1); reverseSub(chars, 0, chars.length - 1); return String.valueOf(chars); &#125; private void reverseSub(char[] chars, int start, int end) &#123; while (start &lt; end) &#123; char tmp = chars[start]; chars[start] = chars[end]; chars[end] = tmp; start++; end--; &#125; &#125;&#125; 总结 这道题看似是移动字符，其实是翻转字符串实现的，要记住这类方法。]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>String</tag>
        <tag>Two Pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer(57) 和为s的数字]]></title>
    <url>%2F2019%2F08%2F03%2Ftwo-number-with-sum.html</url>
    <content type="text"><![CDATA[和为s的两个数字题目一 输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，输出任意一对即可。 思路从头开始遍历数字，确定一个数字后，对后面的数字遍历，判断和是否为s，这种方法复杂度为O(n^2)，效率太低。 我们考虑到，如果一个数字比较小，那么另一个数字一定比较大，同时数字为递增排列；所以，我们设置两个指针，一个指针small从第一个数字（最小）出发，另一个指针big从最后一个数字（最大）出发： 当small加big的和小于s时，只需要将small指向后一个数字（更大），继续判断； 当small加big的和大于s时，只需要将big指向前一个数字（更小），继续判断； 当small加big的和等于s时，求解完成。 由于是从两边往中间移动，所以不会有跳过的情况，时间复杂度为O(n)。 测试用例 功能测试（存在/不存在和为s的一对数字） 特殊输入测试（null） java代码1234567891011121314151617181920212223242526272829/** * @description: * @author: rhsphere * @since: 2019-08-03 09:54 by jdk 1.8 */public class TwoNumberWithSum &#123; public ArrayList&lt;Integer&gt; findNumberWithSum(int[] arr, int sum) &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); if (arr == null || arr.length &lt;= 0) return list; int low = 0; int high = arr.length - 1; while (low &lt; high) &#123; if (arr[low] + arr[high] == sum) &#123; list.add(arr[low]); list.add(arr[high]); break; &#125; else if (arr[low] + arr[high] &lt; sum) &#123; low++; &#125; else &#123; high--; &#125; &#125; return list; &#125;&#125; 总结 利用两个指针从两端向中间扫描，要学会这种技巧。 和为s的连续正数序列题目二输入一个正数s，打印出所有和为s的连续正数序列（至少含有两个数）。例如输入15，由于1+2+3+4+5=4+5+6=7+8=15，所以结果打印出3个连续序列1～5、4～6和7～8。 思路指针法：类似(57-1) 和为s的两个数字的方法，用两个指针small和big分别代表序列的最大值和最小值。令small从1开始，big从2开始。 当从small到big的序列的和小于s时，增加big，使序列包含更多数字；（记得更新序列之和） 当从small到big的序列的和大于s时，增加small，使序列去掉较小的数字；（记得更新序列之和） 当从small到big的序列的和等于s时，此时得到一个满足题目要求的序列，输出，然后继续将small增大，往后面找新的序列。 序列最少两个数字，因此，当small到了s/2时，就可以结束判断了。 数学分析法： 参考自牛客网，丁满历险记的答案。 对于一个长度为n的连续序列，如果它们的和等于s，有： 1）当n为奇数时，s/n恰好是连续序列最中间的数字，即n满足 (n&amp;1)==1 &amp;&amp; s%n==0 2）当n为偶数时，s/n恰好是连续序列中间两个数字的平均值，小数部分为0.5，即n满足 (s%n)*2==n （判断条件中包含了n为偶数的判断） 得到满足条件的n后，相当于得到了序列的中间数字s/n，所以可以得到第一个数字为 (s / n) - (n - 1) / 2，结合长度n可以得到所有数字。 此外，在什么范围内找n呢？我们知道n至少等于2，那至多等于多少？n最大时，序列从1开始，根据等差数列的求和公式根据等差数列的求和公式：S = (1 + n) * n / 2，可以得到n应该小于sqrt(2s)，所以只需要从n=2到sqrt(2s)来判断满足条件的n，继而输出序列。 测试用例 功能测试（存在/不存在和为s的序列） 边界值测试（s=3） java代码1234567891011121314151617181920212223242526272829303132333435363738394041/** * @description: * @author: rhsphere * @since: 2019-08-03 10:09 by jdk 1.8 */public class ContinuousSequenceWithSum &#123; //方法一：双指针法 public ArrrayList&lt;ArrayList&lt;Integer&gt;&gt; findContinuousSeq(int sum) &#123; ArrayList&lt;ArrayList&lt;Integer&gt;&gt; seqList = new ArrayList&lt;&gt;(); if (sum &lt;= 0) return seqList; int small = 1; int big =2; int curSum = small + big; while (small &lt;= sum/2) &#123; if (curSum == sum) &#123; ArrayList&lt;Integer&gt; seq = new ArrayList&lt;&gt;(); for (int i = small; i &lt;= big; i++) seq.add(i); seqList.add(seq); curSum -= small; small++; &#125; if (curSum &lt; sum) &#123; big++; curSum += big; &#125; if (curSum &gt; sum) &#123; curSum -= small; small--; &#125; &#125; return seqList; &#125;&#125; 总结 还是利用两个指针，这个技巧要学会 代码中求连续序列的和，并没有每次遍历计算，而是根据每次操作的情况而在之前的结果上进行加减，可以提高效率，值得学习 题目57-1) 和为s的两个数字中的指针是从两端开始，本题指针从1，2开始，注意指针的初始设置。 方法二中，当s/n的余数为0.5时，s%n的结果是n/2，而不是1。]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Two Pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer(56) 数组中数字出现的次数]]></title>
    <url>%2F2019%2F08%2F02%2Fnumber-appear-once.html</url>
    <content type="text"><![CDATA[数组中数字出现的次数题目一：数组中只出现一次的两个数字 题目一一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。 思路 记住：两个相同的数字异或等于0. 如果数组中只有一个数字只出现一次，我们从头到尾异或每个数字，那么最终的结果刚好是那个只出现一次的数字。 而本题里数组中有两个数字只出现一次，如果能够将数组分为两部分，两部分中都只有一个数字只出现一次，那么就可以解决该问题了。 求解方法： 我们依旧从头到尾异或每个数字，那么最终的结果就是这两个只出现一次的数字的异或结果，由于两个数不同，因此这个结果数字中一定有一位为1，把结果中第一个1的位置记为第n位。因为是两个只出现一次的数字的异或结果，所以这两个数字在第n位上的数字一定是1和0。 接下来我们根据数组中每个数字的第n位上的数字是否为1来进行分组，恰好能将数组分为两个都只有一个数字只出现一次的数组，对两个数组从头到尾异或，就可以得到这两个数了。 测试用例 功能测试（数组中有多对重复的数字；无重复的数字） java代码12345678910111213141516171819202122232425262728293031/** * @description: * @author: rhsphere * @since: 2019-08-02 20:55 by jdk 1.8 */public class NumbersAppearOnce &#123; public void findNumsAppearOnce(int[] arr, int[] num1, int[] num2) &#123; if (arr == null || arr.length &lt;= 0) return; int res = 0; for (int i = 0; i &lt; arr.length; i++) res ^= arr[i]; int indexOf1 = 0; while (((res &amp; 1) == 0) &amp;&amp; (indexOf1 &lt;= 32)) &#123; res = res &gt;&gt; 1; indexOf1++; &#125; num1[0] = 0; num2[0] = 2; for (int i = 0; i &lt; arr.length; i++) &#123; if (((arr[i] &gt;&gt; indexOf1) &amp; 1) == 1) num1[0] ^= arr[i]; else num2[0] ^= arr[i]; &#125; &#125;&#125; 总结 当一个数字出现两次（或者偶数次）时，用异或^ 可以进行消除。一定要牢记 异或的这个功能！ 将一组数字分为两组，可以根据某位上是否为1来进行分组，即根据和1相与（&amp;1）的结果来进行分组。 判断某个数x的第n位（如第3位）上是否为1， 1）通过 x&amp;00000100 的结果是否为0 来判断。（不能根据是否等于1来判断） 2）通过（x&gt;&gt;3)&amp;1 是否为0 来判断 将某个数x右移m位，一定要写成 x=x&gt;&gt;m；而不能只写成 x&gt;&gt;m；这个语句 数组中唯一只出现一次的数字题目二在一个数组中除了一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。 思路 这道题中数字出现了三次，无法像56-1) 数组中只出现一次的两个数字一样通过利用异或位运算进行消除相同个数字。但是仍然可以沿用位运算的思路。 将所有数字的二进制表示的对应位都加起来，如果某一位能被三整除，那么只出现一次的数字在该位为0；反之，为1。 测试用例 功能测试（唯一出现的数字是0，正数，负数；重复出现的数字是0，正数，负数） java代码12345678910111213141516171819202122232425262728293031/** * @description: * @author: rhsphere * @since: 2019-08-02 21:51 by jdk 1.8 */public class NumberAppear &#123; public static int findNumsAppearOnce(int[] arr) &#123; if (arr == null || arr.length &lt;= 0) throw new RuntimeException(); int[] bitSum = new int[32]; for (int i = 0; i &lt; 32; i++) bitSum[i] = 0; for (int i = 0; i &lt; arr.length; i++) &#123; int bitMask = 1; for (int j = 31; j &gt;= 0; j--) &#123; int bit = arr[i] &amp; bitMask; for (bit != 0) bitSum[i] += 1; bitMask = bitMask &lt;&lt; 1; &#125; &#125; int res = 0; for (int i = 0; i &lt; 32; i++) &#123; res = res &lt;&lt; 1; res += (bitSum[i] % 3); &#125; return res; &#125;&#125; 总结 判断某个数x的第n位（如第3位）上是否为1， 1）通过 x&amp;00000100 的结果是否为0 来判断。（不能根据是否等于1来判断） 2）通过（x&gt;&gt;3)&amp;1 是否为0 来判断 通过number&amp;bitMask的结果是否为0（不能用1判断），bitMask=1不断左移，可以将一个数的二进制存储到32位的数组中。 12345678int number = 100;int bitMask = 1;for(int j = 31; j &gt;= 0; j--) &#123; int bit = number &amp; bitMask; //注意arr[i]&amp;bitMask不一定等于1或者0，有可能等于00010000 if(bit != 0) bits[j] =1; bitMask = bitMask &lt;&lt; 1;&#125; 通过以下代码实现二进制转化为数字（注意左移语句的位置）： 123456int result = 0;for(int i = 0;i &lt; 32; i++) &#123; result = result &lt;&lt; 1; result += bits[i]; //result=result&lt;&lt;1; //不能放在后面，否则最前面一位就没了&#125;]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer(55) 二叉树的深度]]></title>
    <url>%2F2019%2F08%2F02%2Ftree-depth.html</url>
    <content type="text"><![CDATA[二叉树的深度题目一：二叉树的深度题目二：平衡二叉树 二叉树的深度输入一棵二叉树的根结点，求该树的深度。从根结点到叶结点依次经过的/结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。 思路简洁理解： 树的深度=max(左子树深度，右子树深度)+1，采用递归实现。 测试用例 功能测试（左斜树、右斜树、普通树） 边界值测试（一个结点） 特殊测试（null） java代码123456789101112131415161718192021222324/** * @description: 剑指offer55 * @author: rhsphere * @since: 2019-08-02 19:29 by jdk 1.8 */public class TreeDepth &#123; public class TreeNode &#123; int val = 0; TreeNode left, right; public TreeNode(int val) &#123; this.val = val; &#125; &#125; public int treeDepth(TreeNode root) &#123; if (root == null) return 0; int left = treeDepth(root.left); int right = treeDepth(root.right); return Math.max(left + 1, right + 1); &#125;&#125; 总结 深度从递归的角度理解，很赞，要记住。 平衡二叉树平衡二叉树判定输入一棵二叉树的根结点，判断该树是不是平衡二叉树。如果某二叉树中任意结点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。 思路 在(55-1) 二叉树的深度基础上修改：计算树的深度，树的深度=max(左子树深度，右子树深度)+1。在遍历过程中，判断左右子树深度相差是否超过1，如果不平衡，则令树的深度=-1，用来表示树不平衡。最终根据树的深度是否等于-1来确定是否为平衡树。 测试用例 功能测试（左斜树、右斜树、平衡或者不平衡树） 特殊测试（一个结点，null） java代码12345678910111213141516171819202122232425262728293031/** * @description: * @author: rhsphere * @since: 2019-08-02 20:29 by jdk 1.8 */public class BanlancedBST &#123; public class TreeNode &#123; int val = 0; TreeNode left, right; TreeNode (int val) &#123; this.val = val; &#125; &#125; public boolean IntBalanced(TreeNode root) &#123; return getDepth(root) != -1; &#125; private int getDepth(TreeNode root) &#123; if (root == null) return 0; int left = getDepth(root.left); if (left == -1) return -1; int right = getDepth(root.right); if (right == -1) return -1; return Math.abs(left - right) &gt; 1 ? -1 : Math.max(left, right) + 1; &#125;&#125; 总结 在判断出树不平衡后，进行剪枝（即代码中直接返回-1，不再对其他子树进行判断），以提高效率。]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer(54) 二叉搜索树的第k大节点]]></title>
    <url>%2F2019%2F08%2F02%2Fkth-node-in-BST.html</url>
    <content type="text"><![CDATA[二叉搜索树的第K大节点题目给定一棵二叉搜索树，请找出其中的第k小的结点。 思路设置全局变量index=0，对BST进行中序遍历，每遍历一个结点，index+1，当index=k时，该结点即为所求结点。 测试用例 功能测试（左斜树、右斜树、普通树） 边界值测试（k=1,k=结点数目） 特殊测试（null，k&lt;=0，k&gt;结点数目） java代码12345678910111213141516171819202122232425262728293031323334353637383940414243/** * @description: * @author: rhsphere * @since: 2019-08-02 14:42 by jdk 1.8 */public class KthNodeInBST &#123; public class TreeNode &#123; int val = 0; TreeNode left, right; public TreeNode(int val) &#123; this.val = val; &#125; &#125; int index = 0; public TreeNode kthNode(TreeNode root, int k) &#123; TreeNode p = null; if (root == null || k &lt;= 0) return p; p = getKthNode(root, k); return p; &#125; private TreeNode getKthNode(TreeNode root, int k) &#123; TreeNode kthNode = null; if (root.left != null) kthNode = getKthNode(root.left, k); if(kthNode == null) &#123; index++; if (k == index) kthNode = root; &#125; if (kthNode == null &amp;&amp; root.right != null) kthNode = getKthNode(root.right, k); reurn kthNode; &#125;&#125; 总结 熟练掌握二叉搜索树和中序遍历。 用中序遍历实现功能时，一定要注意返回值是否满足要求。]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>BST</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer(53-3) 数组中数值和下标相等的元素]]></title>
    <url>%2F2019%2F08%2F02%2Fget-number-same-as-index.html</url>
    <content type="text"><![CDATA[数组中数值和下标相等的元素题目假设一个单调递增的数组里的每个元素都是整数并且是唯一的。请编程实现一个函数找出数组中任意一个数值等于其下标的元素。例如，在数组{-3, -1,1, 3, 5}中，数字3和它的下标相等。 思路 同53-1和53-2一样，不再从头到尾遍历，由于是排序数组，我们继续考虑使用二分查找算法： 1）当中间数字等于其下标时，中间数字即为所求数字； 2）当中间数字大于其下标时，在左半部分区域寻找； 2）当中间数字小于其下标时，在右半部分区域寻找； 测试用例 功能测试（包含/不包含与下标相等的数字） 边界值测试（数字位于数组开头、中间或者结尾；仅一个数字数组） 特殊测试（null） java代码123456789101112131415161718192021222324/** * @description: * @author: rhsphere * @since: 2019-08-02 14:33 by jdk 1.8 */public class IntegerIdenticalToIndex &#123; public int getNumberSameAsIndex(int[] arr) &#123; if (arr == null || arr.length &lt;= 0) return -1; int low = 0; int high = arr.length - 1; while (low &lt;= high) &#123; int mid = (low + high) / 2; if (arr[mid] &gt; mid) &#123; high = mid - 1; &#125; else if (arr[mid] &lt; mid) &#123; low = mid +１; &#125; else &#123; return mid; &#125; &#125; return -1; &#125;&#125;]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>BinarySearch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer(53-2) 0到n-1中缺失的数字]]></title>
    <url>%2F2019%2F08%2F02%2Fmissing-number.html</url>
    <content type="text"><![CDATA[0 ~ n-1中缺失的数字题目一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0到n-1之内。在范围0到n-1的n个数字中有且只有一个数字不在该数组中，请找出这个数字。 思路 如果从头到尾依次比较值与小标是否相等，时间复杂度为O(n)，效率低。 由于是排序数组，我们继续考虑使用二分查找算法，结合上图可知： 当中间数字等于其下标时，我们在后半部分查找； 当中间数字不等于其下标时， 1）如果中间数字的前一个数字也不等于其下标，则在前半部分查找； 2）如果中间数字的前一个数字等于其下标，则说明中间数字的下标即为我们所要找的数字。 测试用例 功能测试（缺失数字位于数组开头、中间或者结尾） 边界值测试（数字只有0或1） 特殊测试（null） java代码123456789101112131415161718192021222324/** * @description: * @author: rhsphere * @since: 2019-08-02 11:21 by jdk 1.8 */public class MissingNumber &#123; public int getMissingNum(int[] arr) &#123; if (arr.length &lt;= 0 || arr == null) return -1; int low = 0; int high = arr.length - 1; while (low &lt;= high) &#123; int mid = (low + high) &gt;&gt; 1; if (arr[mid] != mid) &#123; if (mid == 0 || arr[mid -1] == mid - 1) return mid; high = mid - 1; &#125; else &#123; low = mid + 1; &#125; &#125; return -1; &#125;&#125;]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>BinarySearch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer(53-1) 数字在排序数组中出现的次数]]></title>
    <url>%2F2019%2F08%2F02%2Fnumber-of-k.html</url>
    <content type="text"><![CDATA[数字在排序数组中出现的次数题目统计一个数字在排序数组中出现的次数。例如输入排序数组{1, 2, 3, 3,3, 3, 4, 5}和数字3，由于3在这个数组中出现了4次，因此输出4。 思路二分查找的一种变型 分析：对于例子来说，如果采用二分法找到某一个3后，再往前遍历和往后遍历到第一个和最后一个3，在长度为n的数组中有可能出现O(n)个3，因此这样的扫描方法时间复杂度为O(n)，效率与从头到尾扫描一样，速度太慢。 这题关键是找到第一个和最后一个3，因此我们尝试改进二分法：中间数字比3大或者小的情况与之前类似，关键是中间数字等于3的情况，这时可以分类讨论如下： 1）如果中间数字的前一个数字也等于3，说明第一个3在前面，继续在前半段查找第一个3； 2）如果中间数字的前一个数字不等于3，说明该位置是第一个3； 3）如果中间数字的后一个数字也等于3，说明最后一个3在后面，继续在后半段查找最后一个3； 2）如果中间数字的后一个数字不等于3，说明该位置是最后一个3； 测试用例 功能测试（数字出现次数为0、1、2等） 边界值测试（数组只有一个数字，查找数字为第一个或者最后一个） 特殊测试（null） java代码用二分法的变型非递归写法，可以参考文章二分查找的一种变型中查找第一个与key相等的元素、查找最后一个与key相等的元素。 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * @description: 剑指offer53-1（1） * @author: rhsphere * @since: 2019-08-02 09:51 by jdk 1.8 */public class NumberOfK2 &#123; public int getNumberOfK(int[] arr, int k) &#123; if (arr == null || arr.length &lt;= 0) return 0; int firstK = getFirstEqual(arr, 0, arr.length-1, k); if (first == -1) return 0; //这个firstK作为getLastEqual参数有点亮 int lastK = getLastEqual(arr, firstK, arr.length-1, k); return lastK - firstK + 1; &#125; private int getFirstEqual(int[] arr, int left, int right, int key) &#123; while (left &lt;= right) &#123; int mid = (left + right) / 2; if (arr[mid] &gt;= key) &#123; right = mid - 1; &#125; else &#123; left = mid + 1; &#125; &#125; if (left &lt; arr.length &amp;&amp; arr[left] == key) return left; return -1; &#125; private int getLastEqual(int[] arr, int left, int right, int key) &#123; while (left &lt;= right) &#123; int mid = (left + right) / 2; if (arr[mid] &lt;= key) &#123; left = mid + 1; &#125; else &#123; right = mid - 1; &#125; &#125; if (right &gt;= 0 &amp;&amp; arr[right] == key) return right; return -1; &#125;&#125; 递归写法剑指offer上的写法，不够简洁。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * @description: 剑指offer53-1 * @author: rhsphere * @since: 2019-08-02 09:19 by jdk 1.8 */public class NumberOfK &#123; public int getNumberOfK(int[] arr, int k) &#123; if (arr == null || arr.length &lt;= 0) return 0; int firstK = getFirstK(arr, 0, arr.length-1, k); if (firstK == -1) return 0; int lastK = getLastK(arr, firstK, arr.length-1, k); return lastK - firstK + 1; &#125; private int getFirstK(int[] arr, int left, int right, int k) &#123; if (left &gt; right) return -1; int mid = left + ((right - left) &gt;&gt; 1); if (arr[mid] == k) &#123; if (mid == 0 || arr[mid-1] != k) return mid; else right = mid - 1; &#125; else if (arr[mid] &lt; k) &#123; left = mid + 1; &#125; else &#123; right = mid - 1; &#125; return getFirstK(arr, left, right, k); &#125; private int getLastK(int[] arr, int left, int right, int k) &#123; if (left &gt; right) return -1; int mid = (left + right) / 2; if (arr[mid] == k) &#123; if (mid == arr.length - 1 || arr[mid+1] != k) return mid; else left = mid + 1; &#125; else if (arr[mid] &lt; k) &#123; left = mid + 1; &#125; else &#123; right = mid - 1; &#125; return getLastK(arr, left, right, k); &#125;&#125;]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>BinarySearch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer(52) 两个链表的第一个公共节点]]></title>
    <url>%2F2019%2F08%2F01%2Ffirst-common-node-in-lists.html</url>
    <content type="text"><![CDATA[两个链表的第一个公共节点题目输入两个链表，找出它们的第一个公共结点。 思路蛮力法：遍历第一个链表的结点，每到一个结点，就在第二个链表上遍历每个结点，判断是否相等。时间复杂度为O(m*n)，效率低； 使用栈：由于公共结点出现在尾部，所以用两个栈分别放入两个链表中的结点，从尾结点开始出栈比较。时间复杂度O(m+n)，空间复杂度O(m+n)。 利用长度关系：计算两个链表的长度之差，长链表先走相差的步数，之后长短链表同时遍历，找到的第一个相同的结点就是第一个公共结点。 利用两个指针：一个指针顺序遍历list1和list2，另一个指针顺序遍历list2和list1，（这样两指针能够保证最终同时走到尾结点），两个指针找到的第一个相同结点就是第一个公共结点。 测试用例 功能测试（有/无公共结点；公共结点分别在链表的中间，头结点和尾结点） 特殊测试（头结点为null） java代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * @description: 剑指offer52 * @author: rhsphere * @since: 2019-08-01 21:09 by jdk 1.8 */public class FirstCommonNodesInLists &#123; public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125; &#125; //方法1：利用长度关系 public ListNode findFirstCommonNode1(ListNode list1, ListNode list2) &#123; int len1 = getLength(list1); int len2 = getLength(list2); int lenDiff = len1 - len2; ListNode longList = list1; ListNode shortList = list2; if (lenDiff &lt; 0) &#123; longList =list2; shortList = list1; lenDiff = - lenDiff; &#125; for (int i = 0; i &lt; lenDiff; i++) longList = longList.next; while (longList != null &amp;&amp; longList != shortList) &#123; longList = longList.next; shortList =shortList.next; &#125; return longList; &#125; private int getLength(ListNode list) &#123; int len = 0; while (list != null) &#123; len++; list = list.next; &#125; return len; &#125; //方法2：两个指针，p1顺序遍历list1和list2，p2顺序遍历list2和list1；最终一定会相遇 public ListNode findFirstCommonNode2(ListNode list1, ListNode list2) &#123; ListNode p = list1; ListNode q = list2; while (p != q) &#123; if (p != null) p = p.next; if (q != null) q = q.next; if (p != q) &#123; if (p == null) p = list2; if (q == null) q = list1; &#125; &#125; return p; &#125;&#125; 总结1.由于有共同结点时，后面的链表是重合的，所以这道题关键是要保证最后同时遍历到达尾结点，因此就有了后面三种方法： 利用栈的先进后出实现同时到达； 利用长度关系，长链表先行几步，实现同时到达； 两个指针同时遍历两个链表，一个先list1后list2，另一个则相反，也可以实现同时到达。]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer(51) 数组中逆序对]]></title>
    <url>%2F2019%2F08%2F01%2Finverse-pairs.html</url>
    <content type="text"><![CDATA[数组中的逆序对题目在数组中的两个数字如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。 思路如果遍历数组，对每个数字都和后面的数字比较大小，时间复杂度为O(n^2)，效率太低。 利用归并排序的思想，先将数组分解成为n个长度为1的子数组，然后进行两两合并同时排好顺序。 在对两个子区域合并排序时，记左边区域（下标为start~mid）的指针为i，右边区域（下标为mid+1~end）的指针为j，两个指针都指向该区域内最大的数字，排序时： （1）如果i指向的数字大于j指向的数字，说明：逆序对有j-mid个，我们把i指向的数字放入临时创建的排序数组中，然后令i-1，指向该区域前一个数字，继续进行排序； （2）如果i指向的数字小于等于j指向的数字，说明暂时不存在逆序对，将j指向的数字放入临时创建的排序数组中，然后令j-1，指向该区域前一个数字，继续进行排序； （3）某一子区域数字都放入排序数组后，将另一个子区域剩下的数字放入排序数组中，完成排序； （4）最后将排序好的数字按顺序赋值给原始数组的两个子区域，以便合并后的区域与别的区域合并。 测试用例 功能测试（普通数组，递增数组，递减数组，含重复数字） 边界值测试（数组只有两个数字，只有一个数字） 特殊测试（null） java代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * @description: 剑指offer51 * @author: rhsphere * @since: 2019-08-01 20:05 by jdk 1.8 */public class InversePairs &#123; public static int inversePairs(int[] arr) &#123; if (arr == null || arr.length &lt;= 0) return 0; int count = getCount(arr, 0, arr.length - 1); return count; &#125; private static int getCount(int[] arr, int start, int end) &#123; if (start &gt;= end) return 0; int mid = start + ((end - start) &gt;&gt; 1); int left = getCount(arr, start, mid); int right = getCount(arr, mid+1, end); //合并 int count = 0; int i = mid; //左边区域的指针 int j = end; //右边区域的指针 int[] tmp = new int[end - start + 1]; //临时区域 int k = end - start; //临时区域的指针 while (i &gt;= start &amp;&amp; j &gt;= mid + 1) &#123; if (arr[i] &gt; arr[j]) &#123; count += (j - mid); tmp[k--] = arr[i--]; &#125; else &#123; tmp[k--] = arr[j--]; &#125; &#125; //下面两句while 不要忘记里面的等号 while (i &gt;= start) tmp[k--] = arr[i--]; while (j &gt;= mid + 1) tmp[k--] = arr[j--]; // k + start 不是很理解 for (k = 0; k &lt; tmp.length; k++) arr[k + start] = tmp[k]; return count + left + right; &#125;&#125; 总结 归并排序的变形，递归的熟练使用。]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer(50) 第一个只出现一次的字符]]></title>
    <url>%2F2019%2F07%2F30%2F%E5%89%91%E6%8C%87Offer-50-%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6.html</url>
    <content type="text"><![CDATA[字符串中第一个只出现一次的字符题目一在字符串中找出第一个只出现一次的字符。如输入”abaccdeff”，则输出’b’。 思路创建哈希表，键值key为字符，值value为出现次数。第一遍扫描：对每个扫描到的字符的次数加一；第二遍扫描：对每个扫描到的字符通过哈希表查询次数，第一个次数为1的字符即为符合要求的输出。 由于字符（char）是长度为8的数据类型，共有256中可能，因此哈希表可以用一个长度为256的数组来代替，数组的下标相当于键值key，对应字符的ASCII码值；数组的值相当于哈希表的值value，用于存放对应字符出现的次数。 测试用例 功能测试（存在/不存在只出现一次的字符；全部都为只出现一次的字符） 特殊测试（null） java代码12345678910111213141516171819202122232425262728293031323334/** * @description: * @author: rhsphere * @since: 2019-07-31 08:00 by jdk 1.8 */public class FirstNotRepeatingChar &#123; public char firstNotRepeatingChar(String str) &#123; if (str == null) return '\0'; int[] rep = new int[256]; for (int i = 0; i &lt; 256; i++) rep[i] = 0; for (int i = 0; i &lt; str.length(); i++) &#123; int loc = (int) str.charAt(i); rep[loc] += 1; &#125; for (int i = 0; i &lt; str.length(); i++) &#123; int loc = (int) str.charAt(i); if (rep[loc] == 1) return (char) loc; &#125; return '\0'; &#125; public static void main(String[] args) &#123; FirstNotRepeatingChar demo =new FirstNotRepeatingChar(); System.out.println((demo.firstNotRepeatingChar("google")=='l')); System.out.println((demo.firstNotRepeatingChar("aabccdbd")=='\0')); System.out.println((demo.firstNotRepeatingChar("$abcdefg")=='$')); System.out.println((demo.firstNotRepeatingChar(null)=='\0')); &#125;&#125; 总结 如果需要创建哈希表，键值为 字符，值为 数字时，可以考虑用数组（length=256）来替代，数组下标表示为字符的ASCII码值。 哈希表的时间复杂度为O(1)，要求有较高的查找速度时，可以考虑使用哈希表（Java中可以使用HashMap) 如果需要判断多个字符是否在某个字符串中出现过，或者统计多个字符在某个字符串中出现的次数，可以考虑基于数组创建一个简单的哈希表，这样可以用很小的空间消耗换来时间效率的提升。 字符流中第一个只出现一个的字符题目二请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是’g’。当从该字符流中读出前六个字符”google”时，第一个只出现一次的字符是’l’。 思路字符只能一个一个从字符流中读出来，因此要定义一个容器来保存字符以及其在字符流中的位置。 为尽可能高效解决问题，要在O(1)时间内往数据容器中插入字符，及其对应的位置，因此这个数据容器可以用哈希表来实现，以字符的ASCII码作为哈希表的键值key，字符对应的位置作为哈希表的值value。 开始时，哈希表的值都初始化为-1，当读取到某个字符时，将位置存入value中，如果之前读取过该字符（即value&gt;=0），将value赋值为-2，代表重复出现过。最后对哈希表遍历，在value&gt;=0的键值对中找到最小的value，该value即为第一个只出现一次的字符，ASCII码为key的字符即为所求字符。 测试用例 功能测试（读入一个字符；读入多个字符；所有字符都唯一；所有字符重复） 特殊测试（读入0个字符） java代码123456789101112131415161718192021222324252627282930313233343536/** * @description: * @author: rhsphere * @since: 2019-08-01 18:49 by jdk 1.8 */public class FirstCharInStream &#123; private int index; private int[] occurence; pubilc FirstCharInStream() &#123; index = 0; occurence = new int[256]; for (int i = 0; i &lt; 256; i++) occurence[i] = -1; &#125; public void insert(char ch) &#123; if (occurence[(int)ch] == -1) &#123; occurence[(char)ch] == index; //第一次出现 &#125; else if (occurence[(int)ch] &gt;= 0) &#123; occurence[(int)ch] = -2; &#125; index++; &#125; public char getFirst() &#123; int minIdx = Integer.MAX_VAULE; char ch = '#'; for (int i = 0; i &lt; 256; i++) &#123; if (occurence[i] &gt;= 0 &amp;&amp; occurence[i] &lt; minIdx) &#123; ch = (char) i; minIdx = occurence[i]; &#125; &#125; return ch; &#125;&#125; 总结 对于数据流、字符流等，需要定义数据容器来保存记录。 流和串的区别： 1）串：字符串已经保存下来了，能够读取遍历，因此在字符串中第一个只出现一次的字符中，只需要存下每个字符出现的个数，然后直接在字符串中遍历； 2）流：字符流没有存下来，无法进行遍历，因此在本题中，只能在数据容器哈希表中遍历，而且哈希表中存放的是对应字符的位置，而不是个数。 记得会用构造函数来初始化参数； Integer.MAX_VALUE=2^31-1，是32位操作系统（4字节）中最大的符号型整型常量。 分清楚：字符与ASCII码的转化，以及 字符形式的数字和整形数字之间的转化。 12345678910111213141516public static void main(String[] args) &#123; //字符转化成ASCII码 char ch_a = 'a'; int code_a = (int) char_a; // =ASCII码97 //ASCII码转化成字符 char copyCh_a = (char) code_a; // =ASCII码97对应的字符'a' //字符形式数字转化为整数 char c1 = '2'; int n1 = c1 - '0'; //=2, 由'2'和'1'的ASCII码相减得到 //数字转化为字符形式 char copyC1 = (char)(n1 + '0'); //='2' ,由'0'的ASCII码加2得到'2'的ASCII码&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer(49) 丑数]]></title>
    <url>%2F2019%2F07%2F30%2Fugly-number.html</url>
    <content type="text"><![CDATA[丑数题目我们把只包含因子2、3和5的数称作丑数（Ugly Number）。求按从小到大的顺序的第1500个丑数。例如6、8都是丑数，但14不是，因为它包含因子7。习惯上我们把1当做第一个丑数。 思路直观思路：逐一判断每个整数是否为丑数，效率太低。 空间换时间的解法： 创建数组存放已经排序好的丑数，这将消耗一定的内存开销。根据丑数的定义，丑数应该是另一个丑数的2、3或者5倍的结果，因此，我们从数组中已有的丑数里找到三个丑数T2、T3、T5，它们分别和2、3、5相乘得到的值恰好比已有的最大丑数大，三个乘积中最小的一个就是下一个丑数，存放入数组中，同时更新T2、T3、T5，使它们仍然保持与2、3、5的乘积恰好比已有的最大丑数大。 测试用例 功能测试（2，3，4，5等） 特殊测试（0，1） 性能测试（1500等） java代码逐个判断每个整数123456789101112131415161718192021222324252627282930/** * @description: 暴力法求丑数 * @author: rhsphere * @since: 2019-07-30 22:49 by jdk 1.8 */public class BF_UglyNumber &#123; public int getUglyNumber(int index) &#123; if (index &lt;= 0) return 0; int number = 1; int count = 0; while (true) &#123; if (isUgly(number)) count++; if (count == index) return number; number++; &#125; &#125; private boolean isUgly(int number) &#123; while (number % 5 == 0) number /= 5; while (number % 3 == 0) number /= 3; while (number % 2 == 0) number /= 2; return number == 1; &#125;&#125; 创建数组保存已经找到的丑数，用时间换空间的解法123456789101112131415161718192021222324252627282930313233/** * @description: * @author: rhsphere * @since: 2019-07-30 22:30 by jdk 1.8 */public class UglyNumber &#123; public int getUglyNumber(int index) &#123; if (index &lt;= 0) return 0; int[] uglyNum = new int[index]; uglyNum[0] = 1; int index2 = 0; int index3 = 0; int index5 = 0; for (int i = 1; i &lt; index; i++) &#123; uglyNum[i] = getMinimum(uglyNum[index2] * 2, uglyNum[index3] * 3, uglyNum[index5] * 5); while(uglyNum[index2] * 2 &lt;= uglyNum[i]) index2++; while(uglyNum[index3] * 3 &lt;= uglyNum[i]) index3++; while(uglyNum[index5] * 5 &lt;= uglyNum[i]) index5++; &#125; return uglyNum[index - 1]; &#125; private int getMinimum(int a, int b, int c) &#123; return Math.min(Math.min(a, b), c); &#125;&#125; 总结 判断m是否为n的因子：即判断n能否被m整除，也就是n%m=0。要掌握判断因子的方法。例如判断丑数的程序如下： 123456789private boolean isUgly(int number) &#123; while (number % 5 == 0) number /= 5; while (number % 3 == 0) number /= 3; while (number % 2 == 0) number /= 2; return number == 1;&#125; 丑数是另一个丑数的2、3或者5倍，要记住这类特性和规律。特别是在遇到类似的新概念时。]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer(48) 最长不含重复自负的子字符串]]></title>
    <url>%2F2019%2F07%2F30%2Flongest-substring-without-duplicate.html</url>
    <content type="text"><![CDATA[最长不含重复字符的子字符串题目请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。假设字符串中只包含从’a’到’z’的字符。 思路动态规划法：定义函数f(i)为：以第i个字符为结尾的不含重复字符的子字符串的最大长度。 （1）当第i个字符之前未出现过，则有：f(i)=f(i-1)+1 （2）当第i个字符之前出现过，记该字符与上次出现的位置距离为d 1）如果d&lt;=f(i-1)，则有f(i)=d； 2）如果d&gt;f(i-1)，则有f(i)=f(i-1)+1； 我们从第一个字符开始遍历，定义两个int变量preLength和curLength来分别代表f(i-1)和f(i)，再创建一个长度为26的pos数组来存放26个字母上次出现的位置，即可根据上述说明进行求解。 注意：每次最大长度和字母出现位置要记得更新。 另一种思路：遍历每个字符，把当前字符看成子字符串的末尾结点，同时更新开头结点，详细代码见Longest Substring Without Repeating Characters 测试用例 功能测试（一个或者多个字符，全部字符不同/相同） 特殊测试（null，空字符串） java代码123456789101112131415161718192021222324252627282930313233343536373839404142/** * @description: * @author: rhsphere * @since: 2019-07-30 18:39 by jdk 1.8 */public class LongestSubstringWithoutDup &#123; public static int maxLength(String str) &#123; if (str == null || str.length() &lt;= 0) return 0; int pre = 0; int cur = 0; int max = 0; int[] pos = new int[26]; for (int i = 0; i &lt; pos.length; i++) pos[i] = -1; for (int i = 0; i &lt; str.length(); i++) &#123; int letterNum = str.charAt(i) - 'a'; if (pos[letterNum] &lt; 0 || i - pos[letterNum] &gt; pre) &#123; cur = pre + 1; &#125; else &#123; cur = i - pos[letterNum]; &#125; pos[letterNum] = i; if (cur &gt; max) max = cur; pre = cur; &#125; return max; &#125; public static void main(String[] args) &#123; System.out.println(maxLength("arabcacfr")==4); System.out.println(maxLength("a")==1); System.out.println(maxLength("aaa")==1); System.out.println(maxLength("abcdef")==6); System.out.println(maxLength("")==0); System.out.println(maxLength(null)==0); &#125;&#125; 总结 函数f(i)为：以第i个字符为结尾的不含重复字符的子字符串的最大长度。而不是以第i个字符作为开头。第i个字符作为结尾可以方便与下一个字符进行联系。 学会用长度为26的数组来存放26个字母所在的位置下标。]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer(48) 最长不含重字符的子字符串]]></title>
    <url>%2F2019%2F07%2F30%2Flongest-substring-without-duplicate.html</url>
    <content type="text"><![CDATA[最长不含重复字符的子字符串题目请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。假设字符串中只包含从’a’到’z’的字符。 思路动态规划法：定义函数f(i)为：以第i个字符为结尾的不含重复字符的子字符串的最大长度。 （1）当第i个字符之前未出现过，则有：f(i)=f(i-1)+1 （2）当第i个字符之前出现过，记该字符与上次出现的位置距离为d 1）如果d&lt;=f(i-1)，则有f(i)=d； 2）如果d&gt;f(i-1)，则有f(i)=f(i-1)+1； 我们从第一个字符开始遍历，定义两个int变量preLength和curLength来分别代表f(i-1)和f(i)，再创建一个长度为26的pos数组来存放26个字母上次出现的位置，即可根据上述说明进行求解。 注意：每次最大长度和字母出现位置要记得更新。 另一种思路：遍历每个字符，把当前字符看成子字符串的末尾结点，同时更新开头结点，代码见leetcode03中。 这道题有一个很大的限制条件，字符串的取值为 a~z，所以用一个数组当 hash表足够，但是如果有空格就不行了。所以可以采用一个更大的哈希表存储，最后一次出现的字符的位置 new int[256]; 测试用例 功能测试（一个或者多个字符，全部字符不同/相同） 特殊测试（null，空字符串） java代码123456789101112131415161718192021222324252627282930313233343536373839404142/** * @description: * @author: rhsphere * @since: 2019-07-30 18:39 by jdk 1.8 */public class LongestSubstringWithoutDup &#123; public static int maxLength(String str) &#123; if (str == null || str.length() &lt;= 0) return 0; int pre = 0; int cur = 0; int max = 0; int[] pos = new int[26]; for (int i = 0; i &lt; pos.length; i++) pos[i] = -1; for (int i = 0; i &lt; str.length(); i++) &#123; int letterNum = str.charAt(i) - 'a'; if (pos[letterNum] &lt; 0 || i - pos[letterNum] &gt; pre) &#123; cur = pre + 1; &#125; else &#123; cur = i - pos[letterNum]; &#125; pos[letterNum] = i; if (cur &gt; max) max = cur; pre = cur; &#125; return max; &#125; public static void main(String[] args) &#123; System.out.println(maxLength("arabcacfr")==4); System.out.println(maxLength("a")==1); System.out.println(maxLength("aaa")==1); System.out.println(maxLength("abcdef")==6); System.out.println(maxLength("")==0); System.out.println(maxLength(null)==0); &#125;&#125; 总结 函数f(i)为：以第i个字符为结尾的不含重复字符的子字符串的最大长度。而不是以第i个字符作为开头。第i个字符作为结尾可以方便与下一个字符进行联系。 学会用长度为26的数组来存放26个字母所在的位置下标。 即哈希表。]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>String</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer(47) 礼物的最大价值]]></title>
    <url>%2F2019%2F07%2F30%2Fmax-value-of-gifts.html</url>
    <content type="text"><![CDATA[礼物的最大价值题目在一个m×n的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向左或者向下移动一格直到到达棋盘的右下角。给定一个棋盘及其上面的礼物，请计算你最多能拿到多少价值的礼物？ 思路动态规划：定义f(i,j)为到达(i,j)位置格子时能拿到的礼物总和的最大值，显然有边界条件，f(i, 0) = arr[0][0] + arr[i][0]， f(0, j) = arr[0][0] + arr[0][j]。则有状态转移方程：f(i,j)=max{f(i,j),f(i,j)} + arr(i,j)。 同上道题一样，如果直接使用递归会产生大量的重复计算，因此，创建辅助的数组来保存中间计算结果。 辅助数组不用和m*n的二维数组一样大，只需要保存上一层的最大值就可以。代码中使用长度为列数n的一位数组作为辅助数组，注释部分为二维辅助数组。 测试用例 功能测试（多行多列，一行多列，多行一列，一行一列） 特殊测试（null） java代码二维数组的辅助空间123456789101112131415161718192021222324252627282930313233343536373839/** * @description: * @author: rhsphere * @since: 2019-07-30 10:55 by jdk 1.8 */public class Matrix_MaxValueOfGifts &#123; public int maxValueOfGifts(int[][] values) &#123; if (values == null || values.length &lt;= 0 || values[0].length &lt;= 0) return 0; int rows = values.length; int cols = values[0].length; int[][] cache = new int[rows][cols]; cache[0][0] = values[0][0]; for (int i = 1; i &lt; rows; i++) cache[i][0] = cache[i-1][0] + values[i][0]; for (int j = 1; j &lt; cols; j++) cache[0][j] = cache[0][j-1] + values[0][j]; for (int i = 1; i &lt; rows; i++) &#123; for (int j = 1; j &lt; cols; j++) &#123; if (cache[i-1][j] &gt; cache[i][j-1]) cache[i][j] = cahce[i-1][j] + values[i][j]; else cache[i][j] = cache[i][j-1] + values[i][j] &#125; &#125; return cache[rows-1][cols-1]; &#125; public static void main(String[] args) &#123; MaxValueOfGifts demo = new MaxValueOfGifts(); int[][] values = &#123;&#123;1, 10, 3, 8&#125;, &#123;12, 2, 9, 6&#125;, &#123;5, 7, 4, 11&#125;, &#123;3, 7, 16, 5&#125;&#125;; System.out.print("路径："); System.out.println("最大值为：" + demo.maxValueOfGifts(values)); &#125;&#125; 一维数组的辅助空间分析见剑指offer书本，以及debug模式。 123456789101112131415161718192021222324252627/** * @description: 一维辅助空间 * @author: rhsphere * @since: 2019-07-30 11:43 by jdk 1.8 */public class Array_MaxValueOfGifts &#123; public int maxValueOfGifts(int[][] values) &#123; if (values == null || values.length &lt;= 0 || values[0].length &lt;= 0) return 0; int rows = values.length; int cols = values[0].length; int[] maxValue = new int[clos]; for (int i = 0; i &lt; rows; i++) &#123; for (int j = 0; j &lt; cols; j++) &#123; int left = 0; int up = 0; if (i &gt; 0) up = maxValue[j]; if (j &gt; 0) left = maxValue[j-1]; maxValue = Math.max(up, left) + value[i][j]; &#125; &#125; return maxValue[cols - 1]; &#125;&#125; 总结 动态规划问题，用公式来表示清楚。 动态规划如果有大量重复计算，可以用循环+辅助空间来提高效率。 这道题不用二维数组，只需要用一维数组作为辅助空间即可，以后遇到对中间结果的保存问题，看看能否优化辅助空间。]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
        <tag>matrix</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer(46) 把数字翻译成字符串]]></title>
    <url>%2F2019%2F07%2F30%2Ftranslate-numbers-to-strings.html</url>
    <content type="text"><![CDATA[把数字翻译成字符串题目给定一个数字，我们按照如下规则把它翻译为字符串：0翻译成”a”，1翻译成”b”，……，11翻译成”l”，……，25翻译成”z”。一个数字可能有多个翻译。例如12258有5种不同的翻译，它们分别”bccfi”, “bwfi”, “bczi”, “mcfi” 和”mzi” 。请编程实现一个函数用来计算一个数字有多少种不同的翻译方法。 思路看到题目，很容易想到使用递归：用f(i)来表示从第i位开始的不同翻译数目，可以得到有：f(i)=f(i+1)+g(i,i+1)*f(i+2)。i和i+1位数字拼起来在10~25范围内时g(i,i+1)的值为1，否则为0。 但是存在重复的子问题，所以递归并非最佳方法，我们从数字的末尾开始计算f(i)，自下而上解决问题，就可以消除重复的子问题了。先算f(len-1)，f(len-2)，再根据公式f(i)=f(i+1)+g(i,i+1)*f(i+2)往前逐步推导到f(0)，这就是最终要求的结果。 测试用例 功能测试（1个数字；多个数字） 特殊测试（负数，0，含25、26等） java代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * @description: * @author: rhsphere * @since: 2019-07-30 10:19 by jdk 1.8 */public class TranslateNumbersToStrings &#123; public int getTranslationCount(int number) &#123; if (number &lt; 0) return 0; String sNum = String.valueOf(number); int len = sNum.length(); int[] counts = new int[len]; for (int i = len - 1; i &gt;= 0; i--) &#123; if (i == len - 1) &#123; counts[i] = 1; &#125; else &#123; count[i] = count[i + 1]; if (canBeTrans(sNum, i)) &#123; if (i == len - 2) counts[i] += 1; else counts[i] += counts[i + 2]; &#125; &#125; &#125; return counts[0]; &#125; private boolean canBeTrans(String sNum, int i) &#123; int a = sNum.charAt(i) - '0'; int b = sNum.charAt(i + 1) - '0'; int convert = a * 10 + b; if (convert &gt;= 10 &amp;&amp; convert &lt;= 25) return true; return false; &#125; public static void main(String[] args) &#123; TranslateNumbersToStrings demo= new TranslateNumbersToStrings(); System.out.println(demo.getTranslationCount(0)==1); System.out.println(demo.getTranslationCount(10)==2); System.out.println(demo.getTranslationCount(12258)==5); System.out.println(demo.getTranslationCount(-100)==0); &#125;&#125; 总结 递归方法，我们试着用公式描述会比较清晰 递归是自上而下解决问题，如果遇到重复的子问题时，考虑自下而上求解，不用递归 g(i,i+1)不仅要判断&lt;=25，还要判断&gt;=10，别漏了]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>String</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer(45) 把数组排成最小的数]]></title>
    <url>%2F2019%2F07%2F30%2Fsort-array-for-min-number.html</url>
    <content type="text"><![CDATA[把数组排成最小的数题目输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3, 32, 321}，则打印出这3个数字能排成的最小数字321323。 思路不好的方法：求出所有全排列（类似字符串的排列 ），将数字拼起来，最后求出所有的最小值。这效率太低，且没有考虑到大数问题。 好的方法：观察规律，自行定义一种排序规则。 对于数字m和n，可以拼接成mn和nm，如果mn&lt;nm，我们定义m小于n。反之则相反。利用这个排序规则，从小排到大即可实现题目要求。 拼接m和n时，要考虑到大数问题，因此将m和n拼接起来的数字转换成字符串处理。因为mn和nm的字符串位数相同，因此它们的大小只需要按照字符串大小的比较规则就可以了。 具体实现：将数字存入ArrayList中，通过利用Collections.sort(List list, Comparator&lt;? super T&gt; c)方法进行排序。Comparator中重写compar()方法来规定比较规则。 测试用例 功能测试（1个数字；多个数字；数字数位有重复） 特殊测试（null） java代码12345678910111213141516171819202122232425** * @description: * @author: rhsphere * @since: 2019-07-30 10:05 by jdk 1.8 */public class SortArrayForMinNumber &#123; public String printMinNumber(int[] numbers) &#123; if (numbers == null || numbers.length &lt;= 0) return ""; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); for (int num : numbers) list.add(String.valueOf(num)); Collections.sort(list, new Comparator&lt;String&gt;()&#123; public int conpare(String s1, String s2) &#123; String a = s1 + s2; String b = s2 + s1; return a.compare(b); &#125; &#125;); StringBuilder sb = new StringBuilder(): for(String str : list) sb.append(str); return sb.toString(); &#125;&#125; 总结 记住Collections.(List list, Comparator&lt;? super T&gt; c)在重写compare()方法的使用。 小心大数问题，用字符串解决大数问题。 遇到类似排序问题，想想自定排序规则是否更加方便]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer(44) 数字序列中某一位的数字]]></title>
    <url>%2F2019%2F07%2F30%2Fdigits-in-sequence.html</url>
    <content type="text"><![CDATA[数字序列中某一位的数字题目数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从0开始计数）是5，第13位是1，第19位是4，等等。请写一个函数求任意位对应的数字。 思路逐一枚举数字，计算每个数字的位数相加，效率太低。 观察规律： 个位数的个数一共有10个，即0~9，共占了10*1位数字； 两位数的个数一共有90个，即10~99，每个数字占两位，共占了90*2位数字； …… m位数的个数一共有910^(m-1)个，每个数字占m位，占了910^(m-1)*m位数字。 判断第n个对的数字是属于几位数，再从几位数中进行寻找。 测试用例 功能测试（输入19、1000等） 边界值测试（输入0、1等） java代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** * @description: * @author: rhsphere * @since: 2019-07-30 09:18 by jdk 1.8 */public class DigitsInSeq &#123; public int digitAtIndex(int index) &#123; if (index &lt; 0) return -1; int m = 1; //m位数 while (true) &#123; int numbers = numbersOfInt(m); //m位的个数 if (index &lt; numbers * m) return getDigit(index, m); index -= numbers * m; m++; &#125; &#125; /* * 返回m位数的总个数 * 例如，两位数一共有90个：10~99；三位数有900个：100~999 */ private int numbersOfInt(int m) &#123; if(m==1) return 10; return (int) (9*Math.pow(10, m-1)); &#125; /* * 获取数字 */ private int getDigit(int index, int m) &#123; int number = getFirstNumber(m) + index / m; //对应的m位 int indexFromRight = m - index % m; //在数字中的位置 for (int i = 1; i &lt; indexFromRight; i++) number /= 10; return number % 10; &#125; /* * 第一个m位数 * 例如第一个两位数是10，第一个三位数是100 */ private int getFirstNumber(int m) &#123; if(m==1) return 0; return (int) Math.pow(10, m-1); &#125; public static void main(String[] args) &#123; DigitsInSeq demo=new DigitsInSeq(); System.out.println(demo.digitAtIndex(0)==0); System.out.println(demo.digitAtIndex(1)==1); System.out.println(demo.digitAtIndex(19)==4); System.out.println(demo.digitAtIndex(1000)==3); System.out.println(demo.digitAtIndex(1001)==7); System.out.println(demo.digitAtIndex(1002)==0); &#125;&#125;]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer(43) 1~n整数中1出现的次数]]></title>
    <url>%2F2019%2F07%2F29%2Fnum-of-1-between-1-and-n.html</url>
    <content type="text"><![CDATA[1~n整数中1出现的次数题目 输入一个整数n，求从1到n这n个整数的十进制表示中1出现的次数。例如输入12，从1到12这些整数中包含1 的数字有1，10，11和12，1一共出现了5次。 思路如果是从头到尾遍历(n次)，对每一个数字都计算其1的个数（lgn次），则时间复杂度为O(nlogn)，运算效率太低。因此必须总结规律，提高效率。 总结规律如下（思路比《剑指OFFER》一书简单）： 对于整数n，我们将这个整数分为三部分：当前位数字cur，更高位数字high，更低位数字low，如：对于n=21034，当位数是十位时，cur=3，high=210，low=4。 我们从个位到最高位 依次计算每个位置出现1的次数： 1）当前位的数字等于0时，例如n=21034，在百位上的数字cur=0，百位上是1的情况有：00100~00199，01100~01199，……，20100~20199。一共有21100种情况，即high100; 2）当前位的数字等于1时，例如n=21034，在千位上的数字cur=1，千位上是1的情况有：01000~01999，11000~11999，21000~21034。一共有21000+（34+1）种情况，即high1000+(low+1)。 3）当前位的数字大于1时，例如n=21034，在十位上的数字cur=3，十位上是1的情况有：00010~00019，……，21010~21019。一共有（210+1）10种情况，即(high+1)10。 这个方法只需要遍历每个位数，对于整数n，其位数一共有lgn个，所以时间复杂度为O(logn)。 测试用例 功能测试（3，45，180等） 边界值测试（0，1等） 性能测试（输入较大的数字，如1000000等） java代码1234567891011121314151617181920212223/** * @description: * @author: rhsphere * @since: 2019-07-29 23:14 by jdk 1.8 */public class NumberOf1 &#123; public int NumberOf1(int n) &#123; int count = 0; for (int i = 1; i &lt;= n; i *= 10) &#123; //i代表位数 int high = n / (i * 10); //更高位数字 int low = (n % i); //更低位数字 int cur = (n / i) % 10; //当前数字 if (cur == 0) &#123; count += high * i; &#125; else if ( cur == 1) &#123; count += high * i + (low + 1); &#125; else &#123; count += (high + 1) * i; &#125; &#125; return count; &#125;&#125; 总结 找规律要耐心！欲速则不达。 学会提取不同位置的数字，以及更高、更低位置的数字；学会遍历每个位数的循环。]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer(42) 连续子数组的最大和]]></title>
    <url>%2F2019%2F07%2F29%2Fgreatest-sum-of-subarrays.html</url>
    <content type="text"><![CDATA[连续子数组的最大和本题的动态规划解法，待完成。 题目输入一个整型数组，数组里有正数也有负数。数组中一个或连续的多个整/数组成一个子数组。求所有子数组的和的最大值。要求时间复杂度为O(n)。 思路分析规律，从第一个数字开始累加，若走到某一个数字时，前面的累加和为负数，说明不能继续累加了，要从当前数字重新开始累加。在累加过程中，将每次累加和的最大值记录下来，遍历完成后，返回该数字。 测试用例 功能测试（输入数组有正有负，全负数，全正数） 特殊输入测试（null） java代码12345678910111213141516171819202122232425262728293031/** * @description: * @author: rhsphere * @since: 2019-07-29 23:00 by jdk 1.8 */public class GreatestSumOFSubArrays &#123; boolean isInvalidInput = false; public int findGreatestSumOfSubarray(int[] arr) &#123; if (arr == null || arr.length &lt;= 0) &#123; isInvalidInput = true; return 0; &#125; isInvalidInput = false; int sum = arr[0]; int maxSum = arr[0]; for (int i = 1; i &lt; arr.length; i++) &#123; if (sum &lt; 0) &#123; sum = arr[i]; &#125; else &#123; sum += arr[i]; &#125; if (sum &gt; maxSum) maxSum = sum; &#125; return maxSum; &#125;&#125;]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer(41) 数据流中的中位数]]></title>
    <url>%2F2019%2F07%2F29%2Fstream-median.html</url>
    <content type="text"><![CDATA[数据流中的中位数题目如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。 思路所谓数据流，就是不会一次性读入所有数据，只能一个一个读取，每一步都要求能计算中位数。 将读入的数据分为两部分，一部分数字小，另一部分大。小的一部分采用大顶堆存放，大的一部分采用小顶堆存放。当总个数为偶数时，使两个堆的数目相同，则中位数=大顶堆的最大数字与小顶堆的最小数字的平均值；而总个数为奇数时，使小顶堆的个数比大顶堆多一，则中位数=小顶堆的最小数字。 因此，插入的步骤如下： 1. 若已读取的个数为偶数（包括0）时，两个堆的数目已经相同，将新读取的数插入到小顶堆中，从而实现小顶堆的个数多一。但是，如果新读取的数字比大顶堆中最大的数字还小，就不能直接插入到小顶堆中了 ，此时必须将新数字插入到大顶堆中，而将大顶堆中的最大数字插入到小顶堆中，从而实现小顶堆的个数多一。 2. 若已读取的个数为奇数时，小顶堆的个数多一，所以要将新读取数字插入到大顶堆中，此时方法与上面类似。 测试用例 功能测试（读入奇/偶数个数字） 边界值测试（读入0个、1个、2个数字） jav代码12345678910111213141516171819202122232425262728293031323334353637383940414243/** * @description: * @author: rhsphere * @since: 2019-07-29 21:52 by jdk 1.8 */public class StreamMedian &#123; PriorityQueue&lt;Integer&gt; minHeap = new PriorityQueue&lt;&gt;(); //小顶堆，默认容量11 PriorityQueue&lt;Integer&gt; maxHeap = new PriorityQueue&lt;&gt;(11, new Comparator&lt;Integer&gt;&#123; public int compare(Integer i1, Integer i2) &#123; return i2 - i1; &#125; &#125;); public void insert(Integer num) &#123; if (((minHeap.size() + maxHeap.size()) &amp; 1) == 0) &#123; //偶数个时，下个数字加入小顶堆 if (!maxHeap.isEmpty() &amp;&amp; maxHeap.peek() &gt; num) &#123; maxHeap.offer(num); num = maxHeap.poll(); &#125; minHeap.offer(num); &#125; else &#123; //奇数个时，下个数字放入大顶堆 if (!minHeap.isEmpty() &amp;&amp; minHeap.peek() &lt; num) &#123; minHeap.offer(num); num = minHeap.poll(); &#125; maxHeap.offer(num); &#125; &#125; public Double getMedian() &#123; if ((maxHeap.size() + minHeap.size()) == 0) throw new RuntimeException(); double median; if (((minHeap.size() + maxHeap.size()) &amp; 1) == 0) &#123; median = (maxHeap.peek() + minHeap.peek()) / 2.0; &#125; else &#123; median = minHeap.peek(); &#125; return median; &#125;&#125; 总结 最大堆 最小堆其实就是优先队列，这里可以用PriorityQueue实现，PriorityQueue默认是一个小顶堆，通过传入自定义的Comparator函数，可以实现大顶堆： 12345PriorityQueue&lt;Integer&gt; maxHeap = new PriorityQueue&lt;Integer&gt;(11, new Comparator&lt;Integer&gt;()&#123; public int compare(Integer i1, Integer i2) &#123; retrurn i2 - i1; //降序排列 &#125;&#125;); PriorityQueue的常用方法有： poll()、 offer(Object)、 size()、 peek()等。 平均值定义为double，且 (a+b）/2.0 。 往最大堆中插入数据时间复杂度是O(logn)，获取最大数的时间复杂度是O(1)。 这道题关键在于分成两个平均分配的部分，奇偶时分别插入到最大最小堆中，利用最大最小堆性质的插入方法要掌握。]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>PriorityQueue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer(40) 最小的k个数]]></title>
    <url>%2F2019%2F07%2F28%2Fk-least-numbers.html</url>
    <content type="text"><![CDATA[最小的k个数关于堆排序，堆的下沉操作，圆满解决。 题目输入n个整数，找出其中最小的k个数。例如输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。 思路思路一：同剑指offer(39) 数组中出现次数超过一半的数字中使用partition()方法，基于数组的第k个数字调整，使得更小的k个数字都在数组左边即可。 思路二：依次遍历n个整数，用一个容器存放最小的k个数字，每遇到比容器中最大的数字还小的数字时，将最大值替换为该数字。容器可以使用最大堆或者红黑树来实现。本文根据堆排序的原理来实现。 测试用例 功能测试（数组中存在/不存在重复数字） 边界值测试（k=1或者等于数组长度） 特殊测试（null、k&lt;1、k大于数组长度） java代码用partition函数修改数组1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * @description: 剑指offer40 * @author: rhsphere * @since: 2019-07-28 20:47 by jdk 1.8 */public class KLeastNum &#123; public ArrayList&lt;Integer&gt; getLeastNumbers(int[] input, int k) &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(k); if (input == null || k &lt;= 0 || k &gt; input.length) &#123; return list; &#125; int start = 0; int end = input.length - 1; int index = partition(input, start, end); while (index != k - 1) &#123; if (index &lt; k - 1) &#123; start = index + 1; index = partition(input, start, end); &#125; else &#123; end = index - 1; index = partition(input, start, end); &#125; &#125; for (int i = 0; i &lt; k; i++) list.add(input[i]); return list; &#125; private int partition(int[] arr, int startIndex, int endIndex) &#123; int pivot = arr[startIndex]; int low = startIndex; int high = endIndex; while (low != high) &#123; while (low &lt; high &amp;&amp; arr[high] &gt; pivot) high--; while (low &lt; high &amp;&amp; arr[low] &lt;= pivot) low++; if (low &lt; high) &#123; int tmp = arr[low]; arr[low] = arr[high]; arr[high] = tmp; &#125; &#125; arr[startIndex] = arr[low]; arr[low] = pivot; return low; &#125;&#125; 基于堆的容器1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * @description: 基于堆的容器 * @author: rhsphere * @since: 2019-07-29 13:25 by jdk 1.8 */public class KLeastNum_Heap &#123; public ArrayList&lt;Integer&gt; getLeastNum(int[] input, int k) &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); if (k &lt;= 0 || k &gt; input.length || input == null) return list; int numbers = new int[k]; for (int i = 0; i &lt; k; i++) numbers[i] = input[i]; for (int i = k/2 - 1; i &gt;= 0; i--) downAdjust(numbers, i, k); //这两句可以写成 //buildHeap(numbers); for (int i = k; i &lt; input.length; i++) &#123; if (input[i] &lt; numbers[0]) &#123; numbers[0] = input[i]; adjustHeap(numbers, 0, k); &#125; &#125; for (int i : numbers) list.add(i); return list; &#125; private void downAdjust(int[] arr, int parent, int length) &#123; int tmp = arr[parent]; int child = 2 * parent + 1; while (child &lt; length) &#123; if (child + 1 &lt; length &amp;&amp; arr[child + 1] &gt; arr[child]) child++; if (tmp &gt;= arr[child]) break; arr[parent] = arr[child]; parent = child; child = 2 * child + 1; &#125; arr[parent] = tmp; &#125; private void buildHeap(int arr) &#123; for (int i = arr.length/2 - 1; i &gt;= 0; i--) downAdjust(arr, i, arr.length); &#125;&#125; 总结 本题就是对快速排序和堆排序的延伸。 k小于等于0的情况别忘记了 方法二，只需要在原始数组中进行读入操作，而所有的写操作和判断都是在容器中进行的，不用反复读取原始数组，思想非常好。 记得要弄清楚是否可以改变原始输入的数组。 partition函数：即是快速排序的基础，也可以用来查找n个数中第k大的数字。 当涉及到频繁查找和替换最大最小值时，二叉树是非常合适的数据结构，要能想到堆和二叉树。]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Heap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer(39) 数组中出现次数超过一半的数字]]></title>
    <url>%2F2019%2F07%2F28%2Fmore-than-hanlf-number.html</url>
    <content type="text"><![CDATA[数组中出现次数超过一半的数字题目 数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1, 2, 3, 2, 2, 2, 5, 4, 2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。 思路思路一：数字次数超过一半，则说明：排序之后数组中间的数字一定就是所求的数字。 利用partition()函数获得某一随机数字，其余数字按大小排在该数字的左右。若该数字下标刚好为n/2，则该数字即为所求数字；若小于n/2，则在右边部分继续查找；反之，左边部分查找。 思路二：数字次数超过一半，则说明：该数字出现的次数比其他数字之和还多 遍历数组过程中保存两个值：一个是数组中某一数字，另一个是次数。遍历到下一个数字时，若与保存数字相同，则次数加1，反之减1。若次数=0，则保存下一个数字，次数重新设置为1。由于要找的数字出现的次数比其他数字之和还多，那么要找的数字肯定是最后一次把次数设置为1的数字。 也可以这样理解（来源：牛客网 cm问前程）： 采用阵地攻守的思想： 第一个数字作为第一个士兵，守阵地；count = 1； 遇到相同元素，count++; 遇到不相同元素，即为敌人，同归于尽,count–；当遇到count为0的情况，又以新的i值作为守阵地的士兵，继续下去，到最后还留在阵地上的士兵，有可能是主元素。 再加一次循环，记录这个士兵的个数看是否大于数组一般即可。 测试用例 功能测试（存在或者不存在超过数组长度一半的数字） 特殊测试（null、1个数字） java代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889/** * @description: 剑指offer39 * @author: rhsphere * @since: 2019-07-28 20:21 by jdk 1.8 */public class MoreThanHalfNumber &#123; boolean isInputInvalid = true; //方法一：partition方法 public int moreThanHalfNum(int[] arr) &#123; if (arr == null || arr.length &lt;= 0) return 0; int low = 0; int high = arr.length - 1; int index = partition(arr, low, high); while (index != arr.length &gt;&gt; 1) &#123; if (index &lt; arr.length &gt;&gt; 1) &#123; low = index + 1; index = partition(arr, low, high); &#125; else &#123; high = index - 1; index = partition(arr, low, high); &#125; &#125; //判断次数是否超过一半 int num = arr[index]; int times = 0; for (int i = 0; i &lt; arr.length; i++) &#123; if (arr[i] == num) &#123; times++; &#125; &#125; if (times * 2 &gt; arr.length) &#123; isInputInvalid = false; return num; &#125; return 0; &#125; //partition简洁的的单边循环法 private int partition(int[] arr, int low, int high) &#123; int pivot = arr[low]; int mark = low; for (int i = low + 1; i &lt;= high; i++) &#123; if (arr[i] &lt; pivot) &#123; mark++; int tmp = arr[mark]; arr[mark] = arr[i]; arr[i] = tmp; &#125; &#125; arr[low] = arr[mark]; arr[mark] = pivot; return mark; &#125; //方法二 public int moreThanHalfNum(int[] arr) &#123; if (arr == null || arr.length &lt;= 0) return 0; int num = arr[0]; int count = 1; for (int i = 1; i &lt; arr.length - 1; i++) &#123; if (count == 0) &#123; num = arr[i]; count++; &#125; else if (arr[i] == num) &#123; count++; &#125; else &#123; count--; &#125; &#125; if (count &gt; 0) &#123; int times = 0; for (int i = 0; i &lt; arr.length; i++) &#123; if (arr[i] == num) &#123; times++; &#125; &#125; if (times * 2 &gt; arr.length) &#123; isInputInvalid = false; return num; &#125; &#125; return 0; &#125;&#125; 总结 length/2 用 length&gt;&gt;1 来代替，具有更高的效率 本题中，找到了所求数字，别忘记判断该数字的次数是否超过一半，感觉很容易忘记进行判断。 题目所要求的返回值为int，所以如果数组不满足要求时，无法通过返回值来告知是否出错，所以这道题设置了一个全局变量来进行判断。调用该方法时，需要记得对全局变量进行检查。 方法一中，采用了partition()函数，该函数会改变修改的数组，因此在面试的时候，需要和面试官讨论是否可以修改数组。 两种方法的时间复杂度均为O(n)。]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer(38) 字符串的排列]]></title>
    <url>%2F2019%2F07%2F26%2Fstring-permutation.html</url>
    <content type="text"><![CDATA[字符串的排列题目 输入一个字符串，打印出该字符串中字符的所有排列。例如输入字符串abc，则打印出由字符a、b、c所能排列出来的所有字符串abc、acb、bac、bca、cab和cba。（本文代码采用ArrayList接收返回的字符串，并要求不出现重复字符串） 思路将字符串看成两部分，一部分是第一个字符，另一部分是后面的所有字符。 首先确定第一个字符，该字符可以是字符串中的任意一个；固定第一个字符后，求出后面所有字符的排列（相同步骤，采用递归）。 实现第一个字符的改变，只需要将第一个字符和后面所有字符交换即可。要记得字符串输出后，要将字符交换回来，变成原始的字符串。 使用递归每次处理一个位置，第一个位置有n种选择，第二个位置有n-1种选择 假设当前位置是index，需要把其他位置的元素放到index上，则可以将该元素和index位置上的元素交换，这样原来index位置上的元素可以作为下一轮递归函数的index候选之一 再一次循环中，交换完元素，调用递归函数，最后还需要再交换刚才的两个元素，相当于复原了当前递归函数中的str，在下一轮循环中考虑该index位置上的其他可能的选项。 测试用例 功能测试（有多个重复字母的字符串、所有字符相同的字符串、一个字符或者多个字符的普通字符串） 特殊测试（字符串为null、“”） java代码1234567891011121314151617181920212223242526272829303132333435/** * @description: 剑指offer38 字符串的排列 * @author: rhsphere * @since: 2019-07-26 09:46 by jdk 1.8 */public class StringPermutation &#123; public ArrayList&lt;String&gt; permutation(String str) &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); if (str == null || str.length == 0) return list; permutationCore(str.toCahrArray(), 0, list); Collections.sort(list); return list; &#125; private void permutationCore(char[] arr, int index, ArrayList&lt;String&gt; list) &#123; if (index == arr.length - 1) &#123; if (!list.contains(String.valueOf(arr))) //判断是否有重复字符 list.add(String.valueOf(arr)); &#125; else &#123; for (int i = index; i &lt; arr.length; i++) &#123; swap(arr, index, i); permutationCore(arr, index + 1, list); swap(arr, index, i); &#125; &#125; &#125; private void swap(char[] arr, int index, int i) &#123; char tmp = char[index]; char[inde] = char[i]; char[i] = tmp; &#125;&#125; 总结 要对字符串进行修改，可以将字符串转化为字符数组进行修改，也可以考虑使用StringBuilder类。 list.contains()方法可以直接判断是否有重复字符串；Collections.sort(list)可以将list中的字符串进行排序。 字符串和字符数组间的转化：str.toCharArray() String.valueOf(strArray) 数组在递归过程中进行了交换后，最终要记得交换回来（代码最后几行）]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer(37) 序列化二叉树]]></title>
    <url>%2F2019%2F07%2F25%2Fserialize-binary-tree.html</url>
    <content type="text"><![CDATA[序列化二叉树题目请实现两个函数，分别用来序列化和反序列化二叉树。 思路一般情况下，需要采用前/后序遍历和中序遍历才能确定一个二叉树，但是其实可以只采用前序遍历（从根节点开始），将空节点（null)输出为一个特殊符号（如“$”），就可以确定一个二叉树了。 将二叉树序列化为字符串，就是前序遍历的过程，遇见空结点时，序列化为“$”，每个结点间使用逗号分隔开。 将字符串反序列化为二叉树，也使用前序遍历，遇见一个新数字(或者$)就建立一个新结点，不过需要注意的是，数字可能不只是个位数字，因此创建了一个全局Int变量index（在字符串上的移动的指针），以便于截取字符串中当前的结点值。（详见代码） 测试用例 功能测试（一个节点；左右斜树；完全二叉树；普通二叉树） 特殊测试（根节点为null） java代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * @description: 请实现两个函数，分别用来序列化和反序列化二叉树 * @author: rhsphere * @since: 2019-07-25 22:05 by jdk 1.8 */public class SerializeBinaryTrees &#123; public class TreeNode &#123; int val; TreeNode left, right; public TreeNode(int val) &#123; this.val = val; &#125; &#125; public String serialize(TreeNode node) &#123; StringBuilder sb = new StringBuilder(); if (node == null) &#123; sb.append("$,"); &#125; else &#123; sb.append(node.val + ","); sb.append(serialize(node.left)); sb.append(serialize(node.right)); &#125; return sb.toString(); &#125; int index = 0; public TreeNode deserialize(String str) &#123; TreeNode node = null; if (str == null || str.length &lt;= 0) return node; int start = index; while (str.charAt(index) != ',') index++; if (!str.substring(start, index).equals("$")) &#123; node = new TreeNode(Integer.parseInt(str.substring(start, index))); index++; node.left = deserialize(str); node.right = deserialize(str); &#125; else &#123; index++; &#125; return node; &#125;&#125; 总结 记住这种序列化的方式，用于表示二叉树时非常方便。 字符串中有分割符号时，可以对字符串采用split()方法，变为字符串数组，但是自己觉得数组的保存会消耗一定的空间，因此自己定义了全局变量index，通过substring()方法来截取每一部分的字符串。 字符串的比较以后尽量用equal来比较。在对某字符串采用substring()方法得到的字符串用==判断会返回false。substring的==与equal()使用 String 转int 类型采用 int i = Integer.parseInt( s ); 不能用Integer.valueOf(s)，这返回的是Integer对象。 index++的位置一定不能放错]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer(36) 二叉搜索树与双向链表]]></title>
    <url>%2F2019%2F07%2F14%2Fconvert-binary-search-tree.html</url>
    <content type="text"><![CDATA[二叉搜索树与双向链表题目 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表，要求不能创建任何新的节点，只能调整树中节点指针。 思路二叉搜索树、排序链表，想到使用中序遍历。 要实现双向链表，必须知道当前节点的前一个节点。根据中序遍历，可以知道，当遍历到根节点的时候，左子树已经转化成了一个排序的链表了，根节点的前一节点就是该链表的最后一个节点（这个节点必须记录下来，将遍历函数的返回值设置为该节点即可），连接根节点和前一个节点，此时链表最后一个节点就是根节点了。再处理右子树，遍历右子树，将右子树的最小节点和根节点连接起来即可。左右子树的转化采用递归即可。 首先想象一下中序遍历的大概代码结构（先处理左子树，再处理根节点，之后处理右子树），假设左子树处理完了，就要处理根节点，而根节点必须知道左子树的最大节点，所以要用函数返回值记录下来；之后处理右子树，右子树的最小节点（也是用中序遍历得到）要和根节点链接。 测试用例 功能测试(一个节点；左、右斜树；完全二叉树；普通二叉树) 特殊测试(根节点为null) java代码采用中序遍历非递归的方式123456789101112131415161718192021222324252627282930313233343536373839404142/** * @description: * @author: rhsphere * @since: 2019-11-05 10:28 by jdk 1.8 */public class BSTConvertToDoubleList &#123; public class TreeNode &#123; int val; TreeNode left, right; public TreeNode(int val) &#123; this.val = val; &#125; &#125; public TreeNode convert(TreeNode root) &#123; TreeNode head = null; TreeNode pre = null; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode cur = root; while (!stack.empty() || cur != null) &#123; if (cur != null) &#123; stack.push(cur); cur = cur.left; &#125; else &#123; TreeNode node = stack.pop(); if (head == null) &#123; head = node; pre = node; &#125; else &#123; node.left = pre; pre.right = node; pre = node; &#125; cur = node.right; &#125; &#125; return head; &#125;&#125; 上面中序遍历里面if else嵌套过多，不便于阅读，进行如下修改。 1234567891011121314151617181920212223242526public TreeNode convert(TreeNode root) &#123; TreeNode head = null; TreeNode pre = null; TreeNode cur = root; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); while (!stack.empty() || cur != null) &#123; while (cur != null) &#123; stack.push(cur); cur = cur.left; &#125; TreeNode node = stack.pop(); if (head == null) &#123; head = node; pre = node; &#125; else &#123; node.left = pre; pre.right = node; pre = node; &#125; cur = node.right; &#125; return head;&#125; 采用递归的方法//TODO]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer(35) 复杂链表的复制]]></title>
    <url>%2F2019%2F07%2F12%2Fcpoy-complex-list.html</url>
    <content type="text"><![CDATA[复杂链表的复制题目 请实现函数ComplexListNode Clone(ComplexListNode pHead)，复制一个复杂链表。在复杂链表中，每个结点除了有一个m_pNext指针指向下一个点外，还有一个m_pSibling 指向链表中的任意结点或者nullptr。 思路思路1：先复制结点，用next链接，最后根据原始结点的sibling指针确定该sibling结点距离头结点的位置，从而对复制结点设置sibling指针。但是该思路对于n个结点的链表，每个结点的sibling都需要O(n)个时间步才能找到，所以时间复杂度为O(n^2) 思路2：复制原始结点N创建N’，用next链接。将&lt;N,N’&gt;的配对信息存放入一个哈希表中；在设置sibling时，通过哈希表，只需要用O(1)的时间即可找到复制结点的sibling。该方法的时间复杂度为O(n)，但空间复杂度为O(n)。 思路3：复制原始结点N创建N’，将N’链接到N的后面；根据原始结点N的sibling可以快速设置N’结点的sibling，最后将这个长链表拆分成原始链表和复制链表（根据奇偶位置） 测试用例 功能测试（sibling指向自己；链表只有一个节点；sibling指向null或者指向节点） 特殊测试（头结点为null） java代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * @description: 剑指offer35题 * @author: rhsphere * @since: 2019-07-12 15:15 by jdk 1.8 */public class CopyComplexList &#123; public class ComplexListNode &#123; int val; ComplexListNode next, sibling; ComplexListNode(int val) &#123; this.val = val; &#125; &#125; //主程序 public ComplexListNode cloneList(ComplexListNode head) &#123; cloneNodes(head); connectSiblingNodes(head); return reconnectNodes(head); &#125; //1.第一步，复制每个节点，并插入到原节点后面 private void cloneNodes(ComplexListNode head) &#123; ComplexListNode pNode = head; while (pNode != null) &#123; ComplexListNode clonedNode = new ComplexListNode(pNode.val); clonedNode.next = pNode.next; pNode.next = clonedNode; pNode = clonedNode.next; &#125; &#125; //2.第二步，根据原节点的位置，设置sibling的指针 private ComplexListNode connectSiblingNodes(ComplexListNode head) &#123; ComplexListNode pHead = head; while (pNode != null) &#123; if (pNode.sibling != null) pNode.next.sibling = pNode.sibling.next; pNode = pNode.next.next; &#125; &#125; //3.第三步，将长链表拆分成原始链表和复制链表（按照奇偶位置） public ComplexListNode reconnectNodes(ComplexListNode head) &#123; ComplexListNode clonedHead = null; ComplexListNode clonedNode = null; ComplexListNode pNode = head; if (head != null) &#123; clonedHead = head.next; clonedNode = pNode.next; pNode.next = clonedNode.next; pNode = pNode.next; //提前将pNode指向下一个结点，方便判断是否为null &#125; while (pNode != null) &#123; clonedNode.next = pNode.next; clonedNode = clonedNode.next; pNode.next = clonedNode.next; pNode = pNode.next; &#125; return clonedHead; &#125;&#125; 总结 有关于拆分函数，需要画图分析，才能厘清思路； 复制链表时，在演示节点后面直接插入复制节点，这种方法很方便，有较高的效率。]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer(34) 二叉树中和为某一值的路径]]></title>
    <url>%2F2019%2F07%2F11%2Fpath-in-tree.html</url>
    <content type="text"><![CDATA[二叉树中和为某一值的路径题目输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始一直到也借点所经过的节点形成一条路径。 思路 假设找到了其中一条路径，达到叶结点后，由于没有指向父节点的指针，所以必须 提前创建一个链表 存储前面经过的节点。 由于从根节点出发，所以要想用到使用前序遍历。 利用链表存储节点，在该节点完成左右子树的路径搜索后（即递归函数结束，返回到其父节点后），要删除 该节点，从而记录别的路径。 具体实现： 通过前序遍历，从根节点出发，每次在链表中存储便利到的节点，若到达叶子节点，则根据所有节点的和是否等于输入的整数，判断是否打印输出。在当前节点访问结束后，递归函数将会返回到它的父节点，所以在函数退出之前，要删除链表中的当前节点，以确保返回父节点是，储存的路径刚好是从根节点到父节点。 改进：书中的代码是根据所有结点的和是否等于输入的整数，判断是否打印输出。其实没有这个必要，只需要在每次遍历到一个结点时，令目标整数等于自己减去当前结点的值，若到达根结点时，最终的目标整数等于0就可以打印输出。（描述得不是很清楚，就是相当于每个结点的目标整数不同，详见代码） 测试用例 功能测试（一条或者多条对应的路径，无对应路径，节点值为正负零） 特殊测试（根节点为null） java代码12345678910111213141516171819202122232425262728293031323334353637383940/** * @description:题目：输入一棵二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。 * @author: rhsphere * @since: 2019-07-11 16:58 by jdk 1.8 */public class PathInTree &#123; public class TreeNode &#123; int val = 0; TreeNode left, right; public TreeNode(int val) &#123; this.val = val; &#125; &#125; public void findPath(TreeNode root, int target) &#123; if (root == null) return; ArrayList&lt;TreeNode&gt; list = new ArrayList&lt;&gt;(); printPath(root, target, list); &#125; private void printPath(TreeNode node, int target, ArrayList&lt;Integer&gt; list) &#123; if (node == null) return; list.add(node.val); target -= node.val; if (target == 0 &amp;&amp; node.left == null &amp;&amp; node.right == null) &#123; for (Integer integer : list) &#123; System.out.print(integer + " "); &#125; System.out.println(); &#125; else &#123; printPath(node.left, target, list); printPath(node.right, target, list); &#125; list.remove(list.size() - 1); &#125;&#125; 牛客网代码1234567891011121314151617181920212223242526272829303132333435363738/* * 几个要点： * 1. 将nodeList和pathList定义成全局变量，避免在方法中的多次传递 * 2. 在pathList中添加nodeList时，因为nodeList会不断变化，所以必须新建一个list存入 * 复制ArrayList的方法：newList=new ArrayList&lt;Integer&gt;(oldList)(复制内容，而不是复制地址， * 注意与newList=oldList的区分） * 3. 在当前结点完成左右子树的路径搜索后，记得删除nodeList中的当前结点 * 4. target是基本数据类型int，不会受到方法的影响而改变 */public class PathInTree2 &#123; public static class TreeNode &#123; int val = 0; TreeNode left, right; public TreeNode(int val) &#123; this.val = val; &#125; &#125; private ArrayList&lt;Integer&gt; nodeList = new ArrayList&lt;&gt;(); private ArrayList&lt;ArrayList&lt;Integer&gt;&gt; pathList = new ArrayList&lt;&gt;(); pubilc ArrayList&lt;ArrayList&lt;Integer&gt;&gt; findPath(TreeNode node, int target) &#123; if (node == null) return pathList; nodelist.add(node.val); target -= node.val; if (target == 0 &amp;&amp; node.left == null &amp;&amp; node.right == null) &#123; int i = 0; while (i &lt; pathList.size() &amp;&amp; nodeList.size() &lt; pathList.get(i).size()) i++; pathList.add(i, new ArrayList&lt;Integer&gt;(nodeList)); &#125; else &#123; pathList = findPath(node.left, target); pathList = findPath(node.right, target); &#125; nodeList.remove(nodeList.size() - 1); return pathList; &#125;&#125; 总结 二叉树的许多题目都与遍历（包括层次遍历）有关，要深刻理解；根据节点的位置判断使用哪一种遍历。 而二叉树遍历过程没有父节点指针，要保存路径的话，需要创建容器存储之前的节点。 熟悉这道题中在每次递归函数结束前删除当前节点的操作，这可以确保返回到父节点时路径刚好是从根节点到父节点。]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer(33) 二叉搜索树的后续遍历序列]]></title>
    <url>%2F2019%2F07%2F11%2Fsequence-of-BST.html</url>
    <content type="text"><![CDATA[二叉搜索数的后续遍历序列5,7,6, 9,11,10, 8 显然左子树都比最后一个根节点8小，右子树都比根节点8大，然后是递归判断左子树和右子树。先找到右子树的根节点即可。 题目 输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则返回true，否则返回false。假设输入的数组的任意两个数字都互不相同。 思路二叉树后续遍历数组的最后一个数为根节点，剩余数字中，小于根节点的数字（即左子树部分）都排在前面，大于根节点的数字（即右子树部分）都排在后面。根据遍历数组的这个特性，可以编写一个递归函数，用于实现题目所要求的判断功能。 测试用例 功能测试（左斜、右斜、能对应的二叉树、不能对应的二叉树） 特殊测试（null、一个节点） java代码123456789101112131415161718192021222324252627282930313233/** * @description: 剑指offer28 * @author: rhsphere * @since: 2019-07-11 15:24 by jdk 1.8 */public class SequeneceOfBST &#123; public class TreeNode &#123; int val = 0; TreeNode left, right; public TreeNode(int val) &#123; this.val = val; &#125; &#125; public boolean verifySequenceOfBST(int[] sequence) &#123; if (sequence == null || sequence.length &lt;= 0) return false; return verifyCore(sequence, 0, sequence.length - 1); &#125; private boolean verifyCore(int[] sequence, int start, int end) &#123; if (start &gt;= end) return true; int mid = start; while (sequence[mid] &lt; sequence[end]) mid++; for (int i = mid; i &lt; end; i++) &#123; if (sequence[i] &lt; sequence[end]) return false; &#125; return verifyCore(sequence, start, mid - 1) &amp;&amp; verifyCore(sequence, mid, end - 1); //这里是end-1不是end &#125;&#125; 总结 寻找出序列规律，就能较快得到思路。此题如果改为BST的前序遍历也是相同的思路。 对于要求处理二叉树序列的问题：找到根结点后，拆分出左右子树，对左右子树可以进行递归处理。 右子树的后续遍历序列中，父节点的下标是end-1，不是end。]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer(32) 从上到下打印二叉树]]></title>
    <url>%2F2019%2F07%2F10%2Fprint-tree.html</url>
    <content type="text"><![CDATA[从上往下打印二叉树层次遍历（广度优先遍历）（一）从上往下打印出二叉树的每一个节点，每一层的节点按照从左到右的顺序打印。 思路不分行从上到下打印二叉树，即二叉树的层序遍历，节点满足先进先出的原则，采用队列。每从队列取出头部节点并打印，若有子节点，把子节点放入队列尾部，直到所有节点打印完毕。 Java代码1234567891011121314151617181920212223242526272829/** * @description: 层序遍历 * @author: rhsphere * @since: 2019-07-10 19:08 by jdk 1.8 */public class PrintTree1 &#123; public class TreeNode &#123; int val = 0; TreeNode left, right; public TreeNode(int val) &#123; this.val = val; &#125; &#125; public void printTree1(TreeNode root) &#123; if (root == null) return; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.add(root); while (!queue.isEmpty()) &#123; TreeNode node = queue.element(); if (node.left != null) queue.add(node.left); if (node.right != null) queue.add(node.right); System.out.print(queue.remove().val + " "); &#125; &#125;&#125; 分行从上往下打印二叉树（二）从上到下按层打印二叉树，同一层的结点按从左到右的顺序打印，每一层打印到一行。 思路同样使用队列，但是比第一题增加两个变量来给你：当前层节点数目pCount，下一层节点数目nextCount。根据当前成节点数目来打印当前层节点，同时计算下一层节点数目，之后令pCount等于nextCount，重复循环，直到打印完毕。 Java代码123456789101112131415161718192021222324252627282930313233** * @description: * @author: rhsphere * @since: 2019-07-10 21:03 by jdk 1.8 */public class PrintTree2 &#123; public void printTree2(TreeNode root) &#123; if (root == null) return; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.add(root); TreeNode current; int pCount = 0; //当前层的节点数 int nextCount = 1; //下一层节点数 while (!queue.isEmpty()) &#123; pCount = nextCount; nextCount = 0; for (int i = 1; i &lt;= pCount; i++) &#123; current = queue.element(); if (current.left ！= null) &#123; queue.offer(current.left); nextCount++; &#125; if (current.right != null) &#123; queue.offer(current.right); nextCount++; &#125; System.out.print(queue.remove().val + " "); &#125; System.out.println(); &#125; &#125;&#125; 之字形打印二叉树（三）请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。 思路和代码采用两个栈，对于不同层的节点，一个栈用于正向存储，一个栈用于逆向存储，打印出来就正好是相反方向。 Java代码123456789101112131415161718192021222324252627282930313233343536/** * @description: * @author: rhsphere * @since: 2019-07-11 10:33 by jdk 1.8 */public class PrintTree3 &#123; public void printTree3(TreeNode root) &#123; if (root == null) return; Stack&lt;TreeNode&gt; stack1 = new Stack&lt;&gt;(); Stack&lt;TreeNode&gt; stack2 = new Stack&lt;&gt;(); TreeNode node = null; stack1.push(root); while (!stack.empty() || !stack.empty()) &#123; while (!stack.empty()) &#123; node = stack1.pop(); if (node.left != null) stack2.push(node.left); if (node.right != null) stack2.push(node.right); System.out.println(node.val + " "); &#125; System.out.println(); while (!stack2.empty()) &#123; node = stack2.pop(); if (node.right != null) stack1.push(node.right); if (node.left != null) stack1.push(node.left); System.out.print(node.val + " "); &#125; System.out.println(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer(28) 对称的二叉树]]></title>
    <url>%2F2019%2F07%2F09%2Fsymmetrical-binary-tree.html</url>
    <content type="text"><![CDATA[对称的二叉树题目实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。 思路还是画图分析，不用分析根结点，只需要分析左右子树。可以看出，左右子树刚好是呈镜像的两颗二叉树，所以：对左子树采用（父-左-右）的前序遍历，右子树采用（父-右-左）的前序遍历，遍历时判断两个结点位置的值是否相等即可。 也可以这样理解：左树的左子树等于右树的右子树，左树的右子树等于右树的左子树，对应位置刚好相反，判断两子树相反位置上的值是否相等即可。 使用递归。 测试用例 功能测试（对称二叉树；结构不对称的二叉树；结构对称但值不对称二叉树） 特殊测试（根节点为null；单个节点；所有节点的值都相等的二叉树） java代码1234567891011121314151617181920212223242526272829303132/** * @description: * @author: rhsphere * @since: 2019-07-09 10:18 by jdk 1.8 */public class SymmetricalBinaryTree &#123; public class TreeNode &#123; int val = 0; TreeNode left; TreeNode right; public TreeNode(int val) &#123; this.val = val; &#125; &#125; public boolean isSymmetrical(TreeNode root) &#123; if (root == null) return true; //根节点为null时，认为是对称的 return isEqual(root.left, root.right); &#125; private boolean isEqual(TreeNode la, TreeNode lb) &#123; if (la == null &amp;&amp; lb == null) return true; if (la == null || lb == null) return false; return la.val == lb.val &amp;&amp; isEqual(la.left, lb.right) &amp;&amp; isEqual(la.right, lb.left); &#125;&#125;]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer(27) 二叉树的镜像]]></title>
    <url>%2F2019%2F07%2F09%2Fmirror-of-binary-tree.html</url>
    <content type="text"><![CDATA[二叉树的镜像题目请完成一个函数，输入一个二叉树，该函数输出它的镜像。 思路先画图，可以看到用递归很容易求解：先前序遍历，对每个节点交换左右子节点。 递归使用的3个条件：1）一个问题的解可以分解成几个问题的解；2）这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样；3）存在递归终止条件。 测试用例 功能测试（普通二叉树；左斜树、右斜树；一个节点） 特殊测试（根节点为null） java代码1234567891011121314151617181920212223242526/** * @description: 输入一个二叉树，该函数输出它的镜像 * @author: rhsphere * @since: 2019-07-09 10:16 by jdk 1.8 */public class MirrorOfBinaryTree &#123; public class TreeNode &#123; int val = 0; TreeNode left; TreeNode right; public TreeNode(int val) &#123; this.val = val; &#125; &#125; public void mirror(TreeNode root) &#123; if (root == null) return; //交换左右子节点 TreeNode tmpNode = root.left; root.left = root.right; root.right = tmpNode; mirror(root.left); mirror(root.right); &#125;&#125;]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[堆、堆排序、优先队列总结]]></title>
    <url>%2F2019%2F07%2F09%2Fheap-heapsort-priorityqueue.html</url>
    <content type="text"><![CDATA[1. Heap（堆） 2. HeapSort（堆排序） 3. PriorityQueue（优先队列） 4. PriorityQueue with Generic Type （优先队列-泛型）]]></content>
      <categories>
        <category>Sum-up</category>
      </categories>
      <tags>
        <tag>Heap</tag>
        <tag>PriorityQueue</tag>
        <tag>HeapSort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[堆]]></title>
    <url>%2F2019%2F07%2F08%2Fheap.html</url>
    <content type="text"><![CDATA[堆的应用重点掌握大顶堆的下沉操作，尤其函数 downAdjust(int[] arr, int parentIndex, int length)的实现。 利用堆求 Top K“求top K 问题”抽象成两类。一类是针对静态数据集合，也就是说数据集合事先确定，不会再变。另一类是针对静态数据集合，也就是说数据集合事先并不确定，有数据动态地加入到集合中。 针对静态数据，如何在一个包含n个数据的数组中，查找前K大数据呢？ 可以维护一个大小为K的大顶堆，顺序遍历数组，从数组中去除数据与堆顶元素比较。如果比堆顶元素大，就把堆顶元素删除，并且将这个元素插入到堆中；如果比堆顶元素小，则不做处理，继续遍历数组。这样等数组中的数据都遍历完之后，堆中的数据就是前K大数据了。 遍历数组需要O(n)的时间复杂度，一次堆化操作需要O(logK)的时间复杂度，所以最坏情况下，n个元素都入堆一次，时间复杂度就是O(nlogK)。 针对动态数据求得Top K就是实时Top K。一个数据集合中有两个操作，一个是添加数据，另一个询问当前的前K大数据。 如果每次询问前K大数据，我们都给予当前的数据重新计算的话，那时间复杂度就是O(nlogK)，n表示当前的数据的大小。实际上，可以一直都维护一个K大小的小顶堆，当有数据被添加到集合中是，就拿它与堆顶的元素对比。如果比堆顶元素大，我们就把堆顶元素删除，并且将这个元素插入到堆中；如果比堆顶元素小，则不做处理。这样，无论任何时候需要查询当前的前K大数据，都可以立刻发那会给他。 利用堆求中位数动态的求数据集合的中位数。 这一小节只记录一些概念性的知识，对于具体内容查看极客时间专栏。 如果数据的个数是奇数，把数据从小到大排列，那第 n/2 + 1个数据就是中位数；如果数据是偶数的话，那么处于中间未知的数据有两个，第n/2个和第n/2 + 1个数据，这是随意取一个作为中位数。 99百分位响应时间。如果有n个数据，将数据从小到大排列之后，99百分位数大约就是第n * 99%个数据。 堆的实现下面实现的是大顶堆。堆有自我调整的操作，对于二叉堆，有如下几种操作： 插入节点。 插入位置总是位于二叉树的最后一个位置，然后作为childIndex和parentIndex比较大小。 删除节点。 总是删除堆顶的元素，然后把最后一个位置的元素放在堆顶，然后向下调整位置。 构建二叉树。本质上就是让所以非叶子节点依次下沉。 下面证明，对于完全二叉树来说，下标从n/2 + 1 到 n的节点都是叶子节点？ 使用反证法证明即可： 使用数组存储表示完全二叉树时，从 数组下标为1开始存储数据，数组下标为i的节点，左子节点为2i, 右子节点为2i + 1. 这个结论很重要（可以用数学归纳法证明)，将此结论记为『原理1』，以下证明会用到这个原理。 如果下标为n/2 + 1的节点不是叶子节点，即它存在子节点，按照『原理1』，它的左子节点为：2(n/2 + 1) = n + 2，大家明显可以看出，这个数字已经大于n + 1，超出了实现完全二叉树所用数组的大小（数组下标从1开始记录数据，对于n个节点来说，数组大小是n + 1），左子节点都已经超出了数组容量，更何况右子节点。以此类推，很容易得出：下标大于n/2 + 1的节点肯定都是也叶子节点了，故而得出结论：对于完全二叉树来说，下标从n/2 + 1 到 n的节点都是叶子节点 数组下标为0开始存储数据，数组下标为i的节点，左子节点为2i + 1, 右子节点为2i + 2。下标为n/2 到 n - 1的节点都是叶子节点，那么最后一个非叶子节点是n/2 - 1 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * @description: 二叉堆 * @author: rhsphere * @since: 2019-07-04 16:30 by jdk 1.8 */public class Heap &#123; //上浮操作 public static void upAdjust(int[] arr) &#123; int childIndex = arr.length - 1; //孩子节点 int parentIndex = (childIndex - 1) / 2; //保存插入的叶子节点值，用于最后的赋值 int tmp = arr[childIndex]; while (childIndex &gt; 0 &amp;&amp; tmp &gt; arr[parentIndex]) &#123; arr[childIndex] = arr[parentIndex]; childIndex = parentIndex; parentIndex = (parentIndex - 1) / 2; &#125; arr[childIndex] = tmp; &#125; /** * 下沉调整 * @param arr 待调整的堆 * @param parentIndex 要下沉的父节点 * @param length 堆的有效大小 */ public static void downAdjust(int[] arr, int parentIndex, int length) &#123; //保存父节点的值，用于最后赋值 int tmp = arr[parentIndex]; //左孩子节点 int childIndex = 2 * parentIndex + 1; while (childIndex &lt; length) &#123; //如果有右孩子节点，且右孩子的值大于左孩子的值，则定位到右孩子 if (childIndex + 1 &lt; length &amp;&amp; arr[childIndex + 1] &gt; arr[childIndex]) &#123; childIndex++; &#125; //如果父节点大于等于，任何一个孩子的值，直接跳出 if (tmp &gt;= arr[childIndex]) break; //给父节点单向赋值，最后的一个坑填上tmp即可 arr[parentIndex] = arr[childIndex]; parentIndex = childIndex; //父节点的下标 childIndex = 2 * parentIndex + 1; //左孩子节点下标 &#125; //最后一个坑位，填上tmp arr[parentIndex] = tmp; &#125; public staitc void buildIndex(int[] arr) &#123; //从最后一个非叶子节点开始，依次下沉 for (int i = arr.length/2 - 1; i &gt;= 0; i--) downAdjust(arr, i, arr.length); &#125;&#125;]]></content>
      <categories>
        <category>Heap</category>
      </categories>
      <tags>
        <tag>Heap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[优先队列]]></title>
    <url>%2F2019%2F07%2F08%2Fpriority-queue.html</url>
    <content type="text"><![CDATA[优先级队列优先级队列还是一个队列，队列的最大特性仍是先进先出，不过在优先级队列中，数据的出对顺序不是按照先进先出，而是按照优先级来，优先级最高的最先出队。最大优先级队列，无论入队顺序如何，都是当前最大的元素优先出队。最小优先级队列，无论入队顺序如何，都是当前最小的元素优先出队。 如何实现优先队列如何实现一个优先级队列？方法有很对，但是用堆来实现是最直接、最高效的。这是因为，堆和优先级队列非常相似，一个堆就可以看作一个优先级队列。很多时候，它们只是概念上的区分而已。往优先级队列中插入一个元素，就相当于往堆中插入一个元素；从优先级队列中去除优先级最高的元素，就相当于取出堆顶元素。 优先级队应用场景非常多，比如，哈夫曼编码、图的最短路径、最小生成树算法等等。 下面是两个应用优先级队列的例子。（选自极客时间-王争-数据结构与算法之美） 合并有序小文件假设我们有100个小文件，每个文件的大小时100MB，每个文件中存储的都是有序的字符串。我们希望将这些100个小文件合并成一个有序的大文件。这里就会用到 优先级队列。 整体思路有点像归并排序中的合并函数。我们从这100个文件中，各取第一个字符，放入数组中，然后比较大小，把最小的那个字符串放入合并后的大文件中，并从数组中删除。 假设，最小的字符串来自于13.txt这个小文件，我们就再从这个小文件取下一个字符串，放到数组中，重新比较大小，并且选择最小的放入合并后的大文件，将它从数组中删除。以此类推，知道所有的文件中的数据都放大文件为止。 这里我们用到数组这种数据结构，来存储从小文件中取出来的字符串。每次从数组中取最小字符串，都需要循环遍历整个数组，这种做法是低效的。 这里就可一个用到优先级队列，也就是说堆。我们将小文件中取出来的字符串放入到小顶堆中，把堆顶的元素，也就是优先级队列队首的元素，就是最小的字符串。讲这个字符串放入到大文件中，并将其从堆中删除，然后再从小文件中去除下一个字符串，放入到堆中。循环这个过程就可以把100个小文件中的数据依次入到大文件中。 删除堆顶数据和往堆中插入数据的时间复杂度都是O(logn)，n表示堆中的数据个数，这里就是100，比原来的数组存储的方式高效多了。 高性能定时器假设有一个定时器，定时器中维护了很多定时任务，每个任务都设定了一个要触发指向的时间点。定时器美国一个很小的单位时间（比如1秒），就扫描一边任务，看是否有任务到达设定的执行时间，如果到达就拿出来执行。 但是这样每过1秒就扫描一遍任务列表的做法比较低效，主要原因有两点：第一，任务的约定执行时间离当前时间可能还有很久，这样前面很多次扫描其实都是徒劳的；第二，每次都要扫描整个任务列表，如果任务列表很大的话，势必会比较耗时。 针对这些问题，就可以用优先级队列来解决。我们按照任务设定的执行时间，将这些任务存储在优先级队列中，队列首部(也就是小顶堆的堆顶)存储的是最先执行的任务。 这样，定时器就不需要每隔1秒就扫描一遍任务列表了。拿队首任务的执行时间点，与当前时间点相减，得到一个时间间隔T。 这个时间间隔T就是，从当前时间开始，需要等待多久，才会有第一个任务需要被执行。这样，定时器就可以设定在T秒之后，再来执行任务。从当前时间点到(T-1)秒时间里，定时器都不需要做任何事情。 当T秒时间过后，定时器取优先级队列中投队首的任务执行。然后再计算新的队首任务的执行时间点与当前时间点的差值，把这个值设置为定时器执行I行啊一个任务需要等待的时间。 这样，定时器既不用间隔1秒就轮询一次，也不用遍历整个任务列表，性能就提高了。 优先级队列的实现优先队列主要有入队、出队和扩容操作组成： 入队，需要进行上浮操作 出队，需要进行下沉操作 上浮操作，用于插入的叶子节点（数组最后的位置），将其移到正确的位置 下沉操作，用于删除队头元素，并且将最后一个元素放到队头并调整堆的形状 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990/** * @description: 最大优先队列，无论入队的顺序如何，都是当前最大的元素优先出队；最小队列，无论入队的顺序如何，都是当前最小的元素优先出队。 * @author: rhsphere * @since: 2019-07-08 09:34 by jdk 1.8 */public class PriorityQueue &#123; //使用最大堆来实现最大优先队列，入队就是堆的插入，出队就是堆的删除 private int[] arr; //存储元素的数组 private int size; //队列中元素的个数 public PriorityQueue() &#123; arr = new int[32]; //队列初始长度为32 &#125; //入队 public void enQueue(int key) &#123; //队列长度超出范围，扩容 if(size &gt;= arr.length) &#123; resize(); &#125; arr[size++] = key; upAdjust(); &#125; //出队 public int deQueue() throws Exception &#123; if (size &lt;= 0) throw new Exception("the queue is empty"); //获取堆顶元素 int head = arr[0]; //让最后一个元素移到堆顶 arr[0] = arr[--size]; downAdjust(); return head; &#125; //上浮操作，用于插入的叶子节点，将其移到正确的位置 private void upAdjust() &#123; int childIndex = size - 1; int parentIndex = childIndex / 2; int tmp = arr[childIndex]; while (childIndex &gt; 0 &amp;&amp; tmp &gt; arr[parentIndex]) &#123; arr[childIndex] = arr[parentIndex]; childIndex = parentIndex; parentIndex = (parentIndex - 1) / 2; //这里需要减一吗 &#125; arr[childIndex] = tmp; &#125; //下沉操作，用于删除队头元素，并且将最后一个元素放到队头并调整堆的形状 private void downAdjust() &#123; int parentIndex = 0; //tmp用于保存父节点的值，用于最后的赋值 int tmp = arr[parentIndex]; int childIndex = 1; while (childIndex &lt; size) &#123; //如果有有孩子且右孩子大于左孩子的值，则定位到右孩子 if (childIndex + 1 &lt; size &amp;&amp; arr[childIndex + 1] &gt; arr[childIndex]) childIndex++; //如果父节点大于左右孩子最大的值，直接跳出 if (tmp &gt;= arr[childIndex]) break; //较大子节点单向赋值给父节点即可 arr[parentIndex] = arr[childIndex]; parentIndex = childIndex; childIndex = 2 * childIndex + 1; &#125; arr[parentIndex] = tmp; &#125; //扩容 private void resize() &#123; int newSize = this.size * 2; this.arr = Arrays.copyOf(this.arr, newSize); &#125; public static void main(String[] args) throws Exception &#123; PriorityQueue pq = new PriorityQueue(); pq.enQueue(1); pq.enQueue(3); pq.enQueue(5); pq.enQueue(10); pq.enQueue(2); pq.enQueue(7); System.out.println("出队元素：" + pq.deQueue()); System.out.println("出队元素：" + pq.deQueue()); &#125;&#125; 总结优先队列是一种特殊的队列，优先级高的数据先出队，而不再像普通的队列那样，先进先出。实际上，堆就可以看作优先级队列，只是称谓不一样。]]></content>
      <categories>
        <category>Heap</category>
      </categories>
      <tags>
        <tag>PriorityQueue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树的遍历]]></title>
    <url>%2F2019%2F07%2F04%2Ftraversal-treenode.html</url>
    <content type="text"><![CDATA[二叉树的遍历二叉树的遍历操作复杂度，跟节点的个数n成正比，也就是说二叉树遍历的时间复杂度是O(n)。 前序遍历是指，对于树中的任意节点来说，先打印这个节点，然后再打印它的左子树，最后打印它的右子树。 中序遍历是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它本身，最后打印它的右子树。 后序遍历是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它的右子树，最后打印这个节点本身。 二叉树本身是递归定义的，相应的遍历很自然就成为一种递归问题。 写递归代码的关键，就是看能不能写出递推公式，而写递推公式的关键就是，如果解决问题A，就假设子问题B、C已经解决，然后再来看如何利用B、C来解决A。所以可以把前、中、后序遍历的递推公式都写出来。 12345678//前序遍历的递推公式：preorder(r) = print r -&gt; preorder(r.left) -&gt; preorder(r.right)//中序遍历的递推公式：inorder(r) = inorder(r.left) -&gt; print r -&gt; inorder(r.right)//后序遍历的递推公式：postorder(r) = postorder(r.left) -&gt; postorder(r.right) -&gt; print r 递归遍历操作的关键点是递归体和递归出口： 递归出口是二叉树的空子树或叶节点，此时为空操作，递归不继续进行，只能回退； 递归体是对二叉树根节点或左、右子树进行相应处理。 基于递归的遍历算法易于编写，操作简单，但可读性差，系统需要维护相应的工作栈，效率不是很高。 递归转化为非递归的基本思想是如何实现原本是系统完成的递归工作栈，为此，可以仿照递归执行过程中工作栈状态变化而得到。 对二叉树进行前序、中序和后序遍历时都开始于根节点或结束于根节点，经由路线也相同。彼此差别在于对节点访问时机的选择不同。三种遍历方式都是沿着左子树不断深入下去，当到达二叉树左下节点而无法往下深入时，就向上逐一返回，行进到最近深入时曾遇到节点的右子树，然后进行同样的深入和返回，直到最终从根节点的右子树返回到根节点。这样，遍历时返回顺序与深入节点顺序恰好相反，因此可以在实现二叉树遍历过程中，使用一个工作栈来保存当前深入到的节点信息，以供后面返回需要时使用。 树的节点的定义： 12345678public class TreeNode &#123; int val; TreeNode left; TreeNode right; public TreeNode(int val) &#123; this.val = val; &#125;&#125; 中序遍历(inorder traversal)递归遍历二叉树分为根节点、左子树和右子树，分别表示为 +、1、2。遍历顺序为： 1+2 可以递增顺序显示BST中所有节点。 中序遍历访问左子二叉树 访问根节点 中序遍历访问右子二叉树 中序遍历递归方法1234567891011public void inorder() &#123; inorder(root); &#125;protected void inorder(TreeNode root) &#123; if (root == null) return; inorder(root.left); // 递归遍历左子树 System.out.print(root.val + " "); // 递归遍历根节点 inorder(root.right); // 递归遍历右子树 1+2&#125; 非递归遍历中序遍历的黄金口诀：当前节点(current=root)不为空，压栈，当前节点向左移动；当前节点为空，从栈中弹出一个元素，并打印该节点，当前节点向右移动； 中序遍历非递归方法1234567891011121314151617181920public void inorder() &#123; inorder(root);&#125;protected void inorder(TreeNode root) &#123; if (root == null) return; java.util.Stack&lt;TreeNode&gt; stack = new java.util.Stack&lt;&gt;(); TreeNode current = root; while (!stack.empty() || current != null) &#123; if (current != null) &#123; stack.push(current); current = current.left; &#125; else &#123; TreeNode node = stack.pop(); System.out.print(node.val + " "); current = node.right; &#125; &#125;&#125; 前序遍历(preorder traversal)递归遍历+12 深度优先遍历法(depth-first traversal)与前序遍历法相同。 访问根节点 前序遍历访问左子二叉树 前序遍历访问右子二叉树 preorder递归遍历12345678910public void preorder() &#123; preorder(root);&#125;protected void preorder(TreeNode root) &#123; if (root == null) return; System.out.println(root.val + " "); // 递归遍历根节点 preorder(root.left); // 递归遍历左子树 preorder(root.right); // 递归遍历右子树 +12&#125; 非递归遍历根节点入栈，栈不为空，则循环：出栈并打印节点值，右孩子节点进栈，左孩子节点进栈。 前序非递归遍历1234567891011121314151617181920212223public void preorder() &#123; preorder(root);&#125; protected void preorder(TreeNode root) &#123; if (root == null) return; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); stack.push(root); while (!stack.empty()) &#123; TreeNode node = stack.pop(); System.out.print(node.val + " "); // Push the right child onto the stack // first so the left is processed first if (node.right != null) &#123; stack.push(node.right); &#125; if (node.left != null) &#123; stack.push(node.left); &#125; &#125;&#125; 后序遍历(postorder traversal)递归遍历1 2 + 后序遍历访问左子二叉树 后序遍历访问右子二叉树 访问根节点 postorder递归遍历12345678910public void postorder() &#123; postorder(root);&#125;protected void postorder(TreeNode root) &#123; if (root == null) return; postorder(root.left); // 递归遍历左子树 postorder(root.right); // 递归遍历右子树 System.out.println(root.val + " "); // 递归遍历根节点 12+&#125; 非递归遍历需要两个栈，一个栈用来模拟后续遍历顺序，另一个栈用来存储后续遍历打印顺序。 根节点入栈1，栈1不为空则循环：栈1出栈，将出栈元素存到栈2，出栈节点左孩子节点进栈，右孩子节点进栈； 打印栈2的元素 后序非递归遍历1234567891011121314151617181920212223242526272829public void postorder() &#123; postorder(root);&#125;protected void postorder(TreeNode root) &#123; if (root == null) return; // Create two stacks Stack&lt;TreeNode&gt; stack1 = new Stack&lt;&gt;(); Stack&lt;TreeNode&gt; stack2 = new Stack&lt;&gt;(); // push root to stack1 stack1.push(root); while (!stack1.empty()) &#123; // Pop node from stack1 and push onto stack2 TreeNode node = stack1.pop(); stack2.push(node); if (node.left != null) stack1.push(node.left); if (node.right != null) stack1.push(node.right); &#125; // Display vals in stack2 while (!stack2.empty()) &#123; System.out.print(stack2.pop().val + " "); &#125;&#125; 广度优先遍历(breadth-first traversal)根节点先入队，然后队列不空，取出对头元素，如果左孩子存在就入队列，否则什么也不做，右孩子同理。知道队列为空，则表示树层次遍历结束。树的层次遍历，其实也是广度优先的遍历算法。 广度优先遍历12345678910111213141516171819public void breadthFirstTraversal() &#123; if (root == null) return; // Queue Deque Linkedlist Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.add(root); while (!queue.isEmpty()) &#123; TreeNode current = queue.element(); if (current.left != null) &#123; queue.add(current.left); &#125; if (current.right != null) &#123; queue.add(current.right); &#125; System.out.println(queue.remove().val + " "); &#125;&#125;]]></content>
      <categories>
        <category>Tree</category>
      </categories>
      <tags>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer(26) 树的子结构]]></title>
    <url>%2F2019%2F07%2F02%2Fsubstructure-in-tree.html</url>
    <content type="text"><![CDATA[树的子结构题目输入两棵二叉树A和B，判断B是不是A的子结构。 思路 先对A树进行遍历，找到与B树的根节点值相同的节点R； 判断A树中以R为根节点的子树是否包含B树一样的结构。 测试用例 功能测试（A和B为普通二叉树；B是或者不是A的子结构） 特殊测试（任意一个或者两个数的根节点为null；左斜、右斜树） java代码1234567891011121314151617181920212223242526272829303132333435363738394041424344** * @description: 剑指Offer26 树的子结构 * @author: rhsphere * @since: 2019-07-02 12:19 by jdk 1.8 */public class SubstructureInTree &#123; public class TreeNode &#123; int val; TreeNode left; TreeNode right; public TreeNode(int val) &#123; this.val = val; &#125; &#125; //主程序 public boolean hasSubTree(TreeNode root1, TreeNode root2) &#123; if (root1 == null || root2 == null) return false;// boolean result=false;// if(equal(root1.val, root2.val)) &#123;// result = doesTree1HasTree2(root1, root2);// if(!result)// result=hasSubtree(root1.left, root2)// ||hasSubtree(root1.right, root2);// &#125;// return result; //上面几行可以直接写成： return doesTree1HasTree2(root1, root2) || hasSubtree(root1.left, root2) || hasSubtree(root1.right, root2); &#125; //判断root节点开始的子树中各个节点是否相同 private boolean doesTree1HasTree2(TreeNode root1, TreeNode root2) &#123; if (root2 == null) return true; if (root1 == null) return true; return equal(root1.val, root2.val) &amp;&amp; doesTree1HasTree2(root1.left, root2.left) &amp;&amp; doesTree1HasTree2(root1.right, root2.right); &#125; //判断两个浮点数是否相同 private boolean equal(double num1, double num2) &#123; if (Math.abs(num1 - num2) &lt; 0.00000001) return true; return false; &#125;&#125; 总结 本题是对二叉树遍历的扩展，利用递归比较简洁方便； 浮点数判等方法，不能直接用 “==” 判断。]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Recursive</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer(25) 合并两个有序链表]]></title>
    <url>%2F2019%2F06%2F30%2Fmerge-sorted-linkedlist.html</url>
    <content type="text"><![CDATA[合并两个有序链表题目输入两个递增排序的链表，合并这两个链表并使新链表中的结点仍然是按照递增排序的。 思路递归实现： 合并过程中，每次都是从两个链表中找出较小的一个来链接，因此可以采用递归来实现：当任意一个链表为null时，直接连接另一个链表即可；其余情况只需要在两个链表中找出一个较小的节点进行连接，该节点的next值继续通过递归函数来链接。 非递归实现： 参考leetcode 21. Merge Two Sorted Lists 进行分类讨论即可。 测试用例 功能测试（两个链表有多个或一个节点；节点值相同、不同） 特殊测试（任意一个或者两个链表的头结点为null） java代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * @description: 剑指offer25 * @author: rhsphere * @since: 2019-07-02 10:25 by jdk 1.8 */public class MergeSortedLists &#123; public class ListNode &#123; int val; ListNode next; public ListNode(int val) &#123; this.val = val; &#125; &#125; //递归 public ListNode merge(ListNode la, ListNode lb) &#123; if (la == null) return lb; if (lb == null) return la; if (la.val &lt; lb.val) &#123; la.next = merge(la.next, lb); return la; &#125; else &#123; lb.next = merge(la, lb.next); return lb; &#125; &#125; //非递归 public ListNode mergeSortedList(ListNode la, ListNode lb) &#123; if (la == null) return lb; if (lb == null) return la; ListNode p = la, q = lb, head; if (p.val &lt; q.val) &#123; head = p; p = p.next; &#125; else &#123; head = q; q = q.next; &#125; ListNode r = head; while (p != null &amp;&amp; q != null) &#123; if (p.val &lt; q.val) &#123; r.next = p; p = p.next; &#125; else &#123; r.next = q; q = q.next; &#125; r = r.next; &#125; if (p != null) &#123; r.next = p; &#125; else &#123; r.next = q; &#125; return head; &#125;&#125; 总结 对于递归实现方法，得到链表中值叫次奥的头结点并把它连接到已经合并的链表之后，两个链表剩余的节点依然是排序的，因此合并的步骤和之前的步骤是一样的。这就是典型的递归过程，我们可以定义递归函数完成这一合并过程。]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer(24) 反转链表]]></title>
    <url>%2F2019%2F06%2F30%2Freverse-linkedlist.html</url>
    <content type="text"><![CDATA[反转链表题目 定义一个函数，输入一个链表的头结点，反转该链表并输出反转后链表的头结点。 思路参考 leetcode 206. Reverse Linked List 测试用例 功能测试（链表有多个或一个节点） 特殊测试（头结点为null） java代码123456789101112131415161718192021222324252627282930313233343536/** * @description: 剑指Offer24 * @author: rhsphere * @since: 2019-07-01 10:48 by jdk 1.8 */public class ReverseList &#123; public static class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125; &#125; //迭代 public ListNode reverseList(ListNode head) &#123; ListNode reverse = null; while (head != null) &#123; ListNode second = head.next; head.next = reverse; reverse = head; head = second; &#125; return reverse; &#125; //递归 public ListNode reverseListRecursively(ListNode head) &#123; if (head == null || head.next == null) return head; ListNode res = reverseListRecursively(head.next); head.next.next = head; head.next = null; return res; &#125;&#125;]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer(23) 链表中环的入口节点]]></title>
    <url>%2F2019%2F06%2F30%2Fentry-node-in-linkedlist.html</url>
    <content type="text"><![CDATA[链表中环的入口节点题目一个链表中包含环，如何找出环的入口结点？ 思路 确定链表是否有环：通过两个不同速度的指针确定，当两个指针指向同一个结点时，该结点为环中的一个结点。 确定环中结点的数目n：指针走一圈，边走边计数 找到环的入口：从头结点开始，通过两个相差为n的指针来得到（即寻找链表中倒数第n个结点） 本题和 leetcode 141. Linked List Cycle 1 及 leetcode 142. Linked List Cycle 2相同 测试用例 功能测试 （链表包含与不包含环；链表有多个或一个节点） 特殊测试（头结点为null） java代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * @description: 剑指Offer23 * @author: rhsphere * @since: 2019-06-30 23:34 by jdk 1.8 */public class EntryNodeOfLoop &#123; public static class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125; &#125; //确定链表中是否有环，采用快慢指针 private ListNode meetingNode(ListNode head) &#123; if (head == null) return null; ListNode slow = head; ListNode fast = head; while (fast != null) &#123; slow = slow.next; fast = fast.next; if (fast != null) fast = fast.next; if (slow != null &amp;&amp; slow == fast) return slow; &#125; return null; &#125; //计算环中入口节点 public ListNode entryNodeOfLoop(ListNode head) &#123; ListNode meetingNode = meetingNode(head); if (meetingNode == null) return null; //计算环中节点的数目 int count = 1; ListNode fast = meetingNode.next; while (fast != meetingNode) &#123; count++; fast = fast.next; &#125; //先移动p，次数为count fast = head; for (int i = 1; i &lt;= count; i++) &#123; fast = fast.next; &#125; ListNode slow = head; while (slow != fast) &#123; slow = slow.next; fast = fast.next; &#125; return slow; &#125;&#125;]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer(22) 链表中倒数第k个节点]]></title>
    <url>%2F2019%2F06%2F30%2Fkth-listnode-from-end.html</url>
    <content type="text"><![CDATA[链表中倒数第k个节点题目输入一个链表，输出该链表中倒数第k个结点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾结点是倒数第1个结点。例如一个链表有6个结点，从头结点开始它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个结点是值为4的结点。 思路本题和 leetcode 19. Remove Nth Node From End of List 是同一道题，和书中是同一个思路：设置两个指针，第一个指针先遍历k-1步；从第k步开始，第二个指针指向头结点，两个节点同时往后遍历，当第一个指针到达最后一个节点时，第二个指针指向的正好是倒数第k个节点。 测试用例 功能测试（第k个节点分别在链表的中间、头结点和尾节点） 特殊测试（头结点为null、k超出范围） java代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class KthNodeFromEnd &#123; public static class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125; &#125; //方法1：利用栈 public ListNode findKthToTail(ListNode head, int k) &#123; if (head == null || k &lt; 0) return null; int numOfList = 1; Stack&lt;ListNode&gt; st = new Stack&lt;&gt;(); st.push(head); ListNode node = head.next; while (node != null) &#123; numOfList++; st.push(node); node = node.next; &#125; if (k &gt; numOfList) &#123; return null; &#125; else &#123; for (int i = 1; i &lt;= k; i++) node = st.pop(); return node; &#125; &#125; //方法2：利用两个相距为k-1的指针 public ListNode findKthToTail2(ListNode head, int k) &#123; if (head == null || k &lt;= 0) return null; ListNode fast = head; for (int i = 1; i &lt; k; i++) &#123; fast = fast.next; if (fast == null) return null; &#125; ListNode slow = head; while (fast.next != null) &#123; fast = fast.next; slow = slow.next; &#125; return slow; &#125;&#125; 总结 注意代码的鲁棒性，开始思考前都需要注意特殊输入测试； 一个指针遍历链表无法解决问题时，可以考虑使用两个指针来遍历链表：两个指针先后遍历（即该题目）、或者两个指针遍历速度不同（如：求链表中的中间结点，可以令一个指针一次走一步，另一个指针一次走两步来实现）]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer(21) 调整数组顺序使奇数位于偶数前面]]></title>
    <url>%2F2019%2F06%2F30%2Freorder-array.html</url>
    <content type="text"><![CDATA[调整数组顺序使奇数位于偶数前面题目输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。 思路对于任意一个整数数组，设置一个left指针，从前往后走，如果遇到奇数则指针后移，遇到偶数时，指针停止；设置一个right指针，从前往后走，遇到偶数时指针前移，遇到奇数是，可以喝前面的指针所指的偶数进行调换。 测试用例 功能测试（数组中奇偶交替出现、数组中先奇后偶、先偶后奇） 特殊测试（null、空数组、一个数据的数组） java代码123456789101112131415161718public class ReorderArray &#123; public void reorderArray(int[] arr) &#123; if (arr == null || arr.length &lt;= 0) return; int left = 0; int right = arr.length - 1; int tmp; while (left &lt; right) &#123; while (left &lt; right &amp;&amp; (arr[left] &amp; 1) != 0) left++; while (left &lt; right &amp;&amp; (arr[right] &amp; 1) == 0) right--; tmp = arr[left]; arr[left] = arr[right]; arr[right] = tmp; &#125; &#125;&#125; 附加要求如果题目附加要求：保证调整后的数组中，奇数和奇数之间，偶数和偶数之间的相对位置不变。此时用上面的方法无法实现该功能，可以采用类似于“直接插入排序”的方法：从头开始遍历，遇到奇数时，将该奇数插入到该奇数前面的偶数之前。（如：从头开始遍历246183，遇到奇数1时，将1插入到246之前，变为：124683；该插入的实质是：奇数前面的所有偶数往后移一位，空出的位置放入该奇数） java代码1234567891011121314151617public void reorderArray1(int[] arr) &#123; if (arr == null || arr.length &lt;= 0) return; int tmp, j; for (int i = 1; i &lt; arr.length; i++) &#123; if ((arr[i] &amp; 1) != 0) &#123; j = i; tmp = arr[i]; while ((j &gt; 0) &amp;&amp; (arr[j - 1] &amp; 1) == 0) &#123; arr[j] = arr[j - 1]; j--; &#125; arr[j] = tmp; &#125; &#125;&#125;]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Two Pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer(20) 表示数值的字符串]]></title>
    <url>%2F2019%2F06%2F29%2Fnumberic-strings.html</url>
    <content type="text"><![CDATA[表示数值的字符串题目请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串“+100”、“5e2”、“-123”、“3.1416”及“-1E-16”都表示数值，但“12e”、“1a3.14”、“1.2.3”、“+-5”及“12e+5.4”都不是。 思路具体思路参考剑指offer，需要将数字总结出规律，（A.B E/e A），按顺序进行判断，（A代表有符号整数，B代表无符号整数） 另一种思路：借助几个flag从头到尾遍历，leetcode 65. Valid Number 测试用例 功能测试（正负数、含整数与不含整数部分、含小数与不含、含与不含指数部分；不匹配情况） 特殊测试（null、空字符串） java代码1234567891011121314151617181920212223242526272829303132333435363738public class NumericStrings&#123; public boolean isNumeric(char[] str) &#123; if (str == null || str.length == 0) return false; int[] index = new int[1]; index[0] = 0; boolean isNumeric; isNumeric = isInteger(str, index); if (index[0] &lt; str.lengrh &amp;&amp; (str[index[0]] == '.')) &#123; index[0]++; isNumeric = isUnsignedInteger(str, index) || isNumeric; &#125; if (index[0] &lt; str.length &amp;&amp; (str[index[0]] == 'e' || str[index[0]] == 'E')) &#123; index[0]++; isNumeric = isInteger(str, index) &amp;&amp; isNumeric; &#125; if (isNumeric &amp;&amp; index[0] == str.length) return true; else return false; &#125; private boolean isInteger(char[] str, int[] index) &#123; if (index[0] &lt; str.length &amp;&amp; (str[index[0]] == '+' || str[index[0]] == '-')) index[0]++; return isUnsignedInteger(str, index); &#125; private boolean isUnsignedInteger(char[] str, int[] index) &#123; int start = index[0]; while (index[0] &lt; str.length &amp;&amp; (str[index[0]] - '0' &lt;= 9 &amp;&amp; str[index[0]] - '0' &gt;= 0)) index[0]++; if (index[0] &gt; start) return true; else return false; &#125;&#125; 总结 对字符串进行依次判断时，定义一个boolean变量，每判断一部分就进行更新，最终改变量即为判断结果，不需要进行循环判断。 if (isNumeric &amp;&amp; index[0] == str.length) 判断index是否到达结尾处了。 isNumeric = isUnsignedInteger(str, index) || isNumeric; 顺序不能反了，否则当isNumeric为true时，不会判断后半部分，index就不会走向’e’，从而导致错误。]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer(19) 正则表达式匹配]]></title>
    <url>%2F2019%2F06%2F23%2Fregular-expression.html</url>
    <content type="text"><![CDATA[正则表达式匹配题目实现一个函数用来匹配包含’.’和 ‘*‘ 的正则表达式。模式中的字符’.’表示任意一个字符，而 ‘*‘ 表示塔前面的字符可以出现忍一次（含0次）。在本题中，匹配是指字符穿的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab*ac*a”匹配，但与”aa.a”和”ab*a”均不匹配。 思路使用函数matchCore(char[] str, int indexOfStr, char[] pat, int indexOfPat)来实现每一步的比较（递归）。 当模式中第二个字符不为”*“时：若当前字符相等，则字符串和模式串都前后移一个字符，继续调用函数进行比较；若不相等，则返回false。 当模式中第二个字符为”*“时：若当前字符不相等，则模式后移两个字符，继续比较；若当前字符相等，则有三种情况： 字符串位置不变，模式后移两个字符，继续比较； 字符串后移一个字符，模式后移两个字符，继续比较； 字符串后移一个字符，模式字符位置不变，继续比较。以上三种情况使用”||”进行并列比较。 测试用例 功能测试（模式中包含普通字符、 “.”、””; 匹配情况；不匹配情况） 特殊测试 （null、空字符串） java代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798/** * @description: 实现一个函数用来匹配包含‘，’和‘*’的正则表达式。 * @author: rhsphere * @since: 2019-06-23 08:52 by jdk 1.8 */public class RegularExpression &#123; public boolean match(char[] str, char[] pat) &#123; if (str == null || pat == null) return false; return matchCore(str, 0, pat, 0); &#125; public boolean matchCore(char[] str, int indexOfStr, char[] pat, int indexOfPat) &#123; if (indexOfStr == str.length &amp;&amp; indexOfPat == pat.length) return true; if (indexOfStr &lt; str.length &amp;&amp; indexOfPat == pat.length) return false; if (indexOfPat + 1 &lt; pat.length &amp;&amp; pat[indexOfPat + 1] == '*') &#123; if ((indexOfStr &lt; str.length &amp;&amp; pat[indexOfPat] == '.') || (indexOfStr &lt; str.length &amp;&amp; pat[indexOfPat] == str[indexOfStr])) &#123; return matchCore(str, indexOfStr, pat, indexOfPat + 2) || matchCore(str, indexOfStr + 1, pat, indexOfPat) || matchCore(str, indexOfStr + 1, pat, indexOfPat + 2); &#125; else &#123; return matchCore(str, indexOfStr, pat, indexOfPat + 2); &#125; &#125; if (indexOfStr &lt; str.length &amp;&amp; (pat[indexOfPat] == str[indexOfStr] || pat[indexOfPat] == '.')) &#123; return matchCore(str, indexOfStr + 1, pat, indexOfPat + 1); &#125; return false; &#125; // ==========测试代码========= void test(String testName, char[] str, char[] pattern, boolean expected) &#123; System.out.print(testName + ":"); if (match(str, pattern) == expected) System.out.println("passed!"); else System.out.println("failed!"); &#125; void test1() &#123; char[] str = &#123;&#125;; char[] pattern = &#123; '.' &#125;; test("test1", str, pattern, false); &#125; void test2() &#123; char[] str = &#123;&#125;; char[] pattern = &#123; '.', '*' &#125;; test("test2", str, pattern, true); &#125; void test3() &#123; char[] str = &#123; 'a' &#125;; char[] pattern = &#123; '.', '*' &#125;; test("test3", str, pattern, true); &#125; void test4() &#123; char[] str = &#123;&#125;; char[] pattern = &#123;&#125;; test("test4", str, pattern, true); &#125; void test5() &#123; char[] str = null; char[] pattern = null; test("test5", str, pattern, false); &#125; void test6() &#123; char[] str = &#123; 'a', 'b', 'b' &#125;; char[] pattern = &#123; 'a', 'b', 'b', '*', 'b' &#125;; test("test6", str, pattern, true); &#125; void test7() &#123; char[] str = &#123; 'a' &#125;; char[] pattern = &#123; 'a', 'a', '*' &#125;; test("test7", str, pattern, true); &#125; public static void main(String[] args) &#123; RegularExpression demo = new RegularExpression(); demo.test1(); demo.test2(); demo.test3(); demo.test4(); demo.test5(); demo.test6(); demo.test7(); &#125;&#125; 总结 涉及到数组的情况下，一定要时刻注意数组越界的问题！ 对于每一步都是采用相同判断方法的题目，可以采用递归函数来实现 思维一定要全面，把握住关键矛盾，将每种情况考虑清楚。例如这道题，关键就在于第二个字符是否为“*”，确定关键问题后，分析清楚每一种情况即可 代码第29行的 indexOfStr &lt; str.length 一定要记得加，否则可能会出现重复执行第32行的情况。]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>String</tag>
        <tag>RegExp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer(18) 删除链表中的节点]]></title>
    <url>%2F2019%2F06%2F22%2Fdelete-nodes-in-linkedlist.html</url>
    <content type="text"><![CDATA[在O(1)时间内删除链表结点题目一在给定单向链表的头指针和一个节点指针，定义一个函数在O(1)时间内删除该节点。 思路本题缺陷，要求O(1)时间删除，相当于隐藏了一个假设：待删除的节点的确在链表中。 在单向链表中，节点没有指向前一个节点的指针，所以只好从链表的链表的头结点开始顺序查找。这样的时间复杂度为O(n)，要在O(1)的时间删除节点，可以这样实现： 将待删除节点的next节点 j 的值赋值给 i ，再把 i 的指针指向 j 的下一个节点，最后删除 j ，效果等同于删除 j 。 全面考虑其他情况： 待删除节点i为尾节点是，无下一个节点，只能从头开始遍历到尾节点； 链表中只有一个节点时（即是头结点，又是尾节点），必须把头结点也设置为null； 测试用例 功能测试 （多个节点链表，删除头结点、中间节点和尾节点；单个节点链表） 特殊测试 （头结点或者删除节点为null） java代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138/** * @description: 给定单向链表的头结点和一个节点指针，定义一个函数在O(1)时间删除该节点 * @author: rhsphere * @since: 2019-06-22 15:49 by jdk 1.8 */// 注:本题存在缺陷，要求O(1)时间，则无法确定待删除节点的确在表中public class DeleteNodeInList &#123; private class ListNode &#123; int val; ListNode next; ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; &#125; public ListNode deleteNode(ListNode head, ListNode pToBeDeleted) &#123; ListNode p = pToBeDeleted; if (head == null || p == null) return head; if (p.next != null) &#123; ListNode q = p.next; p.val = q.val; p.next = q.next; q = null; &#125; else if (head == p) &#123; p = null; head = null; &#125; else &#123; ListNode pre = head; while (pre.next != p &amp;&amp; pre != null) &#123; pre = pre.next; &#125; if (pre == null) &#123; System.out.println("无法找到待删除节点")； return head; &#125; pre.next = null; p = null; &#125; return head; &#125; //=========测试代码========== void test(ListNode head,ListNode PToBeDelete) &#123; System.out.println("============"); System.out.print("The original list is: "); ListNode curr=head; if(curr!=null) &#123; while(curr.next!=null) &#123; System.out.print(curr.val+","); curr=curr.next; &#125; System.out.println(curr.val); &#125;else &#123; System.out.println(); &#125; System.out.print("The node to be deleted is: "); if(PToBeDelete!=null) System.out.println(PToBeDelete.val); else System.out.println(); curr=deleteNode(head, PToBeDelete); System.out.print("The result list is: "); if(curr!=null) &#123; while(curr.next!=null) &#123; System.out.print(curr.val+","); curr=curr.next; &#125; System.out.println(curr.val); &#125;else &#123; System.out.println(); &#125; System.out.println("============"); &#125; /** * 链表含多个结点，删除头结点 */ void test1() &#123; ListNode p4=new ListNode(4, null); ListNode p3=new ListNode(3, p4); ListNode p2=new ListNode(2, p3); ListNode p1=new ListNode(1, p2); test(p1, p1); &#125; /** * 链表含多个结点，删除中间结点 */ void test2() &#123; ListNode p4=new ListNode(4, null); ListNode p3=new ListNode(3, p4); ListNode p2=new ListNode(2, p3); ListNode p1=new ListNode(1, p2); test(p1, p3); &#125; /** * 链表含多个结点，删除尾结点 */ void test3() &#123; ListNode p4=new ListNode(4, null); ListNode p3=new ListNode(3, p4); ListNode p2=new ListNode(2, p3); ListNode p1=new ListNode(1, p2); test(p1, p4); &#125; /** * 链表含一个结点，删除结点 */ void test4() &#123; ListNode p4=new ListNode(4, null); test(p4, p4); &#125; /** * 链表为空 */ void test5() &#123; test(null, null); &#125; public static void main(String[] args) &#123; DeleteNodeInList demo = new DeleteNodeInList(); demo.test1(); demo.test2(); demo.test3(); demo.test4(); demo.test5(); &#125;&#125; 总结 链表中删除节点的方法中，虽然直接令 head=null, 但是在主函数中的head还是不变的，因此要令删除节点的返回值为LinkNode，将返回值赋值给主函数中的head，这样才能实现真正的删除。 另一种情况可以令删除函数返回值为void，只是需要定义一个头结点head（1中的head相当于第一个节点），这个头结点中不存任何数据，仅仅起到执政的作用，第一个节点是头结点的下一个节点，通过对head.next操作，能够实现真正的删除。 和链表有关的特殊情况：头结点、尾节点，链表仅有一个节点，null等。 删除链表中的重复节点题目二在一个排序的链表中，如何删除重复的节点？ 思路设置一个 pre ，用于记录当前节点的前一个节点，再设置一个布尔变量 needDelete ，如果说当前节点和后一结点的值相同（记该值为dupVal)，needDelete赋值为真。当 needDelete 为真时，通过寻魂往后找到第一个不为 dupVal 的节点，把该节点设置为当前节点，并赋值给 pre.next, 即相当于完成了删除操作；而当 needDelete 为假时，把当前节点和 pre 往后移一位即可。 测试用例 功能测试（重复的节点位于链表的头部、中间、尾部；链表中无重复节点） 特殊输入测试（头结点为null、所有节点都重复） java代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181/** * @description: 在一个排序链表中删除重复的节点 * @author: rhsphere * @since: 2019-06-23 08:37 by jdk 1.8 */public class DeleteDuplicatedNode &#123; private class ListNode &#123; int val; ListNode next = null; ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; &#125; public ListNode deleteDuplication(ListNode pHead) &#123; if (pHead == null || pHead.next == null) &#123; // 空节点或者仅一个节点 return pHead; &#125; ListNode pre = null; ListNode cur = pHead; while (cur != null) &#123; boolean needDelete = false; if (cur.next != null &amp;&amp; cur.val == cur.next.val) &#123; needDelete = true; &#125; if (!needDelete) &#123; // 当前节点不重复 pre = cur; cur = cur.next; &#125; else &#123; int dupValue = cur.val; ListNode toBeDel = cur; while (toBeDel != null &amp;&amp; toBeDel.val == dupValue) &#123; // 这里删除在那还是不涉及前一节点操作，其实主要是找出后面第一个不重复节点 toBeDel = toBeDel.next; &#125; if (pre == null) &#123; //说明删除的节点是头结点 pHead = toBeDel; &#125; else &#123; pre.next = toBeDel; &#125; cur = toBeDel; //这个节点还是可能出现重复，所以不能 =next &#125; &#125; return pHead; &#125; //========测试代码====== void test(ListNode pHead) &#123; System.out.println("-----------"); System.out.print("The original list is: "); ListNode curr=pHead; if(curr!=null) &#123; while(curr.next!=null) &#123; System.out.print(curr.val+","); curr=curr.next; &#125; System.out.println(curr.val); &#125;else &#123; System.out.println(); &#125; pHead=deleteDuplication(pHead); System.out.print("The result list is: "); curr=pHead; if(curr!=null) &#123; while(curr.next!=null) &#123; System.out.print(curr.val+","); curr=curr.next; &#125; System.out.println(curr.val); &#125;else &#123; System.out.println(); &#125; System.out.println("-----------"); &#125; /** * 重复结点位于链表头部 */ void test1() &#123; ListNode p4=new ListNode(3, null); ListNode p3=new ListNode(2, p4); ListNode p2=new ListNode(1, p3); ListNode p1=new ListNode(1, p2); test(p1); &#125; /** * 重复结点位于链表尾部 */ void test2() &#123; ListNode p4=new ListNode(3, null); ListNode p3=new ListNode(3, p4); ListNode p2=new ListNode(2, p3); ListNode p1=new ListNode(1, p2); test(p1); &#125; /** * 重复结点位于链表中部 */ void test3() &#123; ListNode p4=new ListNode(3, null); ListNode p3=new ListNode(2, p4); ListNode p2=new ListNode(2, p3); ListNode p1=new ListNode(1, p2); test(p1); &#125; /** * 连续出现重复结点 */ void test4() &#123; ListNode p6=new ListNode(3, null); ListNode p5=new ListNode(3, p6); ListNode p4=new ListNode(2, p5); ListNode p3=new ListNode(2, p4); ListNode p2=new ListNode(1, p3); ListNode p1=new ListNode(1, p2); test(p1); &#125; /** * 多个重复结点 */ void test5() &#123; ListNode p6=new ListNode(3, null); ListNode p5=new ListNode(3, p6); ListNode p4=new ListNode(3, p5); ListNode p3=new ListNode(2, p4); ListNode p2=new ListNode(1, p3); ListNode p1=new ListNode(1, p2); test(p1); &#125; /** * 无重复结点 */ void test6() &#123; ListNode p6=new ListNode(6, null); ListNode p5=new ListNode(5, p6); ListNode p4=new ListNode(4, p5); ListNode p3=new ListNode(3, p4); ListNode p2=new ListNode(2, p3); ListNode p1=new ListNode(1, p2); test(p1); &#125; /** * 单个结点 */ void test7() &#123; ListNode p1=new ListNode(6, null); test(p1); &#125; /** * null */ void test8() &#123; ListNode p1=null; test(p1); &#125; public static void main(String[] args) &#123; DeleteDuplicatedNode demo= new DeleteDuplicatedNode(); demo.test1(); demo.test2(); demo.test3(); demo.test4(); demo.test5(); demo.test6(); demo.test7(); demo.test8(); &#125;&#125; 总结 删除多个节点时，只需要把重复节点前一个节点的next指向重复节点的后一个节点； 不要把重复节点一个一个删除，先定义一个布尔变量确定当前节点是否重复，然后按1 中的方法删除即可。]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Linked List</tag>
        <tag>HQ Code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer(17) 打印从1到最大的n位数]]></title>
    <url>%2F2019%2F06%2F19%2Fprint-1-to-n-digits.html</url>
    <content type="text"><![CDATA[打印1到最大的n位数(需复习)题目输入数字n，按顺序打印出从1最大的n位十进制数。比如输入1，则打印出1、2、3一直到最大的3位数即999 思路陷阱：n过大时是大数问题，不能简单用int或者long数据输出，需要采用字符串或者数组表达大数。 解决方法：通过字符数组char[]来进行输出数字。 方法一： 在字符串表达的数字上模拟加法； 把字符串表达的数字打印出来。 方法二： 采用递归将每一位都从0到9排列出来； 把字符串表达的数字打印出来。 测试用例功能测试（输入1、2、3）特殊测试（输入0、-1） int与char类型之间的相互转换 int类型转char类型，将数字加一个’0’，并强制类型转换成char即可、 char类型转int类型，将字符减去一个‘0’ char和int之间的类型转换12345678910public static void main(String[] args) &#123; //int类型转char类型 int number = 9; char cNumber = (char)(number + '0'); System.out.pritnln("Number " + number + "to char is:" + cNumber); //char类型装int类型 char ch = '3'; int number2 = ch - '0';&#125; java代码非递归法每次加一并打印这个数，直到最大的n位数并终止递增 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283/** * @description: 面试题17：输入数字n，按顺序打印出从1最大的n位十进制数。比如输入3，则打印出1、2、3一直到最大的3位数即999。 * @author: rhsphere * @since: 2019-06-13 22:18 by jdk 1.8 */public class Print1ToMaxOfNDigit &#123; // 方法一 /** * 采取模拟加一的方法 */ public void print1ToMaxOfNDigits(int n) &#123; if (n &lt;= 0) return; char[] number = new char[n]; //不能用foreach对number赋值 for (int k = 0; k &lt; number.length; k++) &#123; number[k] = '0'; &#125; while (!increment(number)) &#123; printCharNumber(number); &#125; &#125; /** * 对字符串进行加一操作，number达到最大值后返回true * 最低位加1；所以如果所有位超过10，则进位 */ private boolean increment(char[] number) &#123; int nTakeOver = 0; //代表进位 for (int i = number.length - 1; i &gt;= 0; i--) &#123; int nSum = (number[i] - ' 0') + nTakeOver; //当前位置数字 // number[i] - '0' 是把char转成int，nTakeOver代表进位 if (i == number.length - 1) nSum++; if (nSum &gt;= 10) &#123; if (i == 0) return true; nTakeOver = 1; nSum -= 10; number[i] = (char) (nSum + '0'); &#125; else &#123; number[i] = (char) (nSum + '0'); break; //高位不变，可以直接跳出循环 &#125; &#125; return false; &#125; /** * 打印字符数组形成的数字 * 书中方法：利用布尔变量isBeginning0来从第一个非零字符打印 */ private void printCharNumber(char[] number) &#123; boolean isBeginning0 = true; for (int i = 0; i &lt; number.length; i++) &#123; if (isBeginning0 &amp;&amp; (number[i] - '0') != 0) &#123; isBeginning0 = false; &#125; if (!isBeginning0) &#123; System.out.print(number[i]); &#125; &#125; System.out.println(); &#125; /** * 打印字符数组形成的数字 * 自己的方法：找出第一个非零字符位置，往后进行打印 */ private void printCharNumber2(char[] number) &#123; int beginner = number.length; //不写成number.llength - 1，以防写出0 for (int i = 0; i &lt; number.length - 1; i++) &#123; if ((number[i] - '0') != 0)&#123; beginner = i; break; &#125; &#125; for (int i = beginner; i &lt;= number.length - 1; i++) &#123; System.out.print(number[i]); &#125; if (beginner != number.length) System.out.println(); &#125;&#125; 递归方法如果在数字前面补0.就会发现n位所有十进制其实就是n个从0到9的全排列。也就是说，我们把数字的每一位都从0到9排列一遍，就得到了所有的十进制数。只是在打印的时候，排在前面的0不打印出来。全排列用递归很容易表达，数字的每一位都可能是0~9中的一个数，然后设置下一位。递归终止条件是我们已经设置了数字的最后一位。 12345678910111213141516171819202122232425262728293031323334353637383940414243public class Print1ToMaxOfNDigit &#123; //方法二 /** *采用递归算法 */ public void print1ToMaxOfNDigits(int n) &#123; if (n &lt;= 0) return; char[] number = new char[n]; for (int k = 0; k &lt; number.length; k++) number[k] = '0'; for (int i = 0; i &lt;= 9; i++) makeNumber(n, number, i, 0); &#125; //生成数字 private void makeNumber(int n, char[] number, int nNumber, int index) &#123; if (index == number.length - 1) &#123; number[index] = (char)(nNumber + '0'); printCharNumber(number); return; &#125; else &#123; number[index] = (char)(nNumber + '0'); for (int i = 0; i &lt;=9; i++) &#123; makeNumber(n, number, i, index + 1); &#125; &#125; &#125; private void printCharNumber(char[] number) &#123; int beginner = number.length; for (int i = 0; i &lt;= number.length - 1; i++) &#123; if ((number[i] - '0') != 0) &#123; beginner = i; break; &#125; &#125; for (int i = beginner; i &lt;= number.length - 1; i++) &#123; System.out.print(number[i]); &#125; if (beginner != number.length) System.out.pritnln(); &#125;&#125; 清晰、简洁版本的java代码1234567891011121314151617181920212223242526272829303132public class Print1ToMaxOfNDigit &#123; public void print1ToMaxOfNDigits(int n) &#123; if (n &lt;= 0) return; char[] digit = new char[n]; for (int i = 0; i &lt; n; i++) digit[i] = '0'; for (int i = n - 1; i &gt;= 0; i--) &#123; while (digit[i] != '9') &#123; int m = 0; digit[m]++; while (m &lt; n-1 &amp;&amp; digit[m] &gt; '9') &#123; digit[m] = '0'; digit[m+1]++; m++; &#125; printDigits(digit); &#125; &#125; &#125; private void printDigits(char[] digit) &#123; int m = digit.length - 1; while (digit[m] == '0') m--; for (int i = m; i &gt;= 0; i--) System.out.print(digit[i]); Sytem.out.println(); &#125;&#125; 总结 打印字符串镖师的数组，从第一个非零数字打印。 关注大数问题]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>HQ Code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer(16) 数值的整数次方]]></title>
    <url>%2F2019%2F06%2F14%2Fperfect-power.html</url>
    <content type="text"><![CDATA[数值的整数次方题目本章开始将关注代码的质量，关注功能测试、边界测试和负面（错误测试），写出完整的代码。实现double Power(double base, int exponent)，求base的exponent次方，不得使用库函数，同时不需要考虑大数问题。 思路这道题很容易实现，但是需要注意以下陷阱：1）0的负数次方不存在；2）0的0次方没有数学意义；3）要考虑exponent为负数的情况。所以可以对exponent进行分类讨论，再对base是否为0进行讨论。 java代码递归实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091/** * @description: 面试题16：数值的整数次方 * @author: rhsphere * @since: 2019-06-13 22:16 by jdk 1.8 */public class Power &#123; boolean isInvalid = false; //全局变量标记是否出错 public double power(double base, int exponent) &#123; isValid = false; double result; if (exponent &gt; 0) &#123; result = powerCore(base, exponent); &#125; else if (exponent &lt; 0) &#123; if (base == 0) &#123; isInvalid = true; //0的负数次方不存在 return 0; &#125; return = 1 / powerCore(base, -exponent); &#125; else &#123; return 1; //这里0的0次方输出为1 &#125; return result; &#125; private double powerCore(double base, int exponent) &#123; if (exponent == 1) return base; if (exponent == 0) return 1; // 递归调用本身 double result = powerCore(base, expoennt &gt;&gt; 1); result *= result; if ((exponent &amp; 0x1) == 1) &#123; //最后一次运算的exponent为奇数，需要再乘一次base result *= base; &#125; return result; &#125; // ========测试代码======== void test(String testName, double base, int exponent, double expected, boolean expectedFlag) &#123; if (testName != null) System.out.print(testName + ":"); if (power(base, exponent) == expected &amp;&amp; IsInvalid == expectedFlag) &#123; System.out.println("passed."); &#125; else &#123; System.out.println("failed."); &#125; &#125; void test1() &#123; test("test1", 0, 6, 0, false); &#125; void test2() &#123; test("test2", 0, -6, 0, true); &#125; void test3() &#123; test("test3", 0, 0, 1, false); &#125; void test4() &#123; test("test4", 2, 6, 64, false); &#125; void test5() &#123; test("test5", 2, -3, 0.125, false); &#125; void test6() &#123; test("test6", 5, 0, 1, false); &#125; void test7() &#123; test("test7", -2, 6, 64, false); &#125; public static void main(String[] args) &#123; Power demo = new Power(); demo.test1(); demo.test2(); demo.test3(); demo.test4(); demo.test5(); demo.test6(); demo.test7(); &#125;&#125; 非递归实现上面的powerCore()方法可改写成如下： 12345678910private double powerCore(double base, int exponent) &#123; double result = 0; while (exponent != 0) &#123; if ((exponent &amp; 0x1) == 1) return *= base; exponent &gt;&gt;= 1; base *= base; //指数右移一位，则底数翻倍 &#125; return result;&#125; 总结 double 类型变量在被赋值为0时，是可以用等号判等的 做乘方的地推公式要掌握，用递推公式能够更加简洁； 使用位与运算符代替求余运算符%判断奇偶数，有较高的效率：if ((exponent &amp; 0x1) == 1) 非递归实现乘方，其本质是根据指数与2的倍数关系来对底数进行操作的]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Power</tag>
        <tag>HQ Code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sort(排序)]]></title>
    <url>%2F2019%2F06%2F01%2Fsort-sum-up.html</url>
    <content type="text"><![CDATA[Sort(排序)01. Selection Sort（选择排序实现） 02. Insertion Sort（插入排序实现） 03. Shell Sort（希尔排序实现） 04. Bubble Sort（冒泡排序实现） 05. Cocktail Sort（鸡尾酒排序） 06. Merge Sort（归并排序实现） 07. Quick Sort（快速排序实现） 08. Count Sort（计数排序） 09. Bucket Sort（桶排序） 10. Heap Sort （堆排序(非泛型)） 11. Sort Large File （外部排序） 12. Heap Sort （堆排序(泛型)） Summary of Sorting Algos（排序总结）]]></content>
      <categories>
        <category>Sum-up</category>
      </categories>
      <tags>
        <tag>Sum-up</tag>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Queue(队列)]]></title>
    <url>%2F2019%2F06%2F01%2Fqueue-sum-up.html</url>
    <content type="text"><![CDATA[Queue(队列)Last Modified: 2019/5/30 20:36 by dp 01. Implement Queue by Array（用数组实现队列） 02. Implement Queue by LinkedList（用链表实现队列） 03. Implement Queue using Stacks（用栈实现队列） 04. Implement Circular Queue using Array（用数组实现循环队列） 05. Design Circular Deque（设计一个双端队列）]]></content>
      <categories>
        <category>Sum-up</category>
      </categories>
      <tags>
        <tag>Queue</tag>
        <tag>Sum-up</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[641. Design Circular Deque]]></title>
    <url>%2F2019%2F05%2F31%2F641.html</url>
    <content type="text"><![CDATA[设计一个双端队列题目设计实现双端队列。你的实现需要支持以下操作： MyCircularDeque(k)：构造函数,双端队列的大小为k。insertFront()：将一个元素添加到双端队列头部。 如果操作成功返回 true。insertLast()：将一个元素添加到双端队列尾部。如果操作成功返回 true。deleteFront()：从双端队列头部删除一个元素。 如果操作成功返回 true。deleteLast()：从双端队列尾部删除一个元素。如果操作成功返回 true。getFront()：从双端队列头部获得一个元素。如果双端队列为空，返回 -1。getRear()：获得双端队列的最后一个元素。 如果双端队列为空，返回 -1。isEmpty()：检查双端队列是否为空。isFull()：检查双端队列是否满了。示例： MyCircularDeque circularDeque = new MycircularDeque(3); // 设置容量大小为3circularDeque.insertLast(1); // 返回 truecircularDeque.insertLast(2); // 返回 truecircularDeque.insertFront(3); // 返回 truecircularDeque.insertFront(4); // 已经满了，返回 falsecircularDeque.getRear(); // 返回 2circularDeque.isFull(); // 返回 truecircularDeque.deleteLast(); // 返回 truecircularDeque.insertFront(4); // 返回 truecircularDeque.getFront(); // 返回 4 提示： 所有值的范围为 [1, 1000]操作次数的范围为 [1, 1000]请不要使用内置的双端队列库。 java代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106/** * @description: 使用链表 * @author: rhsphere * @since: 2019-05-31 10:25 by jdk 1.8 */class MyCircularDeque &#123; class Node &#123; int val; Node next; Node prev; Node(int val) &#123; this.val = val; &#125; &#125; Node head, tail; int capacity; int size; /** Initialize your data structure here. Set the size of the deque to be k. */ public MyCircularDeque(int k) &#123; head = new Node(-1); tail = new Node(-1); head.next = tail; tail.prev = head; capacity = k; &#125; /** Adds an item at the front of Deque. Return true if the operation is successful. */ public boolean insertFront(int value) &#123; if (size == capacity) return false; Node node = new Node(value); node.next = head.next; head.next.prev = node; head.next = node; node.prev = head; size++; return true; &#125; /** Adds an item at the rear of Deque. Return true if the operation is successful. */ public boolean insertLast(int value) &#123; if (size == capacity) return false; Node node = new Node(value); tail.prev.next = node; node.prev = tail.prev; node.next = tail; tail.prev = node; size++; return true; &#125; /** Deletes an item from the front of Deque. Return true if the operation is successful. */ public boolean deleteFront() &#123; if (size == 0) return false; head.next.next.prev = head; head.next = head.next.next; size--; return true; &#125; /** Deletes an item from the rear of Deque. Return true if the operation is successful. */ public boolean deleteLast() &#123; if (size == 0) return false; tail.prev.prev.next = tail; tail.prev = tail.prev.prev; size--; return true; &#125; /** Get the front item from the deque. */ public int getFront() &#123; return head.next.val; &#125; /** Get the last item from the deque. */ public int getRear() &#123; return tail.prev.val; &#125; /** Checks whether the circular deque is empty or not. */ public boolean isEmpty() &#123; return size == 0; &#125; /** Checks whether the circular deque is full or not. */ public boolean isFull() &#123; return size == capacity; &#125;&#125;/** * Your MyCircularDeque object will be instantiated and called as such: * MyCircularDeque obj = new MyCircularDeque(k); * boolean param_1 = obj.insertFront(value); * boolean param_2 = obj.insertLast(value); * boolean param_3 = obj.deleteFront(); * boolean param_4 = obj.deleteLast(); * int param_5 = obj.getFront(); * int param_6 = obj.getRear(); * boolean param_7 = obj.isEmpty(); * boolean param_8 = obj.isFull(); */]]></content>
      <categories>
        <category>Queue</category>
      </categories>
      <tags>
        <tag>Queue</tag>
        <tag>Circular Queue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Array && Linked && Circular Queue]]></title>
    <url>%2F2019%2F05%2F31%2Farray-linked-circular-queue.html</url>
    <content type="text"><![CDATA[队列队列跟栈一样，也是操作受限的线性表结构。 队列最基本的操作也是两个：入队enqueue()，放一个数据到队列尾部；出队dequeue()，从队列头部取一个元素。** 队列的应用非常广泛，特别是一些具有某些额外特性的队列，比如循环队列、阻塞队列、并发队列。他们在很多偏底层系统、框架、中间件的开发中，骑着关键性的作用。比如高性能队列Disruptor、Linux环形缓存，都用到了循环并发队列；Java concurrent并发包利用ArrayBlockingQueue来实现公平锁等。 实际的项目，不可能从零实现一个队列，甚至都不会直接用到。而具有特殊特性的队列应用却比较广泛，比如阻塞队列和并发队列。 阻塞队列其实就是在队列基础上增加了阻塞操作。简单来说，就是在队列为空的时候，从队头取数据会被阻塞。因为此时还没有数据可取，直到队列中有了数据才能返回；如果队列已经满了，那么插入数据的操作就会被阻塞，知道队列中有空闲位置后再插入数据，然后再返回。 线程安全的队列叫做 并发队列，对简单直接的实现方式就是直接在enqueue()、dequeue()方法上加锁，但是锁粒度大并发度会比较低，同一时刻仅允许一个存或者取操所。实际上，基于数组的循环队列，利用CAS原子操作，可以实现非常高效的并发队列。 这也是循环队列比链式队列应用更加广泛的原因。 线程池队列的策略线程池没有空闲线程时，新的任务请求线程资源是，线程池该如何处理?这种处理策略又是如何实现的呢？ 一半有两种处理策略。第一种是非阻塞的处理方式，直接拒绝任务请求；另一种是阻塞的处理方式，将请求排队，等到有空闲线程时，去除排队的请求继续处理。 基于链表的实现方式，可以实现一个支持无限排队的无界队列，但是可能会导致过多的请求队列等待，请求处理的相应时间过长。所以，针对响应时间比较敏感的系统，基于链表实现的无限排队的线程池是不合适的。 而基于数组实现的有界队列，队列的大小有限，所以线程池中排队的请求超过队列大小时，接下来的请求就会被拒绝，这种方式对响应时间敏感的系统来说，就像对更加合理。 分布式应用中的消息队列，也是一种队列结构。考虑使用CAS实现无锁队列，在入队前，获取tail位置，入队是比较tail是否发生变化，如果否，则允许入队，反之，本次入队失败，出队则是获取head位置，进行cas。 顺序队列对于队列，需要两个指针：一个是head指针，指向对头；一个是tail指针，指向队尾。随着不停地进行入队、出队操作，head和tail都会持续往后移动。当tail移动到最右边，即使数组中还有空闲空间，也无法继续往队列中添加数据了。一种方法是，对于入队enqueue()，进行判断队列末尾是否有空间，然后将数据整体搬移一次。 1234567891011121314public boolean enqueue(String item) &#123; if (tail == n) &#123; if (head == 0) return false; for (int i = head; i &lt; tail; i++) &#123; items[i - head] = items[i]; &#125; tail -= head; head = 0; &#125; items[tail] = item; tail++; return true;&#125; 顺序队列实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889/** * @description: 用数组实现的动态扩容顺序队列 * @author: rhsphere * @since: 2019-05-30 20:53 by jdk 1.8 */public class ArrayQueue&lt;E&gt; implements Iterable&lt;E&gt; &#123; private E[] q; private int n; private int head; private int tail; public ArrayQueu() &#123; q = (E[]) new Object[2]; n = 0; head = 0; tail = 0; &#125; public boolean isEmpty() &#123; return n == 0; &#125; public int size() &#123; return n; &#125; public void resize(int capacity) &#123; assert capacity &gt; 0; E[] tmp = (E[]) new Object[capacity]; for (int i = 0; i &lt; n; i++) tmp[i] = q[(head + i) % q.length]; q = tmp; head = 0; tail = n; &#125; public void enqueue(E e) &#123; if (n == q.length) resize(2 * q.length); q[tail++] = e; if (tail == q.length) tail = 0; n++; &#125; public E dequeue() &#123; if (isEmpty()) &#123; throw new NoSuchElementException("Queue underflow"); &#125; E e = q[head]; q[head] = null; n--; head++; if (head == q.length) head = 0; if (n &gt; 0 &amp;&amp; n == q.length / 4) resize(q.length / 2); return e; &#125; public E peek() &#123; if (isEmpty()) throw new NoSuchElementException("Queue underflow"); return q[head]; &#125; public Iterator&lt;E&gt; iterator() &#123; return new ArrayIterator(); &#125; private class ArrayIterator implements Iterator&lt;E&gt; &#123; private int i = 0; public boolean hasNext() &#123; return i &lt; n; &#125; public void remove() &#123; throw new UnsupportedOperationException(); &#125; public E next() &#123; if (!hasNext()) throw new NoSuchElementException(); E e = q[(i + head) % q.length]; i++; return e; &#125; &#125;&#125; 链式队列基于链表的实现，同样需要两个指针：head指针和tail指针。分别指向链表的第一个节点和最后一个节点。入队时，tail.next = newNode, tail = tail.next; 出队时，head = head.next; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192/** * @description: 链式队列 * @author: rhsphere * @since: 2019-05-30 22:11 by jdk 1.8 */pubilc class LinkedQueue&lt;E&gt; implements Iterable&lt;E&gt; &#123; private Node&lt;E&gt; head; private Node&lt;E&gt; tail; private int n; private static class Node&lt;E&gt; &#123; private E e; private Node&lt;E&gt; next; &#125; public LinkedQueue() &#123; head = null; tail = null; n = 0; &#125; public boolean isEmpty() &#123; return head == null; &#125; public int size() &#123; return n; &#125; public E peek() &#123; if (isEmpty()) throw new NoSuchElementException("Queue underfolw"); return head.e; &#125; public void enqueue(E e) &#123; Node&lt;E&gt; oldtail = tail; tail = new Node&lt;E&gt;(); tail.e = e; tail.next = null; if (isEmpty()) &#123; head = tail; &#125; else &#123; oldtail.next = tail; &#125; n++; &#125; public E dequeue() &#123; if (isEmpty()) &#123; throw new NoSuchElementException("Queue underflow"); &#125; E e = head.e; head = head.next; n--; if (isEmpty()) tail = null; return e; &#125; pulbic String toString() &#123; StringBuilder sb = new StringBuilder(); for (E e : this) &#123; sb.append(e); sb.append(' '); &#125; return sb.toString(); &#125; public Iterator&lt;E&gt; iterator() &#123; return new ListIterator&lt;E&gt;(head); &#125; private class ListIterator&lt;E&gt; implements Iterator&lt;E&gt; &#123; private Node&lt;E&gt; cur; public ListIterator(Node&lt;E&gt; head) &#123; this.cur = head; &#125; public boolean hasNext() &#123; return cur != null; &#125; public E remove() &#123; throw new UnsupportedOperationException(); &#125; public E next() &#123; if (!hasNext()) throw new NoSuchElementException(); E e = cur.e; cur = cur.next; return e; &#125; &#125;&#125; 循环队列在用数组实现队列的时候，在tail=n时，会有数据搬移，这样入队操作性能就会受到影响。 循环队列最关键的是，确定好队空和队满的判定条件。 对于数组实现的非循环队列中，队满的判断条件是tail == n，队空的判断条件时head == tail。针对循环队列，队空的判断条件是head == tail。但是队满的判断条件是 （tail + 1) % n == head 。 队满时tail指向的位置实际上是没有存储数据的，所有，循环队列会浪费一个数组空间。 1234567891011121314151617181920212223242526272829303132/** * @description: 循环队列 * @author: rhsphere * @since: 2019-05-30 22:42 by jdk 1.8 */public class CircularQueue&lt;E&gt; &#123; private E[] q; private int n = 0; private int head = 0; private int tail = 0; public CircularQueue(int capacity) &#123; q = (E[]) new Object[capacity]; n = capacity; &#125; public boolean enqueue(E e) &#123; if ((tail + 1) % n == head) return false; q[tail] = e; tail = (tail + 1) % n; return true; &#125; public E dequeu() &#123; if (head == tail) return null; E res = q[head]; head = (head + 1) % n; return res; &#125;&#125; 测试LinkedQueue和ArrayQueue12345678910111213141516171819202122232425262728293031323334353637383940414243444546package Queue;/** * @description: 测试顺序队列和链式队列 * @author: rhsphere * @since: 2019-05-30 22:02 by jdk 1.8 */public class TestQueue &#123; public static void main(String[] args) &#123; System.out.println("==========测试ArrayQueue==============="); ArrayQueue&lt;String&gt; arrayQueue = new ArrayQueue&lt;&gt;(); arrayQueue.enqueue("Hello, "); arrayQueue.enqueue("world! "); arrayQueue.enqueue("You, "); arrayQueue.enqueue("there."); for (String s : arrayQueue) System.out.print(s); System.out.println(); while (!arrayQueue.isEmpty()) &#123; System.out.print(arrayQueue.dequeue()); &#125; System.out.println("\n(" + arrayQueue.size() + " left on array queue) "); System.out.println("=========结束测试============"); System.out.println("==========测试LinkedQueue=============="); LinkedQueue&lt;Integer&gt; linkedQueue = new LinkedQueue&lt;&gt;(); linkedQueue.enqueue(1); linkedQueue.enqueue(3); linkedQueue.enqueue(5); linkedQueue.enqueue(7); linkedQueue.enqueue(9); for (Integer i : linkedQueue) System.out.print(i + " "); System.out.println(); while (!linkedQueue.isEmpty()) &#123; System.out.print(linkedQueue.dequeue() + " "); &#125; System.out.println("\n(" + linkedQueue.size() + " left on linked queue) "); System.out.println("=========结束测试============"); &#125;&#125;]]></content>
      <categories>
        <category>Sum-up</category>
      </categories>
      <tags>
        <tag>Queue</tag>
        <tag>ArrayQueue</tag>
        <tag>LinkedQueue</tag>
        <tag>CircularQueue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Stack(栈)]]></title>
    <url>%2F2019%2F05%2F30%2Fstack-sum-up.html</url>
    <content type="text"><![CDATA[Stack(栈)Last Modified: 2019/5/30 20:36 by dp01. Implement Stack by Array（数组实现栈） 02. Implement Stack by LinkedList（链表实现栈） 03. Implement Sample Browser by Stack（用栈模拟浏览器） 04. Valid Parentheses（有效的括号） 05. Longest Valid Parentheses（最长有效括号） 06. Evaluate Reverse Polish Notatio（逆波兰表达式求值）]]></content>
      <categories>
        <category>Sum-up</category>
      </categories>
      <tags>
        <tag>Stack</tag>
        <tag>Sum-up</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[150. Evalute Reverse Polish Notatio]]></title>
    <url>%2F2019%2F05%2F30%2F150.html</url>
    <content type="text"><![CDATA[逆波兰表达式求值题目根据逆波兰表示法，求表达式的值。 有效的运算符包括 +, -, *, / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。 说明： 整数除法只保留整数部分。 给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。 示例 1： 输入: [“2”, “1”, “+”, “3”, ““]输出: 9解释: ((2 + 1) 3) = 9示例 2： 输入: [“4”, “13”, “5”, “/“, “+”]输出: 6解释: (4 + (13 / 5)) = 6示例 3： 输入: [“10”, “6”, “9”, “3”, “+”, “-11”, ““, “/“, ““, “17”, “+”, “5”, “+”]输出: 22解释: ((10 (6 / ((9 + 3) -11))) + 17) + 5= ((10 (6 / (12 -11))) + 17) + 5= ((10 (6 / -132)) + 17) + 5= ((10 0) + 17) + 5= (0 + 17) + 5= 17 + 5= 22 java代码1234567891011121314151617181920212223242526272829/** * @description: * @author: rhsphere * @since: 2019-05-30 19:52 by jdk 1.8 */public class EvaluateReversePolishNotation &#123; public int evalRPN(String[] tokens) &#123; if (tokens.length == 0) return 0; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); for (int i = 0; i &lt; tokens.length; i++) &#123; String s = tokens[i]; if (s.equals("+") || s.equals("-") || s.equals("/") || s.equals("*")) &#123; int b = stack.pop(); int a = stack.pop(); switch(s) &#123; case "+": stack.push(a+b);break; case "-": stack.push(a-b);break; case "*": stack.push(a*b);break; case "/": stack.push(a/b);break; &#125; &#125; else &#123; satck.push(Integer.valueOf(s)); &#125; &#125; return stack.pop(); &#125;&#125;]]></content>
      <categories>
        <category>Medium</category>
      </categories>
      <tags>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[32. Longest Valid Parentheses]]></title>
    <url>%2F2019%2F05%2F30%2F32.html</url>
    <content type="text"><![CDATA[最长有效括号题目给定一个只包含 ‘(‘ 和 ‘)’ 的字符串，找出最长的包含有效括号的子串的长度。 示例 1: 输入: “(()”输出: 2解释: 最长有效括号子串为 “()”示例 2: 输入: “)()())”输出: 4解释: 最长有效括号子串为 “()()” 思路使用栈，本题用了栈的三个操作。 要记住，字符串等价于字符数组，字符串的每个字符都是可以等价于字符数组，所以可以利用数组的性质。 java代码123456789101112131415161718192021222324252627282930313233343536** * @description: * @author: rhsphere * @since: 2019-05-30 18:47 by jdk 1.8 */public class LongestValidParentheses &#123; public static int longestValidParentheses(String s) &#123; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); stack.push(-1); int max = 0; for (int i = 0; i &lt; s.length(); i++) &#123; if (s.charAt(i) == '(') &#123; stack.push(i); &#125; else &#123; if (!stack.isEmpty()) &#123; stack.pop(); &#125; if (stack.isEmpty()) &#123; stack.push(i); &#125; else &#123; max = Math.max(max, i - stack.peek()); &#125; &#125; &#125; return max; &#125; public static void main(String[] args) &#123; String s = "())((())"; int len = longestValidParentheses(s); System.out.println(len); &#125;&#125; 总结写完代码读一下，检查一下错误，这次有两处错误，1）s.charAt(i) == ‘()’2）max = Math.max(max, i - peek());]]></content>
      <categories>
        <category>Hard</category>
      </categories>
      <tags>
        <tag>String</tag>
        <tag>Stack</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode排序]]></title>
    <url>%2F2019%2F05%2F29%2Fleetcode-asc.html</url>
    <content type="text"><![CDATA[leetcode刷过的题 # Title(跳转到网站) Difficulty(刷过的) 0001 Two Sum Easy 0002 Add Two Numbers Medium 0003 Longest Substring Without Repeating Characters Medium 0004 Median of Two Sorted Arrays Hard 0005 Longest Palindromic Substring Medium 0006 ZigZag Conversion Medium 0007 Reverse Integer Easy 0008 String to Integer (atoi) Medium 0009 Palindrome Number Easy 0010 Regular Expression Matching Hard 0011 Container With Most Water Medium 0012 Integer to Roman Medium 0013 Roman to Integer Easy 0014 Longest Common Prefix Easy 0015 3Sum Medium 0016 3Sum Closest Medium 0017 Letter Combinations of a Phone Number Medium 0018 4Sum Medium 0019 Remove Nth Node From End of List Medium 0020 Valid Parentheses Easy 0021 Merge Two Sorted Lists Easy 0022 Generate Parentheses Medium 0023 Merge k Sorted Lists Hard 0024 Swap Nodes in Pairs Medium 0026 Remove Duplicates from Sorted Array Easy 0027 Remove Element Easy 0028 Implement strStr() Easy 0029 Divide Two Integers Medium 0030 Substring with Concatenation of All Words Hard 0031 Next Permutation Medium 0032 Longest Valid Parentheses Hard 0033 Search in Rotated Sorted Array Medium 0034 Find First and Last Position of Element in Sorted Array Medium 0035 Search Insert Position Easy 0036 Valid Sudoku Medium 0037 Sudoku Solver Hard 0038 Count and Say Easy 0039 Combination Sum Medium 0040 Combination Sum II Medium 0041 First Missing Positive Hard 0042 Trapping Rain Water Hard 0043 Multiply Strings Medium 0044 Wildcard Matching Hard 0045 Jump Game II Hard 0046 Permutations Medium 0047 Permutations II Medium 0048 Rotate Image Medium 0049 Group Anagrams Medium 0050 Pow(x, n) Medium 0051 N-Queens Hard 0052 N-Queens II Hard 0053 Maximum Subarray Easy 0054 Spiral Matrix Medium 0055 Jump Game Medium 0056 Merge Intervals Medium 0057 Insert Interval Hard 0058 Length of Last Word Easy 0059 Spiral Matrix II Hard 0060 Permutation Sequence Medium 0061 Rotate List Medium 0062 Unique Paths Medium 0063 Unique Paths II Medium 0064 Minimum Path Sum Medium 0065 Valid Number Hard 0066 Plus One Easy 0068 Text Justification Hard 0069 Sqrt(x) Easy 0070 Climbing Stairs Easy 0071 Simplify Path Medium 0072 Edit Distance Hard 0073 Set Matrix Zeroes Medium 0074 Search a 2D Matrix Medium 0075 Sort Colors Medium 0076 Minimum Window Substring Easy 0077 Combinations Medium 0078 Subsets Medium 0079 Word Search Medium 0080 Remove Duplicates from Sorted Array II Medium 0081 Search in Rotated Sorted Array II Medium 0082 Remove Duplicates from Sorted List II Medium 0083 Remove Duplicates from Sorted List Easy 0084 Largest Rectangle in Histogram Hard 0085 Maximal Rectangle Hard 0086 Partition List Medium 0087 Scramble String Hard 0088 Merge Sorted Array Easy 0089 Gray Code Medium 0090 Subsets II Medium 0091 Decode Ways Medium 0092 Reverse Linked List II Medium 0093 Restore IP Addresses Medium 0094 Binary Tree Inorder Traversal Medium 0095 Unique Binary Search Trees II Medium 0096 Unique Binary Search Trees Medium 0097 Interleaving String Medium 0098 Validate Binary Search Tree Medium 0099 Recover Binary Search Tree Hard 0100 Same Tree Easy 0101 Symmetric Tree Easy 0102 Binary Tree Level Order Traversal Medium 0103 Binary Tree Zigzag Level Order Traversal Medium 0104 Maximum Depth of Binary Tree Easy 0105 Construct Binary Tree from Preorder and Inorder Traversal Medium 0106 Construct Binary Tree from Inorder and Postorder Traversal Medium 0107 Binary Tree Level Order Traversal II Easy 0108 Convert Sorted Array to Binary Search Tree Easy 0109 Convert Sorted List to Binary Search Tree Medium 0110 Balanced Binary Tree Easy 0111 Minimum Depth of Binary Tree Easy 0112 Path Sum Easy 0113 Path Sum II Medium 0114 Flatten Binary Tree to Linked List Medium 0115 Distinct Subsequences Hard 0116 Populating Next Right Pointers in Each Node Medium 0117 Populating Next Right Pointers in Each Node II Medium 0118 Pascal’s Triangle Easy 0119 Pascal’s Triangle II Easy 0120 Triangle Medium 0121 Best Time to Buy and Sell Stock Easy 0122 Best Time to Buy and Sell Stock II Easy 0123 Best Time to Buy and Sell Stock III Hard 0124 Binary Tree Maximum Path Sum Hard 0125 Valid Palindrome Easy 0126 Word Ladder II Hard 0127 Word Ladder Medium 0128 Longest Consecutive Sequence Hard 0129 Sum Root to Leaf Numbers Medium 0130 Surrounded Regions Medium 0131 Palindrome Partitioning Medium 0132 Palindrome Partitioning II Hard 0133 Clone Graph Medium 0134 Gas Station Medium 0135 Candy Hard 0136 Single Number Easy 0137 Single Number II Medium 0138 Copy List with Random Pointer Medium 0139 Word Break Medium 0140 Word Break II Hard 0141 Linked List Cycle Easy 0142 Linked List Cycle II Medium 0143 Reorder-List Medium 0144 Binary Tree Preorder Traversal Medium 0145 Binary Tree Postorder Traversal Hard 0146 LRU Cache Hard 0147 Insertion Sort List Medium 0148 Sort List Medium 0149 Max Points on a Line Hard 0150 Evaluate Reverse Polish Notation Medium 0151 Reverse Words in a String Medium 0152 Maximum Product Subarray Medium 0153 Find Minimum in Rotated Sorted Array Medium 0154 Find Minimum in Rotated Sorted Array II Hard 0155 Min Stack Easy 0160 Intersection of Two Linked Lists Easy 0162 Find Peak Element Medium 0165 Compare Version Numbers Medium 0166 Fraction to Recurring Decimal Medium 0167 Two Sum II - Input array is sorted Easy 0168 Excel Sheet Column Title Easy 0169 Majority Element Easy 0171 Excel Sheet Column Number Easy 0172 Factorial Trailing Zeroes Easy 0173 Binary Search Tree Iterator Medium 0174 Dungeon Game Hard 0187 Repeated-DNA-Sequences Medium 0188 Best Time to Buy and Sell Stock IV Hard 0189 Rotate Array Easy 0190 Reverse Bits Easy 0191 Number of 1 Bits Easy 0198 House Robber Easy 0199 Binary Tree Right Side View Medium 0200 Number of Islands Medium 0201 Bitwise AND of Numbers Range Medium 0202 Happy Number Easy 0203 Remove Linked List Elements Easy 0204 Count Primes Easy 0205 Isomorphic Strings Easy 0206 Reverse Linked List Easy 0208 Implement Trie (Prefix Tree) Easy 0209 Minimum Size Subarray Sum Medium 0211 Add and Search Word - Data structure design Medium 0213 House Robber II Medium 0215 Kth Largest Element in an Array Medium 0216 Combination Sum III Medium 0217 Contains Duplicate Easy 0219 Contains Duplicate II Easy 0222 Count Complete Tree Nodes Medium 0226 Invert Binary Tree Easy 0228 Summary Ranges Medium 0229 Majority Element II Medium 0230 Kth Smallest Element in a BST Medium 0234 Palindrome Linked List Medium 0235 Lowest Common Ancestor of a Binary Search Tree Easy 0236 Lowest Common Ancestor of a Binary Tree Medium 0237 Delete Node in a Linked List Easy 0238 Product of Array Except Self Medium 0239 Sliding Window Maximum Medium 0241 Different Ways to Add Parentheses Medium 0242 Valid Anagram Easy 0242 Binary Tree Paths Easy 0260 Single Number III Medium 0268 Missing Number Easy 0279 Perfect Squares Medium 0283 Move Zeroes Easy 0287 Find the Duplicate Number Medium 0289 Game of Life Medium 0290 Word Pattern Easy 0300 Longest Increasing Subsequence Medium 0303 Range Sum Query - Immutable Easy 0307 Range Sum Query - Mutable Medium 0309 Best Time to Buy and Sell Stock with Cooldown Medium 0322 Coin-Change Medium 0325 Maximum Size Subarray Sum Equals k Medium 0328 Odd Even Linked List Medium 0337 House Robber III Medium 0341 Flatten Nested List Iterator Medium 0343 Integer Break Medium 0344 Reverse String Easy 0345 Reverse Vowels of a String Easy 0347 Top K Frequent Elements Medium 0349 Intersection of Two Arrays Easy 0350 Intersection of Two Arrays II Easy 0377 Combination Sum IV Medium 0389 Find the Difference Easy 0392 Is Subsequence Medium 0401 Binary Watch Easy 0404 Sum of Left Leaves Easy 0416 Partition Equal Subset Sum Medium 0435 Non-overlapping Intervals Medium 0437 Path Sum III Easy 0438 Find All Anagrams in a String Easy 0445 Add Two Numbers II Medium 0447 Number of Boomerangs Easy 0450 Delete Node in a BST Medium 0451 Sort Characters By Frequency Easy 0454 4Sum II Medium 0455 Assign Cookies Easy 0474 Ones and Zeroes Medium 0494 Target Sum Medium 0496 Next Greater Element I Easy 0503 Next Greater Element II Medium 0525 Contiguous Array Medium 0560 Subarray Sum Equals K Medium 0704 Binary Search Easy 0705 Design HashSet Easy 0739 Daily Temperatures Medium 0852 Peak Index in a Mountain Array Easy 0901 Online-Stock-Span Medium 0907 Sum-of-Subarray-Minimums Medium 0917 Reverse Only Letters Easy 0918 Maximum Sum Circular Subarray Medium 0919 Complete Binary Tree Inserter Medium 0920 Number of Music Playlists Medium 0921 Minimum Add to Make Parentheses Valid Medium 0922 Sort Array By Parity II Easy 0923 3Sum With Multiplicity Medium 0925 Long Pressed Name Easy 0926 Flip String to Monotone Increasing Medium 0927 Three Equal Parts Medium 0929 Unique Email Addresses Easy 0930 Binary Subarrays With Sum Medium 0931 Minimum Falling Path Sum Medium 0932 Beautiful Array Medium 0933 Number of Recent Calls Easy 0934 Shortest Bridge Medium 0935 Knight Dialer Medium 0936 Stamping The Sequence Hard 0937 Reorder Log Files Easy 0938 Range Sum of BST Medium 0939 Minimum Area Rectangle Medium 0940 Distinct Subsequences II Hard 0941 Valid Mountain Array Easy 0942 DI String Match Easy 0943 Find the Shortest Superstring Hard 0944 Delete Columns to Make Sorted Easy 0945 Minimum Increment to Make Array Unique Medium 0946 Validate Stack Sequences Medium 0947 Most Stones Removed with Same Row or Column Medium 0948 Bag of Tokens Medium 0949 Largest Time for Given Digits Easy 0950 Reveal Cards In Increasing Order Medium 0951 Flip Equivalent Binary Trees Medium 0953 Verifying an Alien Dictionary Easy 0954 Array of Doubled Pairs Medium 0955 Delete Columns to Make Sorted II Medium 0956 Tallest Billboard Hard 0957 Prison Cells After N Days Medium 0958 Check Completeness of a Binary Tree Medium 0959 Regions Cut By Slashes Medium 0960 Delete Columns to Make Sorted III Hard 0961 N-Repeated Element in Size 2N Array Easy 0962 Maximum Width Ramp Medium 0963 Minimum Area Rectangle II Medium 0965 Univalued Binary Tree Easy 0966 Vowel Spellchecker Medium 0967 Numbers With Same Consecutive Differences Medium 0969 Pancake Sorting Medium 0970 Powerful Integers Easy 0971 Flip Binary Tree To Match Preorder Traversal Medium 0972 Equal Rational Numbers Hard 0973 K Closest Points to Origin Easy 0974 Subarray Sums Divisible by K Medium 0975 Odd Even Jump Hard 0976 Largest Perimeter Triangle Easy 0977 Squares of a Sorted Array Easy]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20. Valid Parentheses]]></title>
    <url>%2F2019%2F05%2F29%2F20.html</url>
    <content type="text"><![CDATA[有效的括号题目给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 注意空字符串可被认为是有效字符串。 示例 1: 输入: “()”输出: true示例 2: 输入: “()[]{}”输出: true示例 3: 输入: “(]”输出: false示例 4: 输入: “([)]”输出: false示例 5: 输入: “{[]}”输出: true java代码1234567891011121314151617181920212223242526272829303132333435/** * @description: 有效括号 * @author: rhsphere * @since: 2019-05-29 09:16 by jdk 1.8 */public class ValidParentheses &#123; static Map&lt;Character, Character&gt; map = new HahsMap&lt;&gt;(); static &#123; map.put('(', ')'); map.put('[', ']'); map.put('&#123;', '&#125;'); &#125; public static boolean isValid(String s) &#123; Stack&lt;Character&gt; stack = new Stack&lt;&gt;(); for (int i = 0; i &lt; s.lengt(); i++) &#123; char c = s.charAt(i); if (map.containsKey(c)) &#123; stack.push(map.get(c)); &#125; else if (map.containsValue(c)) &#123; if (stack.isEmpty() || stack.pop() != c) &#123; return false; &#125; &#125; &#125; return stack.isEmpty(); &#125; public static void main(String[] args) &#123; String s = "()[]&#123;&#125;"; boolean b = isValid(s); System.out.println(b); &#125;&#125;]]></content>
      <categories>
        <category>Easy</category>
      </categories>
      <tags>
        <tag>String</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SampleBrowser]]></title>
    <url>%2F2019%2F05%2F29%2Fsample-browser.html</url>
    <content type="text"><![CDATA[模拟实现浏览器的前进、后退功能浏览器的前进、后退功能。每次一次访问完一串页面a-b-c后，点击浏览器的后退按钮，就可以查看之前浏览过的页面b和a。当你后退到页面a，点击前进按钮，就可以重新查看页面b和c。但是，如果你后退到页面b后，点击了新的页面d，那就无法再通过前进、头腿功能查看页面c了。 现在来实现这个功能，使用链式栈，用backStack、currentPage、forwardStack来存储这些页面。 java代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153** * @description: 使用前后栈实现浏览器的前进后退 * @author: rhsphere * @since: 2019-05-28 19:55 by jdk 1.8 */public class SampleBrowser &#123; public static void main(String[] args) &#123; SampleBrowser browser = new SampleBrowser(); browser.open("http://www.baidu.com"); browser.open("http://news.baidu.com/"); browser.open("http://news.baidu.com/end"); browser.goBack(); browser.goBack(); browser.goForward(); browser.open("http://www.qq.com"); browser.goForward(); browser.goBack(); browser.goForward(); browser.goBack(); browser.goBack(); browser.goBack(); browser.goBack(); browser.checkCurrentPage(); &#125; private String currentPage; private LinkedListBasedStack backStack; private LinkedListBasedStack forwardStack; public SampleBrowser() &#123; this.bakcStack = new LinkedListBasedStack(); this.forwardStack = new LinkedListBasedStack(); &#125; public void open(String url) &#123; if (this.currentPage != null) &#123; this.backStack.push(this.currentPage); this.forwardStack.clear(); &#125; showUrl(url, "Open"); &#125; public boolean canGoBack() &#123; return this.backStack.size() &gt; 0; &#125; public boolean canGOForward() &#123; return this.forwardStack.size() &gt; 0; &#125; public String goBack() &#123; if (this.canGoBack()) &#123; this.forwardStack.push(this.currentPage); String backUrl = this.backStack.pop(); showUrl(backUrl, "Back"); return backUrl; &#125; System.out.println("* Cannot go back, no pages behind."); return null; &#125; public String goForward() &#123; if (this.canGoForward()) &#123; this.backStack.push(this.currentPage); String forwardUrl = this.forwardStack.pop(); showUrl(forwardUrl, "FOrward"); return forwardUrl; &#125; System.out.println("** Cannot go forward, no pages ahead."); return null; &#125; public void showUrl(String url, String prefix) &#123; this.currentPage = url; System.out.println(prefix + " page == " + url); &#125; public void checkCurrentPage() &#123; System.out.println("current Page is: " + this.currentPage); &#125; /** * 基于链表的栈 */ public static class LinkedListBasedStack &#123; private int size; private Node top; static Node createNode(String data, Node next) &#123; return new Node(data, next); &#125; public void clear() &#123; this.top = top; this.size = 0; &#125; public void push(String data) &#123; Node node = createNode(data, this.top); this.top = top; this.size++; &#125; public String pop() &#123; Node popNode = this.top; if (popNode == null) &#123; System.out.println("Stack is empty"); return null; &#125; this.top = popNode.next; if (this.size &gt; ) this.size--; return popNode.data; &#125; public String getTopData() &#123; if (this.top == null) return null; return this.top.data; &#125; public int size() &#123; return this.size; &#125; public void print() &#123; System.out.println("Print stack:"); Node cur = this.top; while (cur != null) &#123; String data = cur.getData(); Sustem.out.println(data + "\t"); cur = cur.next; &#125; System.out.println(); &#125; public static class Node&#123; private String data; private Node next; public Node(String data) &#123; this(datam null); &#125; public Node(String data, Node next) &#123; this.data= data; this.next = next; &#125; public void setData(String data) &#123; this.data = data; &#125; public String getData() &#123; return this.data; &#125; public void setNext(Node next) &#123; this.next = next; &#125; public Node getNext() &#123; return this.next; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Stack</category>
      </categories>
      <tags>
        <tag>Stack</tag>
        <tag>SampleBrowser</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LinkedStack && ArrayStack]]></title>
    <url>%2F2019%2F05%2F28%2Flinked-and-array-stack.html</url>
    <content type="text"><![CDATA[栈当某个数据集合致设计在一端插入和删除数据，并且满足后进先出、先进后出的特性，我们就应该首选“栈”这种数据结构。 栈主要包括两个操作，入栈和出栈，在栈顶插入一个数据和从栈顶删除一个数据。 栈既可以用数组来实现，也可以用链表来实现。用数组实现的栈，就做顺序栈，用链表实现的栈，叫链式栈。 不管是顺序栈还是链式栈，我们存储数据只需要一个大小为n的数组就够了。在入栈和出栈过程中，只需要一两个临时变量存储空间，所以空间复杂度是O(1)。 注意，这里存储数据需要一个大小为n的数组，并不是说空间复杂度就是O(n)。因为这个空间是必须的，无法省掉。所以我们说空间复杂度的时候，是指除了原本的数据存储空间外，算法运行还需要额外的存储空间。 栈的一些应用： 栈在函数调用中的应用 栈在表达式求值中的应用 栈在括号匹配中的应用 关于用函数调用栈来保存临时变量，为什么函数调用要用“栈”来保存变量呢？用其他数据结构不行吗？ 解答： 其实，不一定非要栈来保存临时变量，只不过如果这个函数调用符合后进先出的特性，用栈这种数据结构来实现，是最顺理成章的选择。 从调用函数进入被调用函数，对于数据来说，变化的是什么？是作用域。所以根本上，只要能保证每进入一个新的函数，都是一个新的作用域就可以。而要实现这个，用栈就非常方便。在进入被调用函数的时候，分配一段栈空间给这个函数的变量，在函数结束的时候，将栈顶复位，正好回到调用函数的作用域内。 数组实现顺序栈支持动态扩容的顺序栈，底层依赖一个支持动态扩容的数组就可以了。当栈满了，就申请一个更大的数组，将原来的数据搬移到新数组中。 实际上，支持动态扩容的顺序栈，平时开发并不常用到。出栈的时间复杂度是O(1)，那入栈操作的 均摊时间复杂度是O(1)。 关于分析，参考极客时间08|栈 数组实现栈的代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package Stack;import java.util.*;/** * @description: 数组实现栈，使用支持动态调整数组大小的泛型数组 * @author: rhsphere * @since: 2019-05-28 16:43 by jdk 1.8 */public class ArrayStack&lt;E&gt; implements Iterable&lt;E&gt; &#123; private E[] arr; private int n; public ArrayStack()&#123; arr = (E[]) new Object[2]; n = 0; &#125; public boolean isEmpty() &#123; return n == 0; &#125; public int size() &#123; return n; &#125; private void resize(int capacity) &#123; assert capacity &gt;= 0; E[] tmp = (E[]) new Object[capacity]; for (int i = 0; i &lt; n; i++) &#123; tmp[i] = arr[i]; &#125; arr = tmp; &#125; public void push(E e) &#123; if (n == arr.length) resize(2 * arr.length); arr[n++] = e; &#125; public E pop() &#123; if (isEmpty()) throw new NoSuchElementException("Stack underflow"); E e = arr[n - 1]; arr[n - 1] = null; n--; if (n &gt; 0 &amp;&amp; n == arr.length / 4) resize(arr.length / 2); return e; &#125; public E peek() &#123; if (isEmpty()) throw new NoSuchElementException("Stack underflow"); return arr[n - 1]; &#125; public Iterator&lt;E&gt; iterator() &#123; return new ArrayIterator(); &#125; // 这里写ArrayIterator&lt;E&gt; 会报错是为什么？？？ private class ArrayIterator implements Iterator&lt;E&gt; &#123; private int i; public ArrayIterator() &#123; i = n - 1; &#125; public boolean hasNext() &#123; return i &gt;= 0; &#125; public void remove() &#123; throw new UnsupportedOperationException(); &#125; public E next() &#123; if (!hasNext()) throw new NoSuchElementException(); return arr[i--]; &#125; &#125;&#125; 链表实现链式栈思路 用链表结点存储栈顶top节点，存储链表长度 实现isEmpty()方法、size()方法 push()用增加的节点作为头节点 链表实现栈的代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104package Stack;import java.util.*;/** * @description: 实现链表栈，使用泛型的单链表 * @author: rhsphere * @since: 2019-05-28 15:57 by jdk 1.8 */public class LinkedStack&lt;E&gt; implements Iterable&lt;E&gt; &#123; //栈顶节点top和栈的大小 private Node&lt;E&gt; top; private int n; //内部静态类，因为不用接触类的任何实例对象和方法 //外部类可以访问内部类的private/protected变量，就像访问自己的private/protected变量一样. private static class Node&lt;E&gt; &#123; private E e; private Node&lt;E&gt; next; &#125; //构造一个空的stack public LinkedStack() &#123; top = null; n = 0; &#125; //判断栈顶结点是不是null public boolean isEmpty() &#123; return top == null; &#125; public int size() &#123; return n; &#125; /** * 添加一个元素 * @param e 待添加的元素 */ public void push(E e) &#123; Node&lt;E&gt; oldTop = top; top = new Node&lt;E&gt;(); top.e = e; top.next = oldTop; n++; &#125; /** * 删除并返回最近添加的元素 * @return 最近添加的元素 * @throws NoSuchElementException 如果栈为空 */ public E pop() &#123; if (isEmpty()) throw new NoSuchElementException("LinkedStack underflow"); E e = top.e; top = top.next; n--; return e; &#125; /** * 返回但不移除最近添加的栈顶元素 * @return 最近添加的元素 * @throws NoSuchElementException 如果栈为空 */ public E peek() &#123; if (isEmpty()) throw new NoSuchElementException("LinkedStack underflow"); return top.e; &#125; //foreach的写法是因为LinkedStack的对象实现了Iterable接口 public String toString() &#123; StringBuilder sb = new StringBuilder(); for (E e : this) &#123; sb.append(e); sb.append(' '); &#125; return sb.toString(); &#125; /** * 返回一个以LIFO顺序遍历栈元素的迭代器 * @return 一个以LIFO顺序遍历栈元素的迭代器 */ public Iterator&lt;E&gt; iterator() &#123; return new ListIterator&lt;E&gt;(top); &#125; private class ListIterator&lt;E&gt; implements Iterator&lt;E&gt; &#123; private Node&lt;E&gt; cur; public ListIterator(Node&lt;E&gt; top) &#123; cur = top; &#125; public boolean hasNext() &#123; return cur != null; &#125; public void remove() &#123; throw new UnsupportedOperationException(); &#125; public E next() &#123; if (!hasNext()) throw new NoSuchElementException("LinkedStack underflow"); E e = cur.e; cur = cur.next; return e; &#125; &#125;&#125; 顺序和链式栈测试代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package Stack;/** * @description: * @author: rhsphere * @since: 2019-05-28 16:28 by jdk 1.8 */public class TestStack &#123; public static void main(String[] args) &#123; System.out.println("==========测试ArrayStack=========="); LinkedStack&lt;String&gt; stack = new LinkedStack&lt;String&gt;(); stack.push("! "); stack.push("world"); stack.push(", "); stack.push("Hello"); stack.push("Hi. "); System.out.println("栈顶元素是：" + stack.peek()); // 使用foreach遍历栈元素 for(String s : stack) System.out.print(s); System.out.println(); while (!stack.isEmpty()) &#123; System.out.print(stack.pop()); &#125; System.out.println("\n(now " + stack.size() + " left on linked stack)"); System.out.println("==========测试ArrayStack=========="); ArrayStack&lt;String&gt; arrStack = new ArrayStack&lt;String&gt;(); arrStack.push("! "); arrStack.push("world"); arrStack.push(", "); arrStack.push("Goodbye"); arrStack.push("woo. "); System.out.println("栈顶元素是：" + arrStack.peek()); // 使用foreach遍历栈元素 for(String s : arrStack) System.out.print(s); System.out.println(); while (!arrStack.isEmpty()) &#123; System.out.print(arrStack.pop()); &#125; System.out.println("\n(now " + arrStack.size() + " left on array stack)"); &#125;&#125;]]></content>
      <categories>
        <category>Sum-up</category>
      </categories>
      <tags>
        <tag>Stack</tag>
        <tag>LinkedStack</tag>
        <tag>ArrayStack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LinkedList(链表)]]></title>
    <url>%2F2019%2F05%2F28%2Flinkedlist-sum-up.html</url>
    <content type="text"><![CDATA[LinkedList(链表)Last Modified: 2019/5/28 09:24 by dp 01. Reverse Linked List（反转链表） 02. Linked List Cycley Ⅰ（检测链表是否有环Ⅰ） 03. Linked List Cycley Ⅱ（检测链表是否有环Ⅱ） 04. Merge Two Sorted Lists（合并两个有序链表） 05. Reverse Nodes in k-Group（以 k 为一组反转链表） 06. Remove Nth Node From End of List（删除链表的倒数第N个节点） 07. Middle of the Linked List（链表的中间节点） 08. Merge k Sorted Lists（合并 k 个排序链表）]]></content>
      <categories>
        <category>Sum-up</category>
      </categories>
      <tags>
        <tag>Linked List</tag>
        <tag>Sum-up</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[23. Merge k Sorted Lists]]></title>
    <url>%2F2019%2F05%2F28%2F23.html</url>
    <content type="text"><![CDATA[合并 k 个排序链表题目合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。 示例: 输入:[ 1-&gt;4-&gt;5, 1-&gt;3-&gt;4, 2-&gt;6]输出: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6 java代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * @description: 采用merge算法，一次合并两个 * @author: rhsphere * @since: 2019-05-28 08:32 by jdk 1.8 */public class MergeKLists &#123; public ListNode mergeKLists(ListNode[] lists) &#123; return mergeKLists(lists, 0, list.length - 1); &#125; private ListNode mergeKLists(ListNode[] listNodes, int start, int end) &#123; if (start &gt; end) return null; if (start == end) return listNodes[start]; mid = start + ((end - start) &gt;&gt; 1); ListNode p = mergeKLists(listNodes, start, mid); ListNode q = mergeKLists(listNodes, mid + 1, end); ListNode res = merge(p, q); return res; &#125; public ListNode merge(ListNode p, ListNode q) &#123; ListNode head = new ListNode(0); ListNode r = head; while (true) &#123; if (p == null &amp;&amp; q == null) &#123; break; &#125; else if(p != null &amp;&amp; (q == null || p.val &lt;= q.val)) &#123; r.next = p; p = p.next; &#125; else if (p == null || q.val &lt; p.val) &#123; r.next = q; q = q.next; &#125; r = r.next; &#125; return head.next; &#125; public class ListNode &#123; int val; ListNode next; ListNode(int val) &#123; this.val = val; &#125; &#125;&#125; 总结失误的地方 else if(p != null &amp;&amp; (q == null || p.val &lt;= q.val)) 条件中少了判等， 写成了p.val &lt; q.val。 mergeKLists(ListNode[] listNodes, int start, int end) start和end的形参类型写成了ListNode 这题就是归并排序的衍生，理解归并排序，就能理解这里面的递归调用。]]></content>
      <categories>
        <category>Hard</category>
      </categories>
      <tags>
        <tag>Linked List</tag>
        <tag>Divide and Conquer</tag>
        <tag>Heap</tag>
        <tag>MergeSort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[876. Middle of the Linked List]]></title>
    <url>%2F2019%2F05%2F28%2F876.html</url>
    <content type="text"><![CDATA[链表的中间节点题目给定一个带有头结点 head 的非空单链表，返回链表的中间结点。 如果有两个中间结点，则返回第二个中间结点。 示例 1： 输入：[1,2,3,4,5]输出：此列表中的结点 3 (序列化形式：[3,4,5])返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。注意，我们返回了一个 ListNode 类型的对象 ans，这样：ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, 以及 ans.next.next.next = NULL.示例 2： 输入：[1,2,3,4,5,6]输出：此列表中的结点 4 (序列化形式：[4,5,6])由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。 提示： 给定链表的结点数介于 1 和 100 之间。 思路头结点误导人 快慢指针： 1.慢指针一次走一步，快指针一次走2步，快指针走到末端，慢指针正好指向中间结点； 2.这里分两种情况： 快指针的next为null，慢指针正好指向中间结点，链表结点数为偶数；快指针为null，慢指针正好指向第二个中间结点，链表结点数为奇数； java代码12345678910111213141516171819202122232425262728293031/** * @description: 快慢指针，找到链表的中间节点 * @author: rhsphere * @since: 2019-05-28 08:02 by jdk 1.8 */public class MiddleNode &#123; public static ListNode middleNode(ListNode head) &#123; // 如果没有头结点 //if (head == null) return head; ListNode fast = head, slow = head; //while (fast.next != null &amp;&amp; fast.next.next != null) &#123; while (fast != null &amp;&amp; fast.next != null) &#123; fast = fast.next.next; slow = slow.next; &#125; return slow; &#125; public static class ListNode&#123; int val; ListNode next; public ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Easy</category>
      </categories>
      <tags>
        <tag>Linked List</tag>
        <tag>Two Pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[19. Remove Nth Node From End of List]]></title>
    <url>%2F2019%2F05%2F27%2F19.html</url>
    <content type="text"><![CDATA[删除链表的倒数第N个节点题目给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。 示例： 给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2. 当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.说明： 给定的 n 保证是有效的。 进阶： 你能尝试使用一趟扫描实现吗？ 思路使用fast指针先远离头结点 n-1 的位置，然后slow指针和fast再同时移动到链表尾部，此时slow指针的位置就是倒数第n个节点，提前保存slow的prev节点，然后prev.next = prev.next.next即可完成任务。 注意： 链表为空的情况； 链表只有一个元素的情况 java代码1234567891011121314151617181920212223242526272829303132333435363738/** * @description: * @author: rhsphere * @since: 2019-05-27 20:45 by jdk 1.8 */public class RemoveNthFromEnd &#123; public static ListNode removeNthFromEnd(ListNode head, int n) &#123; ListNode fast = head; int i = 1; while (fast != null &amp;&amp; i &lt; n) &#123; fast = fast.next; i++; &#125; //链表为空 if (fast == null) return head; ListNode slow = head, prev = null; while (fast.next != null) &#123; fast = fast.next; prev = slow; slow = slow.next; &#125; //链表只有一个元素 if (prev == null) head = head.next; else prev.next = prev.next.next; return head; &#125; private static class ListNode&#123; int val; ListNode next; ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Medium</category>
      </categories>
      <tags>
        <tag>Linked List</tag>
        <tag>Two Pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[25. Reverse Nodes in k-Group]]></title>
    <url>%2F2019%2F05%2F27%2F25.html</url>
    <content type="text"><![CDATA[k 个一组翻转链表题目给出一个链表，每 k 个节点一组进行翻转，并返回翻转后的链表。 k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么将最后剩余节点保持原有顺序。 示例 : 给定这个链表：1-&gt;2-&gt;3-&gt;4-&gt;5 当 k = 2 时，应当返回: 2-&gt;1-&gt;4-&gt;3-&gt;5 当 k = 3 时，应当返回: 3-&gt;2-&gt;1-&gt;4-&gt;5说明 : 你的算法只能使用常数的额外空间。 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 java代码思路见注释 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * @description: * @author: rhsphere * @since: 2019-05-27 20:10 by jdk 1.8 */public class ReverseKGroup &#123; public ListNode reverseKGroup(ListNode head, int k) &#123; //计数器 int length = 0; //当前组头结点 ListNode r = head; //遍历剩余链表,用计数器记录,每当链表还满足长度&gt;=k,则终止操作 while (r != null &amp;&amp; length != k) &#123; r = r.next; length++; &#125; //如果长度 == k,说明当前剩余链表长度&gt;=k,还可以再分组 if (length == k) &#123; //对于剩余链表调用自身函数再进行分组,直至剩余长度不足k为止 //用tail 接受此组的下一组反转完成之后的新头结点 ListNode pre = reverseKGroup(r, k); //对于此组的节点进行指向反转 while (k-- &gt; 0) &#123; ListNode next = head.next; head.next = pre; pre = head; head = next; &#125; //值得注意的是:当上述的while循环结束的时候,head 指向的已经是下一组的原头结点了,所以 //不要直接返回head //应该返回head 的上一个元素 ,如上面用pre记录了. return pre; &#125; //如果长度不满足k,则剩余链表不需要进行任何操作,直接返回剩余链表的头结点即可. return head; &#125; private static class ListNode&#123; int val; ListNode next; ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; &#125;&#125; 总结 while(k– &gt; 0)的循环体内就是 反转链表的代码，这里reverse节点是下一组链表的头结点。]]></content>
      <categories>
        <category>Hard</category>
      </categories>
      <tags>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[21. Merge Two Sorted Lists]]></title>
    <url>%2F2019%2F05%2F27%2F21.html</url>
    <content type="text"><![CDATA[合并两个有序链表题目将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例： 输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 java代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748** * @description: 合并两个有序链表 * @author: rhsphere * @since: 2019-05-27 19:41 by jdk 1.8 */public class MergeSortedLists &#123; public static ListNode mergeSortedLists(ListNode la, ListNode lb) &#123; if (la == null) return lb; if (lb == null) return la; ListNode p = la, q = lb, head; if (p.val &lt; q.val) &#123; head = p; p = p.next; &#125; else &#123; head = q; q = q.next; &#125; ListNode r = head; while (p != null &amp;&amp; q != null) &#123; if (p.val &lt; q.val) &#123; r.next = p; p = p.next; &#125; else &#123; r.next = q; q = q.next; &#125; r = r.next; &#125; if (p != null) &#123; r.next = p; &#125; else &#123; r.next = q; &#125; return head; &#125; public static class ListNode&#123; int val; ListNode next; public ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; &#125;&#125; 总结脑袋要清楚知道指针是如何移动的！]]></content>
      <categories>
        <category>Easy</category>
      </categories>
      <tags>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[141. Linked List Cycle 1]]></title>
    <url>%2F2019%2F05%2F27%2F141.html</url>
    <content type="text"><![CDATA[环形链表Ⅰ题目给定一个链表，判断链表中是否有环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。 示例 1：输入：head = [3,2,0,-4], pos = 1输出：true解释：链表中有一个环，其尾部连接到第二个节点。 示例 2：输入：head = [1,2], pos = 0输出：true解释：链表中有一个环，其尾部连接到第一个节点。 示例 3：输入：head = [1], pos = -1输出：false解释：链表中没有环。 进阶：你能用 O(1)（即，常量）内存解决此问题吗？ 思路 如果链表中没有环，则fast指针最终将到达终点，返回false； 对于环形链表，fast和slow指针是两个围绕跑道的跑者。 快速跑步者最终会遇到慢跑者。 为什么？ 考虑这种情况（将其命名为情形A） ： 快速跑步者仅仅是慢跑者的一步。 在下一次迭代中，它们分别增加一步和两步并相互会合。 例如，我们还没有考虑过快速跑步者落后慢跑者两到三步的情况。 这很简单，因为在下一次或下次的下一次迭代中，这种情况将简化为上面的情形A。 证明方法采用了，归纳法。 java代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * @description: * @author: rhsphere * @since: 2019-05-27 18:06 by jdk 1.8 */public class HasCycle &#123; public static boolean hasCycle(ListNode head) &#123; if (head == null) return false; ListNode fast = head.next; ListNode slow = head; // while (fast != null &amp;&amp; slow != null) &#123; // 错误示范 while (fast != null &amp;&amp; fast.next != null) &#123; fast = fast.next.next; slow = slow.next; if (fast == slow) &#123; return true; &#125; &#125; return false; &#125; private static class ListNode&#123; int val; ListNode next; ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; &#125; public static void main(String[] args) &#123; ListNode head = new ListNode(3, null); ListNode second = new ListNode(2, null); ListNode third = new ListNode(0, null); ListNode fourth = new ListNode(-4, null); head.next = second; second.next = third; third.next = fourth; fourth.next = second; boolean hasCycle = hasCycle(head); System.out.println(hasCycle); &#125;&#125; 总结 错误示范 while (fast != null &amp;&amp; slow != null) {]]></content>
      <categories>
        <category>Easy</category>
      </categories>
      <tags>
        <tag>Linked List</tag>
        <tag>Two Pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[142. Linked List Cycle 2]]></title>
    <url>%2F2019%2F05%2F27%2F142.html</url>
    <content type="text"><![CDATA[环形链表Ⅱ题目给定一个链表，判断链表中是否有环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。说明：不允许修改给定的链表。 示例 1： 输入：head = [3,2,0,-4], pos = 1输出：tail connects to node index 1解释：链表中有一个环，其尾部连接到第二个节点。 示例 2： 输入：head = [1,2], pos = 0输出：tail connects to node index 0解释：链表中有一个环，其尾部连接到第一个节点。 示例 3： 输入：head = [1], pos = -1输出：no cycle解释：链表中没有环。 进阶：你能用 O(1)（即，常量）内存解决此问题吗？ 思路分两个步骤，首先通过快慢指针的方法判断链表是否有环；接下来如果有环，则寻找入环的第一个节点。 具体的方法为，首先假定链表起点到入环的第一个节点A的长度为a【未知】，到快慢指针相遇的节点B的长度为（a + b）【这个长度是已知的】。 现在我们想知道a的值，注意到快指针 fast 始终是慢指针 slow 走过长度的2倍，所以慢指针 slow 从B继续走（a + b）又能回到B点，如果只走a个长度就能回到节点A。 但是a的值是不知道的，解决思路是曲线救国，注意到起点到A的长度是a，那么可以用一个从起点开始的新指针head和从节点B开始的慢指针slow同步走，相遇的地方必然是入环的第一个节点A。 画个图就一目了然了~ java代码12345678910111213141516171819202122232425262728293031323334353637/** * @description: 链表有环，返回节点 * @author: rhsphere * @since: 2019-05-27 18:58 by jdk 1.8 */public class DetectCycle &#123; public ListNode detectCycle(ListNode head) &#123; if (head == null || head.next == null) return null; ListNode slow = head; ListNode fast = head; while (fast != null &amp;&amp; fast.next != null) &#123; fast = fast.next.next; slow = slow.next; if (fast == slow) &#123; while (head != fast) &#123; fast = fast.next; head = head.next; &#125; return head; &#125; &#125; return null; &#125; private static class ListNode&#123; int val; ListNode next; ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Medium</category>
      </categories>
      <tags>
        <tag>Linked List</tag>
        <tag>Two Pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[206. Reverse Linked List]]></title>
    <url>%2F2019%2F05%2F27%2F206.html</url>
    <content type="text"><![CDATA[反转链表题目反转一个单链表。 示例: 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL进阶: 你可以迭代或递归地反转链表。你能否用两种方法解决这道题？ 思路有很多种写法：1）迭代方式的解答为了完成这个任务，需要记录链表中三个连续的节点：reverse、head、second。在每一轮迭代中，从原始链表中提取节点head并将它插入到逆链表的开头。我们需要一直保持head指向原链表中所有剩余节点的首节点，second指向原链表中所有剩余节点的第二个节点，reverse指向结果链表中的首节点。 2）假设链表有N个节点，首先递归颠倒最后N-1个节点，然后小心地将原链表的首节点插入到结果链表的末端。 java代码迭代和递归写法，见代码注释。 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * @description: 反转一个链表 * @author: rhsphere * @since: 2019-05-27 16:32 by jdk 1.8 */public class ReverseLinkedList &#123; //迭代解法 public static ListNode reverse(ListNode head) &#123; ListNode reverse = null; while (head != null) &#123; ListNode second = head.next; head.next = reverse; reverse = head; head = second; &#125; return reverse; &#125; //递归解法 public static ListNode reverseRecursive(ListNode head) &#123; if (head == null) return head; if (head.next == null) return head; ListNode second = head.next; ListNode res = reverseRecursive(second); second.next = head; head.next = null; return res; &#125; private class ListNode&#123; private int val; private ListNode next; public ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; public int getData() &#123;return val;&#125; &#125;&#125; 总结 编写和链表相关的代码时，必须要小心处理异常情况（链表为空或是只有一个或两个节点）和边界情况（处理首尾节点）。这些情况通常更加需，要画图等手段来看清楚指针变化。]]></content>
      <categories>
        <category>Easy</category>
      </categories>
      <tags>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Array&&GenericArray]]></title>
    <url>%2F2019%2F05%2F27%2Farray-and-genericarray.html</url>
    <content type="text"><![CDATA[自己实现动态数组： 实现一个大小固定的有序数组，支持动态增删改操作 实现一个支持动态扩容的泛型数组 大小固定的有序数组，支持动态增删改操作12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/** * @description: 实现一个大小国定的有序数组，支持动态增删改操作。 * 1)数组的插入、删除、按照下标随机访问操作； * 2）数组中的数据是int类型的。 * @author: rhsphere * @since: 2019-05-27 10:21 by jdk 1.8 */public class Array &#123; //定义整型数据data保存数据 public int data[]; //定义数组长度 private int n; //定义实际中的个数 private int count; //构造方法，定义数组大小 public Array(int capacity) &#123; this.data = new int[capacity]; this.n = capacity; this.count = 0; //初始化后没有存数 &#125; //根据索引找到数据中的元素并返回 public int find(int index) &#123; if (index &lt; 0 || index &gt;= count) return -1; return data[index]; &#125; //插入元素，尾部插入 public boolean insert(int index, int value) &#123; // 数组空间已满 if (count == n) &#123; System.out.println("没有可插入的位置"); return false; &#125; // 如果count还没满，那么就可以插入数据到数组中 // 位置不合法 if (index &lt; 0 || index &gt; count) &#123; System.out.println("位置不合法"); return false; &#125; //位置合法 for (int i = count; i &gt; index; --i) &#123; data[i] = data[i - 1]; &#125; data[index] = value; ++count; return true; &#125; //根据索引，删除数组中元素 public boolean delete(int index) &#123; if (index &lt; 0 || index &gt;= count) return false; //从删除位置开始，将后面的元素向前移动一位 for (int i = index + 1; i &lt; count; i++) &#123; data[i - 1] = data[i]; &#125; count--; return true; &#125; public void printAll() &#123; for (int i = 0; i &lt; count; i++) &#123; System.out.print(data[i] + " "); &#125; System.out.println(); &#125; public static void main(String[] args) &#123; Array arr = new Array(5); arr.printAll(); arr.insert(0, 3); arr.insert(0, 4); arr.insert(1, 5); arr.insert(3, 9); arr.insert(3, 10); arr.printAll(); &#125;&#125; 支持动态扩容的泛型数组123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168/** * @description: 实现一个支持动态扩容的泛型数组 * @author: rhsphere * @since: 2019-05-27 10:43 by jdk 1.8 */public class GenericArray&lt;T&gt; &#123; private T[] data; private int size; // 根据传入容量，构造Array public GenericArray(int capacity) &#123; data = (T[]) new Object[capacity]; size = 0; &#125; // 无参构造方法，默认数组容量为10 public GenericArray() &#123; this(10); &#125; // 获取数组容量 public int getCapacity() &#123; return data.length; &#125; // 获取当前元素个数 public int count() &#123; return size; &#125; // 判断数组是否为空 public boolean isEmpty() &#123; return size == 0; &#125; // 修改 index 位置的元素 public void set(int index, T e) &#123; checkIndex(index); data[index] = e; &#125; // 获取对应 index 位置的元素 public T get(int index) &#123; checkIndex(index); return data[index]; &#125; // 查看数组是否包含元素e public boolean contains(T e) &#123; for (int i = 0; i &lt; size; i++) &#123; if (data[i].equals(e)) &#123; return true; &#125; &#125; return false; &#125; // 获取对应元素的下标, 未找到，返回 -1 public int find(T e) &#123; for ( int i = 0; i &lt; size; i++) &#123; if (data[i].equals(e)) &#123; return i; &#125; &#125; return -1; &#125; // 在 index 位置，插入元素e, 时间复杂度 O(m+n) public void add(int index, T e) &#123; checkIndex(index); // 如果当前元素个数等于数组容量，则将数组扩容为原来的2倍 if (size == data.length) &#123; resize(2 * data.length); &#125; for (int i = size - 1; i &gt;= index; i--) &#123; data[i + 1] = data[i]; &#125; data[index] = e; size++; &#125; // 向数组头插入元素 public void addFirst(T e) &#123; add(0, e); &#125; // 向数组尾插入元素 public void addLast(T e) &#123; add(size, e); &#125; // 删除 index 位置的元素，并返回 public T remove(int index) &#123; checkIndexForRemove(index); T ret = data[index]; for (int i = index + 1; i &lt; size; i++) &#123; data[i - 1] = data[i]; &#125; size --; data[size] = null; // 缩容 if (size == data.length / 4 &amp;&amp; data.length / 2 != 0) &#123; resize(data.length / 2); &#125; return ret; &#125; // 删除第一个元素 public T removeFirst() &#123; return remove(0); &#125; // 删除末尾元素 public T removeLast() &#123; return remove(size - 1); &#125; // 从数组中删除指定元素 public void removeElement(T e) &#123; int index = find(e); if (index != -1) &#123; remove(index); &#125; &#125; @Override public String toString() &#123; StringBuilder builder = new StringBuilder(); builder.append(String.format("Array size = %d, capacity = %d \n", size, data.length)); builder.append('['); for (int i = 0; i &lt; size; i++) &#123; builder.append(data[i]); if (i != size - 1) &#123; builder.append(", "); &#125; &#125; builder.append(']'); return builder.toString(); &#125; // 扩容方法，时间复杂度 O(n) private void resize(int capacity) &#123; T[] newData = (T[]) new Object[capacity]; for (int i = 0; i &lt; size; i++) &#123; newData[i] = data[i]; &#125; data = newData; &#125; private void checkIndex(int index) &#123; if (index &lt; 0 || index &gt; size) &#123; throw new IllegalArgumentException("Add failed! Require index &gt;=0 and index &lt;= size."); &#125; &#125; private void checkIndexForRemove(int index) &#123; if(index &lt; 0 || index &gt;= size) &#123; throw new IllegalArgumentException("remove failed! Require index &gt;=0 and index &lt; size."); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Sum-up</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>GenericArray</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Array(数组)]]></title>
    <url>%2F2019%2F05%2F27%2Farrays-in-leetcode.html</url>
    <content type="text"><![CDATA[Array(数组)Last Modified: 2019/5/27 11:09 by dp 01. Two Sum（两数之和） 02. Three Sum（三数之和） 03. Majority Element（在数组中出现次数超过一半的数） 04. FizzBuzz（3 和 5 的倍数） 05. Merge Sorted Array（合并两个有序数组） 06. First Missing Positive（寻找缺失的最小正数） 07. Kth Largest Element in an Array（查找第K大的数） 08. Single Number（数组中只出现一次的数） 09. Find All Duplicates in an Array（数组中重复的数字） 10. 实现动态数组（泛型）]]></content>
      <categories>
        <category>Sum-up</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Sum-up</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[442. Find All Duplicates in an Array]]></title>
    <url>%2F2019%2F05%2F27%2F442.html</url>
    <content type="text"><![CDATA[数组中重复的数据题目给定一个整数数组 a，其中1 ≤ a[i] ≤ n （n为数组长度）, 其中有些元素出现两次而其他元素出现一次。 找到所有出现两次的元素。 你可以不用到任何额外空间并在O(n)时间复杂度内解决这个问题吗？ 示例： 输入:[4,3,2,7,8,2,3,1] 输出:[2,3] 思路 元素的值在不超过数组的长度，我们遍历数组，将元素值映射的下标改为负数，当遇到负数时，说明该元素下标映射的值已经出现过了。 和41. First Missing Positive中取负值的思路差不多，但是方法略有不同，所以不要死记硬背！ java代码1234567891011121314151617181920212223242526272829/** * @description: 元素的值在不超过数组的长度，遍历数组将元素映射的下标改成负数，当遇到负数时，说明该元素下标映射的值已经出现过了 * @author: rhsphere * @since: 2019-05-27 09:30 by jdk 1.8 */public class FindAllDuplicates &#123; public static List&lt;Integer&gt; findDuplicates(int[] nums) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); if (nums.length &lt;= 0) return list; for (int i = 0; i &lt; nums.length; i++) &#123; int v = Math.abs(nums[i]); if (nums[v - 1] &gt; 0) &#123; nums[v - 1] *= -1; &#125; else &#123; list.add(Math.nums[i]); &#125; &#125; return list; &#125; public static void main(String[] args) &#123; int[] arr = &#123;4,3,2,7,8,2,3,1&#125;; List&lt;Integer&gt; list = findDuplicates(arr); System.out.println(list); &#125;&#125;]]></content>
      <categories>
        <category>Medium</category>
      </categories>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[136. Single Number]]></title>
    <url>%2F2019%2F05%2F27%2F136.html</url>
    <content type="text"><![CDATA[数组中只出现一次的数题目给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 说明： 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？ 示例 1: 输入: [2,2,1]输出: 1示例 2: 输入: [4,1,2,1,2]输出: 4 java代码1234567891011121314151617181920212223/** * @description: 异或操作最秀的用法了 * @author: rhsphere * @since: 2019-05-27 09:06 by jdk 1.8 */public class SingleNumber &#123; public static int singleNumber(int[] nums) &#123; int ans = 0; /* for (int i : nums) ans ^= i; */ for (int i = 0; i &lt; nums.length; i++) ans ^= nusm[i]; return ans; &#125; public static void main(String[] args) &#123; int[] arr = &#123;4,1,2,1,2&#125;; int a = singleNumber(arr); System.out.println(a); &#125;&#125; 总结 由于题目原因，用异或太简单了，但是foreach比正常for循环执行速度要慢很多]]></content>
      <categories>
        <category>Easy</category>
      </categories>
      <tags>
        <tag>Hash Table</tag>
        <tag>Bit Manipulation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[215. Kth Largest Element in an Array]]></title>
    <url>%2F2019%2F05%2F27%2F215.html</url>
    <content type="text"><![CDATA[数组中的第K个最大元素题目在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。 示例 1: 输入: [3,2,1,5,6,4] 和 k = 2输出: 5示例 2: 输入: [3,2,3,1,2,4,5,5,6] 和 k = 4输出: 4说明: 你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。 java代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * @description: 用快排的思想，partition函数 * @author: rhsphere * @since: 2019-05-26 10:49 by jdk 1.8 */public class KthLarget &#123; public static int findKthLargest(int[] nums, int k) &#123; int start = 0; int end = nums.length - 1; int index = nums.length - 1; while (start &lt; end) &#123; int pivotIndex = partition(nums, start, end); if (pivotIndex &lt; index) &#123; start = pivotIndex + 1; &#125; else if (pivotIndex &gt; index) &#123; end = startIndex - 1; &#125; else &#123; return nums[pivotIndex]; &#125; &#125; return nums[start]; &#125; private static int partition(int[] nums, int start, int end) &#123; int pivot = nums[start]; int mark = start; for (int i = start + 1; i &lt;= end; i++) &#123; if (nums[i] &lt; pivot) &#123; mark++; int tmp = nums[i]; nums[i] = nums[mark]; nums[mark] = tmp; &#125; &#125; nums[start] = nums[mark]; nums[mark] = pivot; return mark; &#125; public static void main(String[] args) &#123; int[] arr = &#123;3,2,1,5,6,4&#125;; int a = findKthLargest(arr, 2); System.out.println(a); &#125;&#125; 总结 应用了快排中partition的函数，参看partition函数的单边循环法 这种方法在提交时，运行时间效果不是很好，不知道有什么可以改进的地方吗? partition单边循环时，可以用一个数组（4 7 6 5 3 2 8 1）演示一下就知道怎么写了]]></content>
      <categories>
        <category>Medium</category>
      </categories>
      <tags>
        <tag>Divide and Conquer</tag>
        <tag>Heap</tag>
        <tag>Quick Sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[41. First Missing Positive]]></title>
    <url>%2F2019%2F05%2F25%2F41.html</url>
    <content type="text"><![CDATA[缺失的第一个正数题目给定一个未排序的整数数组，找出其中没有出现的最小的正整数。 示例 1: 输入: [3,4,-1,1]输出: 2示例 3: 输入: [7,8,9,11,12]输出: 1说明: 你的算法的时间复杂度应为O(n)，并且只能使用常数级别的空间。 思路整个的思路就是把nums[i]存储的数放到，下标为nums[i]的位置，处理小于等于0和大于数组长度的nums[i]，交换nums[i]到下标nums[i]是做一下取负值处理，离开的位置i不做处理，把整个数组处理一遍后，遍历数组找到第一个正数所对应的位置，就是第一个缺失的正数。 和剑指offer中3. 数组中重复中的数字差不多，数组存储的数（长度范围内）放在对应下标的位置，离开的位置保持不变，如果没有人填回来说明这个位置空缺，这是只要遍历一次数组，找到第一个空缺的位置就是第一个缺失的正数。 缺失的位置巧妙的用数组的0、1来辅助，先判断是否有1，如果有1那这个位置就可以拿出来放 数组中存储的不在长度范围内的数，把这些数置为1， 如果说这个数离开现在的位置，到nums[i]的位置（比如数组长度6， i = 3, nums[i] = 4, nums[i]去填到i = 4的位置），把这个数变成负数，所以这种方法，最后统计有多少正数，还能统计在数组范围内缺失多少正数。 java代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class FindMissingPositive &#123; public static int findMissingPositive(int[] nums) &#123; //1. 判断1是否存在 int n = nums.length; boolean isOneExists = false; for (int i : nums) &#123; // foreach语句出错，错成nums[i] == 1 if (i == 1) isOneExists = true; &#125; if (!isOneExists) return 1; // n == 2判断出错 if (n == 1) return 2; //2. 因为上面判断出1存在的（否则程序结束了），所以可以借用数组下标为1的位置， // 存放不在数组长度范围内的数（小于0和大于数组长度的），将值设置为1，等下在搬移时 //会一直搬移到下标为1的位置进行覆盖 for (int i = 0; i &lt; n; i++) &#123; if (nums[i] &lt;= 0 || nums[i] &gt; n) nums[i] = 1; &#125; //3. 把数组长度内的数都给置为负值， for (int i = 0; i &lt; n; i++) &#123; int v = Math.abs(nums[i]); if (v == n) &#123; //避免越界，而且0位置不是正数 nums[0] = -1 * Math.abs(nums[0]); &#125; else &#123; //由于这个位置v可能会反复访问，所以要加绝对值再取负值 nums[v] = -1 * Math.abs(nums[v]); &#125; &#125; //4. 从下标为1的位置遍历 for (int i = 1; i &lt; n; i++) &#123; if (nums[i] &gt; 0) return i; &#125; //若执行到此步，上面的for循环，说明n-1的位置都是在的， if (nums[0] &gt; 0) return n; return n + 1; &#125; public static void main(String[] args) &#123; int[] nums = &#123;3,4,-1,1&#125;; int a = firstMissingPositive(nums); System.out.println(a); &#125; &#125; 总结 O(2n)的意思是遍历两遍！！！ 本题思路借鉴了剑指Offer3. 重复的数字，请复习 犯了两个错误1. // foreach语句出错，错成nums[i] == 1 2. // n == 2判断出错 可以看本题的思路]]></content>
      <categories>
        <category>Hard</category>
      </categories>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[88. Merge Sorted Array]]></title>
    <url>%2F2019%2F05%2F25%2F88.html</url>
    <content type="text"><![CDATA[合并两个有序数组题目给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。 说明: 初始化 nums1 和 nums2 的元素数量分别为 m 和 n。你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。示例: 输入:nums1 = [1,2,3,0,0,0], m = 3nums2 = [2,5,6], n = 3 输出: [1,2,2,3,5,6] java实现123456789101112131415161718192021222324252627282930313233/** * @description: 合并两个有序数组，考虑在归并排序中的merge函数，需要额外的空间， *本题目中，限制了数组的长度 * @author: rhsphere * @since: 2019-05-25 21:30 by jdk 1.8 */public class MergeSorted &#123; public static void merge(int[] nums1, int m, int[] nums2, int n) &#123; int index = n + m - 1; m--; n--; while (m &gt;= 0 || n &gt;= 0) &#123; if (n == -1) &#123; return; &#125; else if (m &lt; 0) &#123; nums1[index--] = nums2[n--]; &#125; else if (nums1[m] &gt; nums1[n]) &#123; nums1[index--] = nums1[m--]; &#125; else &#123; nums1[index--] = nums2[n--]; &#125; &#125; &#125; public static void main(String[] args) &#123; int[] nums1 = &#123;1,2,7,0,0,0&#125;; int[] nums2 = &#123;4,5,6&#125;; int m = 3, n = 3; merge(nums1, m, nums2, n); System.out.println(Arrays.toString(nums1)); &#125;&#125; 总结 善用断点调试，看清流程怎么走的 合并两个有序数组，虽然没有额外的控件，但是nums1数组的长度题目中是大于等于 m+n的，和归并排序中的merge函数是完全不一样的，归并排序中用了O(n)的空间，来存储合并后的数组 对于 i– 的合理利用]]></content>
      <categories>
        <category>Easy</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Two Pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[412. Fizz Buzz]]></title>
    <url>%2F2019%2F05%2F25%2F412.html</url>
    <content type="text"><![CDATA[3和5的倍数题目写一个程序，输出从 1 到 n 数字的字符串表示。 如果 n 是3的倍数，输出“Fizz”； 如果 n 是5的倍数，输出“Buzz”； 3.如果 n 同时是3和5的倍数，输出 “FizzBuzz”。 示例： n = 15, 返回:[ “1”, “2”, “Fizz”, “4”, “Buzz”, “Fizz”, “7”, “8”, “Fizz”, “Buzz”, “11”, “Fizz”, “13”, “14”, “FizzBuzz”] java实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * @description: 比较简单，分别判断3和5的倍数标志 * @author: rhsphere * @since: 2019-05-25 20:51 by jdk 1.8 */public class FizzBuzz &#123; /* public List&lt;String&gt; fizzBuzz(int n) &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); if (n &lt;= 0) return list; int i = 0; while (i &lt;= n) &#123; String out = ""; boolean t = false, f = false; if (i % 3 == 0) t = true; if (i % 5 == 0) f = true; if (t &amp; f) &#123; out = "FizzBuzz"; &#125; else if (t) &#123; out = "Fizz"; &#125; else if (f) &#123; out = "Buzz"; &#125; else &#123; out = Integer.toString(i); &#125; list.add(out); i++; &#125; return list; &#125; */ public List&lt;String&gt; fizzBuzz(int n) &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); for (int i = 1; i &lt;= n; i++) &#123; list.add(isMultiple(i)); &#125; return ans; &#125; private String isMultiple(int n) &#123; if (n % 3 == 0 &amp;&amp; n % 5 != 0) &#123; return "Fizz"; &#125; else if (n % 3 != 0 &amp;&amp; n % 5 == 0) &#123; return "Buzz"; &#125; else if (n % 15 == 0) &#123; return "FizzBuzz"; &#125; else &#123; return String.valueOf(n); &#125; &#125;&#125; 总结 几个方法 String.valueOf(int n)、 Integer.toString(int n)、 list.add() 注释的方法也有可取之处，比如 t &amp; f]]></content>
      <categories>
        <category>Easy</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[169. Majority Element]]></title>
    <url>%2F2019%2F05%2F25%2F169.html</url>
    <content type="text"><![CDATA[求众数题目给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。 你可以假设数组是非空的，并且给定的数组总是存在众数。 示例 1: 输入: [3,2,3]输出: 3示例 2: 输入: [2,2,1,1,1,2,2]输出: 2 java代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950** * @description: leetcode上说明, 一定是具有众数存在的，则可以计算出一个初始值 count,从数组的下标1开始， * 如果与下一个数组下标的数字不相等，则count-- 当count 为0 就切换为下一个比较的数字 * @author: rhsphere * @since: 2019-05-25 20:19 by jdk 1.8 */public class MajorityElement &#123; public static int majorityElement(int[] nums) &#123; int maj = nums[0]; int count = 1; int i = 1; while (i &lt; nums.length) &#123; if (nums[i] == maj) count++; else &#123; count--; if (count == 0) &#123; maj = nums[i]; count = 1; &#125; &#125; i++; &#125; return maj; &#125; /*另一种写法 public static int majorityElement(int[] nums) &#123; int maj = nums[0]; int count = 1; for (int i = 1; i &lt; nums.length; i++) &#123; if (nums[i] == maj) &#123; count++; &#125; else &#123; count--; &#125; if (count == 0) &#123; maj = nums[i + 1]; &#125; &#125; return maj; &#125; */ public static void main(Sting[] args) &#123; int[] test1 = &#123;2, 2, 1, 1, 1, 2, 2&#125;; int a = majorityElement(test1); System.out.println(a); &#125;&#125; 总结 O(n) time and O(n) space O(n) time and O(1) space 使用 major 变量记录众数，count 记录遇到 major +1，非 major -1，最终 count 会大于0，major 即代表众数。]]></content>
      <categories>
        <category>Easy</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Bit Manipulation</tag>
        <tag>Divide and Conquer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[15. Three Sum]]></title>
    <url>%2F2019%2F05%2F25%2F15.html</url>
    <content type="text"><![CDATA[三数之和题目给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0？找出所有满足条件且不重复的三元组。 注意：答案中不可以包含重复的三元组。 例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]， 满足要求的三元组集合为： [ [-1, 0, 1], [-1, -1, 2] ] java代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import java.util.ArrayList;import java.util.Arrays;import java.util.List;/** * @description: 先排序，然后有两个指针 head 和 tail。 要计算的第一个数一定是负数,所以只要后两个数相加等于0-第一个数即可。 * @author: rhsphere * @since: 2019-05-25 18:57 by jdk 1.8 */public class ThreeSum&#123; public static List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); Arrays.sort(nums); for (int i = 0; i &lt; nums.length; i++) &#123; if (nums[i] &gt; 0) return res; //如果上一次匹配成功了在nums[i-1]，相同的nums[i]显然会重复 if (i &gt; 0 &amp;&amp; nums[i] = nums[i - 1]) continue; //双指针的做法谨记 int head = i + 1, tail = nums.length - 1; int val = 0 - nums[i]; while (head &lt; tail) &#123; if (nums[head] + nums[tail] == val) &#123; List&lt;Integer&gt; list = Arrays.asList(nums[i], nums[head], nums[tail]); res.add(list); while (head &lt; tail &amp;&amp; nums[tail] = nums[tail - 1]) tail--; while (head &lt; tail &amp;&amp; nums[head] = nums[head + 1]) head++; tail--; head++; &#125; else if (nums[head] + nums[tail] &gt; val) &#123; tail--; &#125; else &#123; head++; &#125; &#125; &#125; return res; &#125; public static void main(String[] args) &#123; int nums = &#123;-1, 0, 1, 2, -1, -4&#125;; List&lt;List&lt;Integer&gt;&gt; list = threeSum(nums); System.out.println(list); &#125;&#125; 总结 排序后再进行规约成两数之和 记住几个函数 Arrays.asList()、 Arrays.sort()、 list.add()、 List res = new ArrayList() (接口和抽象类不能实例化) 去重的考虑，有三处做了去重 双指针的方法]]></content>
      <categories>
        <category>Medium</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Two Pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[01. Two Sum]]></title>
    <url>%2F2019%2F05%2F25%2F1.html</url>
    <content type="text"><![CDATA[两数之和给定一个整数数组nums和一个目标值target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。 Java代码12345678910111213141516import java.util.*;public class TwoSum&#123; public int[] twoSum(int[] nums, int target) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; int key = target - nums[i]; if (map.contains(key)) return new int[]&#123;map.get(key), i&#125;; map.put(nums[i], i); &#125; throw new IllegalArgumentException("No two sum solution"); &#125;&#125;]]></content>
      <categories>
        <category>Easy</category>
      </categories>
      <tags>
        <tag>Hash Table</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态代理]]></title>
    <url>%2F2019%2F04%2F24%2Fdynamic-proxy.html</url>
    <content type="text"><![CDATA[JDK动态代理涉及java.lang.reflect包中的两个类，Proxy和InvocationHandler。Proxy利用InvocationHandler动态创建一个符合某一接口的实例，生成目标类的代理对象。InvocationHandler可以实现接口定义横切逻辑，并通过反射机制调用目标类的代码，动态地将横切逻辑和业务逻辑编织在一起。 JDK动态代理下面的代码来自于 精通Spring 4.x企业应用开发实战 P224 业务逻辑横切代码业务逻辑实现类的代码，省去ForumService接口类和PerformanceMonitor的代码。 12345678910111213141516171819202122232425public class ForumServiceImpl implements ForumService &#123; public void removeTopic(int topicId) &#123; // 横切逻辑 // PerformanceMonitor.begin(); System.out.println("模拟删除Topic记录" + topicId); try &#123; Thread.currentThread().sleep(20); &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; // PerformanceMonitor.end() &#125; public void removeForum(int forumId) &#123; // PerformanceMonitor.begin(); System.out.println("模拟删除Topic记录" + forumId); try &#123; Thread.currentThread().sleep(20); &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; // PerformanceMonitor.end(); &#125;&#125; 横切逻辑将业务类中性能监视横切代码移除后，放置到InvocationHandler中，代码如下。 123456789101112131415161718192021import java.lang.reflect.Method;import java.lang.reflect.InvocationHandler;public class PerformanceHandler implements InvocationHandler &#123; private Object target; public PerformanceHandler(Object target) &#123; this.target = target; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; // 横切逻辑代码定义在PerformanceMonitor中 PerformanceMonitor.begin(target.getClass().getName() + "." + method.getName()); // 使用反射方法调用业务类的目标方法 Object obj = method.invoke(target, args); // 横切逻辑 PerformanceMonitor.end(); return obj; &#125;&#125; invoke(Object proxy, Method method, Object[] args)方法，其中，proxy是最终生成的代理实例，一般不会用到；method是被代理目标实例的某个具体方法，通过它可以发起目标实例方法的反射调用；args是被代理实例某个方法的入参，在方法反射时调用。其次，在构造参数里通过target传入希望被代理的目标对象，在接口方法invoke(Object proxy, Method method, Object[] args)里，将目标实例传递给method.invoke()方法，并调用目标实例的方法。 下面通过Proxy结合PerformanceHandler创建ForumService接口的代理实例。 创建代理实例123456789101112131415161718192021import java.lang.reflect.Proxy;public class ForumServiceTest &#123; public void proxy() &#123; // 希望被代理的目标业务类 ForumService target = new ForumServiceImpl(); // 将目标业务类和横切代码编织到一起 PerformanceHandler handler = new PerformanceHandler(target); // 根据编织了目标业务类逻辑和性能监视横切逻辑的 // InvocationHandler实例创建代理实例 ForumService proxy = (ForumService) Proxy.newProxyInstance( target.getClass().getClassLoader(), target.getClass().getInterface(), handler); // 调用代理实例 proxy.removeForum(10); proxy.removeTopic(1024); &#125;&#125; Proxy.newProxyInstance() 方法的第一个入参为类加载器；第二个入参为创建代理实例所需实现的一组接口；第三个入参是整合了业务逻辑和横切逻辑的编织器对象。 JDK动态代理另一种简洁写法以下代码来自于 Java EE 互联网轻量级框架整合开发 接口类和实现类的定义在动态代理中必须使用接口，CGLib不需要。下面的代码分别是简单的接口和被代理类的定义。 123456789101112// 接口public interface Service &#123; public void sayHello();&#125;// 实现类public class ServiceImpl implements Service &#123; @Override public void sayHello() &#123; System.out.println("Hello world"); &#125;&#125; 动态代理绑定和代理逻辑实现要实现动态代理要两个步骤，首先，建立起代理对象和被代理对象的关系（将目标业务类和横切代码编织到一起），然后实现代理逻辑。1234567891011121314151617181920212223242526import java.lang.reflect.Proxy;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;public class JdkProxyExample implements InvocationHandler &#123; private Object target = null; public Object bind(Object target) &#123; this.target = target; return Proxy.newProxyInstance( target.getClass().getClassLoader(), target.getClass().gerInterfaces(), this); &#125; public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println("before..."); Object obj = method.invoke(target, args); System.out.println("after..."); return obj; &#125;&#125; 测试动态代理类1234567public class JdkProxyExampleTest &#123; JdkProxyExample jdk = new JdkProxyExample(); Service proxy = (Service) jdk.bind(new ServiceImpl()); proxy.sayHello();&#125; bind方法同时完成了两步。 CGLib动态代理使用JDK创建代理有一个限制，即只能为接口创建代理。Proxy的接口方法中newProxyInstance(ClassLoader loder, Class[] interfaces, InvocationHandler hander)，第二个入参就是需要代理实例实现的接口列表。假如对一个简单业务表的操作也需要创建5个类（领域对象、DAO接口、DAO实现类、Service接口和Service实现类）吗？对于没有通过接口定义业务方法的类，可以使用CGLib动态创建代理实例。 CGLib采用底层的字节码技术，可以为一个类创建子类，在子类中采用方法拦截的技术拦截父类方法的调用并顺势织入横切逻辑。 值得一提的是，由于CGLib采用动态创建子类的方式生成代理对象，所以不能对目标类中的final或private方法进行代理。 CglibProxy下面代码可以创建，为任何类织入性能监视横切逻辑代理对象的代理创建器。 12345678910111213141516171819202122232425262728293031323334353637383940import java.lang.reflect.Method;import net.sf.cglib.proxy.Enhancer;import net.sf.cglib.proxy.MethodInterceptor;import net.sf.cglib.proxy.MethodProxy;public class CglibProxy implemets MethodInterceptor &#123; // 增强类对象 private Enhancer enhancer = new Enhancer(); public Object getProxy(Class cls) &#123; // 设置需要创建子类的类 enhancer.setSuperClass(cls); /* 定义代理逻辑对象为当前对象，要求当前对象实现 * MethodInterceptor方法 */ enhancer.setCallback(this); // 通过字节码技术动态创建子类实例 return enhancer.create(); &#125; /* *代理逻辑方法，拦截父类所有方法的调用 * obj 目标类的实例 * method 目标类方法的反射对象 * args 方法的动态入参 * proxy 代理类实例 * result 代理逻辑方法返回 */ @Override public Object intercept(Objcet obj, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123; PerformanceMonitor.begin(obj.getClass().getName() + "." + method.getName()); // CGLib反射调用父类中的方法 Objcet result = proxy.invokeSuper(obj, args); PerformanceMonitor.end(); return result; &#125;&#125; 用户可以通过getProxy(Class cla)方法动态创建一个动态代理类。 Cglib测试代码123456789101112131415import java.lang.reflect.Proxy;import org.testg.annotations.*;public class ForumServiceTest &#123; @Test public void proxy() &#123; CglibProxy proxy = new CglibProxy(); // 通过动态生成子类的方式创建代理类 ForumServiceImpl forumService = (ForumServiceImpl) proxy.getProxy(ForumServiceImpl.class); forumService.removeForum(10); forumService.removeTopic(1024); &#125;&#125; 拦截器拦截器接口1234567public interface Interceptor &#123; boolean before(Object proxy, Object target, Method method, Objcet[] args); void around(Object proxy, Object target, Method method, Objcet[] args); void after(Object proxy, Object target, Method method, Objcet[] args);&#125; Interceptor实现类123456789101112131415161718public class MyInterceptor implements Interceptor &#123; @Override public boolean before(Object proxy, Object target, Method method, Objcet[] args) &#123; System.err.println("反射方法前逻辑"); return false; &#125; @Override public void after(Object proxy, Object target, Method method, Objcet[] args) &#123; System.err.println("反射方法后逻辑"); &#125; @Override public boolean around(Object proxy, Object target, Method method, Objcet[] args) &#123; System.err.println("取代了目标实例的方法"); &#125;&#125; 在JDK动态代理中使用拦截器123456789101112131415161718192021222324252627282930313233343536373839public class InterceptorJdkProxy implements InvocationHandler &#123; // 目标实例 private Objcet target; // 拦截器全限定名 private String interceptorClass = null; public InterceptorJdkProxy(Objcet target, String interceptorClass) &#123; this.target = target; this.interceptorClass = interceptorClass; &#125; public static Object bind(Object target, String interceptorClass) &#123; return Proxy.newProxyInstance( target.getClass().getClassLoader(), target.getClass().getInterfaces(), new InterceptorJdkProxy(target, interceptorClass)); &#125; public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; if (interceptorClass == null) &#123; return method.invoke(target, args); &#125; Object result = null; Interceptor inceptor = (Interceptor) Class.forName(interceptorClass).newInstance(); if (interceptor.before(proxy, target, method, args)) &#123; result = method.invoke(target, args); &#125; else &#123; inceptor.around(proxy, target, method, args); &#125; interceptor.after(proxy, target, method, args); return result; &#125;&#125;]]></content>
      <categories>
        <category>动态代理</category>
      </categories>
      <tags>
        <tag>动态代理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer(15) 二进制中1的个数]]></title>
    <url>%2F2019%2F04%2F21%2Fnumber-of-1-in-binary.html</url>
    <content type="text"><![CDATA[用机器语言编写程序，经常需要直接处理二进制数值，并在位级别上执行操作。位操作可以解决各种各样的问题。有的问题会明确要求用位操作来解决，而在其他的情况下，位操作也是优化代码的实用技巧。写代码要熟悉位操作，同时也要熟悉位操作的手工运算。写好代码后一定要进行充分测试，也可以边写代码边测试。 位操作手工运算其实二进制的位运算不是很难掌握，因为位运算总共只有7种运算：与、或、非(取反)、异或、左移位、带符号位右移位和无符号位右移位。位操作符仅适用于整数类型（byte、short、int和long）。位操作涉及的字符将转换为整数。所有的位操作符可以构成位赋值操作符，如 &amp;=， |=， ~=， ^=， &lt;&lt;=， &gt;&gt;=， &gt;&gt;&gt;=。 对于复杂一点的位操作，可以使用若干技巧来解决。假定操作数的位宽为4。（1）0110 + 0110相当于 0110 * 2，也就是将0110左移1位。 （2）0100 00110100相当于4，上面就等于 4 0011，也就是2^2，于是将0011左移2位得到1100。**一个数与2^n相乘，相当于将这个数左移n位。 （3）1101 ^ (~1101)逐比特分解这个操作。一个比特与对它去烦的数值做异或操作，结果总是1。因此 x ^ (~x)的结果是一串1。 （4）1011 &amp; (~0 &lt;&lt; 2)类似 x &amp; (~0 &lt;&lt; n)的操作会将x最右边的n位清零。 ~0的值是一串1（0在内存中为0x00000000，故取反后为一串1），将它左移n位后的结果为一串1后面跟n个0。将这个数与x进行“位与”操作，相当于将x最右边的n位清零。 位操作原理与技巧处理位操作问题时，理解下面的原理会有很大帮助。下面的示例中，“1s”和“0s”分别表示一串1和一串0。异或x ^ 0s = x x ^ 1s = ~x x ^ x = 0与x &amp; 0s = 0 x &amp; 1s = x x &amp; x = x或x | 0s = x x | 1s = 1s x | x = x 要理解这些表达式的含义，需要记住 所有操作都是按位进行的，某一位的运算结果不会影响其余位。 清零取数要用与，某位置一可用或若要取反和交换，轻轻松松用异或 常见位操作常见操作有：获取、设置、清除及更新位数据以下这些位操作很重要，不过不要死记硬背，否则会滋生一些难以觉察的错误，相反，要吃透这些操作方法，学会举一反三，灵活处理问题。 获取该方法将1左移i位，接着，对这个值与num执行“位与”操作，从而将i位之外的所有位清零。最后，检查该结果是否为零。不为零说明i位为1，否则，i位为0。 n &amp; (1 &lt;&lt; (k - 1)) 第k位置为1 123boolean getBit(int num, int i) &#123; return ((num &amp; (1 &lt;&lt; i)) != 0);&#125; 置位将1左移i位，然后对这个值和num执行“位或”操作，这样只会改变i位的数据。该掩码i位除外的位均为零，孤儿不会影响num的其余位。 123int setBit(int num, int i) &#123; return num | (1 &lt;&lt; i);&#125; 清零将给定操作数n的第k位清零，可以用表达式 n &amp; ~(1 &lt;&lt; (k-1)) 将掩码和num执行位与操作，这样只会清零num的i位，其余位保持不变。1234int clearBit(int num, int i) &#123; int mask = ~(1 &lt;&lt; i); return num &amp; mask;&#125; 将num最高位至i位（含）清零的做法如下：1234int clearBitsMSBthroughI(int num, int i) &#123; int mask = (1 &lt;&lt; i) - 1; return num &amp; mask;&#125; 将i位至0位（含）清零的做法：1234int clearBitsIthrough0(int num, int i) &#123; int mask = ~((1 &lt;&lt; (i + 1)) - 1); return num &amp; mask;&#125; 更新这个方法将setBit与clearBit合二为一。首先，用诸如11101111的掩码将num的第i位清零。接着，将带写入值val左移i位，得到一个i位为val但其余位都为0的数。最后，对之前去的的两个结果执行“位或”操作，val为1则将num的i位更新为1，否则该位仍为0。 1234int updateBit(int num, int i, int val) &#123; int mask = ~(1 &lt;&lt; i); return (num &amp; mask) | (val &lt;&lt; i);&#125; (n &amp; (n - 1) == 0) 的含义 （A &amp; B） == 0 的含义 意思是，A和B二进制表示的同一位置绝不会同时为1。因此，如果n &amp; (n - 1) == 0，则 n 和 n-1 就不会有共同的1。 表达式 (n &amp; (n - 1) == 0) 是用来检查n是否为2的某次方（或者检查n是否为0）。 二进制中1的个数题目请实现一个函数，输入一个整数，输出该数二进制表示中1的个数。例如把9表示成二进制是1001，有2位是1。因此如果输入9，该函数输出2。 思路遇到与二进制有关的题目，应该想到位运算(与、或、异或、左移、右移)。 方法一：“位与”有一个性质：通过与对应位上为1，其余位为0的数进行与运算，可以判断某一整数指定位上的值是否为1。这道题中，先把整数n与1做与运算，判断最低位是否为1；接着把1左移一位，与n做与运算，可以判断次低位是否为1……反复左移，即可对每一个位置都进行判断，从而可以获得1的个数。这种方法需要循环判断32次。 方法二（better）：如果一个整数不为0，把这个整数减1，那么原来处在整数最右边的1就会变为0，原来在1后面的所有的0都会变成1。其余所有位将不会受到影响。再把原来的整数和减去1之后的结果做与运算，从原来整数最右边一个1那一位开始所有位都会变成0。因此，把一个整数减1，再和原来的整数做与运算，会把该整数最右边的1变成0。这种方法，整数中有几个1，就只需要循环判断几次。 测试用例1.正数（包括边界值1、0x7FFFFFFF）2.负数（包括边界值0x80000000、0xFFFFFFFF）3.0 java代码123456789101112131415161718192021public class NumberOf1InBinary &#123; public int numberOf1_Solution1(int n) &#123; int count = 0; int flag = 1; while (flag != 0) &#123; if ((flag &amp; n) != 0) count++; flag &lt;&lt;= 1;) &#125; return count; &#125; public int numberOf1_Solution2(int n) &#123; int count = 0; while (n != 0) &#123; count++; n = n &amp; (n - 1); &#125; return count; &#125;&#125; 总结 注意：负数右移还是负数！即如果对n=0x8000 0000右移，最高位的1是不会变的。如果这道题目通过令n=n&gt;&gt;1来计算n中1的个数，该数最终会变成0xFFFF FFFF而陷入死循环！ 把一个整数减1，再和原来的整数做与运算，会把该整数最右边的1变成0。这种方法一定要牢牢记住，很多情况下都可能用到，例如： 一句话判断一个整数是否为2的整数次方； 对两个整数m和n，计算需要改变m二进制表示中的几位才能得到n。 与数字操作有关的题目，测试时注意边界值的问题。对于32位数字，其正数的边界值为1、0x7FFFFFFF，负数的边界值为0x80000000、0xFFFFFFFF。 (flag &amp; n！=0)，而非(flag &amp; n == 1)； 也就不能写成count += (flag &amp; 1)。 if语句中，不能写为if(flag &amp; n != 0) ，而要写成 if((flag &amp; n) != 0)，需要加上括号 扩展题题目编写一个函数，确定需要改变几个位，才能将整数A转成整数B。这道题可以分两步解决：第一步求这两个数的异或；第二步统计异或结果中1的位数。 只要输出a^b有几个位为1即可。1234567int bitSwapRequired(int a, int b) &#123; int count = 0; for (int c = a ^ b; c != 0; c &gt;&gt;= 1) &#123; count += c &amp; 1; &#125; return count;&#125; 上面的代码的做法是不断对c执行移位操作，然后检查最低有效位，但是其实可以不断翻转最低有效位，计算要多少次才会变成0。操作c = c &amp; (c - 1)会清楚c的最低有效位。 1234567public static int bitSwapRequired(int a, int b) &#123; int count = 0; for (int c = a ^ b; c != 0; c = c &amp; (c - 1)) count++; return count;&#125;]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>bit</tag>
        <tag>bit manipulation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer(14) 剪绳子]]></title>
    <url>%2F2019%2F04%2F21%2Fcut-rope.html</url>
    <content type="text"><![CDATA[剪绳子题目给你一根长度为n绳子，请把绳子剪成m段（m、n都是整数，n&gt;1并且m≥1）。每段的绳子的长度记为k[0]、k[1]、……、k[m]。k[0]·k[1]·…·k[m]可能的最大乘积是多少？例如当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到最大的乘积18。 思路本题采用动态规划或者贪婪算法可以实现。一开始没有思路时，可以从简单的情况开始想，试着算以下比较短的绳子是如何剪的。当n=1时，最大乘积只能为0； 当n=2时，最大乘积只能为1； 当n=3时，最大乘积只能为2； 当n=4时，可以分为如下几种情况:1·1·1·1，1·2·1，1·3，2·2，最大乘积为4； 往下推时，发现n≥4时，可以把问题变成几个小问题，即：如果把长度n绳子的最大乘积记为f(n)，则有：f(n)=max(f(i) · f(n - 1))，0 &lt; i &lt; n。所以思路就很容易出来了：自底向上，先算小的问题，再算大的问题，大的问题通过寻找小问题的最优组合得到。 贪婪算法依赖于数学证明，当绳子大于5时，尽量多地剪出长度为3的绳子是最优解。 测试用例 功能测试（长度大于5） 边界测试（长度1,2,3,4） Java代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class CuttingRope &#123; // ======动态规划====== public int maxProductAfterCutting_solution1(int length) &#123; if (length &lt;= 1) return 0; if (length == 2) return 1; if (length == 3) return 2; int[] product = new int[length + 1]; // 用于存放最大乘积值 // 下面几个不是乘积，因为其本身长度比乘积大 product[0] = 0; product[1] = 1; product[2] = 2; product[3] = 3; // 开始从下到上计算长度为i绳子的最大乘积值product[i] for (int i = 4; i &lt;= length; i++) &#123; int max = 0; // 算不同子长度的乘积，找出最大的乘积 for (int j = 1; j &lt;= i / 2; j++) &#123; if (max &lt; product[j] * product[i - j]) max = product[j] * product[i - j]; &#125; product[i] = max; &#125; return product[length]; &#125; / =======贪婪算法======== public int maxProductAfterCutting_solution2(int length) &#123; if (length &lt;= 1) return 0; if (length == 2) return 1; if (length == 3) return 2; int timesOf3 = length / 3; int timesOf2 = 0; if (length - timesOf3 * 3 == 1) &#123; timesOf3--; // timesOf2=2; //错误！ &#125; timesOf2 = (length - timesOf3 * 3) / 2; return (int) (Math.pow(3, timesOf3) * Math.pow(2, timesOf2)); &#125;&#125; 总结 最优解问题，经常使用动态规划法，关键要刻画最优解的结构特征（本题的f(n)），从下往上计算最优解的值，没有思路时，从简单情况先算一下。 动态规划法中，子问题的最优解一般存放于一个数组中。 本题贪婪规划的代码中，timeOf2别忘记等于1的情况。 复习时补充： 动态规划法可以直接令 f(n)=max{f(n-2)2,f(n-3)3} 就可以了。 贪婪算法，核心部分可改为 1234567int timesOf3 = n / 3;if (n % 3 == 0) return (int)(Math.pow(3, timesOf3));if (n % 3 == 1) return (int)(Math.pow(3, timesOf3 - 1) *４)；return (int)(Math.pow(3, timesOf3) * 2); int[] product = new int[length + 1]; // 用于存放最大乘积值备忘录的长度不是length - 1]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
        <tag>recursive</tag>
        <tag>greedy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer(13) 机器人的运动范围]]></title>
    <url>%2F2019%2F04%2F19%2Frobot-move.html</url>
    <content type="text"><![CDATA[机器人的移动范围题目地上有一个m行n列的方格。一个机器人从坐标(0, 0)的格子开始移动，它每一次可以向左、右、上、下移动一格，但不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格(35, 37)，因为3+5+3+7=18。但它不能进入方格(35, 38)，因为3+5+3+8=19。请问该机器人能够到达多少个格子？ 思路与剑指offer(12) 矩阵中的路径类似，也采用回溯法，先判断机器人能否进入(i,j)，再判断周围4个格子。不同的是，这题返回的是int值。 递归回溯本质上是一种枚举法，可以看成蛮力法的升级版。回溯法用于多个步骤，每个步骤都有多个选项的问题：若当前步骤满足条件，给定一个标记，当发现之后的步骤不满足条件时，去除标记。 测试用例 功能测试（多行多列矩阵，k为正数） 边界值测试（矩阵只有一行或一列；k=0） 特殊输入测试（k为负数） Java代码已验证代码正确性，测试部分去除。 12345678910111213141516171819202122232425262728293031public class RobotMove &#123; public int movingCount(int threshold, int rows, int cols) &#123; if (rows &lt;= 0 || cols &lt;= 0 || threshold &lt; 0) &#123; return 0; &#125; boolean[] isVisited = new boolean[rows * cols]; int count = movingCountCore(threshold, rows, cols, 0, 0, isVisited); return count; &#125; private int movingCountCore(int threshold, int rows, int cols, int row, int col, boolean[] isVisited) &#123; if (row &lt; 0 || col &lt; 0 || row &gt;= rows || col &gt;= cols || isVisited[row * cols + col] || cal(row) + cal(col) &gt; threshold) return 0; isVisited[row * cols + col] = true; return 1 + movingCountCore(threshold, rows, cols, row - 1, col, isVisited) + movingCountCore(threshold, rows, cols, row + 1, col, isVisited) + movingCountCore(threshold, rows, cols, row, col - 1, isVisited) + movingCountCore(threshold, rows, cols, row, col + 1, isVisited); &#125; private int cal(int num) &#123; int sum = 0; while (num &gt; 0) &#123; sum += num % 10; num /= 10; &#125; return sum; &#125;&#125; 总结 计算数位之和时，要注意数字不一定是十位数，可能是百位、千位甚至更多，所以cal()函数别写成计算十位数的方法了。 row &gt;= rows || col &gt;= cols 这里的等号。 return 0; 而不是 return false;]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer(12) 矩阵中的路径]]></title>
    <url>%2F2019%2F04%2F18%2Fstring-path-in-matrix.html</url>
    <content type="text"><![CDATA[矩阵中的路径题目请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用下划线标出）。但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。 A B T G C F C S J D E H 思路首先对整个矩阵遍历，找到第一个字符，然后向上下左右查找下一个字符，由于每个字符都是相同的判断方法（先判断当前字符是否相等，再向四周查找），因此采用 递归回溯。由于字符查找过后不能重复进入，所有还要定义一个字符矩阵相同大小的 布尔值矩阵，进入过的格子标记为true。如果不满足的情况下，需要进行 回溯，此时，要将当前位置的布尔值标记回false。（所谓的回溯无非就是对使用过的字符进行标记和对处理后的字符去标记） 递归回溯本质上是一种枚举法，可以看成蛮力法的升级版。回溯法用于多个步骤，内个步骤都有多个选项的问题：若当前步骤满足条件，给定一个标记，当发现之后的步骤不满足条件时，去除标记。 测试用例 功能测试（多行多列矩阵中存在或者不存在路径） 边界值测试（矩阵只有一行；矩阵与路径的所有字符都相同） 特殊输入测试（null） Java代码1234567891011121314151617181920212223242526272829303132333435363738394041public class StringPathInMatrix &#123; public boolean hasPath(char[] matrix, int rows, int cols, char[] str) &#123; if (matrix == null || rows &lt; 1 || cols &lt; 1 || str == null) &#123; return false; &#125; boolean[] isVisited = new boolean[rows * cols]; for (boolean v : isVisited) &#123; v = false; &#125; int pathLength = 0; for (int row = 0; row &lt; rows; row++) &#123; for (int col = 0; col &lt; cols; col++) &#123; if (hasPathCore(matrix, rows, cols, row, col, str, pathLength, isVisited)) return true; &#125; &#125; return false; &#125; private boolean hasPathCore(char[] matrix, int rows, int cols, int row, int col, char[] str, int pathLength, boolean[] isVisited) &#123; if (row &lt; 0 || col &lt; 0 || row &gt;= rows || col &gt;= cols || isVisited[row * cols + col] == true || str[pathLength] != matrix[row * cols + col]) return false; if (pathLength == str.length - 1) return true; boolean hasPath = false; isVisited[row * cols + col] = true; hasPath = hasPathCore(matrix, rows, cols, row - 1, col, str, pathLength + 1, isVisited) || hasPathCore(matrix, rows, cols, row + 1, col, str, pathLength + 1, isVisited) || hasPathCore(matrix, rows, cols, row, col - 1, str, pathLength + 1, isVisited) || hasPathCore(matrix, rows, cols, row, col + 1, str, pathLength + 1, isVisited); if (!hasPath) &#123; isVisited[row * cols + col] = false; &#125; return hasPath; &#125;&#125; 总结 回溯法用于多个步骤，每个步骤都有多个选项的问题：若当前步骤满足条件，给定一个标记，当发现之后的步骤不满足条件时，去除标记。 字符串转化为以为字符数组，使用toCharArray()方法。 二维数组下标在一维数组中的计算： row · cols + col。]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer(11) 旋转数组中的最小数字]]></title>
    <url>%2F2019%2F04%2F16%2Fmin-number-in-rotate-array.html</url>
    <content type="text"><![CDATA[查找和排序tips: 在面试时，如果面试官要求实现一个排序算法，那么一定要问清楚这个排序应用的环境是什么、有哪些约束条件。 数组在一定程度上是排序的，很容易分析出：可以采用二分法来寻找最小数字。 题目把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如数组 {3, 4, 5, 1, 2} 为 {1, 2, 3, 4, 5} 的一个旋转，该数组的最小值为1。 思路数组在一定程度上是排序的，很容易分析出：可以采用二分法来寻找最小数字。 但是这里面有一些陷阱： 递增排序数组的本身是自己的旋转，则最小数字是第一个数字 中间数字 与 首尾数字 大小相等，如 {1, 0, 1, 1, 1, 1} 和 {1, 1, 1, 1, 0, 1}，无法采用二分法，只能顺序查找。 测试用例 功能测试（正常旋转数组，中间有或者无重复数字） 边界值测试（升序数组，1个数字的数组） 特殊输入测试（null，空数组） Java代码123456789101112131415161718192021222324252627282930313233public class MinNumberInRotateArray &#123; public int minNumberInRotateArray(int[] arr) &#123; if (arr == null || arr.length &lt;= 0) return 0; int low = 0; int high = arr.length - 1; int mid = low + (high - low) &gt;&gt; 1; // 升序数组 if (arr[low] &lt; arr[high]) return arr[low]; // 中间数字与首尾数字相等 if (arr[mid] == arr[high] &amp;&amp; arr[mid] == arr[low]) &#123; for (int i = 1; i &lt;= high; i++) &#123; if (arr[i] &lt; arr[i - 1]) return arr[i]; &#125; return arr[low]; &#125; // 正常情况 while (low &lt; high) &#123; if (high - low == 1) break; mid = (low + high) / 2; if (arr[mid] &lt;= arr[high]) &#123; high = mid; &#125; else &#123; low = mid; &#125; &#125; return arr[high]; &#125;&#125; 下面是测试代码。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class MinNumberInRotateArray &#123; public void test1() &#123; int[] array = null; System.out.println("test1:" + minNumberInRotateArray(array)); &#125; public void test2() &#123; int[] array = &#123;&#125;; System.out.println("test2:" + minNumberInRotateArray(array)); &#125; public void test3() &#123; int[] array = &#123; 1 &#125;; System.out.println("test3:" + minNumberInRotateArray(array)); &#125; public void test4() &#123; int[] array = &#123; 1, 2, 3, 4, 5, 6 &#125;; System.out.println("test4:" + minNumberInRotateArray(array)); &#125; public void test5() &#123; int[] array = &#123; 2, 2, 2, 2, 1, 2 &#125;; System.out.println("test5:" + minNumberInRotateArray(array)); &#125; public void test6() &#123; int[] array = &#123; 2, 1, 2, 2, 2, 2 &#125;; System.out.println("test6:" + minNumberInRotateArray(array)); &#125; public void test7() &#123; int[] array = &#123; 6, 6, 8, 9, 10, 1, 2, 2, 3, 3, 4, 5, 6 &#125;; System.out.println("test7:" + minNumberInRotateArray(array)); &#125; public static void main(String[] args) &#123; MinNumberInRotateArray demo = new MinNumberInRotateArray(); demo.test1(); demo.test2(); demo.test3(); demo.test4(); demo.test5(); demo.test6(); demo.test7(); &#125;&#125; 牛客网优秀代码1234567891011121314151617public class Solution&#123; public int minNuberInRotateArray(int[] arr) &#123; int low = 0; int high = arr.length - 1; while (low &lt; high) &#123; int mid = low + (high - low) &gt;&gt; 1; if (arr[mid] &gt; arr[high]) &#123; low = mid + 1; &#125; else if (arr[mid] == arr[high]) &#123; high = high - 1; &#125; else &#123; high = mid; &#125; &#125; return arr[low]; &#125;&#125; 这段代码的细节： 使用low = mid + 1，而不是low = mid，最终会使得low = high（左右指针重合）而跳出循环。 使用high = mid，而不是high = mid - 1，因为mid有可能就是最小值点，不能减1。 升序数组的情况可以直接在循环中一起搞定，不用单独列出来判断。 不好的地方： 该程序在array[mid] = array[high]时直接顺序查找。但其实这还有可能可以用二分法的，除非还满足array[mid] = array[low]，才只能使用顺序查找。所以可以先排除掉必须顺序查找的情况（类似自己上面的程序，提前判断掉），之后就可以直接删除else if(array[mid] == array[high]){high = high - 1;这两行了。 缺少null的判断。 总结 题目中给定的特殊条件一定要去关注，往往就是解法的题眼，尤其是接触到一个新的概念时，要能快速理解并考虑全面。 要注意一些特例，如递增数组的本身是自己的旋转、相同数字数组。 如果数组一定程度上是排序的，可以考虑使用二分法来解题。对于数组的方法（如二分法等），可以用low、high、mid或者left、right、mid来表示左右指针，也即数组下标。]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>BinarySearch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer(10) 斐波那契数列及青蛙跳台阶问题]]></title>
    <url>%2F2019%2F04%2F16%2Ffibonacci.html</url>
    <content type="text"><![CDATA[递归和循环如果我们需要重复地多次计算相同的问题，则通常可以选择用递归或循环两种不同的方法。 递归就是把问题层层分解，直到程序出口处。而循环则是通过设置计算的初始值及终止条件，在一个范围内重复运算。 递归虽然有简洁的优点，但它同时也有显著的缺点。递归由于是函数调用自身，而函数调用是有时间和空间的消耗的：每一次函数调用，都需要在内存栈中分配空间以保存参数、返回地址及临时变量，而且往栈里压入数据和弹出数据都需要时间。另外，递归中有可能很多计算都是重复的，从而对性能带来很大的负面影响。递归的本质是把一个问题分解成两个或者多个小问题。如果多个小问题存在相互重叠的部分，就存在重复的计算。 通常应用动态规划解决问题时，我们都是用递归的思路分析问题，但由于递归分解的子问题中存在大量的重复，因此我们总是用自上而下的循环来实现代码。 除了效率，递归还有可能引起更严重的问题：调用栈溢出。每一次函数调用在内存栈中分配空间，而每个进程的栈的容量是有限的。当递归调用层级太多时，就会超出栈的容量，从而导致调用栈溢出。 斐波那契数列思路如果直接写递归函数，由于会出现很多重复计算，效率非常底，不采用。 要避免重复计算，采用从下往上计算，可以把计算过了的保存起来，下次要计算时就不必重复计算了：先由f(0)和f(1)计算f(2)，再由f(1)和f(2)计算f(3)……以此类推就行了，计算第n个时，只要保存第n-1和第n-2项就可以了。 测试用例 功能测试（3，5，8等） 边界值测试（0，1，2等） 性能测试（50，100等） 特殊（负数） Java代码时间复杂度为O(n) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class Fibonacci &#123; public long Fib(long n) &#123; if (n &lt; 0) throw new RuntimeException("下标错误，应从0开始！"); if (n == 0) return 0; if (n == 1) return 1; long prePre = 0; long pre = 1; long result = 1; for (long i = 2; i &lt;= n; i++) &#123; result = prePre + pre; prePre = pre; pre = result; &#125; return result; &#125; // 附：缩略版（考虑到代码的可读性，其实还是上面的方法比较好） public long Fib2(long n) &#123; if (n &lt; 0) throw new RuntimeException("下标错误，应从0开始！"); if (n == 0) return 0; if (n == 1) return 1; long pre = 0; long result = 1; for (long i = 2; i &lt;= n; i++) &#123; result += pre; pre = result - pre; &#125; return result; &#125; public static void main(String[] args) &#123; Fibonacci demo = new Fibonacci(); System.out.println(demo.Fib(0)); System.out.println(demo.Fib(1)); System.out.println(demo.Fib(2)); System.out.println(demo.Fib(8)); System.out.println(demo.Fib(50)); System.out.println(demo.Fib(100)); System.out.println(demo.Fib(-5)); &#125;&#125; 牛客网提交12345678910111213141516public class Solution &#123; public int Fibonacci(int n) &#123; int[] result = &#123;0, 1&#125;; if (n &lt; 2) return result[n]; int fib1 = 0; int fib2 = 1; int fibN = 0; for (int i = 2; i &lt;=n; i++) &#123; fibN = fib1 + fib2; fib1 = fib2; fib2 = fibN; &#125; return fibN; &#125;&#125; 青蛙跳台阶问题题目1一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 将跳法总数记为f(n)，可以知道f(1)=1，f(2)=2。当n&gt;2时，第一次跳1级的话，还有f(n-1)种跳法；第一次跳2级的话，还有f(n-2)种跳法，所以可以推得f(n)=f(n-1)+f(n-2)，即为斐波那契数列。 题目2一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 解法1： 当n=1时，f(1)=1。 当n大于1时，归纳总结可知：跳上n级台阶，第一次跳1级的话，有f(n-1)种方法；第一次跳2级的话，有f(n-2)种方法……第一次跳n-1级的话，有f(1)种方法；直接跳n级的话，有1种方法，所以可以得到如下公式： f(n) = f(n-1)+f(n-2)+……f(1)+1 （n≥2） f(n-1) = f(n-2)+f(n-3)+…..f(1)+1 （n&gt;2） 由上面两式相减可得，f(n)-f(n-1)=f(n-1)，即f(n) = 2*f(n-1) (n&gt;2) 最终结合f(1)和f(2)，可以推得：f(n)=2^(n-1) 解法2： 假设跳到第n级总共需要k次，说明要在中间n-1级台阶中选出任意k-1个台阶，即C(n-1,k-1)种方法。 所以：跳1次就跳上n级台阶，需要C(n-1,0)种方法；跳2次需要C(n-1,1)种方法……跳n次需要C(n-1,n-1)种方法 总共需要跳C(n-1,0)+C(n-1,1)+C(n-1,2)+……C(n-1,n-1)=2^(n-1)种方法。 解法3： 除了必须到达最后一级台阶，第1级到第n-1级台阶都可以有选择的跳，也就是说对于这n-1个台阶来说，每个台阶都有跳上和不跳上2种情况，所以一共有2^(n-1)种方法。 矩形覆盖问题题目用n个2 · 1的小矩形无重叠地覆盖一个2 · n的大矩形，总共有多少种方法？ 当n = 1时，有一种方法。 当n = 2时，有两种方法。 当n &gt;= 3时，和斐波那契数列类似。第一步竖着放，有f(n-1)种方法；第一步横着放，有f(n-2)种方法。所以f(n)=f(n-1)+f(n-2)。 总结 求n次方时，可以利用递归来降低时间复杂度 当遇到涉及n的问题时（类似青蛙跳台阶问题），不要紧张，可以进行归纳分析，特别注意f(n)与f(n-1)、f(n-2)等的关联，从而找出规律，进行合理建模。 return (int)Math.pow(2,target-1); 1) 转int类型]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>fibonacci</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二分查找]]></title>
    <url>%2F2019%2F04%2F15%2Fbinary-search.html</url>
    <content type="text"><![CDATA[查找不外乎顺序查找、二分查找、哈希表查找和二叉排序树查找。 二分查找是一个基础的算法，也是面试中常考的一个知识点。二分查找就是将查找的键和子数组的中间键作比较，如果被查找的键小于中间键，就在左子数组继续查找；如果大于中间键，就在右子数组中查找，否则中间键就是要找的元素。 二分查找如果题目中要求在排序的数组（或者部分排序的数组）中查找一个数字或者统计某个数字出现的次数，那么都可以尝试用二分查找算法。哈希表和二叉树炸找的重点在于考查对应的数据结构而不是算法。 极客时间-二分查找 二分查找代码每次移动left和right指针的时候，需要在mid的基础上+1或者-1， 防止出现死循环， 程序也就能够正确的运行。 注意：代码中的判断条件必须是while (left &lt;= right)，否则的话判断条件不完整，比如：array[3] = {1, 3, 5};待查找的键为5，此时在(low &lt; high)条件下就会找不到，因为low和high相等时，指向元素5，但是此时条件不成立，没有进入while()中。 123456789101112131415161718192021222324/** * @description: 二分查找 * @author: rhsphere * @since: 2019-11-04 22:06 by jdk 1.8 */public class BinarySearch &#123; public int search1(int[] arr, int key) &#123; int low = 0; int high = arr.length - 1; while (low &lt;= high) &#123; int mid = low + ((high - low) &gt;&gt; 1); if (arr[mid] == key) &#123; return mid; &#125; else if (arr[mid] &lt; key) &#123; low = mid + 1; &#125; else &#123; high = mid - 1; &#125; &#125; return -1; &#125;&#125; 二分查找的变种关于二分查找，如果条件稍微变换一下，比如：数组之中的数据可能可以重复，要求返回匹配的数据的最小（或最大）的下标；更近一步， 需要找出数组中第一个大于key的元素（也就是最小的大于key的元素的）下标，等等。 这些，虽然只有一点点的变化，实现的时候确实要更加的细心。 二分查找的变种和二分查找原理一样，主要就是变换判断条件（也就是边界条件），如果想直接看如何记忆这些变种的窍门，请直接翻到本文最后。下面来看几种二分查找变种的代码： 查找第一个与key相等的元素查找第一个相等的元素，也就是说等于查找key值的元素有好多个，返回这些元素最左边的元素下标。 当执行到right == left == mid后，此时会执行，if的 if (arr[mid] &gt;= key) 分支，于是right = left - 1，于是跳出while循环，所以最后时 left是 arr[key]最有左边的值，而right正好卡在left左边。 123456789101112131415161718192021222324252627/** * @description: 使用二分查找第一个给定值的元素 * @author: rhsphere * @since: 2019-11-04 22:21 by jdk 1.8 */public class BinarySearchFirst &#123; public int binarySearch(int[] arr, int key) &#123; int low = 0; int high = arr.length - 1; while (low &lt;= high) &#123; int mid = low + (high - low) / 2; if (arr[mid] &gt;= key) &#123; high = mid - 1; &#125; else &#123; low = mid + 1; &#125; &#125; if (low &lt; arr.length &amp;&amp; arr[low] == key) &#123; return low; &#125; return -1; &#125;&#125; 12345678910111213141516171819/** * @description: * @author: rhsphere * @since: 2019-11-04 22:24 by jdk 1.8 */public class BinarySearchFirstTest &#123; private BinarySearchFirst binaryFirst = new BinarySearchFirst(); @Test public void binarySearch() &#123;// int[] data = new int[] &#123;1, 2, 3, 4, 4, 4, 5, 6, 7, 8, 9, 10&#125;; int[] data = new int[] &#123;0,0,0,0,0,0,0,1,1,1,1,1,1,1&#125;; int index = binaryFirst.binarySearch(data, 1); System.out.println("查找的索引下标为:" + index); &#125;&#125; 查找最后一个与key相等的元素查找最后一个相等的元素，也就是说等于查找key值的元素有好多个，返回这些元素最右边的元素下标。 根据上面的分析，left == right == mid 的时候，left = mid + 1，于是left卡在了right右边，所以应该返回right值。 123456789101112131415161718192021222324/** * @description: 二分查找最后一个 * @author: rhsphere * @since: 2019-11-04 22:44 by jdk 1.8 */public class BinarySearchLast &#123; public int binarySearch(int[] arr, int key) &#123; int low = 0; int high = arr.length - 1; while (low &lt;= high) &#123; int mid = low + (high - low) / 2; if (arr[mid] &lt;= key) &#123; low = mid +1; &#125; else &#123; high = mid - 1; &#125; &#125; if (high &gt;= 0 &amp;&amp; arr[high] == key) return high; return -1; &#125;&#125; 查找最后一个等于或小于key的元素查找最后一个等于或小于key的元素，也就是说等于查找key值的元素有好多个，返回这些元素最右边的元素下标；如果没有等于key值的元素，则返回小于key的最右边元素下标。 1234567891011121314151617181920212223/** * @description: * @author: rhsphere * @since: 2019-11-04 22:51 by jdk 1.8 */public class BinarySearchLastEqualSmaller &#123; public int findLastEqualSmaller(int[] arr, int key) &#123; int low = 0; int high = arr.length - 1; while (low &lt;= high) &#123; int mid = low + (high - low) / 2; if (arr[mid] &gt; key) &#123; high = mid - 1; &#125; else &#123; low = mid + 1; &#125; &#125; return high; &#125;&#125; 查找第一个等于或者大于key的元素查找第一个等于或者大于key的元素，也就是说等于查找key值的元素有好多个，返回这些元素最左边的元素下标；如果没有等于key值的元素，则返回大于key的最左边元素下标。 12345678910111213141516171819202122/** * @description: 查找第一个等于或者大于key的元素 * @author: rhsphere * @since: 2019-11-04 22:57 by jdk 1.8 */public class BinarySearchFirstEqualLarger &#123; public int findFirstEqualLarger(int[] arr, int key) &#123; int low = 0; int high = arr.length - 1; while (low &lt;= high) &#123; int mid = low + ((high - low) &gt;&gt; 1); if (arr[mid] &gt;= key) &#123; high = mid - 1; &#125; else &#123; low = mid + 1; &#125; &#125; return low; &#125;&#125; 查找最后一个小于key的元素查找最后一个小于key的元素，也就是说返回小于key的最右边元素下标。 返回最后一个小于key的元素12345678910111213public static int findLastSmaller(int[] arr, int key) &#123; int left = 0; int right = arr.length - 1; while (left &lt;= right) &#123; int mid = left + (right - left) &gt;&gt; 1; if (arr[mid] &gt;= key) &#123; right = mid - 1; &#125; else &#123; left = mid + 1; &#125; &#125; return right;&#125; 查找第一个大于key的元素查找第一个等于key的元素，也就是说返回大于key的最左边元素下标。 查找第一个大于key的元素12345678910111213public static int findFirstLarger(int[] arr, int key) &#123; int left = 0; int right = arr.length - 1; while (left &lt;= right) &#123; int mid = left + (right - left) &gt;&gt; 1; if (arr[mid] &gt; key) &#123; right = mid - 1; &#125; else &#123; left = mid + 1; &#125; &#125; return left;&#125; 二分查找变种总结二分查找核心123456789while (left &lt;= right) &#123; int mid = (left + right) / 2; if (arr[mid] ? key) &#123; //...right = mid - 1; &#125; else &#123; //...left = mid + 1; &#125;&#125;return xxx; 首先判断出返回left，还是right因为最后跳出 while (left &lt;= right) 循环条件是 right &lt; left 且 right = left - 1。最后right和left一定卡在“边界值”的左右两边，如果比较值是key，查找小于等于（或是小于）key的元素，则边界值就是等于key的所有元素的最左边那个，其实应该返回left。 判断出比较符号二分查找判断符号123456int mid = (left + right) / 2;if (arr[mid] ? key) &#123; //...right = mid - 1;&#125; else &#123; //...left = mid + 1;&#125; 也就是这里的if (array[mid] ? key) 中的判断符号，结合步骤1和给出的条件，如果是查找小于等于key的元素，则知道应该使用判断符号&gt;=，因为是要返回left，所以如果array[mid]等于或者大于key，就应该使用&gt;=，以下是完整代码 查找小于等于key的元素123456int mid = (left + right) / 2;if (arr[mid] &gt;= key) &#123; right = mid - 1;&#125; else &#123; left = mid + 1;&#125;]]></content>
      <categories>
        <category>Search</category>
      </categories>
      <tags>
        <tag>BinarySearch</tag>
        <tag>search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序总结]]></title>
    <url>%2F2019%2F04%2F10%2Fsort-summary.html</url>
    <content type="text"><![CDATA[排序算法可以说是一项基本功，解决实际问题中经常遇到，针对实际数据的特点选择合适的排序算法可以使程序获得更高的效率，有时候排序的稳定性还是实际问题中必须考虑的，这篇博客对常见的排序算法进行整理，包括：选择排序、插入排序、希尔排序、冒泡排序、鸡尾酒排序、归并排序、快速排序、堆排序、计数排序、桶排序、基数排序(代码略)。 十大经典排序算法 比较和非比较排序比较排序常见的快速排序、归并排序、堆排序、冒泡排序等排序算法属于比较排序，在排序的最终结果里，元素之间的次序依赖于它们之间的比较。每个数都必须和其他数进行比较，才能确定自己的位置。在冒泡排序之类的排序中，问题规模为n，又因为需要比较n次，所以平均时间复杂度为O(n²)。在归并排序、快速排序之类的排序中，问题规模通过分治法消减为logN次，所以时间复杂度平均O(nlogn)。比较排序的优势是，适用于各种规模的数据，也不在乎数据的分布，都能进行排序。可以说，比较排序适用于一切需要排序的情况。 非比较排序计数排序、基数排序、桶排序则属于非比较排序。因为数据本身包含了定位特征，所有才能不通过比较来确定元素的位置。非比较排序是通过确定每个元素之前，应该有多少个元素来排序。针对数组arr，计算arr之前有多少个元素，则唯一确定了arr在排序后数组中的位置。非比较排序只要确定每个元素之前的已有的元素个数即可，所以一次遍历即可解决。算法时间复杂度O(n)。非比较排序时间复杂度低，但由于非比较排序需要占用空间来确定唯一位置。所以对数据规模和数据分布有一定的要求。 比较排序时间复杂度证明比较排序的时间复杂度通常为O(n²)或者O(nlogn)，比较排序的时间复杂度下界就是O(nlogn)，而非比较排序的时间复杂度可以达到O(n)，但是都需要额外的空间开销。 比较排序时间复杂度为O(nlogn)的证明： a1, a2, a3, ……, an数列的所有排序有n!种，所以满足要求的排序a1’, a2’, a3’, ……, an’（其中a1’&lt;=a2’&lt;=a3’……&lt;=an’）的概率为1/n!。基于输入元素的比较排序，每一次比较的返回不是0就是1，这恰好可以作为决策树的一个决策将一个事件分成两个分支。比如冒泡排序时通过比较a1和a2两个数的大小，可以把序列分成a1, a2, ……, an与a2, a1, ……, an（气泡a2上升一个身位）两种不同的结果，因此比较排序也可以构造决策树。根节点代表原始序列a1, a2, a3, ……, an，所有叶子节点都是这个序列的重排（共有n!个，其中有一个就是我们排序的结果a1’, a2’, a3’, ……, an’）。如果每次比较的结果都是等概率的话（恰好划分为概率空间相等的两个事件），那么二叉树就是高度平衡的，深度至少是log(n!)。 又因为： n! &lt; n^n ，两边取对数就得到log(n!) &lt; nlog(n)，所以 log(n!) = O(nlogn)。 n! = n(n-1)(n-2)(n-3)…1 &gt; (n/2)^(n/2) 两边取对数得到 log(n!) &gt; (n/2)log(n/2) = Ω(nlogn)，所以 log(n!) = Ω(nlogn)。 因此log(n!)的增长速度与 nlogn 相同，即 log(n!) = Θ(nlogn)，这就是通用排序算法的最低时间复杂度为 O(nlogn) 的依据。 排序稳定性和复杂度不稳定选择排序 （Selection Sort）— O(n²) 希尔排序 （Shell Sort）— O(nlogn) 快速排序 （Quick Sort）— O(nlogn) 平均时间， O(n²)最坏情况;对于大的、乱序串列一般认为是最快的已知排序。 堆排序 （Heap Sort）— O(nlogn) 基数排序 （Radix Sort）— O(n·k); 需要 O(n) 额外存储空间 （K为特征个数） 稳定插入排序 （Insertion Sort）— O(n²) 冒泡排序 （Bubble Sort） — O(n²) 归并排序 （Merge Sort）— O(nlogn); 需要 O(n) 额外存储空间 二叉树排序（Binary Tree Sort） — O(nlogn); 需要 O(n) 额外存储空间 计数排序 (Counting Sort) — O(n+k); 需要 O(n+k) 额外存储空间，k为序列中 Max-Min+1 桶排序 （Bucket Sort）— O(n); 需要 O(k) 额外存储空间 10种排序的原理和实现(基数排序和二叉树排序暂无)选择排序（Selection Sort）选择排序的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 遍历数组，遍历到i时，a0, a1, …, ai-1是已经排好序的，然后从i到n选择出最小的，记录下位置，如果不是第i个，则和第i个元素交换。此时第i个元素可能会排到相等元素之后，造成排序的不稳定。 选择排序实现部分1234567891011121314151617181920212223242526public static void selectionSort(int[] arr) &#123; if (arr == null || arr.length &lt; = 1) &#123; return; &#125; int currentMin; int currentMinIndex; for (int i = 0; i &lt; arr.length - 1; i++) &#123; // 找到最小值和最小值下标位置，在范围arr[i ... arr.length-1] currentMin = arr[i]; currentMinIndex = i; for (int j = i + 1; j &lt; arr.length; j++) &#123; if (currentMin &gt; arr[j]) &#123; currentMin = arr[j]; currentMindIndex = j; &#125; &#125; if (currentMinIndex != i) &#123; arr[currentMinIndex] = arr[i]; arr[i] = currentMin; &#125; &#125;&#125; 插入排序（Insertion Sort）插入排序的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。 遍历数组，遍历到i时，a0,a1…ai-1是已经排好序的，取出ai，从ai-1开始向前和每个比较大小，如果小于，则将此位置元素向后移动，继续先前比较，如果不小于，则放到正在比较的元素之后。 可见相等元素比较是，原来靠后的还是排在后边，所以插入排序是稳定的。当待排序的数据基本有序时，插入排序的效率比较高，只需要进行很少的数据移动。 插入排序实现部分1234567891011121314public static void insertionSort(int[] arr) &#123; for (int i = 1; i &lt; arr.length; i++) &#123; // 插入arr[i]到已经排好序的子线性表arr[0 ... i-1]中 int currentElement = arr[i]; int k; for (k = i - 1; k &gt;= 0 &amp;&amp; arr[k] &gt; currentElement; k--) &#123; arr[k+1] = arr[k]; &#125; // 插入当前元素到arr[k+1]中 arr[k + 1] = currentElement; &#125;&#125; 希尔排序（Shell Sort）希尔排序又叫缩小增量排序，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。 希尔排序是对插入排序的优化，基于以下两个认识：1.数据量较小时插入排序速度较快，因为n和n²差距很小；2.数据基本有序时插入排序效率很高，因为比较和移动的数据量少。 因此，希尔排序的基本思想是，将需要排序的序列划分成为若干个较小的子序列，对子序列进行插入排序，通过插入排序能够使得原来序列成为基本有序。这样通过对较小的序列进行插入排序，然后对基本有序的数列进行插入排序，能够提高插入排序算法的效率。 希尔排序的划分子序列不是像归并排序那种的二分，而是采用的叫做增量的技术，例如有十个元素的数组进行希尔排序，首先选择增量为10/2=5，此时第1个元素和第（1+5）个元素配对成子序列使用插入排序进行排序，第2和（2+5）个元素组成子序列，完成后增量继续减半为2，此时第1个元素、第（1+2）、第（1+4）、第（1+6）、第（1+8）个元素组成子序列进行插入排序。这种增量选择方法的好处是可以使数组整体均匀有序，尽可能的减少比较和移动的次数。二分法中即使前一半数据有序，后一半中如果有比较小的数据，还是会造成大量的比较和移动，因此这种增量的方法和插入排序的配合更佳。 希尔排序的时间复杂度和增量的选择策略有关，上述增量方法造成希尔排序的不稳定性。 希尔排序实现部分123456789101112131415public static int[] shellSort(int[] arr) &#123; for (int gap = arr.length / 2; gap &gt;= 1; gap /= 2) &#123; // 对子序列插入排序 for (int i = gap; i &lt; arr.length; i++) &#123; int j = i; int currentElement = arr[i]; while (j - gap &gt;= 0 &amp;&amp; arr[j - gap] &gt; currentElement) &#123; arr[j] = arr[j - gap]; j -= gap; &#125; arr[j] = currentElement; &#125; &#125; return arr;&#125; 冒泡排序（Bubble Sort）冒泡排序，重复地走访要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 冒泡排序的名字很形象，实际实现是相邻两节点进行比较，大的向后移一个，经过第一轮两两比较和移动，最大的元素移动到了最后，第二轮次大的位于倒数第二个，依次进行。这是最基本的冒泡排序，还可以进行一些优化。优化一：如果某一轮两两比较中没有任何元素交换，这说明已经都排好序了，算法结束，可以使用一个isSorted做标记，默认为true，如果发生交换则置为false，每轮结束时检测isSorted，如果为false则继续，如果为true则返回。优化二：某一轮结束位置为j，但是这一轮的最后一次交换发生在lastExchangedIndex的位置，则lastExchangedIndex到j之间是排好序的，下一轮的结束点就不必是j–了，而直接到lastExchangedIndex即可。 优化一实现123456789101112131415161718192021public static void bubbleSort(int[] arr) &#123; int tmp = 0; for (int i = 0; i &lt; arr.length; i++) &#123; boolean isSorted = true; for (int j = 0; j &lt; arr.length - i - 1; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; tmp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = tmp; isSorted = false; &#125; &#125; if (isSorted) &#123; break; &#125; &#125;&#125; 优化二实现123456789101112131415161718192021222324252627282930public static void bubbleSort(int[] arr) &#123; int tmp = 0; //记录最后一次交换的位置 int lastExchangedIndex = 0; //无序数列的边界，每次比较只需要比到这里为止 int sortBorder = arr.length - 1; for (int i = 0; i &lt; arr.length; i++) &#123; //有序标记，每一轮的初始是true boolean isSorted = true; for (int j = 0; j &lt; sortBorder; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; tmp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = tmp; //有元素交换，所以不是有序，标记变为false isSorted = false; //把无序数列的边界更新为最后一次交换元素的位置 lastExchangedIndex = j; &#125; &#125; sortBorder = lastExchangedIndex; if (isSorted) &#123; break; &#125; &#125;&#125; 鸡尾酒排序（Cocktail Sort）回顾冒泡排序的思想：冒泡排序的每一个元素都可以像一个小气泡一样，根据自身大小，一点一点向着数组的一侧移动。算法的每一轮都是 从左到右比较元素，进行单向的位置交换。那么鸡尾酒排序做了怎样的优化呢？鸡尾酒排序的元素比较和交换过程是 双向的。 鸡尾酒排序代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public static void cockTailSort(int[] arr) &#123; int tmp = 0; int lastRightExchangedIndex = 0; //记录右侧最后一次交换的位置 int lastLeftExchangedIndex = 0; //记录左侧最后一次交换的位置 //无序数列的右边界，每次比较只需要比到这里为止 int rigthSortBorder = arr.length - 1; //无序数列的左边界，每次比较只需要比到这里为止 int leftSortBorder = 0; for (int i = 0; i &lt; arr.length / 2; i++) &#123; boolean isSorted = true; //奇数轮，从左向右比较和交换 for (int j = leftSortBorder; j &lt; rigthSortBorder; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; tmp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = tmp; isSorted = false; lastRightExchangedIndex = j; &#125; &#125; rigthSortBorder = lastRightExchangedIndex; if (isSorted) &#123; break; &#125; isSorted = true; //偶数轮，从右向左比较和交换 for (int j = rigthSortBorder; j &gt; leftSortBorder; j--) &#123; if (arr[j] &lt; arr[j - 1]) &#123; tmp = arr[j]; arr[j] = arr[j - 1]; arr[j - 1] = tmp; isSorted = false; lastLeftExchangedIndex = j; &#125; &#125; leftSortBorder = lastLeftExchangedIndex; if (isSorted) &#123; break; &#125; &#125;&#125; 归并排序（Merge Sort）归并排序是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。 首先考虑下如何将二个有序数列合并。这个非常简单，只要从比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可。这需要将待排序序列中的所有记录扫描一遍，因此耗费O(n)时间，而由完全二叉树的深度可知，整个归并排序需要进行 logn次，因此，总的时间复杂度为O(nlogn)。 归并排序在归并过程中需要与原始记录序列同样数量的存储空间存放归并结果，因此空间复杂度为O(n)。归并算法需要两两比较，不存在跳跃，因此归并排序是一种稳定的排序算法。 归并排序实现1234567891011121314151617181920212223242526272829303132333435363738394041424344public static void mergeSort(int[] arr, int left, int right) &#123; if (left == right) &#123; return; &#125; else &#123; // 取中间的数进行拆分 int mid = (left + right) / 2; // 左边的数不断进行拆分 mergeSort(arr, left, mid); // 右边的数不断进行拆分 mergeSort(arr, mid + 1, right); // 合并 merge(arr, left, mid + 1, right); &#125;&#125;public static void merge(int[] arr, int left, int mid, int right) &#123; int[] leftArray = new int[mid - left]; int[] rightArray = new int[right - mid + 1]; for (int i = left; i &lt; mid; i++) &#123; leftArray[i - left] = arr[i]; &#125; for (int i = mid; i &lt;= right; i++) &#123; rightArray[i - mid] = arr[i]; &#125; int i = 0, j = 0; int k = left; while (i &lt; leftArray.length &amp;&amp; j &lt; rightArray.length) &#123; if (leftArray[i] &lt; rightArray[j]) &#123; arr[k++] = leftArray[i++]; &#125; else &#123; arr[k++] = rigthArray[j++]; &#125; &#125; while (i &lt; leftArray.length) &#123; arr[k++] = leftArray[i++]; &#125; while (j &lt; rightArray.length) &#123; arr[k++] = rigthArray[j++]; &#125;&#125; 快速排序（Quick Sort）快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。其中，最重要的partition主要有两种方法：A.先把选定为pivot的元素放到最后，然后设定指针low和指针high，low指针左移，high指针右移，当两个指针相撞后停止移动。期间如果符合交换条件，两元素交换。最后把pivot元素放到中间。B.类似冒泡排序的思路，把比pivot大的元素“往下沉”，把比pivot小的元素“往上浮”。快速排序是目前被认为最好的一种内部排序方法。快速排序算法处理的最好情况指每次都是将待排序数列划分为均匀的两部分，通常认为快速排序的平均时间复杂度是O(nlogn)。 但是，快速排序的最差情况就是基本逆序或者基本有序的情况，那么此时快速排序将蜕化成冒泡排序，其时间复杂度为O(n^2) 快排实现（挖坑法）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public static void quickSort(int[] arr, int startIndex, int endIndex) &#123; //递归结束条件 if (startIndex &gt;= endIndex) &#123; return; &#125; // 得到基准元素位置 int pivotIndex = partition(arr, startIndex, endIndex); // 用分治法递归数列两部分 quickSort(arr, startIndex, pivotIndex - 1); quickSort(arr, startIndex + 1, endIndex);&#125;private static int partition(int[] arr, int startIndex, int endIndex) &#123; // 取第一个位置的元素作为基准元素 int pivot = arr[startIndex]; int left = startIndex; int right = endIndex; // 坑的位置，初始等于pivot的位置 int index = startIndex; // 大循环左右指针重合或者指针交换时结束 while (right &gt;= left) &#123; // right指针从右向左进行比较 while (right &gt;= left) &#123; if (arr[right] &lt; pivot) &#123; arr[left] = arr[right]; index = right; left++; break; &#125; right--; &#125; //left指针从左向右进行比较 while (right &gt;= left) &#123; if (arr[left] &gt; pivot) &#123; arr[right] = arr[left]; index = left; right--; break; &#125; left++; &#125; &#125; arr[index] = pivot; return index;&#125; 快排实现（指针交换法）12345678910111213141516171819202122232425262728293031323334353637383940public static quickSort(int[] arr, int startIndex, int endIndex) &#123; if (startIndex &gt;= endIndex) &#123; return; &#125; // 得到基准信息 int pivotIndex = partition(arr, startIndex, endIndex); //根据基准元素，分成两部分进行递归 quickSort(arr, startIndex, pivotIndex - 1); quickSort(arr, pivotIndex + 1, endIndex);&#125;private static int partition(int[] arr, int startIndex, int endIndex) &#123; // 取第一个元素作为基准元素 int pivot = arr[startIndex]; int left = startIndex; int right = endIndex; while (left != right) &#123; // 控制right指针比较并左移 while (left &lt; right &amp;&amp; arr[right] &gt; pivot) &#123; right--; &#125; // 控制left指针比较并左移 while (left &lt; right &amp;&amp; arr[left] &lt;= pivot) &#123; left++; &#125; // 交换left和right指向的元素 if (left &lt; right) &#123; int tmp = arr[left]; arr[left] = arr[right]; arr[right] = tmp; &#125; &#125; // pivot和指针重合交换 int tmp = arr[left]; arr[left] = arr[startIndex]; arr[startIndex] = tmp; return left;&#125; 单边循环法1234567891011121314151617181920212223242526public static void quickSort(int[] arr, int startIndex, int endIndex) &#123; if (startIndex &gt;= endIndex) &#123; return; &#125; int pivotIndex = partition(arr, startIndex, endIndex); quickSort(arr, startIndex, pivotIndex - 1); quickSort(arr, pivotIndex + 1, endIndex);&#125;private static int partition(int[] arr, int startIndex, int endIndex) &#123; int pivot = arr[startIndex]; int mark = startIndex; for (int i = startIndex + 1; i &lt;= endIndex; i++) &#123; if (arr[i] &lt; pivot) &#123; mark++; int tmp = arr[mark]; arr[mark] = arr[i]; arr[i] = tmp; &#125; &#125; arr[startIndex] = arr[mark]; arr[mark] = pivot; return mark;&#125; 计数排序（Count Sort）如果通过比较进行排序，那么复杂度的下界是O(nlogn)，但是如果数据本身有可以利用的特征，可以不通过比较进行排序，就能使时间复杂度降低到O(n)。 计数排序要求待排序的数组元素都是整数，有很多地方都要求是 0-K 的正整数，其实负整数也可以通过都加一个偏移量解决的。 计数排序的思想是，考虑待排序数组中的某一个元素a，如果数组中比a小的元素有s个，那么a在最终排好序的数组中的位置将会是s+1，如何知道比a小的元素有多少个，肯定不是通过比较去觉得，而是通过数字本身的属性，即累加数组中最小值到a之间的每个数字出现的次数（未出现则为0），而每个数字出现的次数可以通过扫描一遍数组获得。 计数排序的步骤： 1.找出待排序的数组中最大和最小的元素（计数数组C的长度为max-min+1，其中位置0存放min，依次填充到最后一个位置存放max）2.统计数组中每个值为i的元素出现的次数，存入数组C的第i项3.对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）4.反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1（反向填充是为了保证稳定性） 计数排序适合数据分布集中的排序，如果数据太分散，会造成空间的大量浪费，假设数据为（1,2,3,1000000），这就需要1000000的额外空间，并且有大量的空间浪费和时间浪费。 计数排序实现1234567891011121314151617181920212223242526272829303132333435363738394041public static int[] countSort(int[] arr) &#123; // 1. 得到数列的最大值和最小值，并计算出差值d int max = arr[0]; int min = arr[0]; for (int i = 1; i &lt; arr.length; i++) &#123; if (arr[i] &gt; max) &#123; max = arr[i]; &#125; if (arr[i] &lt; min) &#123; min = arr[i]; &#125; &#125; int d = max - min; // 2. 创建统计数组并统计对应元素个数 int[] countArray = new int[d + 1]; for (int i = 0; i &lt; arr.length; i++) &#123; countArray[arr[i] - min]++; &#125; // 3. 统计数组做变型，后面的元素等于前面的元素之和 int sum = 0; for (int i = 0; i &lt; countArray.length; i++) &#123; sum += countArray[i]; countArray[i] = sum; &#125; // 4. 倒序遍历原始数组，从统计数组找到正确位置，输出到结果数组 int[] sortedArray = new int[arr.length]; for (int i = arr.length - 1; i &gt;= 0; i--) &#123; // arr[i]-min找到这个数在countArray中的位置 int sumCount = countArray[arr[i] - min]; //得到实际排序后的位置 int sortedPos = sumCount - 1; // 向最终结果里存放元素 sortedArray[sortedPos] = arr[i]; // 针对重复的元素，先放后面，然后减1，下次循环就会放在前面 countArray[arr[i] - min]--; &#125; return sortedArray;&#125; 桶排序（Bucket Sort） 假设有一组长度为N的待排关键字序列K[1….n]。首先将这个序列划分成M个的子区间(桶) 。然后基于某种映射函数 ，将待排序列的关键字k映射到第i个桶中(即桶数组B的下标i) ，那么该关键字k就作为B[i]中的元素(每个桶B[i]都是一组大小为N/M的序列)。接着对每个桶B[i]中的所有元素进行比较排序(可以使用快排)。然后依次枚举输出B[0]….B[M]中的全部内容即是一个有序序列。 桶排序利用函数的映射关系，减少了计划所有的比较操作，是一种Hash的思想，可以用在海量数据处理中。计数排序也可以看作是桶排序的特例，数组关键字范围为N，划分为N个桶。 桶排序实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public static double[] bucketSort(double[] arr) &#123; // 1. 得到数列的最大值和最小值，并计算出差值d double max = arr[0]; double min = arr[0]; for (int i = 1; i &lt; arr.length; i++) &#123; if (arr[i] &gt; max) &#123; max = arr[i]; &#125; if (arr[i] &lt; min) &#123; min = arr[i]; &#125; &#125; double d = max - min; // 2. 初始化桶 int bucketNum = arr.length; ArrayList&lt;LinkedList&lt;Double&gt;&gt; bucketList = new ArrayList&lt;&gt;(bucketNum); for (int i = 0; i &lt; bucketNum; i++) &#123; bucketList.add(new LinkedList&lt;Double&gt;()); &#125; // 3. 遍历原始数组，将每个元素放入桶中 for (int i = 0; i &lt; arr.length; i++) &#123; int num = (int) ((arr[i] - min) * (bucketNum - 1) / d); bucketList.get(num).add(arr[i]); &#125; // 4. 对每个桶内部进行排序 for (int i = 0; i &lt; bucketList.size(); i++) &#123; // JDK低层采用了归并排序或归并的优化版本 Collections.sort(bucketList.get(i)); &#125; // 5. 输出全部元素 double[] sortedArray = new double[arr.length]; int index = 0; for (LinkedList&lt;Double&gt; list : bucketList) &#123; for (double element : list) &#123; sortedArray[index] = element; index++; &#125; &#125; return sortedArray;&#125; 堆排序（Heap Sort） 堆排序是把数组看作堆，第i个结点的孩子结点为第2i + 1和2i + 2个结点（不超出数组长度前提下），堆排序的第一步是建堆，然后是取堆顶元素然后调整堆。建堆的过程是自底向上不断调整达成的，这样当调整某个结点时，其左节点和右结点已经是满足条件的，此时如果两个子结点不需要动，则整个子树不需要动，如果调整，则父结点交换到子结点位置，再以此结点继续调整。 下述代码使用的大顶堆，建立好堆后堆顶元素为最大值，此时取堆顶元素即使堆顶元素和最后一个元素交换，最大的元素处于数组最后，此时调整小了一个长度的堆，然后再取堆顶和倒数第二个元素交换，依次类推，完成数据的非递减排序。 堆排序的主要时间花在初始建堆期间，建好堆后，堆这种数据结构以及它奇妙的特征，使得找到数列中最大的数字这样的操作只需要O(1)的时间复杂度，维护需要logn的时间复杂度。堆排序不适宜于记录数较少的文件。 堆排序实现12345678910111213141516171819202122232425262728293031323334353637//堆排序 arr为待调整的堆public static void heapSort(int[] arr) &#123; // 1. 把无序数组构建成二叉堆 for (int i = (arr.length - 2) / 2; i &gt;= 0; i--) &#123; downAdjust(arr, i, arr.length); &#125; System.out.println(Arrays.toString(arr)); // 2.循环删除栈顶元素，移到集合尾部，调整堆产生新的栈顶 for (int i = arr.length - 1; i &gt; 0; i--) &#123; //最后一个元素和第一个元素进行交换 int tmp = arr[i]; arr[i] = arr[0]; arr[0] = tmp; // 下沉调整最大堆 downAdjust(arr, 0, i); &#125;&#125;public static downAdjust(int[] arr, int parentIndex, int length) &#123; int tmp = arr[parentIndex]; int childIndex = 2 * parentIndex + 1; while (childIndex &lt; length) &#123; // 如果有右孩子，且右孩子大于左孩子的值，则定位到右孩子 if (childIndex + 1 &lt; length &amp;&amp; arr[childIndex + 1] &gt; arr[childIndex]) &#123; childIndex++; &#125; //如果父节点大于任何一个孩子的值，直接跳出 if (tmp &gt;= arr[childIndex]) break; //无需真正交换，单向赋值即可 arr[parentIndex] = arr[childIndex]; parentIndex = childIndex; childIndex = 2 * childIndex + 1; &#125; arr[parentIndex] = tmp;&#125;]]></content>
      <categories>
        <category>Sorting</category>
      </categories>
      <tags>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序(11) 外部排序]]></title>
    <url>%2F2019%2F04%2F01%2Fexternal-sort.html</url>
    <content type="text"><![CDATA[前面讨论的排序算法，都假定要排序的所有数据在内存中都同时可用，如数组。要对存储在外部文件中的数据排序，首先要将数据送入内存，然后对它们进行内部排序。然而，如果文件太大，那么文件中的所有数据不能都同时送入内存。在大型外部文件中对数据排序，称为外部排序(external sort)。 创建大文件创建一个200万int值存储在一个名为largedata.dat的二进制文件中。使用下面的程序创建： 123456789101112131415161718import java.io.*;public class CreateLargeFile &#123; public static void main(String[] args) throws Exception &#123; DataOutputStream output = new DataOutputStream( new BufferedOutputStream(new FileOutputStream("largedata.dat"))); for (int i = 0; i &lt; 800004; i++)&#123; output.writeInt((int)(Math.random() * 1000000)); &#125; output.close(); DataInputStream input = new DataInputStream( new BufferedInputStream(new FileInputStream("largedata.dat"))); for (int i = 0; i &lt; 100; i++) &#123; System.out.print(input.readInt() + " "); &#125; input.close(); &#125;&#125; 归并排序实现实现阶段1重复将数据从文件读入数组，并使用内部排序算法堆数组排序，然后将数据从数组输出到一个临时文件中。下面的代码给出了一个方法，它从文件中读取每个数据段，并对分段进行排序，然后将排好序的分段存在一个心文件中。该方法返回分段的个数。 创建初始的有序分段1234567891011121314151617181920212223242526272829private static int initializeSegments (int segmentSize, String originalFile, String f1) throws Exception &#123; int[] list = new int[segmentSize]; DataInputStream input = new DataInputStream( new BufferedInputStream(new FileInputStream(originalFile))); DataOutputStream output = new DataOutputStream( new BufferedOutputStream(new FileOutputStream(f1))); int numberOfSegments = 0; while (input.available() &gt; 0) &#123; numberOfSegments++; // 读取一段数据到数组中 int i = 0; for ( ; input.available() &gt; 0 &amp;&amp; i &lt; segmentSize; i++) &#123; list[i] = input.readInt(); &#125; // 对数组排序 java.util.Arrays.sort(list, 0, i); // 将数组中的数据写入到临时文件中 for (int j = 0; j &lt; i; j++) &#123; output.writeInt(list[j]); &#125; &#125; input.close(); output.close(); //返回分段个数，除了最后一个分段的元素数可能较少外，其他分段都有 //MAX_ARRAY_SIZE个元素 return numberOfSegments; &#125; MAX_ARRAY_SIZE，数组的最大尺寸依赖于操作系统分配给JVM的内存大小。假定数组的最大尺寸为100 000个int值，那么在临时文件中就是对每100 000个int值进行的排序。将它们标记为S1，S2，…，Sk，最后一段包含的数值可能会少于100 000个。 实现阶段2将每对有序分段（比如S1，S2，…，Sk）归并到一个大一些的有序分段中，并将新分段存储到新的临时文件中。继续同样的过程直到得到仅仅一个有序分段。每步归并都将两个有序分段归并成一个新分段。新段的元素数目是原来的两倍，因此，每次归并后分段的个数减少一半。如果一个分段太大，它将不能放到内存的数组中。为了实现归并步骤，要将文件f1.dat中的一半数目的分段复制到临时文件f2.dat中。然后，将f1.dat中剩下的收割分段与f2.dat中的首个分段归并到名为f3.dat的临时文件中。复制前半部分的分段复制前半部分的分段123456private static void copyHalfToF2(int numberOfSegments, int segmentSize, DataInputStream f1, DataOutputStream f2) throws Exception &#123; for (int i = 0; i &lt; (numberOfSegments / 2) * segmentSize; i++) &#123; f2.writeInt(f1.readInt()); &#125;&#125; 归并所有分段归并所有分段1234567891011private static void mergeSegments(int numberOfSegments, int segmentSize, DataInputStream f1, DataInputStream f2, DataOutputStream f3) throws Exception &#123; for (int i = 0; i &lt; numberOfSegments; i++) &#123; mergeTwoSegments(segmentSize, f1, f2, f3); &#125; while (f1.available() &gt; 0) &#123; f3.writeInt(f1.readInt()); &#125; &#125; 归并两个阶段归并两个阶段12345678910111213141516171819202122232425262728293031323334353637private static void mergeTwoSegments(int segmentSize, DataInputStream f1, DataInputStream f2, DataOutputStream f3) throws Exception &#123; int intFromF1 = f1.readInt(); int intFromF2 = f2.readInt(); int f1Count = 1; int f2Count = 1; while (true) &#123; if (intFromF1 &lt; intFromF2) &#123; f3.writeInt(intFromF1); if (f1.available() == 0 || f1Count++ &gt;= segmentSize) &#123; f3.writeInt(intFromF2); break; &#125; else &#123; intFromF1 = f1.readInt(); &#125; &#125; else &#123; f3.writeInt(intFromF2); if (f2.available() == 0 || f2Count++ &gt;= segmentSize) &#123; f3.writeInt(intFromF1); break; &#125; else &#123; intFromF2 = f2.readInt(); &#125; &#125; &#125; while (f1.available() &gt; 0 &amp;&amp; f1Count++ &lt;segmentSize) &#123; f3.writeInt(f1.readInt()); &#125; while (f2.available() &gt; 0 &amp;&amp; f2Count++ &lt; segmentSize) &#123; f3.writeInt(f2.readInt()); &#125; &#125; 结合两个阶段完整代码外部排序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153package sorting;import java.io.*;public class SortLargeFile &#123; public static final int MAX_ARRAY_SIZE = 43; public static final int BUFFER_SIZE = 100000; public static void main(String[] args) throws Exception &#123; sort("largedata.dat", "sortedfile.dat"); displayFile("sortedfile.dat"); &#125; public static void sort(String sourcefile, String targetfile) throws Exception &#123; int numberOfSegments = initializeSegments(MAX_ARRAY_SIZE, sourcefile, "f1.dat"); merge(numberOfSegments, MAX_ARRAY_SIZE, "f1.dat", "f2.dat", "f3.dat", targetfile); &#125; private static int initializeSegments (int segmentSize, String originalFile, String f1) throws Exception &#123; int[] list = new int[segmentSize]; DataInputStream input = new DataInputStream( new BufferedInputStream(new FileInputStream(originalFile))); DataOutputStream output = new DataOutputStream( new BufferedOutputStream(new FileOutputStream(f1))); int numberOfSegments = 0; while (input.available() &gt; 0) &#123; numberOfSegments++; int i = 0; for ( ; input.available() &gt; 0 &amp;&amp; i &lt; segmentSize; i++) &#123; list[i] = input.readInt(); &#125; java.util.Arrays.sort(list, 0, i); for (int j = 0; j &lt; i; j++) &#123; output.writeInt(list[j]); &#125; &#125; input.close(); output.close(); return numberOfSegments; &#125; private static void merge(int numberOfSegments, int segmentSize, String f1, String f2, String f3, String targetfile) throws Exception &#123; if (numberOfSegments &gt; 1) &#123; mergeOneStep(numberOfSegments, segmentSize, f1, f2, f3); merge((numberOfSegments + 1) / 2, segmentSize * 2, f3, f1, f2, targetfile); &#125; else &#123; File sortedFile = new File(targetfile); if (sortedFile.exists()) sortedFile.delete(); new File(f1).renameTo(sortedFile); &#125; &#125; private static void mergeOneStep(int numberOfSegments, int segmentSize, String f1, String f2, String f3) throws Exception &#123; DataInputStream f1Input = new DataInputStream( new BufferedInputStream(new FileInputStream(f1), BUFFER_SIZE)); DataOutputStream f2Output = new DataOutputStream( new BufferedOutputStream(new FileOutputStream(f2), BUFFER_SIZE)); copyHalfToF2(numberOfSegments, segmentSize, f1Input, f2Output); f2Output.close(); DataInputStream f2Input = new DataInputStream( new BufferedInputStream(new FileInputStream(f2), BUFFER_SIZE)); DataOutputStream f3Output = new DataOutputStream( new BufferedOutputStream(new FileOutputStream(f3), BUFFER_SIZE)); mergeSegments(numberOfSegments / 2, segmentSize, f1Input, f2Input, f3Output); f1Input.close(); f2Input.close(); f3Output.close(); &#125; private static void copyHalfToF2(int numberOfSegments, int segmentSize, DataInputStream f1, DataOutputStream f2) throws Exception &#123; for (int i = 0; i &lt; (numberOfSegments / 2) * segmentSize; i++) &#123; f2.writeInt(f1.readInt()); &#125; &#125; private static void mergeSegments(int numberOfSegments, int segmentSize, DataInputStream f1, DataInputStream f2, DataOutputStream f3) throws Exception &#123; for (int i = 0; i &lt; numberOfSegments; i++) &#123; mergeTwoSegments(segmentSize, f1, f2, f3); &#125; while (f1.available() &gt; 0) &#123; f3.writeInt(f1.readInt()); &#125; &#125; private static void mergeTwoSegments(int segmentSize, DataInputStream f1, DataInputStream f2, DataOutputStream f3) throws Exception &#123; int intFromF1 = f1.readInt(); int intFromF2 = f2.readInt(); int f1Count = 1; int f2Count = 1; while (true) &#123; if (intFromF1 &lt; intFromF2) &#123; f3.writeInt(intFromF1); if (f1.available() == 0 || f1Count++ &gt;= segmentSize) &#123; f3.writeInt(intFromF2); break; &#125; else &#123; intFromF1 = f1.readInt(); &#125; &#125; else &#123; f3.writeInt(intFromF2); if (f2.available() == 0 || f2Count++ &gt;= segmentSize) &#123; f3.writeInt(intFromF1); break; &#125; else &#123; intFromF2 = f2.readInt(); &#125; &#125; &#125; while (f1.available() &gt; 0 &amp;&amp; f1Count++ &lt;segmentSize) &#123; f3.writeInt(f1.readInt()); &#125; while (f2.available() &gt; 0 &amp;&amp; f2Count++ &lt; segmentSize) &#123; f3.writeInt(f2.readInt()); &#125; &#125; public static void displayFile(String filename) &#123; try &#123; DataInputStream input = new DataInputStream(new FileInputStream(filename)); for (int i = 0; i &lt; 100; i++) &#123; System.out.print(input.readInt() + " "); &#125; input.close(); &#125; catch (IOException ex) &#123; ex.printStackTrace(); &#125; &#125;&#125; 外部排序复杂度在外部排序中，主要开销是在IO上。假设n是文件中要排序的元素个数。在阶段1，从原始文件读取元素个数n，然后将它输出给一个临时文件。因此，阶段1的IO复杂度为O(n)。 对于阶段2，在第一个合并步骤之前，排好序的分段的个数为 n/c，其中c是MAX_ARRAY_SIZE。每一个合并步骤都会使分段的个数减半。因此，在第一次合并步骤之后，分段个数为 n/2c。在第二次合并步骤之后，分段个数为 n/4c。 在第三次合并步骤之后，分段个数为 n/8c。在第log(n/c)次合并步骤之后，分段个数减到1。因此，合并步骤的总数为log(n/c)。 在每次合并步骤中，从文件f1读取一半数量的分段，然后将它们写入到一个临时文件f2。合并f1中剩余的分段和f2中的分段。每一个合并步骤中IO的次数为O(n)。因为合并步骤的总数是log(n/c)，IO的总数是 O(n) * log(n/c) = O(nlogn)。因此外部排序的复杂度是O(nlogn)]]></content>
      <categories>
        <category>Sorting</category>
      </categories>
      <tags>
        <tag>sort</tag>
        <tag>ExternalSort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序(10) 堆排序(非泛型)]]></title>
    <url>%2F2019%2F04%2F01%2Fheapsort-easy.html</url>
    <content type="text"><![CDATA[堆排序是把数组看作堆，第i个结点的孩子结点为第 2i + 1和 2i + 2个结点（不超出数组长度前提下），堆排序的第一步是建堆，然后是取堆顶元素然后调整堆。建堆的过程是自底向上不断调整达成的，这样当调整某个结点时，其左节点和右结点已经是满足条件的，此时如果两个子结点不需要动，则整个子树不需要动，如果调整，则父结点交换到子结点位置，再以此结点继续调整。 二叉堆回顾最大（小）堆二叉堆本质上是一种完全二叉树，它分为两个类型：1.最大堆2.最小堆 完全二叉树定义：如果一棵二叉树的每一层都是满的，或者最后一层可以不填满并且最后一层的叶子都是靠左放置的，这可二叉树是完全的。 堆排序使用的是二叉堆（binary heap），二叉堆是一棵具有如下属性的二叉树：形状属性：它是一棵完全二叉树。堆属性：什么是最大堆呢？最大堆任何一个父节点的值，都 大于等于它左右孩子节点的值。什么是最小堆呢？最小堆任何一个父节点的值，都 小于等于它左右孩子节点的值。 二叉堆的根节点叫做堆顶。 最大堆和最小堆的特点，决定了在最大堆的堆顶是整个堆中的 最大元素；最小堆的堆顶是整个堆中的 最小元素。 堆的三种操作对于二叉堆，如下有几种操作： 插入节点，二叉堆的节点插入，插入位置是完全二叉树的最后一个位置。 删除节点，二叉堆的节点删除过程和插入过程正好相反，所删除的是处于堆顶的节点。 构建二叉堆，也就是把一个无序的完全二叉树调整为二叉堆。这几种操作都是基于堆的自我调整。 构建二叉堆构建二叉堆，也就是把一个无序的完全二叉树调整为二叉堆，本质上就是让所有非叶子节点依次下沉。 堆的代码实现二叉堆虽然是一颗完全二叉树，但它的存储方式并不是链式存储，而是顺序存储。换句话说，二叉堆的所有节点都存储在数组当中。数组中，在没有左右指针的情况下，如何定位到一个父节点的左孩子和右孩子呢？ 可以依靠数组下标来计算。假设父节点的下标是parent，那么它的左孩子下标就是 2parent+1；它的右孩子下标就是 2parent+2 。 堆的上浮和下浮调整操作12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class HeapOperator &#123; // 上浮调整 arr为待调整的堆 public static void upAdjust(int[] arr) &#123; int childIndex = arr.length - 1; int parentIndex = (childIndex - 1) / 2; // 用tmp保存插入的叶子节点值，用于最后的赋值 int tmp = arr[childIndex]; while (childIndex &gt; 0 &amp;&amp; tmp &lt; arr[parentIndex]) &#123; // 无须真正交换，单向赋值即可 arr[childIndex] = arr[parentIndex]; childIndex = parentIndex; parentIndex = (parentIndex - 1) / 2; &#125; arr[childIndex] = tmp; &#125; // 下沉调整，arr为待调整的堆，parentIndex为要下沉的父节点，length为堆的有效大小 public static void downAdjust(int[] arr, int parentIndex, int length) &#123; int tmp = arr[parentIndex]; int childIndex = 2 * parentIndex + 1; while (childIndex &lt; length) &#123; // 如果有右孩子，且右孩子小于左孩子的值，则定位到右孩子 // arr[childIndex + 1] &gt; arr[childIndex] if (childIndex + 1 &lt; length &amp;&amp; arr[childIndex + 1] &lt; arr[childIndex]) &#123; childIndex++; &#125; // 如果父节点小于任何一个孩子的值，直接跳出 // if (tmp &gt; arr[childIndex]) if (tmp &lt;= arr[childIndex]) break; // 无需真正交换，单向赋值即可 arr[parentIndex] = arr[childIndex]; parentIndex = childIndex; childIndex = 2 * childIndex + 1; &#125; arr[parentIndex] = tmp; &#125; //构建堆 arr为待调整的堆 public static void buildHeap(int[] arr) &#123; // 从最后一个叶子节点开始，依次下沉调整 for (int i = arr.length / 2; i &gt;= 0; i--) &#123; downAdjust(arr, i, arr.length - 1); &#125; &#125; public static void main(String[] args) &#123; int[] arr = &#123; 1, 3, 2, 6, 5, 7, 8, 9, 10, 0 &#125;; upAdjust(arr); System.out.println(Arrays.toString(array)); array = new int[] &#123; 7, 1, 3, 10, 5, 2, 8, 9, 6 &#125;; buildHeap(array); System.out.println(Arrays.toString(array)); &#125;&#125; 代码中有一个优化的点，就是父节点和孩子节点做连续交换时，并不一定要真的交换，只需要先把交换一方的值存入temp变量，做单向覆盖，循环结束后，再把temp的值存入交换后的最终位置。 堆排序我们每一次删除旧堆顶，调整后的新堆顶都是大小仅次于旧堆顶的节点。那么我们只要反复删除堆顶，反复调节二叉堆，所得到的集合就成为了一个有序集合。 二叉堆和最大堆的特性： 二叉堆本质上是一种完全二叉树 最大堆的堆顶是整个堆中的最大元素 当我们删除一个最大堆的堆顶（并不是完全删除，而是替换到最后面），经过自我调节，第二大的元素就会被交换上来，成为最大堆的新堆顶。 由此，我们可以归纳出堆排序算法的步骤： 把无序数组构建成二叉堆。 循环删除堆顶元素，移到集合尾部，调节堆产生新的堆顶。 堆排序代码实现堆排序实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class HeapSort&#123; /** * 下沉调整 * @param arr 待调整的堆 * @param parentIndex 要下沉的父节点 * @param length 堆的有效大小 */ public static void downAdjust(int[] arr, int parentIndex, int length) &#123; int tmp = arr[parentIndex]; int childIndex = 2 * parentIndex + 1; while (childIndex &lt; length) &#123; // 如果有右孩子，且右孩子大于左孩子的值，则定位到右孩子 if (childIndex + 1 &lt; length &amp;&amp; arr[childIndex + 1] &gt; arr[childIndex]) &#123; childIndex++; &#125; //如果父节点大于等于任何一个孩子的值，直接跳出 if (tmp &gt;= arr[childIndex]) break; //无需真正交换，单向赋值即可 arr[parentIndex] = arr[childIndex]; parentIndex = childIndex; childIndex = 2 * childIndex + 1; &#125; arr[parentIndex] = tmp; &#125; //堆排序 arr为待调整的堆 public static void heapSort(int[] arr) &#123; // 1. 把无需数组构建成二叉堆 for (int i = arr.length/2 - 1; i &gt;= 0; i--) &#123; downAdjust(arr, i, arr.length); &#125; System.out.println(Arrays.toString(arr)); // 2.循环删除顶端元素，移到数组尾部，调整堆产生新的堆顶 for (int i = arr.length - 1; i &gt; 0; i--) &#123; //最后一个元素和第一个元素进行交换 int tmp = arr[i]; arr[i] = arr[0]; arr[0] = tmp; // 下沉调整最大堆 downAdjust(arr, 0, i); &#125; &#125; public static void main(String[] args) &#123; int[] arr = &#123; 1, 3, 2, 6, 5, 7, 8, 9, 10, 0 &#125;; heapSort(arr); System.out.println(Arrays.toString(arr)); &#125;&#125; 堆排序的时间空间复杂度算法复杂度：时间复杂度（平均）： O(nlogn)时间复杂度（最坏）： O(nlogn)时间复杂度（最好）： O(nlogn) 空间复杂度： O(1)堆排序是不稳定的排序算法。 堆排序的空间复杂度毫无疑问是O(1)，因为没有开辟额外的集合空间。 对于时间复杂度：二叉堆的节点下沉调整（downAdjust 方法）是堆排序算法的基础，这个调节操作本身的时间复杂度是多少呢？假设二叉堆总共有n个元素，那么下沉调整的最坏时间复杂度就等同于二叉堆的高度，也就是O（logn）。 我们再来回顾一下堆排序算法的步骤： 把无序数组构建成二叉堆。 循环删除堆顶元素，移到集合尾部，调节堆产生新的堆顶。 第一步，把无序数组构建成二叉堆，需要进行n/2次循环。每次循环调用一次 downAdjust 方法，所以第一步的计算规模是 n/2 * logn，时间复杂度 O（nlogn）。 第二步，需要进行n-1次循环。每次循环调用一次 downAdjust 方法，所以第二步的计算规模是 （n-1） * logn ，时间复杂度 O（nlogn）。 两个步骤是并列关系，所以整体的时间复杂度同样是 O（nlogn）。]]></content>
      <categories>
        <category>Sorting</category>
      </categories>
      <tags>
        <tag>HeapSort</tag>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序(9) 桶排序]]></title>
    <url>%2F2019%2F04%2F01%2Fbucket-sort.html</url>
    <content type="text"><![CDATA[假设有一组长度为N的待排关键字序列K[1….n]。首先将这个序列划分成M个的子区间(桶) 。然后基于某种映射函数，将待排序列的关键字k映射到第i个桶中(即桶数组B的下标i)，那么该关键字k就作为B[i]中的元素(每个桶B[i]都是一组大小为N/M的序列)。接着对每个桶B[i]中的所有元素进行比较排序(可以使用快排)。 然后依次枚举输出B[0]….B[M]中的全部内容即是一个有序序列。 桶排序思想一个长度为20的doule类型数组，取值范围从0到10，要求用最快的速度把这20个double类型元素从小到大进行排序。当数列取值范围过大，或者不是整数时，不能适用计数排序。到那时可以使用桶排序来解决问题。 桶排序同样是一种线性时间的排序算法，类似于计数排序所创建的统计数组，桶排序需要创若干个 桶来协助排序。 计数排序：计数排序需要根据原始数列的取值范围，创建一个统计数组，用来统计原始数列中每一个可能的整数值所出现的次数。原始数列中的整数值，和统计数组的下标是一一对应的，以数列的最小值作为偏移量，比如原始数列的最小值是90，那么整数对应的统计数组下标就是95-90=5。 桶排序当中的桶的概念：每一个桶(bucket)代表一个区间范围，里面可以承载一个或多个元素。 桶排序的第一步，就是创建这些桶，确定每一个桶的区间范围。 4.5 0.84 3.25 2.18 0.5[0.5, 1.5) [1.5, 2.5) [2.5, 3.5) [3.5, 4.5) [4.5, 4.5] 具体建立多少个桶，如何确定桶的区间范围，有很多不同的方式。这里创建的桶数量等于原始数列的元素数量，除了最后一个桶只包含数列最大值，前面各个桶的区间按照比例确定。区间跨度 = （最大值-最小值）/ （桶的数量 - 1） 第二步，遍历原始数列，把元素对号入座放入各个桶中： 0.84 0.5 2.18 3.25 4.5[0.5, 1.5) [1.5, 2.5) [2.5, 3.5) [3.5, 4.5) [4.5, 4.5] 第三步，每个桶内部的元素分别排序（显然，只有第一个桶需要排序）： 第四步，遍历所有的桶，输出所有元素：0.5， 0.84， 2.18， 3.25， 4.5 到此为止，排序结束。 桶排序代码实现桶排序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class BucketSort &#123; public static double[] bucketSort(double[] arr) &#123; // 1. 得到数列的最大值和最小值，并计算出差值d double max = arr[0]; double min = arr[0]; for (int i = 1; i &lt; arr.length; i++) &#123; if (arr[i] &gt; max) &#123; max = arr[i]; &#125; if (arr[i] &lt; min) &#123; min = arr[i]; &#125; &#125; double d = max - min; // 2. 初始化桶 int bucketNum = arr.length; ArrayList&lt;LinkedList&lt;Double&gt;&gt; bucketList = new ArrayList&lt;&gt;(bucketNum); for (int i = 0; i &lt; bucketNum; i++) &#123; bucketList.add(new LinkedList&lt;Double&gt;()); &#125; // 3. 遍历原始数组，将每个元素放入桶中 for (int i = 0; i &lt; arr.length; i++) &#123; int num = (int) ((arr[i] - min) * (bucketNum - 1) / d); bucketList.get(num).add(arr[i]); &#125; // 4. 对每个桶内部进行排序 for (int i = 0; i &lt; bucketList.size(); i++) &#123; // JDK低层采用了归并排序或归并的优化版本 Collections.sort(bucketList.get(i)); &#125; // 5. 输出全部元素 double[] sortedArray = new double[arr.length]; int index = 0; for (LinkedList&lt;Double&gt; list : bucketList) &#123; for (double element : list) &#123; sortedArray[index] = element; index++; &#125; &#125; return sortedArray; &#125; public static void main(String[] args) &#123; double[] arr = &#123; 4.12, 6.421, 0.0023, 3.0, 2.123, 8.122, 4.12, 10.09 &#125;; double[] sortedArr = bucketSort(arr); System.out.println(Arrays.toString(sortedArr)); &#125;&#125; 代码中，所有的桶保存在ArrayList集合当中，每一个桶被定义成一个链表（LinkedList），这样便于在尾部插入元素。 定位元素属于第几个桶，是按照比例来定位：(array[i] - min) * (bucketNum-1) / d 同时，代码使用了JDK的集合工具类Collections.sort来为桶内部的元素进行排序。Collections.sort底层采用的是归并排序或Timsort，小伙伴们可以简单地把它们当做是一种时间复杂度 O（nlogn）的排序。 基数排序基数排序 基数排序也可以看作一种桶排序，不断的使用不同的标准对数据划分到桶中，最终实现有序。基数排序的思想是对数据选择多种基数，对每一种基数依次使用桶排序。 基数排序的步骤：以整数为例，将整数按十进制位划分，从低位到高位执行以下过程。 从个位开始，根据0~9的值将数据分到10个桶桶，例如12会划分到2号桶中。 将0~9的10个桶中的数据顺序放回到数组中。 重复上述过程，一直到最高位。 上述方法称为LSD（Least significant digital），还可以从高位到低位，称为MSD。 复杂度及稳定性算法复杂度：时间复杂度（平均）： O(n+m+n(logn-logm))时间复杂度（最坏）： O(nlogn)时间复杂度（最好）： O(n) 空间复杂度： O(m+n)桶排序也是稳定的排序算法。 假设原始数列有n个元素，分成m个桶（我们采用分桶方式m=n），平均每个桶的元素个数为 n/m 下面逐步分析算法复杂度 第一步，求数列最大最小值，运算量为n。第二步，创建空桶，运算量为m。第三步，遍历原始数列，运算量为n。第四步在每个桶内部做排序，由于使用了O(nlogn)的排序算法，所以运算量为 n/m · log(n/m ) · m。第五步，输出排序数列，运算量为n。 加起来，总的运算量为3n+m+ n/m · log(n/m ) · m = 3n+m+n(logn-logm)去掉系数，时间复杂度为：O(n+m+n(logn-logm))至于空间复杂度就很明显了：空桶占用的空间 + 数列在桶中占用的空间 = O(m+n) 桶排序在性能上并非绝对稳定。理想情况下，桶中的元素均匀分布，当n=m时，时间复杂度可以达到O(n)；但是，如果桶内元素的分布极不均匀，极端情况下第一个桶中有n-1个元素，，最后一个桶中有1个元素。此时的时间复杂度将退化成为O(nlogn)，还白白创建了许多空桶。]]></content>
      <categories>
        <category>Sorting</category>
      </categories>
      <tags>
        <tag>sort</tag>
        <tag>BucketSort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序(8) 计数排序]]></title>
    <url>%2F2019%2F04%2F01%2Fcount-sort.html</url>
    <content type="text"><![CDATA[无论是冒泡排序，还是快速排序等等，都是基于元素之间的比较来进行排序。有一种特殊的算法叫做 计数排序，这种排序算法不是基于元素比较，而是利用数组下标来确定元素的正确位置。 计数排序思想如果通过比较进行排序，那么复杂度的下界是O(nlogn)，但是如果数据本身有可以利用的特征，可以不通过比较进行排序，就能使时间复杂度降低到O(n)。 计数排序要求待排序的数组元素都是整数，有很多地方都要求是 0-K 的正整数，其实负整数也可以通过都加一个偏移量解决的。 计数排序的思想是，考虑待排序数组中的某一个元素a，如果数组中比a小的元素有s个，那么a在最终排好序的数组中的位置将会是s+1，如何知道比a小的元素有多少个，肯定不是通过比较去觉得，而是通过数字本身的属性，即累加数组中最小值到a之间的每个数字出现的次数（未出现则为0），而每个数字出现的次数可以通过扫描一遍数组获得。 计数排序的步骤： 1.找出待排序的数组中最大和最小的元素（计数数组C的长度为max-min+1，其中位置0存放min，依次填充到最后一个位置存放max）2.统计数组中每个值为i的元素出现的次数，存入数组C的第i项3.对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）4.反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1（反向填充是为了保证稳定性） 计数排序适合数据分布集中的排序，如果数据太分散，会造成空间的大量浪费，假设数据为（1,2,3,1000000），这就需要1000000的额外空间，并且有大量的空间浪费和时间浪费。 示例数组里有20个随机数，取值范围从0到10,要求用最快的速度把这20个整数从小到大进行排序。 随机整数的取值范围从0到10，这些整数取值范围为0-10这11个数字。根据这个整数取值范围，建立一个长度为11的数组。数组下标从0到10，元素初始值全为0。 假定20个随机整数的值如下：9，3，5，4，9，1，2，7，8，1，3，6，5，3，4，0，10，9 ，7，9 如何给这些无序的随机整数排序呢？非常简单，让我们遍历这个无序的随机数列，每一个整数按照其值对号入座，对应数组下标的元素进行加1操作。最终，数列遍历完毕时，数组的状态如下： 0 1 2 3 4 5 6 7 8 9 10 1 2 1 3 2 2 1 2 1 4 1 数组每一个下标位置的值，代表了数列中对应整数出现的次数。有了这个“统计结果”，排序就很简单了。直接遍历数组，输出数组元素的下标值，元素的值是几，就输出几次：0，1，1，2，3，3，3，4，4，5，5，6，7，7，8，9，9，9，9，10显然，这个输出的数列已经是有序的了。 这就是计数排序的基本过程，它适用于一定范围的整数排序。在取值范围不是很大的情况下，它的性能甚至超过那些O(nlogn)的排序。 计数排序（初步实现）下面代码在一开头补充了一个步骤，就是求得数列的最大整数值max。后面创建的统计数组countArray，长度就是max + 1，以此保证数组的最后一个下标是max。代码如下：计数排序初步实现1234567891011121314151617181920212223242526272829303132public class CountSort &#123; public static int[] countSort(int[] arr) &#123; // 1. 得到数列的最大值 int max = arr[0]; for (int i = 1; i &lt; arr.length; i++) &#123; if (arr[i] &gt; arr[0]) &#123; max = arr[i]; &#125; &#125; // 2.根据数列最大值确定统计数组的长度 int[] countArray = new int[max + 1]; // 3. 遍历数列，填充统计数组 for (int i = 0; i &lt; arr.length; i++) &#123; countArray[arr[i]]++; &#125; // 4. 遍历统计数组，输出结果 int index = 0; int[] sortedArray = new int[arr.length]; for (int i = 0; i &lt; countArray.length; i++) &#123; for (int j = 0; j &lt; countArray[i]; j++) &#123; sortedArray[index++] = i; &#125; &#125; return sortedArray; &#125; public static void main(String[] args) &#123; int[] array = &#123; 4, 4, 6, 5, 3, 2, 8, 1, 7, 5, 6, 0, 10 &#125;; int[] sortedArray = countSort(array); System.out.println(Arrays.toString(sortedArray)); &#125;&#125; 改进点分析初始值和偏移量上面的初步实现，从功能角度，可以实现整数的排序，但是存在一些问题，只以数列的最大值来决定统计数组的长度，其实并不严谨。比如下面的数列：95，94，91，98，99，90，99，93，91，92 这个数列的最大值是99，但最小值的整数是90.如果创建长度为100的数组，前面从0到89的空间位置都浪费了。 解决这个问题，很简单，不再以（输入数列的最大值 + 1）作为统计数组的长度，而是以（数列最大值和最小值的差 + 1）作为统计数组的长度。同时，数列的最小值作为一个偏移量，用于统计数组的对号入座。 以刚才的数列为例，统计数组的长度为 99-90+1 = 10 偏移量等于数列的最小值90.对于第一个整数95，对应的统计数组下标是 95-90=5 反向填充另外一方面，朴素版的计数排序只是简单地按照统计数组的下标输出了元素值，并没有真正给原始数列进行排序。如果只是单纯的给整数排序，这样没有问题，但是如果放在业务代码里，比如给学生的考试分数排序，遇到相同的分数就会分不清谁是谁。 姓名 成绩 小灰 90 大黄 99 小红 95 小白 94 小绿 95 给定一个学生的成绩表，要求按成绩从低到高排序，如果成绩相同，则 遵循原表固有顺序。那么，当我们填充统计数组以后，我们只知道有两个成绩并列95分的小伙伴，却不知道哪一个是小红，哪一个是小绿： 0 1 2 3 4 5 6 7 8 9 1 0 0 0 1 2 0 0 0 1 变型后： 0 1 2 3 4 5 6 7 8 9 1 1 1 1 2 4 4 4 4 5 这是如何变形的呢？统计数组从第二个元素开始，每一个元素都加上前面所有元素之和。为什么要相加呢？ 这样相加的目的，是让统计数组存储的元素值，等于相应整数的最终排序位置。比如下标是9的元素值为5，代表原始数列的整数9，最终的排序是在第5位。 接下来，我们创建输出数组sortedArray，长度和输入数列一致。然后从后向前遍历输入数列：第一步，我们遍历成绩表最后一行的小绿：小绿是95分，我们找到countArray下标是5的元素，值是4，代表小绿的成绩排名位置在第4位。同时，我们给countArray下标是5的元素值减1，从4变成3,，代表着下次再遇到95分的成绩时，最终排名是第3。 第二步，我们遍历成绩表倒数第二行的小白：小白是94分，我们找到countArray下标是4的元素，值是2，代表小白的成绩排名位置在第2位。同时，我们给countArray下标是4的元素值减1，从2变成1,，代表着下次再遇到94分的成绩时（实际上已经遇不到了），最终排名是第1。 第三步，我们遍历成绩表倒数第三行的小红：小红是95分，我们找到countArray下标是5的元素，值是3（最初是4，减1变成了3），代表小红的成绩排名位置在第3位。同时，我们给countArray下标是5的元素值减1，从3变成2,，代表着下次再遇到95分的成绩时（实际上已经遇不到了），最终排名是第2。 这样一来，同样是95分的小红和小绿就能够清楚地排出顺序了，也正因此，优化版本的计数排序属于稳定排序。 计数排序代码实现（优化后）其中关键的地方有两个：第一，在于理解计算max和min之后，需要使用原数组每一个元素减去min的转换值统计词频，特定情况下能节省存储空间，这样做的另一个好处是可以兼容负数的情况，因为每一个元素减去最小值之后，结果必定是大于等于0； 第二，在于理解为什么采用词频求和的方式 + 倒序遍历原始数组的方式，能保证排序算法的稳定性。 这里必须从后向前遍历，只有这样出现重复的元素，才会保持顺序的把最后面的重复元素，永远放在最右边。从而保证排序的稳定性，如果从前向后排序，重复元素的顺序，刚好相反，所以就不是稳定的算法。 计数排序代码实现（优化后）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class CountSort &#123; public static int[] countSort(int[] arr) &#123; // 1. 得到数列的最大值和最小值，并计算出差值d int max = arr[0]; int min = arr[0]; for (int i = 1; i &lt; arr.length; i++) &#123; if (arr[i] &gt; max) &#123; max = arr[i]; &#125; if (arr[i] &lt; min) &#123; min = arr[i]; &#125; &#125; int d = max - min; // 2. 创建统计数组并统计对应元素个数 int[] countArray = new int[d + 1]; for (int i = 0; i &lt; arr.length; i++) &#123; countArray[arr[i] - min]++; &#125; // 3. 统计数组做变型，后面的元素等于前面的元素之和 int sum = 0; for (int i = 0; i &lt; countArray.length; i++) &#123; sum += countArray[i]; countArray[i] = sum; &#125; // 4. 倒序遍历原始数组，从统计数组找到正确位置，输出到结果数组 int[] sortedArray = new int[arr.length]; for (int i = arr.length - 1; i &gt;= 0; i--) &#123; /*sortedArray[countArray[arr[i] - min] - 1] = arr[i]; * countArray[arr[i] - min]--; */ // arr[i]-min找到这个数在countArray中的位置 int sumCount = countArray[arr[i] - min]; //得到实际排序后的位置 int sortedPos = sumCount - 1; // 向最终结果里存放元素 sortedArray[sortedPos] = arr[i]; // 针对重复的元素，先放后面，然后减1，下次循环就会放在前面 countArray[arr[i] - min]--; &#125; return sortedArray; &#125; public static void main(String[] args) &#123; int[] arr = &#123; 95, 94, 91, 98, 99, 90, 99, 93, 91, 92 &#125;; int[] sortedArray = countSort(arr); System.out.println(Arrays.toString(sortedArray)); &#125;&#125; 复杂度分析及稳定性算法复杂度：时间复杂度（平均）： O(n+m)时间复杂度（最坏）： O(n+m)时间复杂度（最好）： O(n+m) 空间复杂度： O(m)计数排序是稳定的排序算法。 如果原始数列的规模是N，最大最小整数的差值是M，计数排序的时间复杂度和空间复杂度。代码第1, 2, 4步都涉及到遍历原数列，运算量都是N，第3步遍历统计数列，运算量是M，所以总体运算量是3N + M，去掉系数，时间复杂度是O(n+m)。 至于空间复杂度，如果不考虑结果数组，只考虑统计数组 countArray 大小的话，空间复杂度是O(m)。 计数排序存在它的局限性： 当数列最大值最小值差距过大时，并不使用计数排序。比如给定20个随机整数，范围在0到1亿之间，这时候如果使用计数排序，需要创建长度1亿的数组。不但严重浪费空间，而且时间复杂度也随之升高。 当数列元素不是整数，并不适用计数排序。如果数列中的元素都是小数，比如25.213，或是0.00000001这样子，则无法创建对应的统计数组。这样显然无法进行计数排序。 基于这些局限性，另一种线性时间排序算法对此做出了弥补，这种排序算法叫做 桶排序。]]></content>
      <categories>
        <category>Sorting</category>
      </categories>
      <tags>
        <tag>sort</tag>
        <tag>CountSort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序(7) 快速排序]]></title>
    <url>%2F2019%2F04%2F01%2Fquick-sort.html</url>
    <content type="text"><![CDATA[快速排序的基本思想：通过一趟排序将待排数列分隔成独立的两部分，其中一部分数列的关键字均比另一部分的关键字小，则可分别对这两部分数列继续进行排序，以达到整个序列有序。 其中，最重要的partition主要有两种方法： 1)指针交换法。先把选定为pivot的元素放到最后，然后设定指针low和指针high，low指针右移，high指针左移，当两个指针相撞后停止移动。期间如果符合交换条件，两元素交换。最后把pivot元素放到中间。 2)挖坑法。类似冒泡排序的思路，把比pivot大的元素“往下沉”，把比pivot小的元素“往上浮”。 快速排序思想快速排序是从冒泡排序演变而来的算法，但是使用了 分治法，比冒泡排序要高效得多，所以叫快速排序。 同冒泡排序一样，快速排序也属于交换排序，通过元素之间的比较和交换位置来达到排序的目的。 不同的是，冒泡排序在每一轮只把一个元素冒泡到数列的一端，而快速排序 在每一轮挑选一个基准元素，并让其他比它大的元素移动到数列一边，比它小的元素移动到数列的另一边，从而把数列拆解成了两个部分。这种思路就叫做分治法。 在分治法的思想下，原数列在每一轮被拆成两部分，每一部分在下一轮又分别被拆成两部分，直到不可再分为止。 基准元素的选择：最简单的方式是选择数列的第一个元素。但是假如有一个原本逆序的数列，期望排序成顺序数列，这样数列每一轮仅仅确定了基准元素的位置。 第一个元素要么是最小值，要么是最大值，根本无法发挥分治法的优势。 在这种极端情况下，快速排序需要进行n轮，时间复杂度退化成了O(n^2)。 如何避免上述情况的发生，最简单的方法，不选择数列的第一个元素，而是随机选择一个元素作为基准元素。 这样一来，即使在数列完全逆序的情况下，也可以有效地将数列分成两部分。当然，即使是随机选择基准元素，每一次也有极小的几率选到数列的最大值或最小值，同样会影响到分治的效果。 快速排序是目前被认为最好的一种内部排序方法。快速排序算法处理的最好情况指每次都是将待排序数列划分为均匀的两部分，通常认为快速排序的平均时间复杂度是O(nlogn)。 但是，快速排序的最差情况就是基本逆序或者基本有序的情况，那么此时快速排序将蜕化成冒泡排序，其时间复杂度为O(n^2) 元素的移动选定了基准元素，要做的就是把其他元素当中小于基准元素的都移动到基准元素一边，大于基准元素的都移动到基准元素另一边。有两种方法： 挖坑法 指针交换法 快排（挖坑法）快速排序挖坑法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class QuickSort &#123; public static void quickSort(int[] arr, int startIndex, int endIndex) &#123; //递归结束条件 if (startIndex &gt;= endIndex) &#123; return; &#125; // 得到基准元素位置 int pivotIndex = partition(arr, startIndex, endIndex); // 用分治法递归数列两部分 quickSort(arr, startIndex, pivotIndex - 1); quickSort(arr, startIndex + 1, endIndex); &#125; private static int partition(int[] arr, int startIndex, int endIndex) &#123; // 取第一个位置的元素作为基准元素 int pivot = arr[startIndex]; int left = startIndex; int right = endIndex; // 坑的位置，初始等于pivot的位置 int index = startIndex; // 大循环左右指针重合或者指针交换时结束 while (right &gt;= left) &#123; // right指针从右向左进行比较 while (right &gt;= left) &#123; if (arr[right] &lt; pivot) &#123; arr[left] = arr[right]; index = right; left++; break; &#125; right--; &#125; //left指针从左向右进行比较 while (right &gt;= left) &#123; if (arr[left] &gt; pivot) &#123; arr[right] = arr[left]; index = left; right--; break; &#125; left++; &#125; &#125; arr[index] = pivot; return index; &#125; public static void main(String[] args) &#123; int[] arr = &#123; 4, 7, 6, 5, 3, 2, 8, 1 &#125;; quickSort(arr, 0, arr.length - 1); System.out.println(Arrays.toString(arr)); &#125;&#125; 指针交换法代码实现和挖坑法相比，指针交换法在partition方法中进行的元素交换次数更少。 对于数列 {4, 7, 6, 5, 3, 2, 8, 1 } 由于left一开始指向的是基准元素，判断肯定相等，所以left右移一位。 进入第四次循环，right移动到元素3停止，这时候请注意，left和right指针已经重合在了一起。 当left和right指针重合之时，我们让pivot元素和left与right重合点的元素进行交换。此时数列左边的元素都小于4，数列右边的元素都大于4，这一轮交换终告结束。 快速排序指针交换法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class QuickSort &#123; public static quickSort(int[] arr, int startIndex, int endIndex) &#123; if (startIndex &gt;= endIndex) &#123; return; &#125; // 得到基准信息 int pivotIndex = partition(arr, startIndex, endIndex); //根据基准元素，分成两部分进行递归 quickSort(arr, startIndex, pivotIndex - 1); quickSort(arr, pivotIndex + 1, endIndex); &#125; private static int partition(int[] arr, int startIndex, int endIndex) &#123; // 取第一个元素作为基准元素 int pivot = arr[startIndex]; int left = startIndex; int right = endIndex; while (left != right) &#123; // 控制right指针比较并左移 while (left &lt; right &amp;&amp; arr[right] &gt; pivot) &#123; right--; &#125; // 控制left指针比较并左移 while (left &lt; right &amp;&amp; arr[left] &lt;= pivot) &#123; left++; &#125; // 交换left和right指向的元素 if (left &lt; right) &#123; int tmp = arr[left]; arr[left] = arr[right]; arr[right] = tmp; &#125; &#125; // pivot和指针重合交换 int tmp = arr[left]; arr[left] = arr[startIndex]; arr[startIndex] = tmp; return left; &#125; public static void main(String[] args) &#123; int[] arr = &#123; 4, 7, 6, 5, 3, 2, 8, 1 &#125;; quickSort(arr, 0, arr.length - 1); System.out.println(Arrays.toString(arr)); &#125;&#125; partition函数的单边循环法无论是挖坑法还是指针交换法，都是一层循环内嵌一层循环，从数组的两边交替遍历元素，代码不够简洁。单边循环法只从数组的一边对元素进行遍历和交换。 单边循环法1234567891011121314151617181920212223242526public static void quickSort(int[] arr, int startIndex, int endIndex) &#123; if (startIndex &gt;= endIndex) &#123; return; &#125; int pivotIndex = partition(arr, startIndex, endIndex); quickSort(arr, startIndex, pivotIndex - 1); quickSort(arr, pivotIndex + 1, endIndex);&#125;private static int partition(int[] arr, int startIndex, int endIndex) &#123; int pivot = arr[startIndex]; int mark = startIndex; for (int i = startIndex + 1; i &lt;= endIndex; i++) &#123; if (arr[i] &lt; pivot) &#123; mark++; int tmp = arr[mark]; arr[mark] = arr[i]; arr[i] = tmp; &#125; &#125; arr[startIndex] = arr[mark]; arr[mark] = pivot; return mark;&#125; 非递归实现上面的代码都是依靠递归来实现的，绝大多数用递归来实现的问题，都可以用栈的方式来代替。因为我们代码中一层一层的方法调用，本身就是一个函数栈。每次进入一个新方法，就相当于入栈；每次有方法返回，就相当于出栈。所以，我们可以把原本的递归实现转化成一个栈的实现，在栈当中存储每一次方法调用的参数： 使用非递归实现快速排序12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public class QuickSort &#123; public static void quickSort(int[] arr, int startIndex, int endIndex) &#123; // 用一个集合栈来代替递归的函数栈 Stack&lt;Map&lt;String, Integer&gt;&gt; quickSortStack = new Stack&lt;&gt;(); // 整个数列的起止下标，以哈希的形式入栈 Map&lt;String, Integer&gt; rootParam = new HashMap&lt;&gt;(); rootParam.put("startIndex", startIndex); rootParam.put("endIndex", endIndex); quickSortStack.push(rootParam); // 循环结束条件，栈为空时结束 while (!quickSortStack.isEmpty()) &#123; // 栈顶元素出栈，得到起止下标 Map&lt;String, Integer&gt; param = quickSortStack.pop(); // 得到基准元素位置 int pivotIndex = partition(arr, param.get("startIndex"), param.get("endIndex")); // 根据基准元素分成两部分，把每一部分的起止下标入栈 if (param.get("startIndex") &lt; pivotIndex - 1) &#123; Map&lt;String, Integer&gt; leftParam = new HashMap&lt;&gt;(); leftParam.put("startIndex", param.get("startIndex")); leftParam.put("endIndex", pivotIndex - 1); quickSortStack.push(leftParam); &#125; if (param.get("endIndex") &gt; pivotIndex + 1) &#123; Map&lt;String, Integer&gt; rightParam = new HashMap&lt;&gt;(); rightParam.put("startIndex", pivotIndex + 1); rightParam.put("endIndex", param.get("endIndex")); quickSortStack.push(rightParam); &#125; &#125; &#125; private static int partition(int[] arr, int startIndex, int endIndex) &#123; // 取第一个元素作为基准元素 int pivot = arr[startIndex]; int left = startIndex; int right = endIndex; while (left != right) &#123; // 控制right指针比较并左移 while (left &lt; right &amp;&amp; arr[right] &gt; pivot) &#123; right--; &#125; // 控制left指针比较并右移 while (left &lt; right &amp;&amp; arr[left] &lt;= pivot) &#123; left++; &#125; // 交换left和right指向的元素 if (left &lt; right) &#123; int tmp = arr[left]; arr[left] = arr[right]; arr[right] = tmp; &#125; &#125; // pivot和指针重合点交换 int tmp = arr[left]; arr[left] = arr[startIndex]; arr[startIndex] = tmp; return left; &#125; public static void main(String[] args) &#123; int[] arr = new int[] &#123; 4, 7, 6, 5, 3, 2, 8, 1 &#125;; quickSort(arr, 0, arr.length - 1); System.out.print(Arrays.toString(arr)); &#125;&#125; 和刚才的递归实现相比，代码的变动仅仅在quickSort方法当中。该方法中引入了一个存储Map类型元素的栈，用于存储每一次交换时的起始下标和结束下标。 每一次循环，都会让栈顶元素出栈，进行排序，并且按照基准元素的位置分成左右两部分，左右两部分再分别入栈。当栈为空时，说明排序已经完毕，退出循环。 改进主元选择的快排在线性表中的第一个元素、中间元素和最后一个元素中选择一个 中位数作主元。 中位数选择的函数，如（1, 3, 5）选择31234public static int median(int first, int middle, int last) &#123; return Math.max(Math.min(first, middle), Math.min(Math.max(first, middle), last)); &#125; 复杂度及稳定性算法复杂度：时间复杂度（平均）： O(nlogn)时间复杂度（最坏）： O(n^2)时间复杂度（最好）： O(nlogn) 空间复杂度： O(nlogn)快速排序是不稳定的排序算法。 快速排序有两个方向，左边的left指针一直往右走，当arr[left] &lt;= pivot。而右边的right指针一直往左走，当arr[right] &gt; pivot。如果left和right都走不动了，left &lt;= right，交换arr[left]和arr[right]，重复上面的过程，直到left &gt; right。 交换arr[left]和arr[startIndex]，完成一趟快速排序。在中枢元素和a[left]交换的时候，很有可能把前面的元素的稳定性打乱，比如序列为5 3 3 4 3 8 9 10 11，现在中枢元素5和3（第5个元素，下标从1开始计）交换就会把元素3的稳定性打乱，所以快速排序是一个不稳定的排序算法，不稳定发生在中枢元素和arr[left] 交换的时刻。 快排和归并归并排序和快速排序都使用了分而治之法。对于归并排序，大量的工作是将两个子线性表进行归并，归并是在两个子线性表都 排好序后进行的。对于快速排序，大量的工作是将线性表划分成两个子线性表，划分是在子线性表 排好序前进行的。最差的情况下，归并排序的效率高于快速排序，但是，在平均情况下，两者效率相同。归并排序在归并两个数组是需要一个临时数组，而快速排序不需要额外的数组空间。因此，快速排序的空间效率高于归并排序。 快排和堆排序相同点：堆排序和快速排序的平均时间复杂度都是O(nlogn)，并且都是 不稳定排序。 不同点：快速排序的最坏时间复杂度是O(n^2)，而堆排序最坏时间复杂度稳定在O(nlogn)。此外，快速排序的递归和非递归的空间复杂度都是O(n)，而堆排序的空间复杂度是O(1)。]]></content>
      <categories>
        <category>Sorting</category>
      </categories>
      <tags>
        <tag>sort</tag>
        <tag>QuickSort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序(6) 归并排序]]></title>
    <url>%2F2019%2F04%2F01%2Fmerge-sort.html</url>
    <content type="text"><![CDATA[归并排序是采用分治法（Divide and Conquer）的一个非常典型的应用。归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(nlogn）的时间复杂度，代价是需要额外的内存空间。 归并排序算法将数组每一次都分解为原来的一半大小的两个子数组，当分解到了右边界比左边界还大的时候，不再分解，开始排序。 然后将排序好的子数组逐级合并，最后得到的结果就是排序好的数组。 归并排序思想归并排序是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。 在这里我们只不过是利用了递归的思想，将数组每一次都分解为原来的一半大小的两个子数组，当分解到了右边界比左边界还大的时候，不再分解，开始排序。然后将排序好的子数组逐级合并，最后得到的结果就是排序好的数组。 首先考虑下如何将两个有序数列合并。这个非常简单，只要从比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可。这需要将待排序序列中的所有记录扫描一遍，因此耗费O(n)时间，而由完全二叉树的深度可知，整个归并排序需要进行 logn次，因此，总的时间复杂度为O(nlogn)。 归并排序在归并过程中需要与原始记录序列同样数量的存储空间存放归并结果，因此空间复杂度为O(n)。 归并算法需要两两比较，不存在跳跃，因此归并排序是一种稳定的排序算法。 递归所谓递归，指的是程序直接或间接调用本身的一种方法，它通常把一个大型的、复杂的问题不直接解决，而是转化成为一个与原问题相似的、规模较小的问题来解决。简单来说， 递归就是把问题层层分解，直到程序出口处。任何递归都必须有递归调用的结束条件，否则，程序将会陷入无限递归而无法结束，而这个结束条件满足时，一定不会调用本身，否则递归调用将无法结束。 算法描述归并排序的算法伪代码：归并排序的算法伪代码12345678public static void mergeSort(int[] arr) &#123; if (arr.length &gt; 1) &#123; mergeSort(arr[0 ... arr.length/2]); mergeSort(arr[arr.length/2 + 1 ... arr.length]); merge arr[0 ... arr.length / 2] with arr[arr.length/2 + 1 ... arr.length]; &#125;&#125; 对数列 {2, 9, 5, 4, 8, 1, 6, 7} 进行归并排序。先进行 拆分数列，直到数列只有一个元素为止，然后，再将其 归并为一个新的有序数列。递归调用持续将数组划分为子数组，直到每个子数组只包含一个元素。然后，该算法将这些小的子数组归并为稍大的有序子数组，直到最后形成一个有序的数组。 归并排序（法一）归并排序利用的是分治的思想，对于给定的一组数据，利用递归与分治技术将数据序列划分成为越来越小的子序列，之后对子序列排序，后再用递归方法将排好序的子序列合并成为有序序列。 合并两个子序列时，需要申请两个子序列加起来长度的内存，临时存储新的生成序列，再将新生成的序列赋值到原数组相应的位置。MergeSort方法在分解过程中创建两个临时数组，将数组前半部分和后半部分复制到临时数组中，对临时数组排序，然后将它们归并到原始数组中，这样产生很多额外的空间开销。 代码如下： 归并排序（）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class MergeSort &#123; public static void mergeSort(int[] list) &#123; if (list.length &gt; 1) &#123; // 对前半部分进行归并 int[] firstHalf = new int[list.length / 2]; System.arraycopy(list, 0, firstHalf, 0, list.length / 2); mergeSort(firstHalf); // 对后半部分进行归并 int secondHalfLength = list.length - list.length / 2; int[] secondHalf = new int[secondHalfLength]; System.arraycopy(list, list.length / 2, secondHalf, 0, secondHalfLength); mergeSort(secondHalf); // 把两部分数列合并到一个数列中 merge(firstHalf, secondHalf, list); &#125; &#125; public static void merge(int[] list1, int[] list2, int[] temp) &#123; int current1 = 0; int current2 = 0; int current3 = 0; while (current1 &lt; list1.length &amp;&amp; current2 &lt; list2.length) &#123; if (list1[current1] &lt; list2[current2]) temp[current3++] = list1[current1++]; else temp[current3++] = list2[current2++]; &#125; while (current1 &lt; list1.length) temp[current3++] = list1[current1++]; while (current2 &lt; list2.length) temp[current3++] = list2[current2++]; &#125; public static void main(String[] args) &#123; int[] list = &#123; 2, 3, 2, 5, 6, 1, -2, 3, 14, 12 &#125;; mergeSort(list); for (int i = 0; i &lt; list.length; i++) System.out.print(list[i] + " "); &#125;&#125; 在方法二中，递归地对数组的前半部分和后半部分进行排序，而不创建新的临时数组，然后把两个数组归并到一个临时数组中并将它的内容复制到初始数组中。 归并排序（推荐）归并排序（法二）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class MergeSort &#123; public static void mergeSort(int[] arr, int left, int right) &#123; if (left == right) &#123; return; &#125; else &#123; // 取中间的数进行拆分 int mid = (left + right) / 2; // 左边的数不断进行拆分 mergeSort(arr, left, mid); // 右边的数不断进行拆分 mergeSort(arr, mid + 1, right); // 合并 merge(arr, left, mid + 1, right); &#125; &#125; public static void merge(int[] arr, int left, int mid, int right) &#123; int[] leftArray = new int[mid - left]; int[] rightArray = new int[right - mid + 1]; for (int i = left; i &lt; mid; i++) &#123; leftArray[i - left] = arr[i]; &#125; for (int i = mid; i &lt;= right; i++) &#123; rightArray[i - mid] = arr[i]; &#125; int i = 0, j = 0; int k = left; while (i &lt; leftArray.length &amp;&amp; j &lt; rightArray.length) &#123; if (leftArray[i] &lt; rightArray[j]) &#123; arr[k++] = leftArray[i++]; &#125; else &#123; arr[k++] = rigthArray[j++]; &#125; &#125; while (i &lt; leftArray.length) &#123; arr[k++] = leftArray[i++]; &#125; while (j &lt; rightArray.length) &#123; arr[k++] = rigthArray[j++]; &#125; &#125; public static void main(String[] args) &#123; int[] arrays = &#123; 9, 2, 5, 1, 3, 2, 1, 3, 2, 8, 7, 10 &#125;; //设置4个值的断点查看递归调用栈变化 //int[] arrays = &#123; 9, 2, 5, 1 &#125;; mergeSort(arrays, 0, arrays.length - 1); System.out.println(Arrays.toString(arrays)); &#125;&#125; 可以在Eclipse的debug中设置断点，查看递归调用和返回的次序，注意观察变量值的变化。 算法复杂度及稳定性算法复杂度：时间复杂度（平均）： O(nlogn)时间复杂度（最坏）： O(nlogn)时间复杂度（最好）： O(nlogn) 空间复杂度： O(n) 在这里我们只不过是利用了递归的思想，将数组每一次都分解为原来的一半大小的两个子数组，当分解到了右边界比左边界还大的时候，不再分解，开始排序。然后将排序好的子数组逐级合并，最后得到的结果就是排序好的数组。 原数组的长度为n，则细分得最大深度为logn，每一层需要排序的元素为n；则归并排序的时间复杂度为O(nlogn)。 稳定性：因为交换元素时，可以在相等的情况下做出不移动的限制，所以归并排序是可以稳定的。]]></content>
      <categories>
        <category>Sorting</category>
      </categories>
      <tags>
        <tag>MergeSort</tag>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序(5) 鸡尾酒排序]]></title>
    <url>%2F2019%2F04%2F01%2Fcock-tail-sort.html</url>
    <content type="text"><![CDATA[冒泡排序已经对算法进行有优化，但仍然不是最优。鸡尾酒排序又叫快乐小时排序，它基于冒泡排序又做了一点优化。博客中给出了鸡尾酒排序的优化版本。 鸡尾酒排序原理回顾冒泡排序的思想：冒泡排序的每一个元素都可以像一个小气泡一样，根据自身大小，一点一点向着数组的一侧移动。算法的每一轮都是 从左到右比较元素，进行单向的位置交换。 那么鸡尾酒排序做了怎样的优化呢？鸡尾酒排序的元素比较和交换过程是 双向的。 举个例子：有8个数组成一个无序数列 {2, 3, 4, 5, 6, 7, 8, 1}，希望从小到大排序 冒泡排序过程省略，可以看出来，需要将1进行7轮排序。 按照冒泡排序，事实上，2到8已经是有序了，只有元素1的位置不对，却还要进行7轮排序！！这明显不合理，需要改进。而鸡尾酒排序正是要解决这种问题。 鸡尾酒排序过程那么鸡尾酒排序又是什么样的？下面看看详细过程： 数列{2, 3, 4, 5, 6, 7, 8, 1} 第一轮（和冒泡排序一样，8和1交换）：交换后 {2, 3, 4, 5, 6, 7, 1, 8} 第二轮：反过来 从右往左比较和交换： 8已经处于有序区，我们忽略掉8，让1和7比较。元素1小于7，所以1和7交换位置：{2, 3, 4, 5, 6, 1, 7, 8} 接下来1和6比较，元素1小于6，所以1和6交换位置：{2, 3, 4, 5, 1, 6, 7, 8} 接下来1和5比较，元素1小于5，所以1和5交换位置：{2, 3, 4, 1, 5, 6, 7, 8} 接下来1和4交换，1和3交换，1和2交换，最终成为了下面的结果：{1, 2, 3, 4, 5, 6, 7, 8} 第三轮（虽然已经有序，但是流程并没有结束）： 鸡尾酒排序的第三轮，需要重新从左向右比较和交换 1和2比较，位置不变；2和3比较，位置不变；3和4比较，位置不变……6和7比较，位置不变。 没有元素位置交换，证明已经有序，排序结束。 以上就是鸡尾酒排序的思路。排序过程就像钟摆一样，第一轮从左到右，第二轮从右到左，第三轮再从左到右…… 原始实现下面这段代码是鸡尾酒排序的原始实现。代码外层的大循环控制着所有排序回合，大循环内包含两个小循环，第一个循环从左向右比较并交换元素，第二个循环从右向左比较并交换元素。 鸡尾酒排序java原始实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class CockTailSort &#123; public static void cockTailSort(int[] arr) &#123; int tmp = 0; for (int i = 0; i &lt; arr.length / 2; i++) &#123; //有序标记，每一轮的初始是true boolean isSorted = true; //奇数轮，从左向右比较和交换 for (int j = i; j &lt; arr.length - i - 1; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; tmp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = tmp; //有元素交换，所以不是有序，标记变为false isSorted = false; &#125; &#125; if (isSorted) &#123; break; &#125; //偶数轮之前，重新标记为true isSorted = true; //偶数轮，从右向左比较和交换 for (int j = arr.length - i - 1; j &gt; i; j--) &#123; if (arr[j] &lt; arr[j - 1]) &#123; tmp = arr[j]; arr[j] = arr[j - 1]; arr[j -1] = tmp; //有元素交换，所以不是有序，标记变为false isSorted = false; &#125; &#125; if (isSorted) &#123; break; &#125; &#125; &#125; public static void main (String[] args) &#123; int[] list = &#123;2, 32, 3, 34, 45, 8, 89, 20, 23, -1, -2, -3, -25&#125;; cockTailSort(list); for (int i: list) System.out.print(i + " "); System.out.println(); &#125;&#125; 鸡尾酒排序进一步优化在将冒泡排序的时候，有一种针对有序区的优化，鸡尾酒排序也可以根据这个思路来进行优化。 回顾一下冒泡排序针对有序区的优化思路：原始的冒泡排序，有序区的长度和排序的轮数是相等的。比如第一轮排序过后的有序区长度是1，第二轮排序过后的有序区长度是2…… 要想优化，我们可以在每一轮排序的最后，记录下最后一次元素交换的位置，那个位置也就是无序数列的边界，再往后就是有序区了。 对于单向的冒泡排序，我们需要设置一个边界值，对于 双向的鸡尾酒排序，我们需要设置两个边界值。 优化边界条件的鸡尾酒排序代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class CockTailSort &#123; public static void cockTailSort(int[] arr) &#123; int tmp = 0; int lastRightExchangedIndex = 0; //记录右侧最后一次交换的位置 int lastLeftExchangedIndex = 0; //记录左侧最后一次交换的位置 //无序数列的右边界，每次比较只需要比到这里为止 int rigthSortBorder = arr.length - 1; //无序数列的左边界，每次比较只需要比到这里为止 int leftSortBorder = 0; for (int i = 0; i &lt; arr.length / 2; i++) &#123; boolean isSorted = true; //奇数轮，从左向右比较和交换 for (int j = leftSortBorder; j &lt; rigthSortBorder; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; tmp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = tmp; isSorted = false; lastRightExchangedIndex = j; &#125; &#125; rigthSortBorder = lastRightExchangedIndex; if (isSorted) &#123; break; &#125; isSorted = true; //偶数轮，从右向左比较和交换 for (int j = rigthSortBorder; j &gt; leftSortBorder; j--) &#123; if (arr[j] &lt; arr[j - 1]) &#123; tmp = arr[j]; arr[j] = arr[j - 1]; arr[j - 1] = tmp; isSorted = false; lastLeftExchangedIndex = j; &#125; &#125; leftSortBorder = lastLeftExchangedIndex; if (isSorted) &#123; break; &#125; &#125; &#125;&#125; 代码中使用了左右两个边界值，rightSortBorder 代表右边界，leftSortBorder代表左边界。 在比较和交换元素时，奇数轮从 leftSortBorder 遍历到 rightSortBorder 位置，偶数轮从 rightSortBorder 遍历到 leftSortBorder 位置。 复杂度及稳定性鸡尾酒排序的优点是能够在特定条件下，减少排序的回合数；缺点是，代码量几乎扩大了一倍。 至于能发挥出优势的场景，就是在 大部分元素已经有序 的情况下，比冒泡完美版还要好。 但是鸡尾酒排序即使优化了，时间复杂度也是O(n^2)，和冒泡排序的是时间复杂度相同。]]></content>
      <categories>
        <category>Sorting</category>
      </categories>
      <tags>
        <tag>sort</tag>
        <tag>CockTailSort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序(4) 冒泡排序]]></title>
    <url>%2F2019%2F04%2F01%2Fbubble-sort.html</url>
    <content type="text"><![CDATA[冒泡排序算法多次遍历数组，在每次遍历中连续比较相邻的元素，如果元素没有按照顺序排列，则互换他们的值。 博客中先给出了朴素版本，再给出了优化了每一轮内循环结束点（减少遍历轮次）的needNextPass版本和isSorted版本，还有进一步优化判断边界的sortBorder版本，sortBorder版本为最优化版本。 冒泡排序原理冒泡排序算法需要遍历几次数组。在每次遍历中，比较连续相邻的元素。如果某一堆元素是降序，则互换他们的值；否则，保持不变。由于较小的值像“气泡”一样逐渐浮向顶部，而较大的值沉向底部，由此得名冒泡排序（bubble sort）或下沉排序（sinking sort）。 冒泡排序的名字很形象，实际实现是相邻两节点进行比较，大的向后移一个，经过第一轮两两比较和移动，最大的元素移动到了最后，第二轮次大的位于倒数第二个，依次进行。这是最基本的冒泡排序，还可以进行一些优化。 优化一： 如果某一轮两两比较中没有任何元素交换，这说明已经都排好序了，算法结束，可以使用一个isSorted做标记，默认为true，如果发生交互则置为false，每轮结束时检测isSorted，如果为false则继续，如果为true则返回。 优化二： 某一轮结束位置为j，但是这一轮的最后一次交换发生在lastExchangedIndex的位置，则lastExchangedIndex到j之间是排好序的，下一轮的结束点就不必是j–了，而直接到lastExchangedIndex即可。 算法描述第一次遍历后，最后一个元素称为数组中的最大数。第二次遍历后，倒数第二个元素成为数组中的第二大数。整个过程持续到所有元素都已排好序。第k次遍历时，不需要考虑最后k-1个元素，因为它们已经排好序了。 朴素版本伪代码描述：朴素版本伪代码123456for (int k = 1; k &lt; arr.length; k++) &#123; for (int i = 0; i &lt; arr.length - k; i++) &#123; if (arr[i] &gt; arr[i + 1]) swap arr[i] with arr[i + 1]; &#125;&#125; 注意到如果在某次遍历中没有发生交换，那么就不必进行下一次遍历，因为所有的元素已经排好序了。可以用下面的伪代码描述needNextPass版本：如果某一轮两两比较中没有任何元素交换，这说明已经都排好序了，算法结束，可以使用一个needNextPass做标记，默认为false，如果发生交互则置为true，每轮结束时检测needNextPass，如果为true则继续，如果为false则返回。 needNextPass版本伪代码123456789101112boolean needNextPass = true;for (int k = 1; k &lt; arr.length &amp;&amp; needNextPass; k++) &#123; // 数组可能已经排好序，不需要再进入下次循环 needNextPass = false; // 第k次遍历 for (int i = 0; i &lt; arr.length - k; i++) &#123; if (arr[i] &gt; arr[i + 1]) &#123; swap arr[i] with arr[i + 1]; needNextPass = true; &#125; &#125;&#125; 冒泡排序朴素版本代码非常简单，使用双循环来进行排序。外部循环控制所有的回合，内部循环代表每一轮冒泡处理，先进行元素比较，再进行元素交换。这种写法不会拿到offer的。 java实现朴素版本12345678910111213141516171819202122public class BubbleSort &#123; public static void bubbleSort(int[] arr) &#123; int tmp = 0; for (int i = 0; i &lt; arr.length; i++) &#123; // 内部循环代表每一轮冒泡处理 for (j = 0; j &lt; arr.length - i - 1; j++) &#123; if (arr[j + 1] &lt; arr[j]) &#123; tmp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = tmp; &#125; &#125; &#125; &#125; public static void main(String[] args) &#123; int[] array = new int[] &#123; 5, 8, 6, 3, 9, 2, 1, 7 &#125;; bubbleSort(array); System.out.println(Arrays.toString(array)); &#125;&#125; 很明显可以看出，自从经过第六轮排序，整个数列已然是有序的了。可是我们的排序算法仍然“兢兢业业”地继续执行第七轮、第八轮。这种情况下，如果我们能判断出数列已经有序，并且做出标记，剩下的几轮排序就可以不必执行，提早结束工作。 冒泡排序优化一第一步优化，可以使用needNextPass版本或者isSorted版本。这两个版本的含义，从两个flag的字面就能理解其作用。本质上是一样的。 needNextPass版本代码如果某一轮两两比较中没有任何元素交换，这说明已经都排好序了，那么就不必进行下一次遍历，因为所有的元素都已排好序，算法结束。 可以使用一个needNextPass做标记，默认为false，如果发生交换则置为true，每轮结束时检测needNextPass，如果为true则继续，如果为false则返回。 needNextPass版本123456789101112131415161718192021222324252627public class BubbleSort &#123; public static void bubbleSort(int[] arr) &#123; boolean needNextPass = true; for (int i = 1; i &lt; arr.length &amp;&amp; needNextPass; i++) &#123; needNextPass = false; for (int j = 0; j &lt; arr.length - i; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; int tmp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = tmp; // 改变标志位 needNextPass = true; &#125; &#125; &#125; &#125; public static void main(String[] args) &#123; int[] list = &#123; 2, 32, 3, 34, 45, 8, 89, 20, 23, -1, -2 &#125;; bubbleSort(list); for (int i : list) System.out.print(i + " "); System.out.println(); &#125;&#125; isSorted版本代码这一版代码做了小小的改动，利用布尔变量isSorted作为标记。如果在本轮排序中，元素有交换，则说明数列无序；如果没有元素交换，说明数列已然有序，直接跳出大循环。 如果某一轮两两比较中没有任何元素交换，这说明已经都排好序了，算法结束，可以使用一个isSorted做标记，默认为true，如果发生交换则置为false，每轮结束时检测isSorted，如果为false则继续，如果为true则返回。 isSorted版本12345678910111213141516171819202122232425262728293031public class BubbleSort &#123; public static void bubbleSort(int[] arr) &#123; int tmp = 0; for (int i = 0; i &lt; arr.length; i++) &#123; boolean isSorted = true; for (int j = 0; j &lt; arr.length - i - 1; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; tmp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = tmp; isSorted = false; &#125; &#125; if (isSorted) &#123; break; &#125; &#125; &#125; public static void main(String[] args) &#123; int[] list = &#123; 2, 32, 3, 34, 45, 8, 89, 20, 23, -1, -2 &#125;; bubbleSort(list); for (int i : list) System.out.print(i + " "); System.out.println(); &#125;&#125; sortBorder版本(结合优化一和优化二)具体分析为了说明问题，用下面的数列为例（在纸上演示一下）：{3, 4, 2, 1, 5, 6, 7, 8}这个数组的特点是前半部分{3, 4, 2, 1}无序，后半部分{5, 6, 7, 8}有序，并且后半部分的元素已经是数列最大值。 按照冒泡排序的思路来排序： 第一轮： 元素3和4比较，发现3小于4，所以位置不变； 元素4和2比较，发现4大于2，所以4和2交换； 元素4和1比较，发现4大于1，所以4和1交换。 此时数列：{3, 2, 1, 4, 5, 6, 7, 8} 但是接下来： 元素4和5比较，发现4小于5，所以位置不变； 元素5和6比较，发现5小于6，所以位置不变； 元素6和7比较，发现6小于7，所以位置不变； 元素7和8比较，发现7小于8，所以位置不变。 第一轮结束，数列有序区包含一个元素： 8{3, 2, 1, 4, 5, 6, 7, 8} 第二轮： 元素3和2比较，发现3大于2，所以3和2交换； 元素3和1比较，发现3大于1，所以3和1交换。 此时数列：{2, 1, 3, 4, 5, 6, 7, 8} 但是接下来 元素3和4比较，发现3小于4，所以位置不变； 元素4和5比较，发现4小于5，所以位置不变； 元素5和6比较，发现5小于6，所以位置不变； 元素6和7比较，发现6小于7，所以位置不变； 元素7和8比较，发现7小于8，所以位置不变。 第二轮结束，数列有序区包含一个元素： 7, 8{2, 1, 3, 4, 5, 6, 7, 8} 由上面两轮分析，发现问题：右面的许多元素已经是有序了，可是每一轮还是白白比较了许多次。这正是冒泡排序当中另一个需要优化的点。 接下来的讨论，在代码实现部分进行。 完全优化版本代码这个问题的关键点在哪里呢？关键在于对数列有序区的界定。 按照现有的逻辑，有序区的长度和排序的轮数是相等的。比如第一轮排序过后的有序区长度是1，第二轮排序过后的有序区长度是2,…… 实际上，数列真正的有序区可能会大于这个长度，比如例子中仅仅第二轮，后面5个元素实际都已经属于有序区。因此后面的许多次元素比较是没有意义的。 如何避免这种情况呢？我们可以在每一轮排序的最后，记录下最后一次元素交换的位置，那个位置也就是无序数列的边界，再往后就是有序区了。 sortBorder版本（完美版本）1234567891011121314151617181920212223242526272829303132333435363738public class BubbleSort &#123; public static void bubbleSort(int[] arr) &#123; int tmp = 0; //记录最后一次交换的位置 int lastExchangedIndex = 0; //无序数列的边界，每次比较只需要比到这里为止 int sortBorder = arr.length - 1; for (int i = 0; i &lt; arr.length; i++) &#123; //有序标记，每一轮的初始是true boolean isSorted = true; for (int j = 0; j &lt; sortBorder; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; tmp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = tmp; //有元素交换，所以不是有序，标记变为false isSorted = false; //把无序数列的边界更新为最后一次交换元素的位置 lastExchangedIndex = j; &#125; &#125; sortBorder = lastExchangedIndex; if (isSorted) &#123; break; &#125; &#125; &#125; public static void main(String[] args) &#123; int[] array = new int[] &#123; 5, 8, 6, 3, 9, 2, 1, 7 &#125;; bubbleSort(array); System.out.println(Arrays.toString(array)); &#125;&#125; 这一版代码中，sortBorder就是无序数列的边界。每一轮排序过程中，sortBorder之后的元素就完全不需要比较了，肯定是有序的。 算法复杂度和稳定性其实这样的实现，仍然不是最优，有一种排序算法叫做 鸡尾酒排序，是基于冒泡排序的一种升级。具体见博客鸡尾酒排序。 算法复杂度：时间复杂度（平均）： O(n^2)时间复杂度（最坏）： O(n^2)时间复杂度（最好）： O(n) 空间复杂度： O(1) 冒泡排序把小元素往前调或者把大元素往后调，在相邻的两个元素间比较和交换。如果两个元素相等且相邻，它们不会进行交换；如果两个相等的元素没有相邻，那么即使通过前面的两两交换把两个相邻起来，这时候也不会交换。 所以相同元素的前后顺序并没有改变，冒泡排序是一种 稳定排序算法。]]></content>
      <categories>
        <category>Sorting</category>
      </categories>
      <tags>
        <tag>sort</tag>
        <tag>BubbleSort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序(3) 希尔排序]]></title>
    <url>%2F2019%2F04%2F01%2Fshell-sort.html</url>
    <content type="text"><![CDATA[希尔排序又叫缩小增量排序，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。 希尔排序是对插入排序的优化，基于以下两个认识：1.数据量较小时插入排序速度较快，因为n和n²差距很小；2.数据基本有序时插入排序效率很高，因为比较和移动的数据量少。 希尔排序的时间复杂度和增量的选择策略有关，博客中的选择策略会导致排序的不稳定性。 希尔排序原理因此，希尔排序的基本思想是，将需要排序的序列划分成为若干个较小的子序列，对子序列进行插入排序，通过插入排序能够使得原来序列成为基本有序。这样通过对较小的序列进行插入排序，然后对基本有序的数列进行插入排序，能够提高插入排序算法的效率。 希尔排序的划分子序列不是像归并排序那种的二分，而是采用的叫做增量的技术，例如有十个元素的数组进行希尔排序，首先选择增量为10/2=5，此时第1个元素和第（1+5）个元素配对成子序列使用插入排序进行排序，第2和（2+5）个元素组成子序列，完成后增量继续减半为2，此时第1个元素、第（1+2）、第（1+4）、第（1+6）、第（1+8）个元素组成子序列进行插入排序。这种增量选择方法的好处是可以使数组整体均匀有序，尽可能的减少比较和移动的次数。二分法中即使前一半数据有序，后一半中如果有比较小的数据，还是会造成大量的比较和移动，因此这种增量的方法和插入排序的配合更佳。 在此我们选择增量gap=length/2，缩小增量继续以gap = gap/2的方式，这种增量选择我们可以用一个序列来表示，{n/2, (n/2)/2, …, 1}，称为增量序列。希尔排序的增量序列的选择与证明是个数学难题，我们选择的这个增量序列是比较常用的，也是希尔建议的增量，称为希尔增量，但其实这个增量序列不是最优的。 希尔排序的时间复杂度和增量的选择策略有关，上述增量方法造成希尔排序的不稳定性。 因为直接插入排序在元素基本有序的情况下，效率是很高的，因此希尔排序在时间效率上有很大提高。 算法描述无序序列：int a[] = {3, 1, 5, 7, 2, 4, 9, 6}; 第一趟时：n=8; gap = n/2 = 4； 把整个序列共分成了4个子序列{3, 2}、{1, 4}、{5, 9}、{7, 6}第一趟结束时，数列为：{2, 1, 5, 6, 3, 4, 9, 7}; 第二趟时：gap = gap/2 = 2； 把整个序列共分成了2个子序列{2, 5, 3, 9}、{1, 6, 4, 7}第一趟结束时，数列为：{2, 1, 3, 4, 5, 6, 9, 7}; 第三趟时：gap = gap/2 = 1； 对整个序列进行 插入排序 ##代码实现Shell排序1234567891011121314151617181920212223public class ShellSort &#123; public static int[] shellSort(int[] arr) &#123; for (int gap = arr.length / 2; gap &gt;= 1; gap /= 2) &#123; // 对子序列插入排序 for (int i = gap; i &lt; arr.length; i++) &#123; int j = i; int currentElement = arr[i]; while (j - gap &gt;= 0 &amp;&amp; arr[j - gap] &gt; currentElement) &#123; arr[j] = arr[j - gap]; j -= gap; &#125; arr[j] = currentElement; &#125; &#125; return arr; &#125; public static void main(String[] args) &#123; int[] testList = new int[] &#123; -6, -3, -2, 7, -15, 1, 2, 2 &#125;; int[] test = shellSort(testList); System.out.println(Arrays.toString(test)); &#125;&#125; 复杂度及稳定性复杂度时间复杂度（平均）： O(n^1.3)时间复杂度（最坏）： O(n^2)时间复杂度（最好）： O(n) 空间复杂度： O(1) 稳定性Shell排序通过将数据分成不同的组，先对每一组进行排序，然后再对所有的元素进行一次插入排序，以减少数据交换和移动的次数。 希尔排序是按照不同步长对元素进行插入排序，当刚开始元素很无序的时候，步长最大，所以插入排序的元素个数很少，速度很快；当元素基本有序了，步长很小，插入排序对于有序的序列效率很高。 由于多次插入排序，我们知道一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱，所以，Shell排序是 不稳定的。 例如，有100个整数需要排序：第一趟排序，先把它分成50组，每组2个整数，分别排序。第二趟排序，再把经过第一趟排序后的100个整数分成25组，每组4个整数，分别排序。第三趟排序，再把前一次排序后的数分成12组，第组8个整数，分别排序。 照这样子分下去，最后一趟分成100组，每组一个整数，这就相当于一次插入排序。由于开始时每组只有很少整数，所以排序很快。之后每组含有的整数越来越多，但是由于这些数也越来越有序，所以排序速度也很快。 希尔排序平均效率是O(nlogn)，其中分组的合理性会对算法产生重要的影响。 Shell排序比冒泡排序快5倍，比插入排序大致快2倍。Shell排序比起QuickSort，MergeSort，HeapSort慢很多。但是它相对比较简单，它适合于数据量在5000以下并且速度并不是特别重要的场合。它对于数据量较小的数列重复排序是非常好的。 由于开始时每组只有很少整数，所以排序很快。之后每组含有的整数越来越多，但是由于这些数也越来越有序，所以排序速度也很快。然而，情况并不总是这么理想的，在一些特定（但并不算罕见）的情况下，虽然经过了很多趟排序但是数据却没有变得更有序。例如，如果用上面的算法对下面这些数进行排序：1, 9, 2, 10, 3, 11, 4, 12, 5, 13, 6, 14, 7, 15, 8, 16 在gap = 1之前的每一趟排序都在浪费时间！ 这种坏情形是可以避免的，就是把上面的增量数列（1, 2, 4, 8）改成Hibbard增量（1, 3, 5, 7）由此可见，增量数列的选择对希尔排序的性能有着极大的影响。 Mark Allen Weiss指出，最好的增量序列是Sedgewick提出的 (1, 5, 19, 41, 109, …)，该序列的项来自 9 4^i - 9 2^i + 1 和 4^i - 3 * 2^i + 1 这两个算式。]]></content>
      <categories>
        <category>Sorting</category>
      </categories>
      <tags>
        <tag>sort</tag>
        <tag>ShellSort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序(2) 插入排序]]></title>
    <url>%2F2019%2F04%2F01%2Finsertion-sort.html</url>
    <content type="text"><![CDATA[插入排序重复地将新的元素插入到一个排好序的子线性表中，直到整个线性表排好序。 遍历数组，遍历到i时，a0,a1,…,ai-1是已经排好序的，取出ai，从ai-1开始向前和每个比较大小，如果小于，则将此位置元素向后移动，继续先前比较，如果不小于，则放到正在比较的元素之后。可见相等元素比较是，原来靠后的还是排在后边，所以插入排序是稳定的。 当待排序的数据基本有序时，插入排序的效率比较高，只需要进行很少的数据移动。 插入排序原理遍历数组，遍历到i时，a0,a1,…,ai-1是已经排好序的，取出ai，从ai-1开始向前和每个比较大小，如果小于，则将此位置元素向后移动，继续先前比较，如果不小于，则放到正在比较的元素之后。可见相等元素比较是，原来靠后的还是排在后边，所以插入排序是稳定的。当待排序的数据基本有序时，插入排序的效率比较高，只需要进行很少的数据移动。 插入排序的一个重要的特点是，如果原始数据的大部分元素已经排序，那么插入排序的速度很快（因为需要移动的元素很少）。从这个事实我们可以想到，如果原始数据只有很少元素，那么排序的速度也很快。－－希尔排序就是基于这两点对插入排序作出了改进。 算法描述对数列{2, 9, 5, 4, 8, 1, 6}进行排序，可以自己模拟对未排序的数列{9, 5, 4, 8, 1, 6}插入排序，直到数列排好序。 这个算法可以描述为：插入排序伪代码123for (int i = 1; i &lt; arr.length; i++) &#123; 将arr[i]插入到已排好序的只线性表中，这样arr[0 ... i]也是排好序的&#125; 插入arr[i]到arr[0, …, i-1]中有下面的过程：1.将arr[i]存储在一个名为currentElement的临时变量中；2.如果arr[i - 1] &gt; currentElement，就将arr[i - 1]移到arr[i]中；3.如果arr[i - 2] &gt; currentElement，就将arr[i - 2]移到arr[i - 1]中；4.依此类推，直到arr[i - k] &lt;= currentElement 或者 k &gt; i(传递的是排好序的数列的第一个元素)， 将currentElement赋值给arr[i - k + 1]。 插入排序代码插入排序的过程很好理解，代码如下： 插入排序123456789101112131415161718192021222324public class InsertionSort &#123; public static void insertionSort(int[] arr) &#123; for (int i = 1; i &lt; arr.length; i++) &#123; // 插入arr[i]到已经排好序的子线性表arr[0 ... i-1]中 int currentElement = arr[i]; int k; for (k = i - 1; k &gt;= 0 &amp;&amp; arr[k] &gt; currentElement; k--) &#123; arr[k+1] = arr[k]; &#125; // 插入当前元素到arr[k+1]中 arr[k + 1] = currentElement; &#125; &#125; public static void main(String[] args) &#123; int[] list = &#123;2, 32, 3, 34, 45, 8, 89, 20, 23, -1&#125;; insertionSort(list); for (int i: list) System.out.print(i + " "); &#125;&#125; 内外层循环的作用：外层循环（循环控制变量i）的迭代是为了获取已排好序的子线性表，其范围是arr[0] 到arr[i]。 内层循环（循环控制变量k）将arr[i]插入到arr[0]到arr[i-1]的子线性表。 复杂度和稳定性时间复杂度（平均）： O(n^2)时间复杂度（最坏）： O(n^2)时间复杂度（最好）： O(n) 空间复杂度： O(1) 因为在有序部分元素和待插入元素相等的时候，可以将待插入的元素放在前面，所以插入排序是 稳定的。]]></content>
      <categories>
        <category>Sorting</category>
      </categories>
      <tags>
        <tag>sort</tag>
        <tag>InsertionSort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序(1) 选择排序]]></title>
    <url>%2F2019%2F04%2F01%2Fselection-sort.html</url>
    <content type="text"><![CDATA[选择排序是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 遍历数组，遍历到i时，a0,a1,…,ai-1是已经排好序的，然后从i到n选择出最小的，记录下位置，如果不是第i个，则和第i个元素交换。此时第i个元素可能会排到相等元素之后，造成排序的不稳定。 选择排序（最小元素）分析假设要按照升序排列一个数列 {2, 9, 5, 4, 8, 1, 6}。选择排序法首先找到数列中最小的数，然后将它和第一个元素交换。接下来，在剩下的数中找到最小数，将它和第二个元素交换，以此类推，直到数列中仅剩一个数为止。 可以在纸上模拟一下具体选择排序过程。 开始编写第一次迭代的代码，找出数列中的最大数，将其与最后一个元素互换，然后观察第二次迭代与第一次的不同之处，接着是第三次，以此类推。通过这样的观察可以写出推广到所有迭代的循环。 解决方案伪代码1234567for (int i = 0; i &lt; arr.length - 1; i++) &#123; select the smallest element in arr[i ... arr.length-1]; swap the smallest with arr[i], if necessary; // arr[i] is in its correct position // the next iteration applies on arr[i+1 ... arr.length-1]&#125; java实现选择排序（最小元素）代码实现过程比较简单，如下： 选取最小值的选择排序12345678910111213141516171819202122232425262728293031323334353637public class SelectionSort &#123; // 选择排序 public static void selectionSort(int[] arr) &#123; if (arr == null || arr.length &lt; = 1) &#123; return; &#125; int currentMin; int currentMinIndex; for (int i = 0; i &lt; arr.length - 1; i++) &#123; // 找到最小值和最小值下标位置，在范围arr[i ... arr.length-1] currentMin = arr[i]; currentMinIndex = i; for (int j = i + 1; j &lt; arr.length; j++) &#123; if (currentMin &gt; arr[j]) &#123; currentMin = arr[j]; currentMindIndex = j; &#125; &#125; if (currentMinIndex != i) &#123; arr[currentMinIndex] = arr[i]; arr[i] = currentMin; &#125; &#125; &#125; public static void main(String[] args) &#123; int[] list = &#123;2, 32, 3, 34, 45, 8, 89, 20, 23&#125;; selectionSort(list); for (int i: list) System.out.print(i + " "); &#125;&#125; 选择排序（最大值）上面的选择排序法重复地在当前数组中找到最小值，然后将这个最小值与该数组中的第一个数进行交换。修改成：重复地选取当前数组中最大值，然后将这个最大值与该数组中的最后一个数进行交换，直到数组中的第一个元素。 选择最大值的选择排序123456789101112131415161718192021222324252627public class SelectionSort&#123; // 选择排序 public static void selectionSort(int[] arr) &#123; int currentMax; int currentMaxIndex; for (int i = list.length - 1; i &gt;= 0; i--) &#123; currentMax = list[i]; currentMaxIndex = i; for (int j = i - 1; j &gt;= 0; j--) &#123; if (currentMax &lt; arr[j]) &#123; currentMax = arr[j]; currentMaxIndex = j; &#125; &#125; if (currentMaxIndex != i) &#123; arr[currentMaxIndex] = arr[i]; arr[i] = currentMax; &#125; &#125; &#125; // ========测试用例略=========&#125; 算法复杂度选择排序复杂度：时间复杂度（平均）： O(n^2)时间复杂度（最坏）： O(n^2)时间复杂度（最好）： O(n^2) 空间复杂度： O(1) 选择排序稳定性选择排序是不稳定的算法。 算法稳定性定义在待排序的数据中，存在多个相同的数据，经过排序之后，他们的对相对顺序依旧保持不变，实际上就是说 array[i] = array[j], i &lt; j就是array[i]在array[j]之前，那么经过排序之后array[i]依旧在array[j]之前，那么这个排序算法稳定，否则，这个排序算法不稳定 也就是说，只要能举出一个反例来说明这个算法不稳定，那么这个算法就是不稳定的 针对选择排序算法，如下反例：数列 {5, 8, 5, 2, 9} 这个在执行选择排序的时候，第一遍，肯定会将array[0]=5，交换到2所在的位置:也就是 {2, 8, 5, 5, 9} 那么很显然，之后的排序我们就会发现，array[2]中的5会出现在原先的array[0]之前，所以选择排序不是一个稳定的排序。]]></content>
      <categories>
        <category>Sorting</category>
      </categories>
      <tags>
        <tag>SelectionSort</tag>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer(9) 用两个栈实现队列]]></title>
    <url>%2F2019%2F03%2F29%2Fqueue-with-two-stacks.html</url>
    <content type="text"><![CDATA[题目用两个栈实现一个队列。队列的声明如下，请实现它的两个函数appendTail和deleteHead，分别完成在队列尾部插入结点和在队列头部删除结点的功能。 方法一思路插入删除的过程（在草稿纸上动手画一下）： 插入肯定是往一个栈stack1中一直插入； 删除时，直接出栈无法实现队列的先进先出规则，这时需要将元素从stack1出栈，压到另一个栈stack2中，然后再从stack2中出栈就OK了。 需要稍微注意的是：当stack2中还有元素，stack1中的元素不能压进来；当stack2中没元素时，stack1中的所有元素都必须压入stack2中。否则顺序就会被打乱。 测试用例： 往空队列添加、删除元素 往非空队列里添加、删除元素 连续删除元素至队列为空 Java代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import java.util.Stack;public class QueueWithStacks &#123; class Queue &#123; Stack&lt;Integer&gt; stack1 = new Stack&lt;&gt;(); Stack&lt;Integer&gt; stack2 = new Stack&lt;&gt;(); /** * 插入节点 */ public void push(int node) &#123; stack1.push(node); &#125; /** * 删除节点 */ public int pop() &#123; if (stack2.empty()) &#123; if (stack1.empty()) &#123; throw new RuntimeException("队列为空"); &#125; else &#123; while (!stack1.empty()) stack2.push(stack1.pop()); &#125; &#125; return stack2.pop(); &#125; &#125; // =======测试代码========== public void test1() &#123; Queue queue = new Queue(); queue.push(1); queue.push(2); System.out.println(queue.pop()); queue.push(3); System.out.println(queue.pop()); System.out.println(queue.pop()); &#125; /** * 往空队列删除元素 */ public void test2() &#123; Queue queue = new Queue(); System.out.println(queue.pop()); &#125; public static void main(String[] args) &#123; QueueWithStacks demo = new QueueWithStacks(); demo.test1(); // demo.test2(); &#125;&#125; 方法二思路队列和栈的主要区别在于元素进出顺序，因此，需要修改peek()和pop()，以相反的顺序执行。利用第二个栈反转元素的次序（弹出s1的元素，压入s2）。 在这种实现中，每当执行peek()和pop()操作时，就要将s1的所有元素弹出，压入s2中，然后执行peek()和pop()操作，再将元素压入s1. 但是若连续执行两次peek()和pop()操作，那么，所有元素移来移去，重复移动。 可以延迟元素的移动，即让元素一直留在s2中，只有必须反转元素次序是才移动元素。 stackNew顶端为最新元素，stackOld顶端为最旧元素。在将一个元素出列是，我们希望先移除最旧元素，因此先将元素从stackOld将元素出列。若stackOld为空，在将stackNew中所有元素以相反的顺序移到stackOld中。如果要插入元素，就将其压入stackNew，因为最新元素位于它的顶端。 Java代码1234567891011121314151617181920212223242526272829303132333435import java.util.Stack;public class MyQueue&lt;T&gt; &#123; Stack&lt;T&gt; stackNew, stackOld; public MyQueue() &#123; stackNew = new Stack&lt;&gt;(); stackOld = new Stack&lt;&gt;(); &#125; public int size() &#123; return stackNew.size() + stackOld.size(); &#125; public void add(T val) &#123; stackNew.push(val); &#125; private void shiftStacks() &#123; if (stackOld.isEmpty()) &#123; while (!stackNew.isEmpty()) &#123; stackOld.push(stackNew.pop()); &#125; &#125; &#125; public T peek() &#123; shiftStacks(); return stackOld.peek(); &#125; public T remove() &#123; shiftStacks(); return stackOld.pop(); &#125;&#125;]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Queue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer(8) 二叉树的下一个节点]]></title>
    <url>%2F2019%2F03%2F28%2Fnext-node-in-binary-tree.html</url>
    <content type="text"><![CDATA[二叉树的下一个节点题目给定一棵二叉树和其中的一个结点，如何找出中序遍历顺序的下一个结点？ 树中的结点除了有两个分别指向左右子结点的指针以外，还有一个指向父结点的指针。 思路首先自己在草稿纸上画图，进行分析（不再展开）。可以发现下一个结点的规律为： 若当前节点有右子树，旗下一个节点为右子树中最左子节点； 若当前节点无右子树时， 若当前节点为其父节点的左子结点时，其子啊一个节点为其父节点； 若当前节点为其父节点的右子节点时，继续向上遍历父节点的父节点，直到找到一个节点是其父节点的左子结点（与(1)中判断相同），该节点的父节点即为下一节点。 测试用例 正常二叉树 左斜树、右斜树 单个节点 null 不同位置节点的下一节点(包含下一个节点为当前节点的右子树节点，右子树的最左子节点，父节点，跨层的父节点等；当前节点没有下一个节点) Java代码123456789101112131415161718192021222324252627282930313233343536public class NextNodeInBinaryTrees &#123; private class TreeLinkNode &#123; int val; TreeLinkNode left = null; TreeLinkNode right = null; TreeLinkNode parent = null; TreeLinkNode(int val) &#123; this.val = val; &#125; &#125; public TreeLinkNode getNext(TreeLinkNode pNode) &#123; if (pNode == null) &#123; System.out.print("节点为null"); return null; &#125; if (pNode.right != null) &#123; pNode = pNode.right; while (pNode.left != null) &#123; pNode = pNode.left; &#125; return pNode; &#125; while (pNode.parent != null) &#123; if (pNode == pNode.parent.left) &#123; return pNode.parent; &#125; pNode = pNode.parent; &#125; return null; &#125;&#125; 下面是测试代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class NextNodeInBinaryTrees &#123; // ==================================测试代码================================== // 创建树较为繁琐，未包括所有测试代码。 public void test1() &#123; TreeLinkNode node = null; TreeLinkNode nextNode = getNext(node); if (nextNode != null) System.out.println(nextNode.val); else System.out.println("无下一结点"); &#125; public void test2() &#123; TreeLinkNode node1 = new TreeLinkNode(1); TreeLinkNode node2 = new TreeLinkNode(2); TreeLinkNode node3 = new TreeLinkNode(3); TreeLinkNode node4 = new TreeLinkNode(4); node1.left = node2; node1.right = node3; node2.parent = node1; node3.parent = node1; node4.left = node1; node1.parent = node4; TreeLinkNode nextNodeOf1 = getNext(node1); TreeLinkNode nextNodeOf2 = getNext(node2); TreeLinkNode nextNodeOf3 = getNext(node3); TreeLinkNode nextNodeOf4 = getNext(node4); if (nextNodeOf1 != null) System.out.println("1结点的下一个结点值为：" + nextNodeOf1.val); else System.out.println("1结点无下一结点"); if (nextNodeOf2 != null) System.out.println("2结点的下一个结点值为：" + nextNodeOf2.val); else System.out.println("2结点无下一结点"); if (nextNodeOf3 != null) System.out.println("3结点的下一个结点值为：" + nextNodeOf3.val); else System.out.println("3结点无下一结点"); if (nextNodeOf4 != null) System.out.println("4结点的下一个结点值为：" + nextNodeOf4.val); else System.out.println("4结点无下一结点"); &#125; public static void main(String[] args) &#123; NextNodeInBinaryTrees demo = new NextNodeInBinaryTrees(); System.out.print("test1:"); demo.test1(); System.out.print("test2:"); demo.test2(); &#125;&#125; 总结 在面对复杂问题时要学会画图和举例分析。 在分情况讨论时，一定要考虑到所有情况，这些都是在写代码前需要考虑到的。]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>BinaryTree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer(7) 重建二叉树]]></title>
    <url>%2F2019%2F03%2F27%2Fconstruct-binary-tree.html</url>
    <content type="text"><![CDATA[根据前序和中序遍历重建二叉树热身题目已知二叉树先序遍历序列是A-B-C-D-E-F-G，中序遍历序列是C-B-D-A-E-G-F。由这两个序列可唯一确定一颗二叉树。 分析从先序遍历序列第一个节点可知二叉树根节点是A。 由节点A在中序遍历序列里位置可知该根点左子树包含节点 B-C-D，右子树包含节点 E-G-F。 由先序序列片段 B-C-D可知，B是A左子树根节点，再结合中序序列片段 C-B-D可知，C和D分别是B的左右子节点。由先序序列片段E-F-G可知，E是A的右子节点，结合中序序列片段E-F-G可知，G和F均是E的右子树节点。 再由先序序列片段F-G和中序序列片段G-F可知，F是E的右子节点，并且G是F的左子结点。 正题输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。 例如输入前序遍历序列{1, 2, 4, 7, 3, 5, 6, 8}和中序遍历序列{4, 7, 2, 1, 5, 3, 8, 6}，则重建出其二叉树并输出它的头结点。 思路前序遍历第一个值就是根结点的值，根据该值在中序遍历的位置，可以轻松找出该根结点左右子树的前序遍历和中序遍历，之后又可以用同样方法构建左右子树，所以该题可以采用递归的方法完成。 刚开始思考的时候，想的是构建一个遍历函数，输入为前序和中序遍历的数组，输出为根结点。但是这样的话每次都需要构建子树的数组，非常麻烦。 之后想到，该函数的输入不一定要用数组，因为最初的前序和中序遍历数组已经有了，就直接用该数组的下标来表示子树的数组即可。 即构建函数 construct(int[] pre, int[] in, int pStart, int pEnd, int iStart, int iEnd) ，pre和in始终用最初前序遍历和中序遍历的数组代入，pStart、pEnd代表当前树的前序数组开始和结束位置，iStart、iEnd代表中序数组开始和结束位置。 测试用例 正常二叉树 左斜树 右斜树 单个结点 数组为空 前序与中序不匹配 Java代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class ConstructBinaryTree &#123; class TreeNode &#123; int val; TreeNode left; TreeNode right; public TreeNode(int val) &#123; this.val = val; &#125; &#125; public TreeNode reConstructBinaryTree(int[] pre, int[] in) &#123; if (pre == null || in == null || pre.length &lt;= 0 || in.length &lt;= 0 || pre.length != in.length) &#123; throw new RuntimeException("数组不符合规范"); &#125; return construct(pre, in, 0, pre.length - 1, 0, in.length - 1); &#125; /** * @Description 由前序遍历序列和中序遍历序列得到根结点 pre、in：始终用最初的前序遍历和中序遍历数组代入 * pStart、pEnd：当前树的前序数组开始和结束位置 iStart、iEnd：中序数组开始和结束位置 */ public TreeNode construct(int[] pre, int[] in, int pStart, int pEnd, int iStart, int iEnd) &#123; TreeNode root = new TreeNode(pre[pStart]); if (pStart == pEnd &amp;&amp; iStart == iEnd) &#123; if (pre[pStart] != in[iStart]) throw new RuntimeException("数组不符合规范"); return root; &#125; int index = iStart; while (root.val != in[index] &amp;&amp; index &lt;= iEnd) &#123; index++; &#125; if (index &gt; iEnd) &#123; throw new RuntimeException("数组不符合规范"); &#125; int leftLength = index - iStart; if (leftLength &gt; 0) &#123; root.left = construct(pre, in, pStart + 1, pStart + leftLength, iStart, index - 1); &#125; if (leftLength &lt; iEnd - iStart) &#123; root.right = construct(pre, in, pStart + leftLength + 1, pEnd, index + 1, iEnd); &#125; return root; &#125;&#125; 测试部分代码，如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596public class ConstructBinaryTree &#123; private void preOrderTraverse(TreeNode node) &#123; if (node == null) return; System.out.print(node.val); preOrderTraverse(node.left); preOrderTraverse(node.right); &#125; private void inOrderTraverse(TreeNode node) &#123; if (node == null) return; inOrderTraverse(node.left); System.out.print(node.val); inOrderTraverse(node.right); &#125; /** * 正常二叉树 */ public void test1() &#123; int[] pre = &#123; 1, 2, 4, 7, 3, 5, 6, 8 &#125;; int[] in = &#123; 4, 7, 2, 1, 5, 3, 8, 6 &#125;; TreeNode root = reConstructBinaryTree(pre, in); System.out.print("test1:"); preOrderTraverse(root); System.out.print("//"); inOrderTraverse(root); System.out.println(); &#125; /** * 左斜树 */ public void test2() &#123; int[] pre = &#123; 1, 2, 3, 4, 5 &#125;; int[] in = &#123; 5, 4, 3, 2, 1 &#125;; TreeNode root = reConstructBinaryTree(pre, in); System.out.print("test2:"); preOrderTraverse(root); System.out.print("//"); inOrderTraverse(root); System.out.println(); &#125; /** * 右斜树 */ public void test3() &#123; int[] pre = &#123; 1, 2, 3, 4, 5 &#125;; int[] in = &#123; 1, 2, 3, 4, 5 &#125;; TreeNode root = reConstructBinaryTree(pre, in); System.out.print("test3:"); preOrderTraverse(root); System.out.print("//"); inOrderTraverse(root); System.out.println(); &#125; /** * 单个节点 */ public void test4() &#123; int[] pre = &#123; 1 &#125;; int[] in = &#123; 1 &#125;; TreeNode root = reConstructBinaryTree(pre, in); System.out.print("test4:"); preOrderTraverse(root); System.out.print("//"); inOrderTraverse(root); System.out.println(); &#125; /** * 数组为空 */ public void test5() &#123; int[] pre = &#123;&#125;; int[] in = &#123;&#125;; TreeNode root = reConstructBinaryTree(pre, in); System.out.print("test5:"); preOrderTraverse(root); System.out.print("//"); inOrderTraverse(root); System.out.println(); &#125; public static void main(String[] args) &#123; ConstructBinaryTree demo = new ConstructBinaryTree(); demo.test1(); demo.test2(); demo.test3(); demo.test4(); // demo.test5(); &#125;&#125; 总结 在递归问题中，代码可以用下标表示的就用下标表示，不用重新构建新的数组。 数组为空与数组为null不是一回事。]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>BinaryTree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React项目实践]]></title>
    <url>%2F2019%2F03%2F27%2FReact%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5.html</url>
    <content type="text"><![CDATA[指定计划功能模块架构设计 前后端完全分离 单页应用 模块化开发 技术储备 React框架 React16 JSX表达式 React组件 生命周期 React-Router 浏览器路由原理 动态路由 VS 静态路由 React-Router Sass Bootstrap ES6语法 基础语法 Promise 面向对象 浏览器资源加载 URL结构 资源加载 浏览器渲染 本地存储 Cookie &amp;&amp; Seeeion 用户登录状态保持 H5本地存储 发布上线 Linux服务器配置 自动化发布脚本 域名解析 后台管理系统的需求分析及技术选型核心需求根据实际情况来定义 功能拆分根据实际情况来定义 技术选型–语言和框架 React Sass + Bootstrap ES6 技术选型–语言和框架 前后端分离 分层架构 模块化开发 技术选型–辅助工具node npm安装速度慢，包之间的依赖关系很难搞 yarn 包管理工具 webpack 代码打包 git 托管代码，做代码的版本维护 技术选型–发布过程 环境配置 代码部署 nginx配置 域名配置 数据接口的定义接口文档规范–格式接口文档规范–请求和相应]]></content>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer(6) 从尾到头打印链表]]></title>
    <url>%2F2019%2F03%2F26%2Fprint-list-from-head-to-tail.html</url>
    <content type="text"><![CDATA[从头到尾打印链表题目输入一个链表的头结点，从尾到头反过来打印出每个结点的值。节点定义如下： class ListNode { int val; ListNode next; ListNode(int val) { this.val = val; }} 思路输入一个链表的头结点，从尾到头反过来打印出每个结点的值。对于“后进先出”问题，要快速想到”栈“，也同时想到递归。 结点遍历顺序只能从头到尾，但是输出的顺序却为从尾到头，是典型的“后进先出”问题，这就要联想到使用栈，从而也可以联想到使用递归。 测试用例 功能测试（单个节点链表，多个节点链表） 特殊输入测试（链表为空） Java代码1234567891011121314151617181920212223242526272829303132import java.util.Stack;public class PrintListInReversedOrder &#123; class Node &#123; int element; Node next; public Node(int element) &#123; this.element = element; &#125; &#125; // 采用栈 public void printListReversingly_Iteratively(Node node) &#123; Stack&lt;Node&gt; stack = new Stack&lt;&gt;(); while (node != null) &#123; stack.push(node); node = node.next; &#125; while (!stack.empty()) &#123; System.out.println(stack.pop().element); &#125; &#125; // 采用递归 public void printListReversingly_Recursively(Node node) &#123; if (node != null) &#123; printListReversingly_Recursively(node.next); System.out.println(node.element); &#125; else &#123; return; &#125; &#125;&#125; 测试代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class PrintListInReversedOrder &#123; /** * 链表为空 */ public void test1() &#123; Node aNode = null; System.out.println("采用栈："); printListReversingly_Iteratively(aNode); System.out.println("采用递归："); printListReversingly_Recursively(aNode); &#125; /** * 多个结点链表 */ public void test2() &#123; Node Node1 = new Node(1); Node Node2 = new Node(2); Node Node3 = new Node(3); Node Node4 = new Node(4); Node Node5 = new Node(5); Node1.next = Node2; Node2.next = Node3; Node3.next = Node4; Node4.next = Node5; System.out.println("采用栈："); printListReversingly_Iteratively(Node1); System.out.println("采用递归："); printListReversingly_Recursively(Node1); &#125; /** * 单个结点链表 */ public void test3() &#123; Node Node1 = new Node(1); System.out.println("采用栈："); printListReversingly_Iteratively(Node1); System.out.println("采用递归："); printListReversingly_Recursively(Node1); &#125; public static void main(String[] args) &#123; PrintListInReversedOrder demo = new PrintListInReversedOrder(); System.out.println("test1:"); demo.test1(); System.out.println("test2:"); demo.test2(); System.out.println("test3:"); demo.test3(); &#125;&#125; 递归的其他写法递归部分代码也可以像下面这样写，注意体会不同的递归写法 12345678public void printListReversingly_Recursively(Node node) &#123; if (node != null) &#123; if (node.next != null) &#123; printListReversingly_Recursively(node.next); &#125; System.out.println(node.element); &#125;&#125; 牛客网提交代码采用的递归，非常简洁，很值得学习。 1234567891011121314151617181920212223/*** public class ListNode &#123;* int val;* ListNode next = null;** ListNode(int val) &#123;* this.val = val;* &#125;* &#125;*/import java.util.ArrayList;public class Solution &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode node) &#123; if (node != null) &#123; this.printListFromTailToHead(listNode.next); list.add(node.val); &#125; return list; &#125;&#125; 总结 对于“后进先出”问题，要快速想到”栈“，也同时想到递归。 采用递归时，返回的函数值不一定要有赋值操作，只要实现了遍历的作用就可以了，牛客网的代码可以多多学习。]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Recursive</tag>
        <tag>LikedList</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring框架快速入门]]></title>
    <url>%2F2019%2F03%2F26%2FSpring%E6%A1%86%E6%9E%B6%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8.html</url>
    <content type="text"><![CDATA[## ## ##]]></content>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer(5) 替换空格]]></title>
    <url>%2F2019%2F03%2F24%2Freplace-spaces.html</url>
    <content type="text"><![CDATA[替换空格本文有两道题。第一道题，请实现一个函数，把字符串中的每个空格替换成”%20”。例如输入“We are happy.”，则输出“We%20are%20happy.”。 第二道题，实现对一组无序的字母进行从小到大排序（区分大小写），当两个字母相同时，小写字母放在大写字母前。要求时间复杂度为O(n)。 题目一请实现一个函数，把字符串中的每个空格替换成”%20”。例如输入“We are happy.”，则输出“We%20are%20happy.”。 思路首先要询问面试官是新建一个字符串还是在原有的字符串上修改，本题要求在原字符串上进行修改。 若从前往后依次替换，在每次遇到空格字符时，都需要移动后面O(n)个字符，对于含有O(n)个空格字符的字符串而言，总的时间效率为O(n^2)。 转变思路：先计算需要的总长度，然后从后往前进行复制和替换，则每个字符只需要复制一次即可。时间效率为O(n)。 测试用例 字符串中无空格 字符串中含有空格（连续空格，空格在首尾等） 字符串为空字符串或者为null Java代码根据牛客网的编程练习参考，方法的输入为StringBuffer（String无法改变长度，所以采用StringBuffer），输出为String。 12345678910111213141516171819202122232425262728293031public class ReplaceSpaces &#123; public String replaceSpaces(StringBuffer str) &#123; if (str == null) &#123; System.out.println("输入错误")； return null; &#125; int length = str.length(); int indexOfOriginal = length - 1; for (int i = 0; i &lt; str.length(); i++) &#123; if (str.charAt(i) == ' ') &#123; length += 2; &#125; &#125; str.setLength(length); int indexOfNew = length - 1; while (indexOfNew &gt; indexOfOriginal) &#123; if (str.charAt(indexOfOriginal) != ' ') &#123; str.setCharAt(indexOfNew--, str.charAt(indexOfOriginal)); &#125; else &#123; str.setCharAt(indexOfNew--, '0'); str.setCharAt(indexOfNew--, '2'); str.setCharAt(indexOfNew--, '%'); &#125; indexOfOriginal--; &#125; return str.toString(); &#125;&#125; 在同一个类中，与上面的函数拆开的测试代码，为了函数更加简洁。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class ReplaceSpaces &#123; // ==================================测试代码================================== /** * 输入为null */ public void test1() &#123; System.out.print("Test1："); StringBuffer sBuffer = null; String s = replaceSpace(sBuffer); System.out.println(s); &#125; /** * 输入为空字符串 */ public void test2() &#123; System.out.print("Test2："); StringBuffer sBuffer = new StringBuffer(""); String s = replaceSpace(sBuffer); System.out.println(s); &#125; /** * 输入字符串无空格 */ public void test3() &#123; System.out.print("Test3："); StringBuffer sBuffer = new StringBuffer("abc"); String s = replaceSpace(sBuffer); System.out.println(s); &#125; /** * 输入字符串为首尾空格，中间连续空格 */ public void test4() &#123; System.out.print("Test4："); StringBuffer sBuffer = new StringBuffer(" a b c "); String s = replaceSpace(sBuffer); System.out.println(s); &#125; public static void main(String[] args) &#123; ReplaceSpaces rs = new ReplaceSpaces(); rs.test1(); rs.test2(); rs.test3(); rs.test4(); &#125;&#125; 替换空格-采用数组的方法因为java字符串是不可变的，所以也可以使用字符数组来解决这个问题。 处理字符串的时候，常见做法是从尾部开始编辑，从后往前反向操作。这种做法很有用，因为字符串尾部有额外的缓冲，可以直接修改，不必担心会覆写原有数据。采用上面的做法，进行两次扫描，第一次扫描先数出字符串中有多少空格，从而计算出最终的字符串有多长。第二次扫描才真正开始反向编辑字符串。检测到空格则将%20复制到下一个位置，若不是空白，就复制原先的字符。 1234567891011121314151617181920public void replaceSpace(char[] str, int length) &#123; int spaceCount = 0; int newLength; for (int i = 0; i &lt; length; i++) &#123; if (str[i] == ' ') &#123; spaceCount++; &#125; &#125; newLength = length + spaceCount * 2; str[newLength] = '\0'; for (int i = length - 1; i &gt;= 0 ; i--) &#123; if (str[i] == ' ') &#123; str[--newLength] = '0'; str[--newLength] = '2'; str[--newLength] = '%'; &#125; else &#123; str[--newLength] = str[i]; &#125; &#125;&#125; 总结 对于一个错误 123456// 这里用了 for (int i = 0; i &lt; length; i++) &#123; // 非常之愚蠢，因为在for循环体里面 length的值一直在变化 for (int i = 0; i &lt; length; i++) &#123; if (str.charAt(i) == ' ') length += 2; &#125; 如果在从前往后进行复制时，需要多次移动数据，则可以考虑从后往前复制，从而减小移动次数，提高效率。 Java 打印输出字符数组 Java 中，char 类型数组可以直接使用数组名打印。char 类型的数组就相当于一个字符串。 输出流 System.out 是 PrintStream 对象，PrintStream 有多个重载的 println 方法，其中一个就是 public void println(char[ ] x)它会直接调用这个方法来打印字符数组。因此可以直接打印出数组内容，而不是地址。 不要使用 i % 2 == 1 来判断是否是奇数，因为i为负奇数时不成立，请 使用 i % 2 != 0 来判断是否是奇数，或使用 高效式 (i &amp; 1) != 0来判断奇数，奇数与1相与必为1。。 生成char array的方法 1234567891011//生成char ArrayString s = "HappyBirthdayzLinkeRuIlikeyouazz";char[] src = s.toCharArray();//打印char 数组成字符串System.out.print(src);//数组转字符串String[] arr = &#123;"laowang", "stone", "wanglei"&#125;;String str2 = Arrays.toString(arr);System.out.println(str2); // 输出[laowang, stone, wanglei] 数组拷贝 123int[] arr = &#123;3, 4, 9&#125;;int[] arr2 = Arrays.copyOf(arr, arr.length);System.out.println(Arrays.toString(arr2)); 无序字母排序本题不属于剑指offer。 题目二实现对一组无序的字母进行从小到大排序（区分大小写），当两个字母相同时，小写字母放在大写字母前。要求时间复杂度为O(n)。 思路使用排序算法在最好的情况下的时间复杂度都在O(nlogn)，不满足题目要求。通常字母为26个，当区分大小写后，变成26*2=52个，所以申请长度为52的int型数组，按照aAbB…zZ(小写字母保存在下标为偶数的位置，大写字母保存在下标为奇数的位置)的顺序一次记录各个字母出现的次数，当记录完成后，就可以遍历这个数组按照各个字母出现的次数来重组排序后的数组。 Java代码123456789101112131415161718192021222324252627282930313233343536373839404142434445public class SortCharacters &#123; public static void main(String[] args) &#123; String s = "HappyBirthdayzLinkeRuIlikeyouazz"; char[] src = s.toCharArray(); sort(src); for (char ch : src) &#123; System.out.print(ch + " "); &#125; &#125; private static void sort(char[] src) &#123; if (src == null) &#123; System.out.println("参数不合法"); return; &#125; // 用于保存52个字符出现的次数，小写字母保存在下标为偶数的位置，大写字母保存在奇数位置 int[] charCount = new int[52]; for (int i = 0; i &lt; src.length; i++) &#123; // if (src[i] &gt;= 'a' &amp;&amp; src[i] &lt;= 'z') &#123; charCount[(src[i] - 'a') * 2]++; &#125; else if (src[i] &gt;= 'A' &amp;&amp; src[i] &lt;= 'Z') &#123; charCount[(src[i] - 'A') * 2 + 1]++; &#125; &#125; int index = 0; for (int i = 0; i &lt; charCount.length; i++) &#123; if (charCount[i] != 0) &#123; if (i % 2 == 0) &#123; // 小写字母 for (int j = 0; j &lt; charCount[i]; j++) src[index++] = (char) (i / 2 + 'a'); &#125; else &#123; // 大写字母 for (int j = 0; j &lt; charCount[i]; j++) src[index++] = (char) ((i - 1) / 2 + 'A'); &#125; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer(4) 二维数组中的查找]]></title>
    <url>%2F2019%2F03%2F24%2Ffind-in-partially-sorted-matrix.html</url>
    <content type="text"><![CDATA[二维数组中的查找题目在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 思路查找整数时，如果从左上角开始查找，情况较为复杂，可以转换思路，从右上角开始查找：左边数字比较小，下边数字比较大，容易进行判断。 当我们需要解决一个复杂的问题是，一个很有效的办法就是从一个具体的问题入手，通过分析简单具体的例子，寻找普遍规律。 测试用例： 要查找的数字在数组中 要查找的数字不在数组中 数组为空 数组不满足大小规则 数组每行长度不一致 Java代码及复杂度1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class FindInPartiallySortedMatrix &#123; /* * 判断二维数组matrix中是否含有整数a * 返回值为a的下标，&#123;-1，-1&#125;代表不存在 */ public int[] find(int[][] martrix, int a) &#123; int[] index = &#123;-1, -1&#125;; if (matrix == null || matrix.length &lt;= 0) &#123; System.out.println("数组无效"); return index; &#125; int columns = matrix[0].length; for (int i = 0; i &lt; matrix.length; i) &#123; if (matrix[i].length != columns) &#123; System.out.println("数组列数不一致"); return index; &#125; for (int j = 0; j &lt; matrix[i].length; j++) &#123; if (i == 0 &amp;&amp; j == 0) break; //matrix[0][0]不比较 if (i == 0) &#123; //第一行的数,仅和前一列比较 if (matrix[i][j] &lt; matrix[i][j - 1])&#123; System.out.print("数组中数字大小不符合要求")； return index; &#125; &#125; else if (j == 0) &#123; //第一列的，仅和前一行比较 if (matrix[i][j] &lt; matrix[i - 1][j]) &#123; System.out.print("数组中数字大小不符合要求")； return index; &#125; &#125; else if (matrix[i][j] &lt; matrix[i - 1][j] || matrix[i][j] &lt; matrix[i][j - 1])&#123; System.out.print("数组中数字大小不符合要求")； return index; &#125; &#125; &#125; //查找过程 int row = 0; //行数 int col = matrix[0].length - 1; //列数 while (row &lt;= matrix.length - 1 &amp;&amp; col &gt;= 0) &#123; if (a == matrix[row][col]) &#123; index[0] = row; index[1] = col; System.out.println("数字" + a + "在二维数组中的下标为： " + index[0] + ", " + index[1]); return index; &#125; else if (a &lt; matrix[row][col]) &#123; col--; &#125; else &#123; row++; &#125; &#125; System.out.println("数组中不含数字" + a); return index; &#125;&#125; 在同一个类中，与上面的函数拆开的测试代码，为了函数更加简洁。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class FindInPartiallySortedMatrix &#123; // 1 2 8 9 // 2 4 9 12 // 4 7 10 13 // 6 8 11 15 // 要查找的数在数组中 public void test1() &#123; System.out.print("test1："); int[][] matrix = &#123; &#123; 1, 2, 8, 9 &#125;, &#123; 2, 4, 9, 12 &#125;, &#123; 4, 7, 10, 13 &#125;, &#123; 6, 8, 11, 15 &#125; &#125;; int[] index = find(matrix, 7); &#125; // 1 2 8 9 // 2 4 9 12 // 4 7 10 13 // 6 8 11 15 // 要查找的数不在数组中 public void test2() &#123; System.out.print("test2："); int[][] matrix = &#123; &#123; 1, 2, 8, 9 &#125;, &#123; 2, 4, 9, 12 &#125;, &#123; 4, 7, 10, 13 &#125;, &#123; 6, 8, 11, 15 &#125; &#125;; int[] index = find(matrix, 5); &#125; // 数组为空 public void test3() &#123; System.out.print("test3："); int[][] matrix = null; int[] index = find(matrix, 7); &#125; // 1 2 8 9 // 4 3 9 12 // 4 7 10 13 // 6 8 11 15 // 数组不满足大小规则 public void test4() &#123; System.out.print("test4："); int[][] matrix = &#123; &#123; 1, 2, 8, 9 &#125;, &#123; 4, 3, 9, 12 &#125;, &#123; 4, 7, 10, 13 &#125;, &#123; 6, 8, 11, 15 &#125; &#125;; int[] index = find(matrix, 7); &#125; // 数组每行长度不一致 public void test5() &#123; System.out.print("test5："); int[][] matrix = &#123; &#123; 1, 2, 8 &#125;, &#123; 4, 3, 9, 12 &#125;, &#123; 4, 7, 10 &#125;, &#123; 6, 8, 11, 15 &#125; &#125;; int[] index = find(matrix, 7); &#125; public static void main(String[] args) &#123; FindInPartiallySortedMatrix f = new FindInPartiallySortedMatrix(); f.test1(); // 注意下标是从0开始的 f.test2(); f.test3(); f.test4(); f.test5(); &#125;&#125; 不含测试代码(简化版)上面代码考虑了数组数字大小不符合规则的情况，较为繁琐。下面为剑指Offer4 二维数组中的查找(简化版)： 12345678910111213141516171819public class Solution &#123; public boolean Find(int target, int[][] array) &#123; if (array == null || array.length &lt;= 0) return false; int row = 0; int col = array[0].length - 1; while (row &lt;= array.length - 1 &amp;&amp; col &gt;= 0) &#123; if (target == array[row][col]) &#123; return false; &#125; else if (target &lt; array[row][col]) &#123; col--; &#125; else &#123; row++; &#125; &#125; return false; &#125;&#125;]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之禅|6大设计原则]]></title>
    <url>%2F2019%2F03%2F23%2Fsolid-principles.html</url>
    <content type="text"><![CDATA[曾经对“设计模式”(Design Pattern)很膜拜，以为是最高大上的东西。现在看来更多的是前人总结的经验吧，了解一下就可以了，关键是要用的时候“熟能生巧”。最开始看的时候也正在学习Java，配合着这本书中的Java代码，感觉各种神奇。其实，Java语言设计之初为了避免像C++般复杂却过于简化了语法，结果大大降低了本身的表达能力。很多本来可以很简洁的代码，必须绕来绕去得写出来，这个时候就很需要利用设计模式来整理代码逻辑。另一方面，设计模式也还是有些用途的，尤其是在开发大型软件系统，很注重系统架构的设计和功能模块的解耦的场合。 题外话，UML类图中类之间的关系有：泛化 = 实现 &gt; 组合 &gt; 聚合 &gt; 关联 &gt; 依赖 泛化(Generalization)： 继承关系，子类继承父类 继承用实线三角箭头指向父类 实现(Realization)： 对接口的实现，类实现一个接口 继承接口用虚线三角箭头指向接口 组合(Composition)： 整体与部分的关系,但部分不能离开整体而单独存在 实心菱形，菱形指向整体 聚合(Aggregation)： 整体与部分的关系,且部分可以离开整体而单独存在 空心菱形，菱形指向整体 关联(Association)： 拥有的关系，让一个类知道另一个类的属性方法 实线箭头，箭头指向被关联的类 依赖(Dependency)： 一种使用的关系，即一个类的实现需要另一个类的协助，所以尽量不要使用双向的相互依赖，代码体现：局部变量、方法的参数或者调用类的静态方法 虚线箭头，指向被使用者 软件分析与设计是编码前的2个阶段，分析仅与业务有关，而与技术无关，设计以分析为基础，与具体技术有关。 紧耦合 类间耦合过重 接口封装过度 类间解耦，弱耦合 单一职责原则单一职责原则的英文名称是Single Responsibility Principle，简称是SRP。这个原则存在争议之处在对职责的定义，什么是类的职责，以及怎么划分类的职责。 RBAC模式（Role-Based Access Control，基于角色的访问控制，通过分配和取消角色来完成用户权限的授予和取消，使动作主体（用户）与资源的行为（权限）分离）。把用户的信息抽取成一个BO（Business Object, 业务对象），把行为抽取成一个Biz（Business Logic，业务逻辑）。 SRP的定义是：应该有且仅有一个原因引起类的变更。SRP的原话解释： There should never be more than one reason for a class to change.就一个类而言，应该只有一个引起它变化的原因。 单一职责原则的优点： 可以降低类的复杂度，实现什么职责都有清晰明确的定义； 提高类的可读性； 提高系统的可维护性； 变更引起的风险降低，变更是必然的，如果单一职责原则遵守的好，一个接口修改只对相应地实现类有影响，对其他的接口无影响，这对系统的扩展性、维护性都有非常大的帮助。 单一职责原则要求一个接口或类只有一个原因引起变化，也就是一个接口或类只有一个职责，它就负责一件事。一个职责就是一个接口。对于接口，我们在设计的时候一定要做到单一，但是对于实现类就需要多方面考虑了，可能不会满足单一职责原则。单一职责适用于接口、类，同时也适用于方法。一个方法尽可能做一件事情。 里氏替换原则在实际项目中，每个子类对应不同的业务含义，使用父类作为参数，传递不同的子类完成不同的业务逻辑，非常完美。里氏替换原则(LSP:Liskov Substitution Principle)的定义： 第一种定义，也是最正宗的定义： If for each object o1 of type S there is an object o2 of type T such that for all programs P defined in terms of T, the behavior of P is unchanged when o1 is substituted for o2 then S is a subtype of T.（如果对每一个类型为S的对象o1，都有类型为T的对象o2，使得以T定义的所有程序P在所在的对象o1都代换为o2时，程序P的行为没有发生变化，那么类型S是类型T的字类型。） 第二种定义：Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it.（所有引用基类的地方必须能透明地使用其子类的对象。） 继承的优点： 代码共享，减少创建类的工作量，每个子类都拥有父类的方法和属性。 提高代码的重用性。 子类可以形似父类，但又异于父类。 提高代码的可扩展性，只需实现父类的方法。 提高产品或项目的开放性。 继承的缺点： 继承是侵入性的。只要继承，就必须拥有父类的所有属性和方法。 降低代码的灵活性。子类必须拥有父类的属性和方法。 增强了耦合性。当父类的常量、变量和方法被修改时，必须要考虑子类的修改，而且在缺乏规范的环境下，这种修改可能带来非常糟糕的结果——大片代码需要重构。 在类中调用其他类时务必要使用父类或接口，如果不能使用负累或接口，则说明类的设计已经违背了LSP原则。里氏替换原则包含了4层含义： 子类必须完全实现父类的方法如果子类不能完整地实现父类的方法，或者父类的某些方法在子类中已经发生”畸变”，则建议断开父子继承关系，采用依赖、聚集、组合等关系代替继承。 子类可以有自己的个性子类可以有自己的行为和外观，也就是方法和属性。 覆盖或实现父类的方法时输入参数可以被放大子类的方法可以重载（Overload）父类的方法，并把输入参数设置成为父类的方法的输入参数的父类（即把输入参数放大）。这时，通过父类的引用调用这个方法，实际调用的还是父类的方法，子类的方法由于只是重载而不是覆写（Override），会被隐藏掉。子类可以覆写（Override）父类的方法。 覆写或实现父类的方法时输出结果可以被缩小父类的方法返回值是一个类型T，子类的相同方法（重载或覆写）的返回值为S，那么里氏替换原则就要求S必须小于等于T，也就是说，要么S和T是同一个类型，要么S是T的子类。 如果是覆写，父类和子类的同名方法的输入参数相同，两个方法的范围值S小于等于T，这是覆写的要求，这才是重中之重，子类覆写父类的方法，天经地义。 如果是重载，则要求方法的输入参数类型或数量不相同，在里氏替换原则要求下，就是子类的输入参数宽于或等于父类的输入参数，也就是说你写的这个方法是不会被调用的，参考上面讲的前置条件。 依赖倒置原则依赖正置就是类间的依赖是实实在在的实现类间的依赖。 依赖倒置原则（Dependence Inversion Principle, DIP）的定义：High level modules should not depend upon low level modules. Both should depend upon abstractions. Abstractions should not depend upon details. Details should depend upon abstractions.翻译过来，有三重含义： 高层模块不应该依赖底层模块，两者都应该依赖其抽象。 抽象不应该依赖细节。 细节应该依赖抽象。 高层模块和低层模块容易理解，每一个逻辑的实现都是由原子逻辑组成的，不可分割的原子逻辑就是低层模块，原子逻辑的再组装就是高层模块。在Java中，抽象是指接口或抽象类，两者都不是不能直接被实例化的；细节就是实现类，实现接口或继承抽象类而产生的类就是细节，其特点就是可以直接被实例化。依赖倒置原则在Java语言中的表现就是： 模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的。 接口或抽象类不依赖于实现类。 实现类依赖与接口或抽象类。 更加精髓的定义就是 “面向接口编程”——面向对象设计的精髓之一。 采用依赖倒置原则可以减少类间的耦合性，提高系统的稳定性，降低并发开发引起的风险，提高代码的可读性和可维护性。 依赖是可以传递的。只要做到抽象依赖，即使是多层的依赖传递也无所畏惧。 依赖倒置原则要求我们在程序代码中传递参数时或在关联关系中，尽量 引用层次高的抽象层类，即使用 接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等，而不要用具体类来做这些事情。 最佳实践： 每个类尽量都有接口或抽象类，或者抽象类和接口两者都具备。接口负责定义public属性和方法，并且声明与其他对象的依赖关系，抽象类负责公共构造部分的实现，实现类准确的实现业务逻辑，同时在适当的世界对父类进行细化。 变量的表名类型尽量是接口或者抽象类。 任何类都不应该从具体类派生。 尽量不要覆写基类的方法。 结合里氏替换原则使用。 对象的依赖关系又三种方式来传递： 构造函数传递依赖对象 Setter方法传递依赖对象 接口声明依赖对象 接口隔离原则接口的两种类型： 实例接口（Object Interface），在Java中声明一个类，然后用new关键字产生一个实例，它是对一个类型的事物的描述，就是一种接口。 类接口（Class Interface），Java中经常使用的interface关键字定义的接口。接口是我们设计时对外提供的契约。 接口隔离原则(ISP：Interface Segregation Principle)定义：使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。 根据接口隔离原则，当一个接口太大时，我们需要将它分割成一些更细小的接口，使用该接口的客户端仅需知道与之相关的方法即可。每一个接口应该承担一种相对独立的角色，不干不该干的事，该干的事都要干。 看到这里好像接口隔离原则与单一职责原则是相同的。其实接口隔离原则与单一职责原则的审视角度是不相同的，单一职责原则要求的是类和接口职责单一，注重的是职责，这是业务逻辑上的划分，而接口隔离原则要求接口的方法尽量少。 接口隔离原则是对接口进行规范约束，其包含的以下4层含义： 接口要尽量小这是接口隔离原则的核心定义。但是”小”是有限度的，首先就是不能违反单一职责原则，已经做到单一职责的接口不应该再分。即，根据接口隔离原则拆分接口时，首先必须满足单一职责原则。 接口要高内聚高内聚就是提高接口、类、模块的处理能力，减少对外的交互。具体到接口隔离原则就是，要求在接口中尽量少公布public方法，接口是对外的承诺，承诺越少对系统的开发越有利，变更的风险也就越少，同时也有利于降低成本。 定制服务定制服务就是单独为一个个体提供优良的服务。要求就是：只提供访问者需要的方法。 接口设计是有限度的接口的设计粒度越小，系统越灵活。但是，灵活的同时也带来了结构的复杂化，开发难度增加，可维护性降低。所以接口设计一定要注意适度。 最佳实践： 一个接口只服务于一个子模块或业务逻辑。 通过业务逻辑压缩接口中的public方法，接口时常去回顾，尽量让接口达到“满身筋骨肉”，而不是“肥嘟嘟”的一大堆方法。 已经被污染了的接口，尽量去修改，若变更的风险较大，则采用适配器模式进行转化处理。 了解环境，拒绝盲从。环境不同，接口拆分的标准就不同，深入了解业务逻辑，根据实际情况设计接口。 迪米特法则最小知识原则（Least Knowledge Principle，LKP）： 一个对象应该对其他对象有最少的了解。 通俗地讲，一个类应该对自己需要耦合或调用的类知道得最少。最小知识原则包含以下4层含义： 只和朋友交流Only talk to your immedate friends（只和直接朋友通信。）两个对象之间的耦合就成为朋友关系。 类和类之间的关系是建立在类间的，而不是方法间。朋友类：出现在在成员变量、方法的输入输出参数中的类成为成员朋友类，而出现在方法内部的类不属于朋友类。 朋友间也是有距离的朋友类之间也不应该暴露太多方法。尽量不要对外公布太多的public和非静态的public变量，尽量内敛，多使用protected、package-private、protected等访问权限。 是自己的就是自己的如果一个方法放在本类中，既不增加类间关系，也对本类不产生负面影响，就放置在本类中。 谨慎使用Serializable可能会因为对类的更改未在服务器和客户端之间同步而引起序列化失败问题。 迪米特法则的核心观念就是类间解耦，弱耦合 开闭原则开闭原则(OCP:Open-Closed Principle)的定义：Software entities like classes, modules and functions should be open for extension but closed for modifications.（一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。）一个软件实体（模块、类、接口、方法）应该通过 扩展来实现变化，而不是通过修改已有的代码来实现变化。 开闭原则是最基本的原则，是其他原则和设计模式的精神。 开闭原则的重要性： 开闭原则对测试的影响所有已经投产的代码都是有意义的，并且都不受系统规则的约束。如果通过修改而不是扩展代码来应对需求变化，需要重新测试已经修改的代码。 开闭原则可以提高复用性在面向对象的设计中，所有的逻辑都是从原子逻辑组合而来的，而不是在一个类中独立实现一个业务逻辑。 开闭原则可以提高可维护性 面向对象开发的要求快速的应对变化，需要在设计之初就考虑所有可能变化的因素，然后留下接口。 需求变化的三种类型： 逻辑变化可以通过修改原有类中的方法的方式来完成 子模块变化通过扩展来应对 可见视图变化可见视图是提供给客户使用的界面，该部分的变化一般会引起连锁反应，但还是可以通过扩展来完成变化，这就要看原来的设计是否灵活。 应对需求变化的原则： 保持历史的纯洁性，不去修改历史。 应对需求变化的三种方法： 修改接口不可靠的，该方案应该被直接否定。 修改实现类该方法在项目有明确的章程或优良的架构设计时，是一个非常优秀的方法，但是仍有缺陷。 通过扩展实现变化好方法，修改少，风险小。 最佳实践： 抽象约束首先通过接口或抽象类约束扩展，对扩展进行边界限定，不允许出现在接口或抽象类中不存在的public方法；第二，参数类型，引用对象尽量使用接口或者抽象类，而不是实现类；第三，抽象层尽量保持稳定，一旦确定既不允许修改。 元数据(metadata)控制模块行为尽量使用元数据(用来描述环境和数据的数据，通俗的说就是配置参数)来控制程序的行为，减少重复开发。 制定项目章程对于项目来说，约定优于配置。 封装变化第一，将相同的变化封装到一个接口或抽象类中；第二，将不同的变化封装到不同的接口或抽象类中，不应该有两个不同的变化出现在同一个接口或抽象类中。]]></content>
      <categories>
        <category>DPModel</category>
      </categories>
      <tags>
        <tag>DPModel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer(3) 数组中重复的数字]]></title>
    <url>%2F2019%2F03%2F21%2Fduplication-in-array.html</url>
    <content type="text"><![CDATA[本文参考《剑指Offer》一书，代码采用Java实现。题目一：在一个长度为n的数组里的所有数字都在0到n-1的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。 题目二：在一个长度为n+1的数组里的所有数字都在1到n的范围内，所以数组中至少有一个数字是重复的。请找出数组中任意一个重复的数字，但不能修改输入的数组。 本文的两道题解题思路是不一样的，具体事项见正文。 找出数组中重复数字题目一在一个长度为n的数组里的所有数字都在0到n-1的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。例如，如果输入长度为7的数组 {2, 3, 1, 0, 2, 5, 3} ，那么对应的输出是重复的数字2或者3。 思路从哈希表的思路拓展，重排数组：把扫描的每个数字（如数字m）放到其对应下标（m下标）的位置上，若同一位置有重复，则说明该数字重复。 （在动手写代码前应该先想好测试用例） 测试用例： 数组中带有一个或多个重复数字 数组中不包含重复数字 无效输入测试用例（空数组、数组数字越界等） Java代码及复杂度复杂度：时间复杂度： O(n)空间复杂度： O(1) 尽管有两重循环，但是每个数字最多只要交换两次就能找到属于它的位置，因此钟的时间按复杂度是O(n)。另外所有操作时在输入数组上进行的，不需要分配内存，空间复杂度是O(1)。 含测试代码12345678910111213141516171819202122232425262728public class FindDuplicateNumber1 &#123; public int getDuplicate(int[] arr) &#123; if (arr == null || arr.length &lt;= 0) &#123; System.out.println("数组输入无效"); return -1; &#125; for (int a : arr) &#123; if (a &lt; 0 || a &gt; arr.length - 1) &#123; System.out.println("数字大小超出范围"); return -1; &#125; &#125; int tmp = 0; for (int i = 0; i &lt; arr.length; i++) &#123; while (arr[i] != i) &#123; if (arr[arr[i]] = arr[i]) &#123; return arr[i]; &#125; tmp = arr[i]; arr[i] = arr[tmp]; arr[tmp] = tmp; &#125; &#125; System.out.println("数组中无重复数字"); return -1; &#125;&#125; 在同一个类中，与上面的函数拆开的测试代码，为了函数更加简洁。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class FindDuplicateNumber1 &#123; /** *数组为null */ public void test1() &#123; System.out.print("test1："); int[] a = null; int dup = getDuplicate(a); if (dup &gt;= 0) System.out.println("重复数字为：" + dup); &#125; /** * 数组无重复数字 */ public void test2() &#123; System.out.print("test2："); int[] a = &#123; 0, 1, 2, 3 &#125;; int dup = getDuplicate(a); if (dup &gt;= 0) System.out.println("重复数字为：" + dup); &#125; /** * 数组数字越界 */ public void test3() &#123; System.out.print("test3："); int[] a = &#123; 1, 2, 3, 4 &#125;; int dup = getDuplicate(a); if (dup &gt;= 0) System.out.println("重复数字为：" + dup); &#125; /** * 数组带重复数字 */ public void test4() &#123; System.out.print("test4："); int[] a = &#123; 1, 2, 3, 2, 4 &#125;; int dup = getDuplicate(a); if (dup &gt;= 0) System.out.println("重复数字为：" + dup); &#125; public static void main(String[] args) &#123; FindDuplicateNumber1 f = new FindDuplicateNumber1(); f.test1(); f.test2(); f.test3(); f.test4(); &#125;&#125; 不含测试代码（牛客网提交）这里的代码为牛客网上通过的代码，如下： 12345678910111213141516171819202122232425public class Solution &#123; public boolean duplication(int[] numbers, int length, int[] duplication) &#123; if (numbers == null || numbers.length &lt;= 0) return false; for (int a : numbers) &#123; if (a &lt; 0 || ａ &gt;= length) return false; &#125; int tmp; for (int i = 0 ; i &lt; length; i++) &#123; while (numbers[i] != i) &#123; if (numbers[numbers[i]] == numbers[i]) &#123; duplication[0] = numbers[i]; return true; &#125; tmp = numbers[i]; numbers[i] = numbers[tmp]; numbers[tmp] = tmp; &#125; &#125; return false; &#125;&#125; 不修改数组找出数组中重复数字题目二在一个长度为n+1的数组里的所有数字都在1到n的范围内，所以数组中至少有一个数字是重复的。请找出数组中任意一个重复的数字，但不能修改输入的数组。例如，如果输入长度为8的数组{2, 3, 5, 4, 3, 2, 6, 7}，那么对应的输出是重复的数字2或者3。 思路数组长度为n+1，而数字只从1到n， —说明必定有重复数字—。 可以由二分查找法拓展：把1~n的数字从中间数字m分成两部分，若前一半1~m的数字数目超过m个，说明重复数字在前一半区间，否则，在后半区间m+1~n。每次在区间中都一分为二，知道找到重复数字。 更简单的思路：把该数组看作一个链表，下标代表当前结点，值代表next指针。 测试用例： 数组中带有一个或多个重复数字 数组中不包含重复的数字(题目设置必有重复) 无效输入测试用例（空数组、数组数字越界等） Java代码时间复杂度说明：函数countRange()将被调用O(logn)次，每次需要O(n)的时间。 时间复杂度：O(nlogn) （while循环为O(logn)，coutRange()函数为O(n)） 空间复杂度：O(1) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class FindDuplicateNumber2 &#123; /** * 找到数组中一个重复的数字 * 返回-1代表无重复数字或者输入无效 */ public int getDuplicate(int[] arr) &#123; if (arr == null || arr.lenght &lt;= 0) &#123; System.out.println("数组输入无效！"); return -1; &#125; for (int a : arr) &#123; if (a &lt; 1 || a &gt; arr.length - 1) &#123; System.out.println("数字大小超出范围！"); return -1; &#125; &#125; int low = 0; int high = arr.length - 1; //为题目中的n int mid, count; while (low &lt;= high) &#123; mid = low + ((high - low) &gt;&gt; 1); count = countRange(arr, low, mid); if (low == high) &#123; if (count &gt; 1) return low; else break; &#125; if (count &gt; mid - low + 1) &#123; high = mid; &#125; else &#123; low = mid + 1; &#125; &#125; return -1; &#125; /** * 返回在[low,high]范围中数字的个数 */ public int countRange(int[] arr, int low, int high) &#123; if (arr == null) return 0; int count = 0; for (int a : arr) &#123; if (a &gt;= low &amp;&amp; a &lt;= high) &#123; count++; &#125; &#125; return count; &#125;&#125; 在同一个类中，与上面的函数拆开的测试代码，为了函数更加简洁。 1234567891011121314151617181920212223242526272829303132333435363738394041public class FindDuplicateNumber2 &#123; /** *数组为null */ public void test1() &#123; System.out.print("test1："); int[] a = null; int dup = getDuplicate(a); if (dup &gt;= 0) System.out.println("重复数字为：" + dup); &#125; /** *数组数字越界 */ public void test2() &#123; System.out.print("test2："); int[] a = &#123; 1, 2, 3, 4 &#125;; int dup = getDuplicate(a); if (dup &gt;= 0) System.out.println("重复数字为：" + dup); &#125; /** *数组带重复数字 */ public void test3() &#123; System.out.print("test3："); int[] a = &#123; 1, 2, 3, 2, 4 &#125;; int dup = getDuplicate(a); if (dup &gt;= 0) System.out.println("重复数字为：" + dup); &#125; public static void main(String[] args) &#123; FindDuplicateNumber2 f2 = new FindDuplicateNumber2(); f2.test1(); f2.test2(); f2.test3(); &#125;&#125;]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>BinarySearch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer(2) 实现Singleton模式]]></title>
    <url>%2F2019%2F03%2F21%2Fsingleton.html</url>
    <content type="text"><![CDATA[饿汉模式不会出现产生多个实例的情况，见单例模式的通用代码。懒汉模式在volatile关键字修饰后，使用双重锁机制，可以解决多个实例被构建的情况，以及由于指令重排而导致的返回一个没有初始化完成的singleton对象。 实现单例模式的手段非常多，还有通过静态内部类实现的方法。 但是上述方法存在共同的问题： 无法防止利用反射来重复构建对象。 阻止反射的构建方式是使用枚举类型，有了enum语法糖，JVM会阻止反射获取枚举类的私有构造方法。 最后还有使用工厂方法模式替代单例模式，当然，其他类也可以通过反射的方式构建一个单例模式。 本文还简单的总结了volatile的两种语义的使用。 DPModel中单例模式单例模式的通用代码(线程安全)如果单例初始值是null，还未构建，则构建单例对象并返回。这个写法属于单例模式当中的懒汉模式。如果单例对象一开始就被new Singleton()主动构建，则不再需要判空操作，这种写法属于饿汉模式。 单例模式的通用代码(饿汉模式)123456789101112131415public class Singleton &#123; private static Singleton singleton = new Singleton(); private Singleton()&#123; &#125; public static Singleton getInstance() &#123; return singleton; &#125; public static void doSomething() &#123; &#125;&#125; 线程不安全的单例模式 假设Singleton类刚刚被初始化，singleton对象还是空，这时候两个线程同时访问getInstance方法 因为singleton对象为空，所以两个线程同时通过了条件判断，开始执行new操作 这样一来，显然instance被构建了两次。 线程不安全的单例(懒汉模式)123456789101112public class Singleton &#123; private static Singleton singleton = null; private Singleton() &#123;&#125; public static Singleton getInstance() &#123; if (singleton == null) &#123; singleton = new Singleton(); &#125; return singleton; &#125;&#125; 单例模式第二版(双重检测机制)单例模式第二版两次判空的机制叫做双重检测机制。 但是不是绝对的安全！！！双重检测123456789101112131415161718public class Singleton &#123; private static Singleton singleton = null; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; if (singleton == null) &#123; //双重检测 synchronized (Singleton.class) &#123; //同步锁 if (singleton == null) &#123; //双重检测 singleton = new Singleton(); &#125; &#125; &#125; return singleton; &#125;&#125; 为了防止new Singleton被执行多次，因此在new操作之前加上Synchronized 同步锁，锁住整个类（注意，这里不能使用对象锁）； 进入Synchronized 临界区以后，还要再做一次判空。因为当两个线程同时访问的时候，线程A构建完对象，线程B也已经通过了最初的判空验证，不做第二次判空的话，线程B还是会再次构建instance对象。 隐藏的漏洞(指令重排)！！！！隐藏的漏洞假设这样的场景，当两个线程一先一后访问getInstance方法的时候，当A线程正在构建对象，B线程刚刚进入方法。这种情况表面看似没什么问题，要么singleton还没被线程A构建，线程B执行 if（singleton == null）的时候得到true；要么singleton已经被线程A构建完成，线程B执行 if（singleton == null）的时候得到false。 真的如此吗？答案是否定的。这里涉及到了JVM编译器的 指令重排。 指令重排是什么意思呢？比如java中简单的一句 singleton = new Singleton，会被编译器编译成如下JVM指令： memory =allocate(); //1：分配对象的内存空间ctorInstance(memory); //2：初始化对象singleton =memory; //3：设置instance指向刚分配的内存地址 但是这些指令顺序并非一成不变，有可能会经过JVM和CPU的优化，指令重排成下面的顺序： memory =allocate(); //1：分配对象的内存空间singleton =memory; //3：设置instance指向刚分配的内存地址ctorInstance(memory); //2：初始化对象 当线程A执行完1,3,时，singleton对象还未完成初始化，但已经不再指向null。此时如果线程B抢占到CPU资源，执行 if（singleton == null）的结果会是false，从而返回一个 没有初始化完成的singleton对象。 如何避免这一情况呢？我们需要在instance对象前面增加一个 修饰符volatile。 单例模式第三版(volatile关键字加双重检测)volatile实现123456789101112131415161718public class Singleton &#123; private volatile static Singleton singleton = null; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; if (singleton == null) &#123; //双重检测机制 synchronized (Singleton.class) &#123; //同步锁 if (singleton == null) &#123; //双重检测机制 singleton = new Singleton(); &#125; &#125; &#125; return singleton; &#125;&#125; 经过volatile的修饰，当线程A执行singleton = new Singleton的时候，JVM执行顺序是什么样？始终保证是下面的顺序： memory =allocate(); //1：分配对象的内存空间ctorInstance(memory); //2：初始化对象singleton =memory; //3：设置instance指向刚分配的内存地址 如此在线程B看来，singleton对象的引用要么指向null，要么指向一个初始化完毕的Singleton，而不会出现某个中间态，保证了安全。 静态内部类实现方式1234567891011121314public class Singleton &#123; private static class LazyHolder &#123; private static final Singleton SINGLETON = new Singleton(); &#125; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; return LazyHolder.SINGLETON; &#125;&#125; 这里有几个需要注意的点： 从外部无法访问静态内部类LazyHolder，只有当调用Singleton.getInstance方法的时候，才能得到单例对象SINGLETON。 SINGLETON对象初始化的时机并不是在单例类Singleton被加载的时候，而是在调用getInstance方法，使得静态内部类LazyHolder被加载的时候。因此这种实现方式是利用 classloader的加载机制来实现懒加载，并保证构建单例的线程安全。 !!!!缺点：无法防止利用反射来重复构建对象。 这也是单例模式共同的问题。 使用工厂方法模式(利用反射打破单例)单例类1234567public static Singleton &#123; private Singleton() &#123; &#125; public void doSomething&#123; &#125;&#125; 通过反射方式创建单例的工厂类12345678910111213141516171819public class SingeltonFactory &#123; private static Singleton singleton; static &#123; try &#123; Class c1 = Class.forName(singleton.class.getName()); Constructor constructor = c1.getDeclaredConstructor(); constructor.setAccessible(true); singleton = (Singleton) constructor.newInstance(); &#125; catch (Exception e) &#123; // 异常处理 &#125; &#125; public static Singleton getInstance() &#123; return singleton; &#125;&#125; 123456789//获得构造器Constructor con = Singleton.class.getDeclaredConstructor();//设置为可访问con.setAccessible(true);//构造两个不同的对象Singleton singleton1 = (Singleton)con.newInstance();Singleton singleton2 = (Singleton)con.newInstance();//验证是否是不同对象System.out.println(singleton1.equals(singleton2)); 代码可以简单归纳为三个步骤： 第一步，获得单例类的构造器。第二步，把构造器设置为可访问。第三步，使用newInstance方法构造对象。 最后为了确认这两个对象是否真的是不同的对象，我们使用equals方法进行比较。毫无疑问，比较结果是false。 无懈可击的单例模式(枚举类实现)123public enum SingletonEnum &#123; SINGLETON;&#125; 让我们来做一个实验，仍然执行刚才的反射代码： 123456789//获得构造器Constructor con = SingletonEnum.class.getDeclaredConstructor();//设置为可访问con.setAccessible(true);//构造两个不同的对象SingletonEnum singleton1 = (SingletonEnum)con.newInstance();SingletonEnum singleton2 = (SingletonEnum)con.newInstance();//验证是否是不同对象System.out.println(singleton1.equals(singleton2)); 执行获得构造器这一步的时候，抛出了异常。 唯一的缺点是，并非适用懒加载，其单例对象是在枚举类被加载的时候进行初始化的。 单例模式实现简单总结 单例模式实现 是否线程安全 是否懒加载 是否防止反射构建 双重锁检测(第三版) 是 是 否 静态内部类 是 是 否 枚举 是 否 是 几点补充： volatile关键字不但可以防止指令重排，也可以保证线程访问的变量值是主内存中的最新值。 使用枚举实现的单例模式，不但可以防止利用反射强行构建单例对象，而且可以在枚举类对象被反序列化的时候，保证反序列的返回结果是同一对象。 对于其他方式实现的单例模式，如果既想要做到可序列化，又想要反序列化为同一对象，则必须实现readResolve方法。 枚举C/C++ 的枚举类型是int类型常量值，不安全。 java在1.5 加入枚举。 枚举是类，枚举常量是类的对象，在枚举类外无法创建枚举对象，可以保证枚举的类型安全性 所有的枚举类都继承自java.lang.Enum，并且所有的枚举类都声明为final，每个枚举常量都声明为public static final，我们不能显示地继承Enum类 枚举类实例初始化中不能访问静态变量（枚举类特殊初始化方式：构造器先于静态初始化） volatile关键字Java内存模型Java内存模型简称JMM（Java Memory Model），是Java虚拟机所定义的一种抽象规范，用来屏蔽不同硬件和操作系统的内存访问差异，让java程序在各种平台下都能达到一致的内存访问效果。 主内存（Main Memory）主内存可以简单理解为计算机当中的内存，但又不完全等同。主内存被所有的线程所共享，对于一个共享变量（比如静态变量，或是堆内存中的实例）来说，主内存当中存储了它的“本尊”。 工作内存（Working Memory）工作内存可以简单理解为计算机当中的CPU高速缓存，但又不完全等同。每一个线程拥有自己的工作内存，对于一个共享变量来说，工作内存当中存储了它的“副本”。 线程对共享变量的所有操作都必须在工作内存进行，不能直接读写主内存中的变量。不同线程之间也无法访问彼此的工作内存，变量值的传递只能通过主内存来进行。 volatile关键字具有许多特性，其中最重要的特性就是保证了 用volatile修饰的变量对所有线程的可见性。 为什么volatile关键字可以有这样的特性？这得益于java语言的先行发生原则（happens-before）。在计算机科学中，先行发生原则是两个事件的结果之间的关系，如果一个事件发生在另一个事件之前，结果必须反映，即使这些事件实际上是乱序执行的（通常是优化程序流程）。这里所谓的事件，实际上就是各种指令操作，比如读操作、写操作、初始化操作、锁操作等等。先行发生原则作用于很多场景下，包括同步锁、线程启动、线程终止、volatile。 volatile关键字只能保证变量的可见性，并不能保证变量的原子性。 不能保证线程安全！因此，什么时候适合用volatile呢？ 运行结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。 变量不需要与其他的状态变量共同参与不变约束。 指令重排指令重排是指JVM在编译Java代码的时候，或者CPU在执行JVM字节码的时候，对现有的指令顺序进行重新排序。指令重排的目的是为了在不改变程序执行结果的前提下，优化程序的运行效率。需要注意的是，这里所说的不改变执行结果，指的是不改变单线程下的程序执行结果。然而，指令重排是一把双刃剑，虽然优化了程序的执行效率，但是在某些情况下，会影响到多线程的执行结果。 内存屏障内存屏障（Memory Barrier）是一种CPU指令。内存屏障也称为内存栅栏或栅栏指令，是一种屏障指令，它使CPU或编译器对屏障指令之前和之后发出的内存操作执行一个排序约束。 这通常意味着在屏障之前发布的操作被保证在屏障之后发布的操作之前执行。内存屏障共分为四种类型： LoadLoad屏障 StoreStore屏障 LoadStore屏障 StoreLoad屏障 volatile做了什么？在一个变量被volatile修饰后，JVM会为我们做两件事： 在每个volatile写操作前插入StoreStore屏障，在写操作后插入StoreLoad屏障。 在每个volatile读操作前插入LoadLoad屏障，在读操作后插入LoadStore屏障。 两种语义volatile特性之一： 保证变量在线程之间的可见性。可见性的保证是基于CPU的内存屏障指令，被JSR-133抽象为happens-before原则。 volatile特性之二：阻止编译时和运行时的指令重排。编译时JVM编译器遵循内存屏障的约束，运行时依靠CPU屏障指令来阻止重排。 几点补充： 关于volatile的介绍，本文很多内容来自《深入理解Java虚拟机》这本书。 在使用volatile引入内存屏障的时候，普通读、普通写、volatile读、volatile写会排列组合出许多不同的场景。 volatile除了保证可见性和阻止指令重排，还解决了long类型和double类型数据的8字节赋值问题。这个特性相对简单，本文就不详细描述了。]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>DPModel</tag>
        <tag>Singleton</tag>
        <tag>volatile</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划前瞻]]></title>
    <url>%2F2019%2F03%2F20%2Foutpost-of-DP.html</url>
    <content type="text"><![CDATA[Those who cannot remember the past are condemned to repeat it.-Dynamic Programming. 动态规划定义动态规划（dynamic programming）是通过组合子问题而解决整个问题的解。 分治法是将问题划分成一些独立的子问题，递归地求解各子问题，然后合并子问题的解。 动态规划适用于子问题不是独立的情况，也就是各子问题包含公共的子子问题。此时，分治法会做许多不必要的工作，即重复地求解公共的子问题。动态规划算法对每个子问题只求解一次，将其结果保存起来，从而避免每次遇到各个子问题时重新计算答案。 适用范围最优性原理体现为问题的最优子结构特性。当一个问题的最优解中包含了子问题的最优解时，则称该问题具有最优子结构特性。最优性原理是动态规划的基础。任何一个问题，如果失去了这个最优性原理的支持，就不可能用动态规划设计求解。 问题中的状态满足最优性原理。 问题中的状态必须满足无后效性。 所谓无后效性是指：“下一时刻的状态只与当前状态有关，而和当前状态之前的状态无关，当前状态是对以往决策的总结”。 首先，动态规划方法适合的题型4个基本特点是： 最优子结构，当前一个状态得到最佳解时，当前状态在前一个状态下一定有最佳解； 子问题重叠，每个状态下要解决的问题除参数不同外，其本质是一样的； 有边界，当解决了最后一个子问题时，整个问题得解； 子问题独立，解决一个子问题时不依赖于另一个同级的子问题，只与它的母问题有关。 动态规划的设计两种方法： 自顶向下（又称记忆化搜索、备忘录）：基本上对应着递归函数实现，从大范围开始计算，要注意不断保存中间结果，避免重复计算 自底向上（递推）：从小范围递推计算到大范围 一般分为两个步骤： 问题建模 求解问题 核心元素有三个核心元素： 最优子结构 边界 状态转移方程 总结DP算法的思路核心: 最优子结构、边界条件、状态转移方程 解题步骤: 1.建立数学模型 2.写代码求解问题 如何建模?先写出所求问题的最优子结构,进而分析出边界和状态转移方程，数学模型即这2者的组合，对于2输入维度动态规划，画表格帮助分析，行列分别代表1个输入维度 如何求解? 建好模后，根据方程组写出自底向上的动态规划代码，一维输入就是1个for循环，二维输入就是2个for循环，如果方程组比较抽象，可以画表格帮助分析 棋盘问题问题寻找一条从左上角（arr[0][0]）到右下角（arr[m - 1][n - 1]）的路线，使得沿途经过的数组中的整数和最小。 递归算法从右下角倒着分析，最后一步到达arr[m - 1][n - 1]只有两条路径，即通过arr[m - 2][n - 1]或arr[m - 1][n - 2]到达。推广到一半的情况，假设到达arr[i - 1][j]与arr[i][j - 1]的最短路径的和为f(i - 1, j)和f(i, j - 1)，那么到达arr[i][j]的路径上所有数字和的最小值为 f(i, j) = min{f(i - 1, j), f(i, j - 1)} + arr[i][j] 递归方法实现效率太低，有大量重复计算过程。 动态规划算法动态规划其实是一种空间换时间的算法，通过缓存计算的中间值，减少重复计算的次数，从而提高算法的效率。递归从arr[m - 1][n - 1]开始逆向通过递归来求解，采用动态规划可以自底向上求解，以便使用前面计算出来的结果。对于本题而言，显然有边界条件，f(i, 0) = arr[0][0] + arr[i][0]， f(0, j) = arr[0][0] + arr[0][j]。状态转移方程： f(i, j) = min{f(i - 1, j), f(i, j - 1)} + arr[i][j] 可以把遍历过程中求出所有的f(i, j)的值，保存到另一个二维数组中供后续使用。 数组和最小的路线1234567891011121314151617181920212223242526272829303132333435public class Test &#123; public static int getMinPath() &#123; if (arr == null || arr.lenth == 0) return 0; int row = arr.length; int col = arr[0].length; int[][] cache = new int[row][col]; for (int i = 1; i &lt; row; i++) cache[i][0] = cache[i-1][0] + arr[i][0]; for (int j = 1; j &lt; col; j++) cache[0][j] = cache[0][j-1] + arr[0][j]; for (int i = 1; i &lt; row; i++) &#123; for (int j = 1; j &lt; col; j++) &#123; //可以确定选择的路线为arr[i-1][j] if (arr[i-1][j] &lt; arr[i][j-1]) &#123; cache[i][j] = cache[i-1][j] + arr[i][j]; System.out.print("[" + (i - 1) + ", " + j + "] "); &#125; else &#123; cache[i][j] = cache[i][j-1] + arr[i][j]; System.out.print("[" + i + ", " + (j - 1) + "] "); &#125; &#125; &#125; System.out.println("[" + (row - 1) + ", " + (col - 1) + "]"); return cache[row - 1][col - 1]; &#125; public static void main(String[] args) &#123; int[][] arr = &#123;&#123;1,4,3&#125;, &#123;8,7,5&#125;, &#123;2,1,5&#125;&#125;; System.out.print("路径： ")； System.out.println("最小值为： " + getMinPath(arr)); &#125;&#125; 对二维数组遍历一次，时间复杂度为O(mn)，申请了一个二维数组来保存中间结果，空间复杂度为O(mn)。 国王与金矿知道 i-1 座金矿的最大产量就一定能知道 i 座金矿的最大产量，这是 最优子结构，每个人要知道i座金矿的最大产量就必须知道知道 i-1 座金矿的最大产量，这是 子问题重叠，最终当考虑第 1 座金矿的最大产量时，只要看是否有足够人手开采第 1 座金矿，有的话，答案是已探明的储量，没有的话就是0，然后答案汇报到上级，上级再得出第 2 座金矿开采与不开采得出的较大产量，再往上汇报…，这就是 边界，而每个人从上级得到的前提都是不同的，上级决定开不开采，再将这个前提之一告诉下属，而下属不需要考虑上级给另一个下属什么前提，这是 子问题独立。 把金矿数量设为n，工人数量设为w，金矿的黄金量设为g[]，金矿的用工量设为p[]。F(n, w) = 0 (n &lt;= 1, w &lt; p[0]);F(n, w) = g[0] (n == 1, w &gt;= p[0]);F(n, w) = F(n - 1, w) (n &gt; 1, w &lt; p[n - 1]);F(n, w) = max(F(n - 1, w)， F(n - 1, w - p[n - 1]) + g[n - 1]) (n &gt; 1, w &gt;= p[n-1]); 递归算法把状态转移方程翻译成递归程序，递归结束条件是方程中的边界。 因为每个状态有两个最优子结构，所以递归的执行流程类似于一棵高度为N的二叉树。 时间复杂度为O(2^n)。 递归解法123456789101112131415161718public static int getMostGold(int n, int w, int[] g, int[] p) &#123; if (n &gt; g.length) throw new RuntimeException("输入的n值大于给定的金矿数"); if (n &lt;= 1 &amp;&amp; w &lt; p[0]) return 0; if (n == 1 &amp;&amp; w &gt;= p[0]) return g[0]; if (n &gt; 1 &amp;&amp; w &lt; p[n-1]) return getMostGold(n-1, w, g, p); int a = getMostGold(n-1, w, g, p); int b = getMostGold(n-1, w - p[n-1], g, p) + g[n-1]; return Math.max(a, b); &#125; DP解法画表格分析，表格第一列代表给定前1-5做金矿的情况，也就是N的取值。表格第一行代表给定的工人数，也就是w的取值。其余空白格表示，给定n和w值对应的黄金获得数，也就是F(n,w)。 1工人 2工人 3工人 4工人 5工人 6工人 7工人 8工人 9工人 10工人 1金矿 2金矿 3金矿 4金矿 5金矿 第一个金矿的信息：400金，5工人 1工人 2工人 3工人 4工人 5工人 6工人 7工人 8工人 9工人 10工人 1金矿 0 0 0 0 400 400 400 400 400 400 2金矿 3金矿 4金矿 5金矿 第二个金矿的信息：500金，5工人根据F(n,w) = Max(F(n-1, w), F(n-1, w-5) + 500)， 5-9格子为500，第2行第10个格子，n=2，w=10 F(n-1, w-5) = 400 Max(400, 400+500) = 900 1工人 2工人 3工人 4工人 5工人 6工人 7工人 8工人 9工人 10工人 1金矿 0 0 0 0 400 400 400 400 400 400 2金矿 0 0 0 0 500 500 500 500 500 900 3金矿 4金矿 5金矿 第三个金矿的信息：200金，3工人 根据F(n,w) = Max(F(n-1, w), F(n-1, w-5) + 200) 1工人 2工人 3工人 4工人 5工人 6工人 7工人 8工人 9工人 10工人 1金矿 0 0 0 0 400 400 400 400 400 400 2金矿 0 0 0 0 500 500 500 500 500 900 3金矿 0 0 200 200 500 500 500 700 700 900 4金矿 5金矿 第四个金矿的信息：300金，4工人 根据F(n,w) = Max(F(n-1, w), F(n-1, w-5) + 300) 1工人 2工人 3工人 4工人 5工人 6工人 7工人 8工人 9工人 10工人 1金矿 0 0 0 0 400 400 400 400 400 400 2金矿 0 0 0 0 500 500 500 500 500 900 3金矿 0 0 200 200 500 500 500 700 700 900 4金矿 0 0 200 300 500 500 500 700 800 900 5金矿 第五个金矿的信息：350金，3工人 根据F(n,w) = Max(F(n-1, w), F(n-1, w-5) + 350) 1工人 2工人 3工人 4工人 5工人 6工人 7工人 8工人 9工人 10工人 1金矿 0 0 0 0 400 400 400 400 400 400 2金矿 0 0 0 0 500 500 500 500 500 900 3金矿 0 0 200 200 500 500 500 700 700 900 4金矿 0 0 200 300 500 500 500 700 800 900 5金矿 0 0 350 350 500 550 650 850 850 900 上述表格，比如5金矿10工人的结果，来自于4金矿7工人和4金矿10工人， Max(900, 500+350)=900 不需要存储整个表格，只需要存储前一行的结果，就可以推导出新的一行。使用动态规划如下： DP解法123456789101112131415161718192021222324252627282930313233343536373839404142434445int getMostGold(int n, int w, int[] g, int[] p) &#123; if (n &gt; g.length) throw new RuntimeException("输入的n值大于给定的金矿数")； if (w &lt; 0) throw new RuntimeException("输入的工人数w不能为负数")； if (n &lt; 1 || w == 0) reurn 0; int col = w + 1; int[] preResults = new in[col]; int[] results = new int[col]; //填充边界格子的值 (边界) for (int i = 0; i &lt; col; i++) &#123; if (i &lt; p[0]) &#123; preResults[i] = 0; &#125; else &#123; preResults[i] = g[0]; &#125; &#125; if (n == 1) &#123; return preResults = g[0]; &#125; //填充其余格子的值，外层循环是金矿的数量(递推的轮次)，内层循环是工人数 for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; col; j++) &#123; if (j &lt; p[1]) &#123; results[j] = preResults[j]; &#125; else &#123; results[j] = Math.max(preResults[j], reResults[j-p[i]] + g[i]); &#125; &#125; for (int j = 0; j &lt; col; j++) &#123; //更新上一行的值，为下一轮递推做准备 preResults[j] = results[j]; &#125; /* preResults = results; * 这样赋值会导致preResults和results指向同一个数组， *在下一轮循环中改变results中的值也改变了preResults中的值 */ &#125; return results[w];&#125; 上述方法利用两层迭代，外层迭代对表格每一行的迭代过程中，会保留上一行的结果数组preResults，并循环计算当前的结果数组results。方法的时间复杂度为O(n*w)，空间复杂度是O(w)。当金矿更多的时候，动态规划的优势就能体现出来。 然而，当工人为1000时，动态规划的时间复杂度为5 * 1000 = 5000，开辟1000单位的空间。 递归的时间复杂度是O(2^n)，需要计算32次，开辟5单位（递归深度）的空间。 动态规划方法的时间和空间都和w成正比，而简单递归和w无关，所以工人很多的时候，动规反而不如递归。 所以说，每一种算法都没有绝对的好与坏，关键看应用场景。 备忘录解法备忘录解法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677// 该内部类对象用于备忘录算法中作为HashMap存储的键private static class Input &#123; private int n; private int w; public Input(int n, int w) &#123; super(); this.n = n; this.w = w; &#125; @Override public int hashCode() &#123; final int prime = 31; int result = 1; result = prime * result + n; result = prime * result + w; return result; &#125; @Override public boolean equals(Object obj) &#123; if (this == obj) return true; if (obj == null) return false; if (getClass() != obj.getClass()) return false; Input other = (Input) obj; if (n != other.n) return false; if (w != other.w) return false; return true; &#125;&#125; // 备忘录算法解法public static int getMostGold2(int n, int w, HashMap&lt;Input, Integer&gt; map, int[] g, int[] p) &#123; if (n &gt; g.length) throw new RuntimeException("输入的n值大于给定的金矿数"); if (n &lt;= 1 &amp;&amp; w &lt; p[0]) return 0; if (n == 1 &amp;&amp; w &gt;= p[0]) return g[0]; if (n &gt; 1 &amp;&amp; w &lt; p[n-1]) &#123; Input input = new Input(n-1, w); if (map.containsKey(input)) return map.get(input); int value = getMostGold2(n-1, w, map, g, p); map.put(input, value); return value; &#125; Input input1 = new Input(n-1, w); Input input2 = new Input(n-1, w-p[n-1]); int a = 0; //用于记录F(n-1,w)的值 int b = 0; //用于记录F(n-1,w-p[n-1])+g[n-1])的值 if (map.containsKey(input1)) a = map.get(input1); a = getMostGold2(n-1, w, map, g, p); map.put(input1, a); if (map.containsKey(input2)) b = map.get(input2) + g[n-1]; b = getMostGold2(n-1, w-p[n-1], map, g, p); map.put(input2, b); b += g[n-1]; return a &gt; b ? a : b;&#125;]]></content>
      <categories>
        <category>Dynamic Programming</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉搜索树]]></title>
    <url>%2F2019%2F03%2F16%2Fbinary-search-tree.html</url>
    <content type="text"><![CDATA[二叉搜索树（没有重复元素）的特征是：对于树中的每一个节点，它的左子树中的节点的值都小于该节点的值，而它的右子树中节点的值都大于该节点的值。 表示二叉搜索树二叉搜索树（Binary Search Tree, BST）可以用一个链式节点的集合来表示二叉树。 每个节点都包含一个数值和两个称为left和right的链接，分别指向左孩子和右孩子。 树的节点类12345678910111213/** This inner class is static, because it does not access *any instance members defined in its outer class */public static class TreeNode&lt;E extends Comparable&lt;E&gt;&gt; &#123; protected E element; protected TreeNode&lt;E&gt; left; protected TreeNode&lt;E&gt; right; public TreeNode(E e) &#123; element = e; &#125;&#125; TreeNode&lt;Integer&gt; root = new TreeNode&lt;&gt;(60); 变量root指向根节点。如果树为空，root的值为null。 树的遍历二叉树分为根节点、左子树和右子树，分别表示为 +、1、2。二叉树本身是递归定义的，相应的遍历很自然就成为一种递归问题。 递归遍历操作的关键点是递归体和递归出口： 递归出口是二叉树的空子树或叶节点，此时为空操作，递归不继续进行，只能回退； 递归体是对二叉树根节点或左、右子树进行相应处理。 基于递归的遍历算法易于编写，操作简单，但可读性差，系统需要维护相应的工作栈，效率不是很高。递归转化为非递归的基本思想是如何实现原本是系统完成的递归工作栈，为此，可以仿照递归执行过程中工作栈状态变化而得到。 对二叉树进行前序、中序和后序遍历时都开始于根节点或结束于根节点，经由路线也相同。彼此差别在于对节点访问时机的选择不同。三种遍历方式都是沿着左子树不断深入下去，当到达二叉树左下节点而无法往下深入时，就向上逐一返回，行进到最近深入时曾遇到节点的右子树，然后进行同样的深入和返回，直到最终从根节点的右子树返回到根节点。这样，遍历时返回顺序与深入节点顺序恰好相反，因此可以在实现二叉树遍历过程中，使用一个工作栈来保存当前深入到的节点信息，以供后面返回需要时使用。 中序遍历(inorder traversal)遍历顺序为： 1+2 可以递增顺序显示BST中所有节点。中序遍历的黄金口诀：当前节点为空，从栈中弹出一个元素，当前节点向右移动；当前节点不为空，压栈，当前节点向左移动 中序遍历访问左子二叉树 访问根节点 中序遍历访问右子二叉树 inorder递归遍历1234567891011public void inorder() &#123; inorder(root); &#125;protected void inorder(TreeNode&lt;E&gt; root) &#123; if (root == null) return; inorder(root.left); // 递归遍历左子树 System.out.print(root.element + " "); // 递归遍历根节点 inorder(root.right); // 递归遍历右子树 1+2&#125; 中序非递归遍历1234567891011121314151617181920public void inorder() &#123; inorder(root);&#125;protected void inorder(TreeNode&lt;E&gt; root) &#123; if (root == null) return; java.util.Stack&lt;TreeNode&lt;E&gt;&gt; stack = new java.util.Stack&lt;&gt;(); TreeNode&lt;E&gt; current = root; while (!stack.empty() || current != null) &#123; if (current != null) &#123; stack.push(current); current = current.left; &#125; else &#123; TreeNode&lt;E&gt; node = stack.pop(); System.out.print(node.element + " "); current = node.right; &#125; &#125;&#125; 前序遍历(preorder traversal)+12 深度优先遍历法(depth-first traversal)与前序遍历法相同。 访问根节点 前序遍历访问左子二叉树 前序遍历访问右子二叉树 preorder递归遍历12345678910public void preorder() &#123; preorder(root);&#125;protected void preorder(TreeNode&lt;E&gt; root) &#123; if (root == null) return; System.out.println(root.element + " "); // 递归遍历根节点 preorder(root.left); // 递归遍历左子树 preorder(root.right); // 递归遍历右子树 +12&#125; 前序非递归遍历1234567891011121314151617181920212223public void preorder() &#123; preorder(root);&#125; protected void preorder(TreeNode&lt;E&gt; root) &#123; if (root == null) return; Stack&lt;TreeNode&lt;E&gt;&gt; stack = new Stack&lt;&gt;(); stack.push(root); while (!stack.empty()) &#123; TreeNode&lt;E&gt; node = stack.pop(); System.out.print(node.element + " "); // Push the right child onto the stack // first so the left is processed first if (node.right != null) &#123; stack.push(node.right); &#125; if (node.left != null) &#123; stack.push(node.left); &#125; &#125;&#125; 后序遍历(postorder traversal)12+ 后序遍历访问左子二叉树 后序遍历访问右子二叉树 访问根节点 postorder递归遍历12345678910public void postorder() &#123; postorder(root);&#125;protected void postorder(TreeNode&lt;E&gt; root) &#123; if (root == null) return; postorder(root.left); // 递归遍历左子树 postorder(root.right); // 递归遍历右子树 System.out.println(root.element + " "); // 递归遍历根节点 12+&#125; 后序非递归遍历1234567891011121314151617181920212223242526272829public void postorder() &#123; postorder(root);&#125;protected void postorder(TreeNode&lt;E&gt; root) &#123; if (root == null) return; // Create two stacks Stack&lt;TreeNode&lt;E&gt;&gt; stack1 = new Stack&lt;&gt;(); Stack&lt;TreeNode&lt;E&gt;&gt; stack2 = new Stack&lt;&gt;(); // push root to stack1 stack1.push(root); while (!stack1.empty()) &#123; // Pop node from stack1 and push onto stack2 TreeNode&lt;E&gt; node = stack1.pop(); stack2.push(node); if (node.left != null) stack1.push(node.left); if (node.right != null) stack1.push(node.right); &#125; // Display elements in stack2 while (!stack2.empty()) &#123; System.out.print(stack2.pop().element + " "); &#125;&#125; 广度优先遍历(breadth-first traversal)广度优先遍历12345678910111213141516171819public void breadthFirstTraversal() &#123; if (root == null) return; // Queue Deque Linkedlist java.util.Queue&lt;TreeNode&lt;E&gt;&gt; queue = new java.util.LinkedList&lt;&gt;(); queue.add(root); while (!queue.isEmpty()) &#123; TreeNode&lt;E&gt; current = queue.element(); if (current.left != null) &#123; queue.add(current.left); &#125; if (current.right != null) &#123; queue.add(current.right); &#125; System.out.println(queue.remove().element + " "); &#125;&#125; 搜索一个元素二叉搜索树中搜索一个元素，可以从根节点向下扫描，知道找到匹配元素，或者达到一棵空子树为止。在BST中搜索一个元素12345678910111213public boolean search(E e) &#123; TreeNode&lt;E&gt; current = root; // 当前指针指向根节点 while (current != null) &#123; if (e.compareTo(current.element) &lt; 0) &#123; current = current.left; // 比当前指针的元素小，则往左 &#125; else if (e.compareTo(current.element) &gt; 0) &#123; current = current.right; // 比当前指针的元素大，则往右 &#125; else &#123; // 元素匹配 return true; // 找到元素 return true &#125; &#125; return false;&#125; 插入一个元素BST中插入一个元素，需要确定在书中插入的位置，关键思路是确定新节点的父节点所在的位置。 如果树是空的，使用新元素创建一个根节点； 否则，寻找新节点的父节点的位置 为该元素创建一个新节点，如果新元素的值小于父元素的值，左子节点；如果新元素的值大于父元素的值，右子节点；BST没有重复元素，重复则不插入 在BST中插入一个元素12345678910111213141516171819202122232425262728293031public boolean insert(E e) &#123; if (root == null) &#123; root = createNewNode(e); // 创建一个节点，树为空该节点成为根节点 &#125; else &#123; TreeNode&lt;E&gt; parent = null; // 定位父节点 TreeNode&lt;E&gt; current = root; // 当前指针指向根节点 while (current != null) &#123; if (e.compareTo(current.element) &lt; 0) &#123; parent = current; current = current.left; &#125; else if (e.compareTo(current.element) &gt; 0) &#123; parent = current; current = current.right; &#125; else &#123; return false; // 元素已经在树中，return false &#125; &#125; // 为元素e创建一个节点 if (e.compareTo(parent.element) &lt; 0) &#123; parent.left = createNewNode(e); &#125; else &#123; parent.right = createNewNode(e); &#125; &#125; size++; return true;&#125;public TreeNode&lt;E&gt; createNewNode(E e) &#123; return new TreeNode&lt;&gt;(e);&#125; 删除BST中的一个元素为了从一棵二叉搜索树中删除一个元素，首先需要定位该元素位置，然后再删除该元素以及重新连接树前，考虑两种情况–该节点有或者没有左子节点。情况1：当前节点没有左子结点。只需将该节点的父节点和该节点的右子节点相连。如果当前节点是叶子节点，属于情况1； 情况2：当前节点有左子结点。假设rightMost指向包含current节点的左子树中的最大元素的节点，而parentOfRightMost指向rightMost节点的父节点。使用rightMost节点中的元素替代current节点中的元素值，将parentOfRightMost节点和rightMost节点的左子节点相连，然后删除rightMost节点。 rightMost作为最大值不能有右节点，但是可能会有左子节点！从BST中删除一个元素1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public boolean delete(E e) &#123; // 如果current为root,那么parent为null TreeNode&lt;E&gt; parent = null; // 指向current节点的父节点 TreeNode&lt;E&gt; current = root; // 指向二叉搜索树中包含该元素的节点 while (current != null) &#123; // 递归寻找current节点 if (e.compareTo(current.element) &lt; 0) &#123; parent = current; current = current.left; &#125; else if (e.compareTo(current.element) &gt; 0) &#123; parent = current; current = current.right; &#125; else &#123; break; // 找到包含e的current节点 &#125; &#125; if (current == null) &#123; return false; // 元素不在树内 &#125; // 情况1：当前节点没有左子节点 if (current.left == null) &#123; //只需将该节点的父节点和该节点的右子节点相连 if (parent == null) &#123; root = current.right; &#125; else &#123; if (e.compareTo(parent.element) &lt; 0) &#123; parent.left = current.right; // e是父节点的左子结点 &#125; else &#123; parent.right = current.right; // e是父节点的右子结点 &#125; &#125; &#125; else &#123; // 情况2：当前节点有左子节点 TreeNode&lt;E&gt; parentOfRightMost = current; // rightMost节点的父节点 TreeNode&lt;E&gt; rightMost = current.left; // 当前节点的左子树最右端的节点 while (rightMost.right != null) &#123; parentOfRightMost = rightMost; rightMost = rightMost.right; // 向右不断递归 &#125; // 用rightMost节点的内容替换current中的内容 current.element = rightMost.element; // rightMost的父节点和rightMost的左子节点相连 if (parentOfRightMost.right == rightMost) &#123; // rightMost是右子节点 parentOfRightMost.right = rightMost.left; &#125; else &#123; // rightMost是左子节点 parentOfRightMost.left = rightMost.left; &#125; &#125; size--; return true;&#125; 找出叶子节点和非叶子结点找出叶子节点的个数123456789101112public int getNumberOfLeaves() &#123; return getNumberOfLeaves(root);&#125;protected int getNumberOfLeaves(TreeNode&lt;E&gt; root) &#123; if (root ==null) return 0; // If node has no children return 1 // else return the sum of all the leaves return root.left == null &amp;&amp; root.right == null ? 1 : getNumberOfLeaves(root.left) + getNumberOfLeaves(root.right);&#125; 找出非叶子节点的个数12345678910111213public int getNumberOfNonLeaves() &#123; return getNumberOfNonLeaves(root);&#125; protected int getNumberOfNonLeaves(TreeNode&lt;E&gt; root) &#123; if (root == null) return 0; // If node has children return 0 // else return 1 plus the sum of the nonleaves return (root.left == null &amp;&amp; root.right == null) ? 0 : 1 + getNumberOfNonLeaves(root.left) + getNumberOfNonLeaves(root.right) ;&#125; 实现equals和clone方法树的equals方法12345678910111213public boolean equals(BST&lt;E&gt; tree) &#123; if (tree.size != size) return false; return equals(root, tree.root);&#125;/** Equals helper */protected boolean equals(TreeNode&lt;E&gt; root1, TreeNode&lt;E&gt; root2) &#123; if (root1 == root2) return true; if (root1 == null || root2 == null) return false; return root1.element.equals(root2.element) &amp;&amp; equals(root1.left, root2.left) &amp;&amp; equals(root1.right, root2.right);&#125; 树的clone方法12345678910111213public BST&lt;E&gt; clone() throws CloneNotSupportedException &#123; BST&lt;E&gt; cloneBST = new BST&lt;&gt;(); clone(cloneBST, root); return cloneBST;&#125;/** Clone helper */protected void clone(BST&lt;E&gt; clone, TreeNode&lt;E&gt; root) &#123; if (root == null) return; clone.insert(root.element); clone(clone, root.left); clone(clone, root.right);&#125; BST类使用一个Tree的接口来定义树的所有常用操作，提供AbstractTree的抽象类部分实现了Tree，最后实现了BST类。 Tree接口Tree.java 接口定义树的常用操作12345678910111213141516171819202122232425262728public interface Tree&lt;E&gt; extends Iterable&lt;E&gt;&#123; /** Return true 如果搜索成功 */ boolean search(E e); /** 向二叉搜索树插入元素 Return true 如果成功添加 */ boolean insert(E e); /** Return true 如果成功从树中删除元素 */ boolean delete(E e); /** 中序遍历打印节点 1+2 */ void inorder(); /** 后序遍历打印节点 12+ */ void postorder(); /** 前序遍历打印节点 +12 */ void preorder(); /** 广度优先遍历打印节点 */ void breadthFirstTraversal(); /** 返回树中节点数 */ int getSize(); /** Return true 如果树为空 */ boolean isEmpty(); &#125; AbstractTree抽象类AbstractTree.java 抽象类部分地实现了Tree123456789101112131415161718public abstract class AbstractTree&lt;E&gt; implements Tree&lt;E&gt; &#123; @Override /** 中序遍历打印节点 1+2 */ public void inorder() &#123; &#125; @Override /** 后序遍历打印节点 12+ */ public void postorder() &#123; &#125; @Override /** 前序遍历打印节点 +12 */ public void preorder() &#123; &#125; @Override /** Return true 如果树为空 */ public boolean isEmpty() &#123; return getSize() == 0; &#125;&#125; 具体的BSTBST.java 具体定义了BST123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410import java.util.ArrayList;import java.util.Iterator;import java.util.LinkedList;import java.util.Queue;/* 因为每个节点只遍历一次，遍历的时间复杂度都是O(n) * 搜索、插入和删除的时间复杂度是树的高度。 * 最差的情况下，树的高度为O(n) * 如果树是平衡的，高度将是O（logn) */public class BST&lt;E extends Comparable&lt;E&gt;&gt; extends AbstractTree&lt;E&gt; &#123; protected TreeNode&lt;E&gt; root; //根节点 protected int size = 0; //节点数目 /** 默认构造方法 */ public BST() &#123; &#125; /** 泛型数组构造二叉搜索树 */ public BST(E[] objects) &#123; for (int i = 0; i &lt; objects.length; i++) insert(objects[i]); &#125; @Override public boolean search(E e) &#123; TreeNode&lt;E&gt; current = root; // 当前指针指向根节点 while (current != null) &#123; if (e.compareTo(current.element) &lt; 0) &#123; current = current.left; // 比当前指针的元素小，则往左 &#125; else if (e.compareTo(current.element) &gt; 0) &#123; current = current.right; // 比当前指针的元素大，则往右 &#125; else &#123; // 元素匹配 return true; // 找到元素 return true &#125; &#125; return false; &#125; @Override public boolean insert(E e) &#123; if (root == null) &#123; root = createNewNode(e); // 创建一个节点，树为空该节点成为根节点 &#125; else &#123; TreeNode&lt;E&gt; parent = null; // 定位父节点 TreeNode&lt;E&gt; current = root; // 当前指针指向根节点 while (current != null) &#123; if (e.compareTo(current.element) &lt; 0) &#123; parent = current; current = current.left; &#125; else if (e.compareTo(current.element) &gt; 0) &#123; parent = current; current = current.right; &#125; else &#123; return false; // 元素已经在树中，return false &#125; &#125; // 为元素e创建一个节点 if (e.compareTo(parent.element) &lt; 0) &#123; parent.left = createNewNode(e); &#125; else &#123; parent.right = createNewNode(e); &#125; &#125; size++; return true; &#125; public TreeNode&lt;E&gt; createNewNode(E e) &#123; return new TreeNode&lt;&gt;(e); &#125; /** 为了从一棵二叉搜索树中删除一个元素，首先需要定位该元素位置， * 然后在删除该元素以及重新连接树之前，考虑两种情况： * 1）该节点有左子节点 * 2）该节点没有左子节点 */ @Override public boolean delete(E e) &#123; // 如果current为root,那么parent为null TreeNode&lt;E&gt; parent = null; // 指向current节点的父节点 TreeNode&lt;E&gt; current = root; // 指向二叉搜索树中包含该元素的节点 while (current != null) &#123; // 递归寻找current节点 if (e.compareTo(current.element) &lt; 0) &#123; parent = current; current = current.left; &#125; else if (e.compareTo(current.element) &gt; 0) &#123; parent = current; current = current.right; &#125; else &#123; break; // 找到包含e的current节点 &#125; &#125; if (current == null) &#123; return false; // 元素不在树内 &#125; // 情况1：当前节点没有左子节点 if (current.left == null) &#123; //只需将该节点的父节点和该节点的右子节点相连 if (parent == null) &#123; root = current.right; &#125; else &#123; if (e.compareTo(parent.element) &lt; 0) &#123; parent.left = current.right; // e是父节点的左子结点 &#125; else &#123; parent.right = current.right; // e是父节点的右子结点 &#125; &#125; &#125; else &#123; // 情况2：当前节点有左子节点 TreeNode&lt;E&gt; parentOfRightMost = current; // rightMost节点的父节点 TreeNode&lt;E&gt; rightMost = current.left; // 当前节点的左子树最右端的节点 while (rightMost.right != null) &#123; parentOfRightMost = rightMost; rightMost = rightMost.right; // 向右不断递归 &#125; // 用rightMost节点的内容替换current中的内容 current.element = rightMost.element; // rightMost的父节点和rightMost的左子节点相连 if (parentOfRightMost.right == rightMost) &#123; // rightMost是右子节点 parentOfRightMost.right = rightMost.left; &#125; else &#123; // rightMost是左子节点 parentOfRightMost.left = rightMost.left; &#125; &#125; size--; return true; &#125; @Override public void inorder() &#123; inorder(root); &#125; protected void inorder(TreeNode&lt;E&gt; root) &#123; if (root == null) return; inorder(root.left); // 递归遍历左子树 System.out.print(root.element + " "); // 递归遍历根节点 inorder(root.right); // 递归遍历右子树 1+2 &#125; @Override public void postorder() &#123; postorder(root); &#125; protected void postorder(TreeNode&lt;E&gt; root) &#123; if (root == null) return; postorder(root.left); // 递归遍历左子树 postorder(root.right); // 递归遍历右子树 System.out.println(root.element + " "); // 递归遍历根节点 12+ &#125; @Override public void preorder() &#123; preorder(root); &#125; protected void preorder(TreeNode&lt;E&gt; root) &#123; if (root == null) return; System.out.println(root.element + " "); // 递归遍历根节点 preorder(root.left); // 递归遍历左子树 preorder(root.right); // 递归遍历右子树 +12 &#125; @Override public void breadthFirstTraversal() &#123; if (root == null) return; Queue&lt;TreeNode&lt;E&gt;&gt; queue = new LinkedList&lt;&gt;(); // Queue Deque Linkedlist queue.add(root); while (!queue.isEmpty()) &#123; TreeNode&lt;E&gt; current = queue.element(); if (current.left != null) &#123; queue.add(current.left); &#125; if (current.right != null) &#123; queue.add(current.right); &#125; System.out.println(queue.remove().element + " "); &#125; &#125; /**以数组线性表返回节点的路径： * 从根节点开始到该元素所在的节点 * 元素可能不在树中 */ public ArrayList&lt;TreeNode&lt;E&gt;&gt; path(E e) &#123; ArrayList&lt;TreeNode&lt;E&gt;&gt; list = new ArrayList&lt;&gt;(); TreeNode&lt;E&gt; current = root; while (current != null) &#123; list.add(current); if (e.compareTo(current.element) &lt; 0) &#123; current = current.left; &#125; else if (e.compareTo(current.element) &gt; 0) &#123; current = current.right; &#125; else &#123; break; &#125; &#125; return list; &#125; public int height() &#123; return height(root); &#125; public int height(TreeNode&lt;E&gt; root) &#123; if (root == null) return 0; return 1 + Math.max(height(root.left), height(root.right)); &#125; @Override public int getSize() &#123; return size; &#125; public TreeNode&lt;E&gt; getRoot() &#123; return root; &#125; public void clear() &#123; root = null; size = 0; &#125; /** 测试完全二叉树，完全二叉树的节点格式为 2^depth - 1 */ public boolean isFullBST() &#123; return size == Math.pow(2, height()) - 1 ? true : false; &#125; /** 找出叶子节点的个数 */ public int getNumberOfLeaves() &#123; return getNumberOfLeaves(root); &#125; protected int getNumberOfLeaves(TreeNode&lt;E&gt; root) &#123; if (root ==null) return 0; // If node has no children return 1 // else return the sum of all the leaves return root.left == null &amp;&amp; root.right == null ? 1 : getNumberOfLeaves(root.left) + getNumberOfLeaves(root.right); &#125; public int getNumberOfNonLeaves() &#123; return getNumberOfNonLeaves(root); &#125; protected int getNumberOfNonLeaves(TreeNode&lt;E&gt; root) &#123; if (root == null) return 0; // If node has children return 0 // else return 1 plus the sum of the nonleaves return (root.left == null &amp;&amp; root.right == null) ? 0 : 1 + getNumberOfNonLeaves(root.left) + getNumberOfNonLeaves(root.right) ; &#125; /** Returns true if two trees are equal. Otherwise returns false (recursive) */ public boolean equals(BST&lt;E&gt; tree) &#123; if (tree.size != size) return false; return equals(root, tree.root); &#125; /** Equals helper */ protected boolean equals(TreeNode&lt;E&gt; root1, TreeNode&lt;E&gt; root2) &#123; if (root1 == root2) return true; if (root1 == null || root2 == null) return false; return root1.element.equals(root2.element) &amp;&amp; equals(root1.left, root2.left) &amp;&amp; equals(root1.right, root2.right); &#125; @Override /** Override the protected clone method defined in the Object class, and deep copy BST */ public BST&lt;E&gt; clone() throws CloneNotSupportedException &#123; BST&lt;E&gt; cloneBST = new BST&lt;&gt;(); clone(cloneBST, root); return cloneBST; &#125; /** Clone helper */ protected void clone(BST&lt;E&gt; clone, TreeNode&lt;E&gt; root) &#123; if (root == null) return; clone.insert(root.element); clone(clone, root.left); clone(clone, root.right); &#125; @Override public Iterator&lt;E&gt; iterator() &#123; return new InorderIterator(); &#125; private class InorderIterator implements Iterator&lt;E&gt; &#123; private ArrayList&lt;E&gt; list = new ArrayList&lt;&gt;(); private int current = 0; // 指向线性表中的第一个元素 public InorderIterator() &#123; inorder(); &#125; private void inorder() &#123; inorder(root); &#125; private void inorder(TreeNode&lt;E&gt; root) &#123; if (root == null) return; inorder(root.left); list.add(root.element); inorder(root.right); &#125; @Override public boolean hasNext() &#123; if (current &lt; list.size()) // 检查current是否在list范围内 return true; return false; &#125; @Override public E next() &#123; return list.get(current++); // 返回当前元素 然后current+1 &#125; @Override public void remove() &#123; delete(list.get(current)); // 删除当前元素 list.clear(); // 清空线性表 inorder(); // 创建一个新的线性表，每次通过迭代器删除一个元素都要重新构造整个线性表 &#125; /* 在使得remove方法不被迭代器支持后， * 无须为树中的元素维护一个线性表使得迭代器更加高效。 * 可以使用栈来存储节点 * public void remove() &#123; throw new UnsupportedOparetionException("removing an element from the iterator is not supported"); &#125; */ &#125; /** Returns an iterator for traversing the elements in preorder */ public java.util.Iterator&lt;E&gt; preorderIterator() &#123; return new PreorderIterator(); &#125; // Inner class preorderIterator private class PreorderIterator implements java.util.Iterator&lt;E&gt; &#123; // Store the elements in a list private java.util.ArrayList&lt;E&gt; list = new java.util.ArrayList&lt;&gt;(); private int current = 0; // Point to the current element in list public PreorderIterator() &#123; preorder(); // Traverse binary tree and store elements in list &#125; /** Preorder traversal from the root */ private void preorder() &#123; preorder(root); &#125; /** preorder traversal from a subtree */ private void preorder(TreeNode&lt;E&gt; root) &#123; if (root == null) return; list.add(root.element); preorder(root.left); preorder(root.right); &#125; @Override /** More elements for traversing? */ public boolean hasNext() &#123; if (current &lt; list.size()) return true; return false; &#125; @Override /** Get the current element and move to the next */ public E next() &#123; return list.get(current++); &#125; @Override /** Remove the current element */ public void remove() &#123; delete(list.get(current)); // Delete the current element list.clear(); // Clear the list preorder(); // Rebuild the list &#125; &#125; /** This inner class is static, because it does not access any instance members defined in its outer class */ public static class TreeNode&lt;E extends Comparable&lt;E&gt;&gt; &#123; protected E element; protected TreeNode&lt;E&gt; left; protected TreeNode&lt;E&gt; right; public TreeNode(E e) &#123; element = e; &#125; &#125; &#125; BST的测试用例BST测试用例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384import java.util.Iterator;public class TestBST &#123; public static void main(String[] args) throws Exception &#123; // 广度优先遍历和树的高度 BST&lt;String&gt; strTree = new BST&lt;&gt;(); strTree.insert("George"); strTree.insert("Micheal"); strTree.insert("Tom"); strTree.insert("Adam"); strTree.insert("Jones"); strTree.insert("Peter"); strTree.insert("Daniel"); System.out.print("\nBreadth-first: "); strTree.breadthFirstTraversal(); System.out.print("\nHeight of tree: "); System.out.println(strTree.height()); // 测试完全二叉树 Integer[] numbers1 = &#123;2, 4, 3, 1, 8, 5, 6, 7&#125;; Integer[] numbers2 = &#123;4, 2, 1, 3, 8, 5, 9&#125;; Integer[] numbers3 = &#123;10, 4, 2, 1, 3, 8, 5, 9, 15, 12, 11, 13, 21, 19, 25&#125;; BST&lt;Integer&gt; intTree1 = new BST&lt;&gt;(numbers1); BST&lt;Integer&gt; intTree2 = new BST&lt;&gt;(numbers2); BST&lt;Integer&gt; intTree3 = new BST&lt;&gt;(numbers3); System.out.print("\nIs tree #1 a full binary tree? "); System.out.println(intTree1.isFullBST()); System.out.print("\nIs tree #2 a full binary tree? "); System.out.println(intTree2.isFullBST()); System.out.print("\nIs tree #3 a full binary tree? "); System.out.println(intTree3.isFullBST()); // 找出叶子节点和非叶子节点 Integer[] numbers = &#123;60, 55, 45, 47, 59, 100, 76, 107, 101&#125;; BST&lt;Integer&gt; intTree = new BST&lt;&gt;(numbers); System.out.println("Number of leaf nodes: " + intTree.getNumberOfLeaves()); System.out.println("Number of nonleaf nodes: " + intTree.getNumberOfNonLeaves()); // 前序遍历 Integer[] numbers4 = &#123;60, 55, 45, 48, 59, 100, 76, 107, 101&#125;; BST&lt;Integer&gt; intTree4 = new BST&lt;&gt;(numbers4); System.out.print("intTree: "); intTree4.preorder(); // 测试clone方法 BST&lt;Integer&gt; intTreeCopy = intTree.clone(); // 测试equals方法 System.out.println("\nIs intTree equal to intTree2? " + intTree.equals(intTree2)); System.out.println("Is intTree equal to intTreeCopy? " + intTree.equals(intTreeCopy)); // 前序遍历 System.out.print("intTreeCopy: "); intTreeCopy.preorder(); System.out.println(); // 测试前序迭代器 BST&lt;String&gt; tree0 = new BST&lt;&gt;(); tree0.insert("George"); tree0.insert("Michael"); tree0.insert("Tom"); tree0.insert("Adam"); tree0.insert("Jones"); tree0.insert("Peter"); tree0.insert("Daniel"); Iterator&lt;String&gt; iterator = tree0.preorderIterator(); while (iterator.hasNext()) System.out.print(iterator.next().toUpperCase() + " "); System.out.println(); &#125;&#125;]]></content>
      <categories>
        <category>Tree</category>
      </categories>
      <tags>
        <tag>BST</tag>
        <tag>tree</tag>
        <tag>search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[堆排序]]></title>
    <url>%2F2019%2F03%2F14%2Fheap-sort.html</url>
    <content type="text"><![CDATA[堆排序使用的是二叉堆。首先将所有的元素添加到一个堆上，然后不断移除最大的元素以获得一个排好序的线性表。 堆的存储堆排序(heap sort)使用二叉堆(binary heap)，它是一棵 完全二叉树，每个节点大于或等于它的任意一个孩子。如果一颗二叉树的每一层都是满的，或者最后一层可以不填满并且最后一层的叶子都是靠左放置的，那么这棵二叉树就是完全的(complete)。如果堆的大小是事先知道的，那么可将堆存储在一个ArrayList或一个数组中。树根在位置0处，它的两个子节点在位置1和位置2处。 对于位置i处的节点，它的： 左子结点在位置 2i+1 处 右子结点在位置 2i+2 处 父节点在位置 (i-1)/2 处 添加一个新结点给堆添加一个新结点，首先将它添加到堆的末尾，然后按如下方式重建这棵树：Adding a New Node Psuedo Code123456789101112Let the last node be the current node;while (the current node is greater than its parent) &#123; Swap the current node with its parent; Now the current node is one level up;&#125;令最后一个节点的那个做当前节点;while (当前节点大于他的父节点) &#123; 将当前节点和它的父节点交换; 现在当前节点往上面进了一个层级;&#125; 删除一个结点经常需要从堆中删除最大的元素，也就是这个堆中的根节点。在删除根节点之后，就必须重建这棵树以保持堆的属性。重建该树的算法如下所示： Removing the Root Psuedo code123456789101112131415Move the last node to replace the root;Let the root be the current node;while (the current node has childen &amp;&amp; the current node is smaller than one of its children) &#123; Swap the current node with the larger of its children; Now the current node is one level down; &#125;用最后一个节点替换根节点;让根节点成为当前节点;while (当前节点具有子节点&amp;&amp;当前节点小于它的子节点) &#123; 将当前节点和它的较大子节点交换; 现在当前节点往下面退了一个层次;&#125; Heap类Comparable可以认为是一个内比较器，实现了Comparable接口的类有一个特点，就是这些类是可以和自己比较的，至于具体和另一个实现了Comparable接口的类如何比较，则依赖compareTo方法的实现，compareTo方法也被称为自然比较方法。如果开发者进入一个Collection的对象想要Collections的sort方法帮你自动进行排序的话，那么这个对象必须实现Comparable接口。compareTo方法的返回值是int，有三种情况： 比较者大于被比较者（也就是compareTo方法里面的对象），那么返回正整数 比较者等于被比较者，那么返回0 比较者小于被比较者，那么返回负整数 Comparator可以认为是是一个外比较器，个人认为有两种情况可以使用实现Comparator接口的方式：1)一个对象不支持自己和自己比较（没有实现Comparable接口），但是又想对两个对象进行比较;2)一个对象实现了Comparable接口，但是开发者认为compareTo方法中的比较方式并不是自己想要的那种比较方式Comparator接口里面有一个compare方法，方法有两个参数T o1和T o2，是泛型的表示方式，分别表示待比较的两个对象，方法返回值和Comparable接口一样是int，有三种情况： o1大于o2，返回正整数 o1等于o2，返回0 o1小于o3，返回负整数 使用Comparable接口对元素排序使用Comparable接口对元素排序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import java.util.Comparator;import java.util.ArrayList;public class Heap&lt;E extends Comparabel&lt;E&gt;&gt; &#123; private ArrayList&lt;E&gt; list = new ArrayList&lt;&gt;(); public Heap() &#123;&#125; public Heap(E[] objects) &#123; for (int i = 0; i &lt; objects.length; i++) &#123; this.add(objects[i]); &#125; &#125; public void add(E newObject) &#123; list.add(newObject); int currentIndex = list.size() - 1; while (currentIndex &gt; 0) &#123; int parentIndex = (currentIndex - 1) / 2; if (list.get(currentIndex).compareTo(list.get(parentIndex)) &gt; 0) &#123; E tmp = list.get(currentIndex); list.set(currentIndex, list.get(parentIndex)); list.set(parentIndex, tmp); &#125; else &#123; break; &#125; currentIndex = parentIndex; &#125; &#125; public E remove() &#123; if (list.size() == 0) return null; E removeObject = list.get(0); list.set(0, list.get(list.size() - 1)); list.remove(list.size() - 1); int currentIndex = 0; while (currentIndex &lt; list.size()) &#123; int leftChildIndex = 2 * currentIndex + 1; int rightChildIndex = 2 * currentIndex + 2; if (leftChildIndex &gt;= list.size()) break; int maxIndex = leftChildIndex; if (rightChildIndex &lt; list.size()) &#123; if (list.get(maxIndex).comparetTo(list.get(rightChildIndex)) &lt; 0) &#123; maxIndex = rightChildIndex; &#125; &#125; if (list.get(currentIndex).compareTo(list.get(maxIndex)) &lt; 0) &#123; E tmp = list.get(maxIndex); list.set(maxIndex, list.get(currentIndex)); list.set(currentIndex, tmp) &#125; else &#123; break; &#125; currentIndex = maxIndex; &#125; return removeObject; &#125; public int getSize() &#123; return list.size(); &#125;&#125; 使用Comparator接口对元素排序使用Comparator接口对元素排序12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import java.util.ArrayList;import java.util.Comparator;public class HeapA&lt;E&gt; &#123; private Comparator&lt;? super E&gt; comparator; private ArrayList&lt;E&gt; list = new ArrayList&lt;&gt;(); public HeapA(Comparator&lt;? super E&gt; comparator) &#123; this.comparator = comparator; &#125; public void add(E newObject) &#123; list.add(newObject); int currentIndex = list.size() - 1; while (currentIndex &gt; 0) &#123; int parentIndex = (currentIndex - 1) / 2; if (comaprator.compare(list.get(currentIndex), list.getIparentIndex)) &gt; 0) &#123; E tmp = list.get(currentIndex); list.set(currentIndex, list.get(parentIndex)); list.set(parentIndex, tmp); &#125; else &#123; break; &#125; currentIndex = parentIndex; &#125; &#125; pubic E remove() &#123; if (list.size() == 0) return null; E removeObject = list.get(0); list.set(0, list.get(list.size() - 1)); list.remove(list.size() - 1); int currentIndex = 0; while (currentIndex &lt; list.size()) &#123; int leftChildIndex = 2 * currentIndex + 1; int rightChildIndex = 2 * currentIndex + 2; //这里是大于等于 if (leftChildIndex &gt;= list.size()) break; int maxIndex = leftChildIndex; if(rigthChildIndex &lt; list.size()) &#123; if (comparator.compare(list.get(maxIndex), list.get(rightChildIndex)) &lt; 0) &#123; maxIndex = rightChildIndex; &#125; &#125; if (comparator.compare(list.get(currentIndex), list.get(maxIndex)) &lt; 0) &#123; E tmp = list.get(maxIndex); list.set(maxIndex, list.get(currentIndex)); list.set(currentIndex, tmp); &#125; else &#123; break; &#125; currentIndex = maxIndex; &#125; return removeObject; &#125; pubic int getSize() &#123; return list.size(); &#125;&#125; 使用Heap类进行排序使用Comparator需要编写测试用例，实现Comparator接口的的GeomatricObjectComparator，以及抽象父类GeometricObject,抽象方法getArea，在子类Circle和Rectangle类中实现。排序算法为HeapSort。 HeapSort排序算法HeapSort排序算法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273import java.util.Comparator;public class HeapSort &#123; public static &lt;E extends Comparable&lt;E&gt;&gt; void heapSort(E[] list) &#123; Heap&lt;E&gt; heap = new Heap&lt;&gt;(); for (int i = 0; i &lt; list.length; i++) &#123; heap.add(list[i]); &#125; for (int i = list.length - 1; i &gt;= 0; i--) &#123; list[i] = heap.remove(); &#125; &#125; public static &lt;E&gt; void heapSort(E[] list, Comparator&lt;? super E&gt; comparator) &#123; HeapA&lt;E&gt; heap = new HeapA&lt;&gt;(comparator); for (int i = 0; i &lt; list.length; i++) &#123; heap.add(list[i]); &#125; for (int i = list.length - 1; i &gt;= 0; i--) &#123; list[i] = heap.remove(); &#125; &#125; public static void main(String[] args) &#123; /** Create an Array of Integers */ Integer[] intArray = &#123;-44, -5, -3, 3, 3, 1, -4, 0, 1, 2, 4, 5, 53&#125;; /** Create an Array of Doubles */ Double[] doubleArray = &#123;3.4, 1.3, -22.1, 14.8, 6.0, 2.3, 12.2&#125;; /** Create an Array of Characters */ Character[] charArray = &#123;'a', 'J', 'r'&#125;; /** Create an Array of String */ String[] stringArray = &#123;"Tom", "Susan", "Kim"&#125;; /** Heapsort the arrays */ heapSort(intArray); heapSort(doubleArray); heapSort(charArray); heapSort(stringArray); /** Display the array */ System.out.print("Sorted Integers: "); printList(intArray); System.out.print("Sorted Doubles: "); printList(doubleArray); System.out.print("Sorted Characters: "); printList(charArray); System.out.print("Sorted Strings: "); printList(stringArray); GeometricObject[] list = &#123;new Circle(5), new Rectangle(4, 5), new Circle(5.5), new Rectangle(2.4, 5), new Circle(0.5), new Rectangle(4, 65), new Circle(4.5), new Rectangle(4.4, 1), new Circle(6.5), new Rectangle(4, 5)&#125;; heapSort(list, new GeometricObjectComparator()); System.out.print("Sorted elements: "); for (GeometricObject e: list) &#123; System.out.printf("%.2f ", e.getArea()); &#125; System.out.println(); &#125; public static void printList(Object[] list) &#123; for (int i = 0; i &lt; list.length; i++) System.out.print(list[i] + " "); System.out.println(); &#125;&#125; GeometricObjectComparator类实现java.util.Comparator接口GeometricObjectComparator类实现java.util.Comparator接口12345678910111213141516171819import java.io.Serializable;import java.util.Comparator;public class GeometricObjectComparator implements Comparator&lt;GeometricObject&gt;, Serializable &#123; @Override public int compare(GeometricObject o1, GeometricObject o2) &#123; // TODO Auto-generated method stub double area1 = o1.getArea(); double area2 = o2.getArea(); if (area1 &lt; area2) &#123; return -1; &#125; else if (area1 == area2) &#123; return 0; &#125; else &#123; return 1; &#125; &#125;&#125; GeometricObject抽象父类GeometricObject抽象父类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import java.util.Date;public abstract class GeometricObject &#123; private String color = "white"; private boolean filled; private Date dateCreated; protected GeometricObject() &#123; dateCreated = new Date(); &#125; protected GeometricObject(String color, boolean filled) &#123; dateCreated = new Date(); this.color = color; this.filled = filled; &#125; /** Return color */ public String getColor() &#123; return color; &#125; /** Set a new color */ public void setColor(String color) &#123; this.color = color; &#125; /** Return filled. Since filled is boolean, * the get method is named isFilled */ public boolean isFilled() &#123; return filled; &#125; /** Set a new filled */ public void setFilled(boolean filled) &#123; this.filled = filled; &#125; /** Get dateCreated */ public java.util.Date getDateCreated() &#123; return dateCreated; &#125; @Override public String toString() &#123; return "created on " + dateCreated + "\ncolor: " + color + " and filled: " + filled; &#125; /** Abstract method getArea */ public abstract double getArea(); /** Abstract method getPerimeter */ public abstract double getPerimeter(); &#125; Circle类继承自GeometricObjectCircle类继承自GeometricObject12345678910111213141516171819202122232425262728293031323334353637383940public class Circle extends GeometricObject &#123; private double radius; public Circle() &#123; &#125; public Circle(double radius) &#123; this.radius = radius; &#125; public Circle(double radius, String color, boolean filled) &#123; this.radius = radius; setColor(color); setFilled(filled); &#125; public double getRadius() &#123; return radius; &#125; public void setRadius(double radius) &#123; this.radius = radius; &#125; @Override public double getArea() &#123; return radius * radius * Math.PI; &#125; public double getDiameter() &#123; return 2 * radius; &#125; @Override public double getPerimeter() &#123; return 2 * radius * Math.PI; &#125; @Override public String toString() &#123; return super.toString() + ", Circle, Created: " + getDateCreated() + ", Radius: " + radius; &#125;&#125; Rectangle类继承自GeometricObjectRectangle类继承自GeometricObject123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class Rectangle extends GeometricObject &#123; private double width; private double height; public Rectangle() &#123; &#125; public Rectangle( double width, double height) &#123; this.width = width; this.height = height; &#125; public Rectangle( double width, double height, String color, boolean filled) &#123; this.width = width; this.height = height; setColor(color); setFilled(filled); &#125; public double getWidth() &#123; return width; &#125; public void setWidth(double width) &#123; this. width = width; &#125; public double getheight() &#123; return height; &#125; public void setheight(double height) &#123; this.height = height; &#125; @Override public double getArea() &#123; return width * height; &#125; @Override public double getPerimeter() &#123; return 2 * (width * height); &#125; @Override public String toString() &#123; return super.toString() + " Rectangle, Created: " + getDateCreated() + ", Width: " + width + ", Height: " + height; &#125;&#125; 堆排序的时间复杂度设h表示包含n个元素的堆的高度。 堆的高度为O(logn)。由于add方法会追踪从叶子节点到根节点的路径，因此向堆中添加一个新元素最多需要h步。所以建立一个包含n个元素的数组的初始堆需要O(nlogn)时间。由于remove方法要跟踪从根节点到叶子节点的路径，因此从堆中删除根节点后，重建堆最多需要h步。由于要调用n次remove方法，所以产生一个有序数组需要的总时间为O(nlogn)。堆排序不需要额外的数组空间，空间效率高于归并排序。 实现clone和equals的堆方法实现clone和equals方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101import java.util.Comparator;import java.util.ArrayList;public class Heap &lt;E extends Comparable&lt;E&gt;&gt; implements Cloneable&#123; private ArrayList&lt;E&gt; list = new ArrayList&lt;&gt;();; /** Create a default heap */ public Heap() &#123; &#125; /** Create a heap from an array of objects */ public Heap(E[] objects) &#123; for (int i = 0; i &lt; objects.length; i++) add(objects[i]); &#125; /** Add a new object into the heap */ public void add(E newObject) &#123; list.add(newObject); // Append to the heap int currentIndex = list.size() - 1; // The index of the last node while (currentIndex &gt; 0) &#123; int parentIndex = (currentIndex - 1) / 2; // Swap if the current object is greater than its parent if (list.get(currentIndex).compareTo( list.get(parentIndex)) &gt; 0) &#123; E temp = list.get(currentIndex); list.set(currentIndex, list.get(parentIndex)); list.set(parentIndex, temp); &#125; else break; // The tree is a heap now currentIndex = parentIndex; &#125; &#125; /** Remove the root from the heap */ public E remove() &#123; if (list.size() == 0) return null; E removedObject = list.get(0); list.set(0, list.get(list.size() - 1)); list.remove(list.size() - 1); int currentIndex = 0; while (currentIndex &lt; list.size()) &#123; int leftChildIndex = 2 * currentIndex + 1; int rightChildIndex = 2 * currentIndex + 2; // Find the maximum between two children if (leftChildIndex &gt;= list.size()) break; // The tree is a heap int maxIndex = leftChildIndex; if (rightChildIndex &lt; list.size()) &#123; if (list.get(maxIndex).compareTo( list.get(rightChildIndex)) &lt; 0) &#123; maxIndex = rightChildIndex; &#125; &#125; // Swap if the current node is less than the maximum if (list.get(currentIndex).compareTo( list.get(maxIndex)) &lt; 0) &#123; E temp = list.get(maxIndex); list.set(maxIndex, list.get(currentIndex)); list.set(currentIndex, temp); currentIndex = maxIndex; &#125; else break; // The tree is a heap &#125; return removedObject; &#125; /** Get the number of nodes in the tree */ public int getSize() &#123; return list.size(); &#125; @Override /** Override teh proctected clone method defined in the Object class, and stregthen its accessibility */ public Object clone() throws CloneNotSupportedException &#123; return super.clone(); &#125; @Override /** Override the equals method in the Object class */ public boolean equals(Object other) &#123; if (list.size() != ((Heap)(other)).getSize()) return false; for (int i = 0; i &lt; list.size(); i++) &#123; if (list.get(i) != ((Heap)(other)).list.get(i)) return false; &#125; return true; &#125;&#125;]]></content>
      <categories>
        <category>Sorting</category>
      </categories>
      <tags>
        <tag>sort</tag>
        <tag>heap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[355. Design Twitter]]></title>
    <url>%2F2019%2F03%2F11%2F355.html</url>
    <content type="text"><![CDATA[设计一个简化版的推特(Twitter)，可以让用户实现发送推文，关注/取消关注其他用户，能够看见关注人（包括自己）的最近十条推文。 你的设计需要支持以下的几个功能： postTweet(userId, tweetId): 创建一条新的推文 getNewsFeed(userId): 检索最近的十条推文。每个推文都必须是由此用户关注的人或者是用户自己发出的。推文必须按照时间顺序由最近的开始排序。 follow(followerId, followeeId): 关注一个用户 unfollow(followerId, followeeId): 取消关注一个用户 355. 设计推特123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120public class Twitter &#123; private static int timeStamp=0; // easy to find if user exist private Map&lt;Integer, User&gt; userMap; // Tweet link to next Tweet so that we can save a lot of time // when we execute getNewsFeed(userId) private class Tweet&#123; public int id; public int time; public Tweet next; public Tweet(int id)&#123; this.id = id; time = timeStamp++; next=null; &#125; &#125; // OO design so User can follow, unfollow and post itself public class User&#123; public int id; public Set&lt;Integer&gt; followed; public Tweet tweet_head; public User(int id)&#123; this.id=id; followed = new HashSet&lt;&gt;(); follow(id); // first follow itself tweet_head = null; &#125; public void follow(int id)&#123; followed.add(id); &#125; public void unfollow(int id)&#123; followed.remove(id); &#125; // everytime user post a new tweet, add it to the head of tweet list. public void post(int id)&#123; Tweet t = new Tweet(id); t.next=tweet_head; tweet_head=t; &#125; &#125; /** Initialize your data structure here. */ public Twitter() &#123; userMap = new HashMap&lt;Integer, User&gt;(); &#125; /** Compose a new tweet. */ public void postTweet(int userId, int tweetId) &#123; if(!userMap.containsKey(userId))&#123; User u = new User(userId); userMap.put(userId, u); &#125; userMap.get(userId).post(tweetId); &#125; // Best part of this. // first get all tweets lists from one user including itself and all people it followed. // Second add all heads into a max heap. Every time we poll a tweet with // largest time stamp from the heap, then we add its next tweet into the heap. // So after adding all heads we only need to add 9 tweets at most into this // heap before we get the 10 most recent tweet. public List&lt;Integer&gt; getNewsFeed(int userId) &#123; List&lt;Integer&gt; res = new LinkedList&lt;&gt;(); if(!userMap.containsKey(userId)) return res; Set&lt;Integer&gt; users = userMap.get(userId).followed; PriorityQueue&lt;Tweet&gt; q = new PriorityQueue&lt;Tweet&gt;(users.size(), (a,b)-&gt;(b.time-a.time)); for(int user: users)&#123; Tweet t = userMap.get(user).tweet_head; // very imporant! If we add null to the head we are screwed. if(t!=null)&#123; q.add(t); &#125; &#125; int n=0; while(!q.isEmpty() &amp;&amp; n&lt;10)&#123; Tweet t = q.poll(); res.add(t.id); n++; if(t.next!=null) q.add(t.next); &#125; return res; &#125; /** Follower follows a followee. If the operation is invalid, it should be a no-op. */ public void follow(int followerId, int followeeId) &#123; if(!userMap.containsKey(followerId))&#123; User u = new User(followerId); userMap.put(followerId, u); &#125; if(!userMap.containsKey(followeeId))&#123; User u = new User(followeeId); userMap.put(followeeId, u); &#125; userMap.get(followerId).follow(followeeId); &#125; /** Follower unfollows a followee. If the operation is invalid, it should be a no-op. */ public void unfollow(int followerId, int followeeId) &#123; if(!userMap.containsKey(followerId) || followerId==followeeId) return; userMap.get(followerId).unfollow(followeeId); &#125;&#125;/** * Your Twitter object will be instantiated and called as such: * Twitter obj = new Twitter(); * obj.postTweet(userId,tweetId); * List&lt;Integer&gt; param_2 = obj.getNewsFeed(userId); * obj.follow(followerId,followeeId); * obj.unfollow(followerId,followeeId); */]]></content>
      <categories>
        <category>Medium</category>
      </categories>
      <tags>
        <tag>Hash Table</tag>
        <tag>Heap</tag>
        <tag>Design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[594. Longest Harmonious Subsequence]]></title>
    <url>%2F2019%2F03%2F11%2F594.html</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Easy</category>
      </categories>
      <tags>
        <tag>Hash Table</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[散列集合]]></title>
    <url>%2F2019%2F03%2F10%2FHashSet.html</url>
    <content type="text"><![CDATA[Set注重独一无二的性质，该体系集合用于存储无序元素（存入和取出的顺序不一定相同），值不能重复。对象相等性本质是对象hashCode值（java十一局对象的内存地址计算出来的此序号）判断的，如果想要两个不同的对象视为相等的，就必须覆盖Object的hashCode方法和equals方法。 使用散列实现集合Java集合框架定义了java.util.Set接口来对集合建模。三种具体的实现是HashSet、LinkedHashSet和TreeSet，HashSet采用散列实现，LinkedHashSet采用LinkedList实现，TreeSet采用红黑树实现。 MyMap接口MySet接口1234567891011121314public interface MySet&lt;E&gt; extends Iterable&lt;E&gt; &#123; void clear(); boolean contains(E e); boolean add(E e); boolean remove(E e); boolean isEmpty(); int size();&#125; MyHashSet实现类链地址实现MyHashSet123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217import java.util.LinkedList;public class MyHashSet&lt;E&gt; implements MySet&lt;E&gt; &#123; private static int DEFAULT_INITIAL_CAPACITY = 4; private static int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; private int capacity; private static float DEFAULT_MAX_LOAD_FACTOR = 0.75f; private float loadFactorThreshold; private int size = 0; private LinkedList&lt;E&gt;[] table; public MyHashSet() &#123; this(DEFAULT_INITIAL_CAPACITY, DEFAULT_MAX_LOAD_FACTOR); &#125; public MyHashSet(int initialCapacity) &#123; this(initialCapacity, DEFAULT_MAX_LOAD_FACTOR); &#125; public MyHashSet(int initialCapacity, float loadFactorThreshold) &#123; if (initialCapacity &gt; MAXIMUM_CAPACITY) this.capacity = MAXIMUM_CAPACITY; else this.capacity = trimToPowerOf2(initialCapacity); this.loadFactorThreshold = loadFactorThreshold; table = new LinkedList[capacity]; &#125; @Override /** Remove all elements from this set */ public void clear() &#123; size = 0; removeElements(); &#125; @Override /** Return true if the element is in the set */ public boolean contains(E e) &#123; int bucketIndex = hash(e.hashCode()); if (table[bucketIndex] != null) &#123; LinkedList&lt;E&gt; bucket = table[bucketIndex]; for (E element : bucket) if (element.equals(e)) return true; &#125; return false; &#125; @Override /** Add an element to the set */ public boolean add(E e) &#123; if (contains(e)) // Duplicate element not stored return false; if (size + 1 &gt; capacity * loadFactorThreshold) &#123; if (capacity == MAXIMUM_CAPACITY) throw new RuntimeException("Exceeding maximum capacity"); rehash(); &#125; int bucketIndex = hash(e.hashCode()); // Create a linked list for the bucket if it is not created if (table[bucketIndex] == null) &#123; table[bucketIndex] = new LinkedList&lt;E&gt;(); &#125; table[bucketIndex].add(e); size++; // Increase size return true; &#125; @Override /** Remove the element from the set */ public boolean remove(E e) &#123; if (!contains(e)) return false; int bucketIndex = hash(e.hashCode()); // Create a linked list for the bucket if it is not created if (table[bucketIndex] != null) &#123; LinkedList&lt;E&gt; bucket = table[bucketIndex]; for (E element : bucket) if (e.equals(element)) &#123; bucket.remove(element); break; &#125; &#125; size--; // Decrease size return true; &#125; @Override /** Return true if the set contains no elements */ public boolean isEmpty() &#123; return size == 0; &#125; @Override /** Return the number of elements in the set */ public int size() &#123; return size; &#125; @Override /** Return an iterator for the elements in this set */ public java.util.Iterator&lt;E&gt; iterator() &#123; return new MyHashSetIterator(this); &#125; /** Inner class for iterator */ private class MyHashSetIterator implements java.util.Iterator&lt;E&gt; &#123; // Store the elements in a list private java.util.ArrayList&lt;E&gt; list; private int current = 0; // Point to the current element in list private MyHashSet&lt;E&gt; set; /** Create a list from the set */ public MyHashSetIterator(MyHashSet&lt;E&gt; set) &#123; this.set = set; list = setToList(); &#125; @Override /** Next element for traversing? */ public boolean hasNext() &#123; if (current &lt; list.size()) return true; return false; &#125; @Override /** Get current element and move cursor to the next */ public E next() &#123; return list.get(current++); &#125; @Override /** Remove the current element and refresh the list */ public void remove() &#123; // Delete the current element from the hash set set.remove(list.get(current)); list.remove(current); // Remove current element from the list &#125; &#125; /** Hash function */ private int hash(int hashCode) &#123; return supplementalHash(hashCode) &amp; (capacity - 1); &#125; /** Ensure the hashing is evenly distributed */ private static int supplementalHash(int h) &#123; h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12); return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4); &#125; /** Return a power of 2 for initialCapacity */ private int trimToPowerOf2(int initialCapacity) &#123; int capacity = 1; while (capacity &lt; initialCapacity) &#123; capacity &lt;&lt;= 1; &#125; return capacity; &#125; /** Remove all e from each bucket */ private void removeElements() &#123; for (int i = 0; i &lt; capacity; i++) &#123; if (table[i] != null) &#123; table[i].clear(); &#125; &#125; &#125; /** Rehash the set */ private void rehash() &#123; java.util.ArrayList&lt;E&gt; list = setToList(); // Copy to a list capacity &lt;&lt;= 1; // Double capacity table = new LinkedList[capacity]; // Create a new hash table size = 0; // Reset size for (E element : list) &#123; add(element); // Add from the old table to the new table &#125; &#125; /** Copy elements in the hash set to an array list */ private java.util.ArrayList&lt;E&gt; setToList() &#123; java.util.ArrayList&lt;E&gt; list = new java.util.ArrayList&lt;&gt;(); for (int i = 0; i &lt; capacity; i++) &#123; if (table[i] != null) &#123; for (E e : table[i]) &#123; list.add(e); &#125; &#125; &#125; return list; &#125; @Override public String toString() &#123; java.util.ArrayList&lt;E&gt; list = setToList(); StringBuilder builder = new StringBuilder("["); // Add the elements except the last one to the string builder for (int i = 0; i &lt; list.size() - 1; i++) &#123; builder.append(list.get(i) + ", "); &#125; // Add the last element in the list to the string builder if (list.size() == 0) builder.append("]"); else builder.append(list.get(list.size() - 1) + "]"); return builder.toString(); &#125;&#125; 测试程序TestMyHashSet.java1234567891011121314151617181920212223public class TestMyHashSet &#123; public static void main(String[] args) &#123; // Create a MyHashSet MySet&lt;String&gt; set = new MyHashSet&lt;&gt;(); set.add("Smith"); set.add("Anderson"); set.add("Lewis"); set.add("Cook"); set.add("Smith"); System.out.println("Elements in set: " + set); System.out.println("Number of elements in set: " + set.size()); System.out.println("Is Smith in set? " + set.contains("Smith")); set.remove("Smith"); System.out.print("Names in set in uppercase are "); for (String s : set) System.out.print(s.toUpperCase() + " "); set.clear(); System.out.println("\nElements in set: " + set); &#125;&#125;]]></content>
      <categories>
        <category>HashSet</category>
      </categories>
      <tags>
        <tag>HashSet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[散列表]]></title>
    <url>%2F2019%2F03%2F09%2FHashMap.html</url>
    <content type="text"><![CDATA[在一个良好平衡的查找树中，可以在O(logn)时间内找到一个元素。 使用散列来实现一个映射表或集合，从而在O(1)时间内查找、插入和删除一个元素。 HashMapjava.util.HashMap public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable HashMap和Hashtable有什么区别？ HashMap是Hashtable的轻量级实现（非线程安全的实现），都实现了Map接口，主要区别是HashMap允许key为null(但只允许一条null)，而后者不行。 HashMap把contains方法去掉，改为containsKey()和containsValue()。 Hashtable继承自Dictionary，而HashMap实现了Map接口，继承自AbstractMap。 Hashtable使用Enumeration遍历，而HashMap使用Iterator遍历。 使用的hash/rehash算法几乎一致，性能差别不大 Hashtable的hash数组默认大小是11,增加方式是2*old + 1。 HashMap中，hash数组默认大小是16，一定是2的指数。 一般在不需要并发的时候使用HashMap，并发的时候使用锁粒度更细的ConcurrentHashMap。迭代HashMap使用了快速失败机制，fail-fast，是Java集合的一种错误检测机制。当多个线程对集合进行结构上的改变操作时，就有可能产生fail-fast事件。假如线程1和线程2，当线程1通过iterator遍历集合A中的元素时，如果线程2修改了集合A的结构（删除、增加新元素），程序就会抛出ConcurrentModificationException异常，从而产生fail-fast事件。 遍历HashMap的四种方法：keySet需要首先把key转换成itaretor，然后根据key在map中取出value，需要两个操作，而entrySet只一次操作就把key和value都取到entry中来，效率更高。foreach和itaretor是等价的。 foreach map.entrySet() foreach map.entrySet()12345public static void traversal(Map&lt;String, String&gt; map) &#123; for (Entry&lt;String, String&gt; entry : map.entrySet()) &#123; System.out.print(entry.getKey() + ", " + entry.getValue()); &#125;&#125; 显示调用map.entrySet集合迭代器 显示调用map.entrySet集合迭代器 12345678public static void traversal(Map&lt;String, Integer&gt; map) &#123; Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; iterator = map.entrySet().iterator(); while (iterator.hasNext()) &#123; Map.Entry&lt;String, Integer&gt; entry = iterator.next(); System.out.println(entry.getKey() + ", " + entry.getValue()); &#125;&#125; foreach map.keySet(), 再调用get方法本方法多调用一次get，效率会降低，只适合只遍历key的情况。 foreach map.keySet(), 再调用get方法12345public static void traversal(Map&lt;String, String&gt; map) &#123; for (String key : map.keySet()) &#123; System.out.println(key + ", " + map.get(key)); &#125;&#125; foreach map.entrySet(), 再临时变量保存map.entrySet() foreach map.entrySet(), 再临时变量保存map.entrySet()123456public static void traversal(Map&lt;String, String&gt; map) &#123; Set&lt;Entry&lt;String, String&gt;&gt; entrySet = map.entrySet(); for (Entry&lt;String, String&gt; enty : entrySet) &#123; System.out.println(entry.getKey() + ", " + entry.getValue()); &#125;&#125; 散列函数和散列码折叠法byte、short、int、char类型的搜索键，简单地转换为int。long类型的散列码： hashCode = (int)(key ^ (key &gt;&gt; 32));double类型： long bits = Double.doubleToLongBits(key); int hashCode = (int)(bits ^ (bits &gt;&gt; 32)); 除余法(压缩)假设散列表的索引处于0~N-1 之间。设N为2的幂值。 h(hashCode) = hashCode % N;h(hashCode) = hashCode &amp; (N - 1);为了保证散列码是均匀分布的，java.util.HashMap采用了补充的散列函数与主散列函数一起使用。 字符串类型的散列码(…((s0 * b) + s1)b + s2)b + … + sn-2)b + sn-1在String中，b取值31，来计算上述多项式，以达到最小化冲突，其中si = s.charAt(i)。 除此之外，还有平方取中法，数字分析法等等。 使用链地址法处理冲突当两个键映射到散列表中的同一个索引上时，冲突发生。链地址法将具有同样的散列索引的条目都放在同一个位置，而不是寻找一个新位置。链地址法的每个位置使用一个桶来放置多个条目。可以使用数组，ArrayList或LinkedList来实现一个桶。使用LinkedListl来实现一个映射表。 此处实现与jdk中的实现不同，只是为了演示理解。 MyMap接口MyMap接口 123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.util.Set;public interface MyMap&lt;K, V&gt; &#123;// 删除映射表中所有条目 void clear();// 映射表是否包含键的条目 boolean containsKey(K key);// 如果映射表将一个或多个键映射到指定的值 返回true boolean containsValue(V value);// 返回包含该映射表中所有条目的集合 Set&lt;Entry&lt;K, V&gt;&gt; entrySet();// 指定键对应的值 V get(K key);// 是否包含映射条目 boolean isEmpty();// 映射表所有键的集合 Set&lt;K&gt; keySet();// 将一个映射置于映射表中 V put(K key, V value);// 移除指定键的条目 void remove(K key);// 映射条目数 int size();// 映射表值的集合 Set&lt;V&gt; values();// 映射条目的内部静态类 public static class Entry&lt;K, V&gt; &#123; K key; V value; public Entry(K key, V value) &#123; this.key = key; this.value = value; &#125; public K getKey() &#123; return key; &#125; public V getValue() &#123; return value; &#125; public String toString() &#123; return "[" + key + ", " + value + "]"; &#125; &#125;&#125; MyHashMap类的实现MyHashMap类链地址法处理冲突的实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213import java.util.*;public class MyHashMap&lt;K ,V&gt; implements MyMap&lt;K, V&gt; &#123; private static int DEFAULT_INITIAL_CAPACITY = 4; private static int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; private int capacity; private static float DEFAULT_MAX_LOAD_FACTOR = 0.75f; private float loadFactorThreshold; //映射表条目数，只有执行一次方法put(key, value)后，size才会增加一次 private int size = 0; LinkedList&lt;MyMap.Entry&lt;K, V&gt;&gt;[] table; //散列表是一个数组，数组中的每个单元是一个链表 public MyHashMap() &#123; this(DEFAULT_INITIAL_CAPACITY, DEFAULT_MAX_LOAD_FACTOR); &#125; public MyHashMap(int initialCapacity) &#123; this(initialCapacity, DEFAULT_MAX_LOAD_FACTOR); &#125; public MyHashMap(int initialCapacity, float loadFactorThreshold) &#123; if (initialCapacity &gt; MAXIMUM_CAPACITY) &#123; this.capacity = MAXIMUM_CAPACITY; &#125; else &#123; this.capacity = trimToPowerOf2(initialCapacity); &#125; this.loadFactorThreshold = loadFactorThreshold; table = new LinkedList[capacity]; &#125; @Override public void clear() &#123; size = 0; removeEntries(); &#125; private void removeEntries() &#123; //耗费时间为O(capacity) for (int i = 0; i &lt; capacity; i++) &#123; if (table[i] != null) &#123; table[i].clear(); &#125; &#125; &#125; @Override public boolean containsKey(K key) &#123; //耗费时间也为O(1) if (get(key) != null) &#123; return true; &#125; else &#123; return false; &#125; &#125; @Override public boolean containsValue(V value) &#123; LinkedList&lt;Entry&lt;K, V&gt;&gt; bucket; for (int i = 0; i &lt; capacity; i++）&#123; if (table[i] != null) &#123; bucket = table[i]; for (Entry&lt;K, V&gt; entry : bucket) &#123; if (entry.getValue().equals(value)) return true; &#125; &#125; &#125; &#125; @Override public Set&lt;Entry&lt;K, V&gt;&gt; entrySet() &#123; Set&lt;MyMap.Entry&lt;K, V&gt;&gt; set = new HashSet&lt;&gt;(); LinkedList&lt;Entry&lt;K, V&gt;&gt; bucket; for (int i = 0; i &lt; capacity; i++) &#123; if (table[i] != null) &#123; bucket = table[i]; for (Entry&lt;K ,V&gt; entry : bucket) set.add(entry); &#125; &#125; return set; &#125; @Override public V get(K key) &#123; //耗费O(1)的时间 int bucketIndex = hash(key.hashCode()); LinkedList&lt;Entry&lt;K, V&gt;&gt; bucket; if (table[bucketIndex] != null) &#123; bucket = table[bucketIndex]; for (Entry&lt;K, V&gt; entry : bucket) &#123; if (entry.getKey().equals(key)) return entry.getValue(); &#125; &#125; return null; &#125; @Override public boolean isEmpty() &#123; return size == 0; &#125; @Override public Set&lt;K&gt; keySet() &#123; Set&lt;K&gt; set = new HashSet&lt;&gt;(); for (int i = 0; i &lt; capacity; i++) &#123; if (table[i] != null) &#123; LinkedList&lt;Entry&lt;K, V&gt;&gt; bucket = table[i]; for (Entry&lt;K, V&gt; entry: bucket) &#123; set.add(entry.getKey()); &#125; &#125; &#125; return set; &#125; @Override public V put(K key, V value) &#123; if (get(key) != null) &#123; int bucketIndex = hash(key.hashCode()); LinkedList&lt;Entry&lt;K, V&gt;&gt; entry = table[bucketIndex]; for (Entry&lt;K, V&gt; entry : bucket) &#123; if (entry.getKey().equals(key)) &#123; V oldValue = entry.getValue(); entry.value = value; return oldValue; &#125; &#125; &#125; if (size &gt;= capacity * loadFactorThreshold) &#123; if (capacity == MAXIMUM_CAPACITY) throw new RuntimeException("Exceeding maximum capacity"); rehash(); &#125; int bucketIndex = hash(key.hashCode()); if (table[bucketIndex] == null) &#123; table[bucketIndex] = new LinkedList&lt;Entry&lt;K, V&gt;&gt;(); &#125; table[bucketIndex].add(new MyMap.Enty&lt;K, V&gt;(key, value)); size++; return value; &#125; @Override public void remove(K key) &#123; int bucketIndex = hash(key.hashCode()); if (table[bucketIndex] != null) &#123; LinkedList&lt;Entry&lt;K, V&gt;&gt; bucket = table[bucketIndex]; for (Entry&lt;K, V&gt; entry : bucket) &#123; if (entry.getKey().equals(key)) &#123; bucket.remove(entry); size--; break; &#125; &#125; &#125; &#125; @Override public int size() &#123; return size; &#125; @Override public Set&lt;V&gt; values() &#123; Set&lt;V&gt; set = new HashSet&lt;&gt;(); for (int i = 0; i &lt; capacity; i++) &#123; if (table[i] != null) &#123; LinkedList&lt;Entry&lt;K, V&gt;&gt; bucket = table[i]; for (Entry&lt;K, V&gt; entry : bucket) &#123; set.add(entry.getValue()); &#125; &#125; &#125; return set; &#125; private int hash(int hashCode) &#123; return supplementalHash(hashCode) &amp; (capacity - 1); &#125; private static int supplementalHash(int h) &#123; h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12); return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4); &#125; private int trimToPowerOf2(int initialCapacity) &#123; int capacity = 1; while (capacity &lt; initialCapacity) &#123; capacity &lt;&lt;= 1; &#125; return capacity; &#125; private void rehash() &#123; Set&lt;Entry&lt;K, V&gt;&gt; set = entrySet(); capacity &lt;&lt;= 1; table = new LinkedList[capacity]; size = 0; for (Entry&lt;K, V&gt; entry : set) &#123; put(entry.getKey(), entry.getValue()); &#125; &#125; @Override public String toString() &#123; StringBuilder builder = new StringBuilder(); for (int i = 0; i &lt; capacity; i++) &#123; if (table[i] != null &amp;&amp; table[i].size() &gt; 0) &#123; for (Entry&lt;K, V&gt; entry: table[i]) &#123; builder.append(entry); &#125; &#125; &#125; builder.append("]"); return builder.toString(); &#125;&#125; 使用开放地址法处理冲突开放地址法（open addressing）是在冲突发生时，在散列表中找到一个开放位置的过程。 线性探测法按照顺序找到下一个可用的位置，如果冲突发生在hashTable[k % N]，则检查hashTable[(k+1) % N]，依次类推。查找时，依次检查k，k+1，…，直到达到一个空单元，或者找到。缺点：会形成一次簇（cluster），从而降低查找时间。 线性探测法处理冲突123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215import java.util.ArrayList;public class MyHashMap&lt;K, V&gt; implements MyMap&lt;K, V&gt; &#123; private static int DEFAULT_INITIAL_CAPACITY = 4; private static int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; private int capacity; private static float DEFAULT_MAX_LOAD_FACTOR = 0.5f; private float loadFactorThreshold; private int size = 0; ArrayList&lt;MyMap.Entry&lt;K, V&gt;&gt; table; public MyHashMap() &#123; this(DEFAULT_INITIAL_CAPACITY, DEFAULT_MAX_LOAD_FACTOR); &#125; public MyHashMap(int initialCapacity) &#123; this(initialCapacity, DEFAULT_MAX_LOAD_FACTOR); &#125; public MyHashMap(int initialCapacity, float loadFactorThreshold) &#123; if (initialCapacity &gt; MAXIMUM_CAPACITY) this.capacity = MAXIMUM_CAPACITY; else this.capacity = trimToPowerOf2(initialCapacity); this.loadFactorThreshold = loadFactorThreshold; table = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; capacity; i++) table.add(null); &#125; @Override public void clear() &#123; size = 0; removeEntries(); &#125; @Override public boolean containsKey(K key) &#123; if (get(key) != null) return true; else return false; &#125; @Override public boolean containsValue(V value) &#123; for (int i = 0; i &lt; capacity; i++) &#123; if (table.get(i) != null &amp;&amp; table.get(i).getValue() == value) return true; &#125; return false; &#125; @Override public java.util.Set&lt;MyMap.Entry&lt;K,V&gt;&gt; entrySet() &#123; java.util.Set&lt;MyMap.Entry&lt;K, V&gt;&gt; set = new java.util.HashSet&lt;&gt;(); for (int i = 0; i &lt; capacity; i++) &#123; if (table.get(i) != null) &#123; set.add(table.get(i)); &#125; &#125; return set; &#125; @Override public V get(K key) &#123; int index = hash(key.hashCode()); while(table.get(index) != null) &#123; if (table.get(index).getKey().equals(key)) &#123; return table.get(index).getValue(); &#125; index++; index %= capacity; &#125; return null; &#125; @Override public boolean isEmpty() &#123; return size == 0; &#125; @Override public java.util.Set&lt;K&gt; keySet() &#123; java.util.Set&lt;K&gt; set = new java.util.HashSet&lt;K&gt;(); for (int i = 0; i &lt; capacity; i++) &#123; if (table.get(i) != null) set.add(table.get(i).getKey()); &#125; return set; &#125; @Override /** Add an entry (key, value) into the map */ public V put(K key, V value) &#123; int index = hash(key.hashCode()); while (table.get(index) != null) &#123; // The key is already in the map if (table.get(index).getKey().equals(key)) &#123; Entry&lt;K, V&gt; entry = table.get(index); V oldvalue = entry.getValue(); // Replace old value with new value entry.value = value; table.set(index, entry); // Return the old value for the key return oldvalue; &#125; // Collision check if the next index is available index++; index %= capacity; &#125; // Check load factor if (size &gt;= capacity * loadFactorThreshold) &#123; if (capacity == MAXIMUM_CAPACITY) throw new RuntimeException("Exceeding maximum capacity"); rehash(); &#125; // Add a new entry (key, value) to hashtable table.set(index, new MyMap.Entry&lt;K, V&gt;(key, value)); size++; // Increase size return value; &#125; @Override /** Remove the entry for the specified key */ public void remove(K key) &#123; int index = hash(key.hashCode()); // Remove the entry that matches the key while (table != null) &#123; if (table.get(index).getKey().equals(key)) &#123; table.remove(index); size--; // Decrease size break; // Remove just one entry that matches the key &#125; index++; index %= capacity; &#125; &#125; @Override /** Return the number of entries in this map */ public int size() &#123; return size; &#125; @Override /** Return a set consisting of values in this map */ public java.util.Set&lt;V&gt; values() &#123; java.util.Set&lt;V&gt; set = new java.util.HashSet&lt;&gt;(); for (int i = 0; i &lt; capacity; i++) &#123; if (table.get(i) != null) set.add(table.get(i).getValue()); &#125; return set; &#125; /** Hash function */ private int hash(int hashCode) &#123; return supplementalHash(hashCode) &amp; (capacity - 1); &#125; /** Ensure the hashing is evenly distributed */ private static int supplementalHash(int h) &#123; h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12); return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4); &#125; /** Return a power of 2 for initialCapacity */ private int trimToPowerOf2(int initialCapacity) &#123; int capacity = 1; while (capacity &lt; initialCapacity) &#123; capacity &lt;&lt;= 1; &#125; return capacity; &#125; private void removeEntries() &#123; table.clear(); &#125; /** Rehash the map */ private void rehash() &#123; java.util.Set&lt;Entry&lt;K, V&gt;&gt; set = entrySet(); capacity &lt;&lt;= 1; // Same as capacity *= 2. &lt;= is more efficient size = 0; // Reset size to 0 table.clear(); // Clear the hash table for (int i = 0; i &lt; capacity; i++) table.add(null); for (Entry&lt;K, V&gt; entry : set) &#123; put(entry.getKey(), entry.getValue()); &#125; &#125; @Override /** Return a string repesentation for this map */ public String toString() &#123; StringBuilder builder = new StringBuilder("["); for (Entry&lt;K, V&gt; entry: table) &#123; if (entry != null &amp;&amp; table.size() &gt; 0) builder.append(entry); &#125; builder.append("]"); return builder.toString(); &#125;&#125; 二次探测法二次探测法从索引 (k + j*j) % N位置的单元开始审查。 二次探测法处理冲突123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214import java.util.ArrayList;public class MyHashMap&lt;K, V&gt; implements MyMap&lt;K, V&gt; &#123; private static int DEFAULT_INITIAL_CAPACITY = 4; private static int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; private int capacity; private static float DEFAULT_MAX_LOAD_FACTOR = 0.5f; private float loadFactorThreshold; private int size = 0; ArrayList&lt;MyMap.Entry&lt;K, V&gt;&gt; table; public MyHashMap() &#123; this(DEFAULT_INITIAL_CAPACITY, DEFAULT_MAX_LOAD_FACTOR); &#125; public MyHashMap(int initialCapacity) &#123; this(initialCapacity, DEFAULT_MAX_LOAD_FACTOR); &#125; public MyHashMap(int initialCapacity, float loadFactorThreshold) &#123; if (initialCapacity &gt; MAXIMUM_CAPACITY) this.capacity = MAXIMUM_CAPACITY; else this.capacity = trimToPowerOf2(initialCapacity); this.loadFactorThreshold = loadFactorThreshold; table = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; capacity; i++) &#123; table.add(null); &#125; &#125; @Override /** Remove all of the entries from this map */ public void clear() &#123; size = 0; removeEntries(); &#125; @Override /** Return true if the specified key is in the map */ public boolean containsKey(K key) &#123; if (get(key) != null) return true; else return false; &#125; @Override /** Return true if this map contains the value */ public boolean containsValue(V value) &#123; for (int i = 0; i &lt; capacity; i++) &#123; if (table.get(i) != null &amp;&amp; table.get(i).getValue() == value) return true; &#125; return false; &#125; @Override /** Return a set of entries in the map */ public java.util.Set&lt;MyMap.Entry&lt;K, V&gt;&gt; entrySet() &#123; java.util.Set&lt;MyMap.Entry&lt;K, V&gt;&gt; set = new java.util.HashSet&lt;&gt;(); for (int i = 0; i &lt; capacity; i++) &#123; if (table.get(i) != null) &#123; set.add(table.get(i)); &#125; &#125; return set; &#125; @Override /** Return the value that matches the specified key */ public V get(K key) &#123; int index = hash(key.hashCode()); int j = 0; while (table.get(index) != null) &#123; if (table.get(index).getKey().equals(key)) &#123; return table.get(index).getValue(); &#125; index += Math.pow(j++, 2); index %= capacity; &#125; return null; &#125; @Override /** Return true if this map contains no entries */ public boolean isEmpty() &#123; return size == 0; &#125; @Override /** Return a set consisting of the keys in this map */ public java.util.Set&lt;K&gt; keySet() &#123; java.util.Set&lt;K&gt; set = new java.util.HashSet&lt;&gt;(); for (int i = 0; i &lt; capacity; i++) &#123; if (table.get(i) != null) &#123; set.add(table.get(i).getKey()); &#125; &#125; return set; &#125; @Override /** Add an entry (key, value) into the map */ public V put(K key, V value) &#123; int index = hash(key.hashCode()); int j = 0; while (table.get(index) != null) &#123; // The key is already in the map if (table.get(index).getKey().equals(key)) &#123; Entry&lt;K, V&gt; entry = table.get(index); V oldValue = entry.getValue(); // Replace old value with new value entry.value = value; table.set(index, entry); // Return the old value for the key return oldValue; &#125; index += Math.pow(j++, 2); index %= capacity; &#125; // Check load factor if (size &gt;= capacity * loadFactorThreshold) &#123; if (capacity == MAXIMUM_CAPACITY) throw new RuntimeException("Exceeding maximum capacity"); rehash(); &#125; // Add a new entry(key, value) to hashtable table.set(index, new MyMap.Entry&lt;K, V&gt;(key, value)); size++; // Increase size return value; &#125; @Override /** Remove the entry for the specified key */ public void remove(K key) &#123; int index = hash(key.hashCode()); int j = 0; // Remove the first entry that matches the key while (table.get(index) != null) &#123; if (table.get(index).getKey().equals(key)) &#123; table.remove(index); size--; // Decrease size break; // Remove just one entry that matches key &#125; index += Math.pow(j++, 2); index %= capacity; &#125; &#125; @Override /** Return the number of entries in this map */ public int size() &#123; return size; &#125; @Override /** Return a set consisting of values in this map */ public java.util.Set&lt;V&gt; values() &#123; java.util.Set&lt;V&gt; set = new java.util.HashSet&lt;&gt;(); for (int i = 0; i &lt; capacity; i++) &#123; if (table.get(i) != null) set.add(table.get(i).getValue()); &#125; return set; &#125; /** Hash function */ private int hash(int hashCode) &#123; return supplementalHash(hashCode) &amp; (capacity - 1); &#125; /** Ensure the hashing is evenly distributed */ private static int supplementalHash(int h) &#123; h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12); return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4); &#125; /** Return a power of 2 for initialCapacity */ private int trimToPowerOf2(int initialCapacity) &#123; int capacity = 1; while (capacity &lt; initialCapacity) &#123; capacity &lt;&lt;= 1; &#125; return capacity; &#125; /** Remove all entries from map */ private void removeEntries() &#123; table.clear(); &#125; /** Rehash the map */ private void rehash() &#123; java.util.Set&lt;Entry&lt;K, V&gt;&gt; set = entrySet(); capacity &lt;&lt;= 1; // Same as capacity *= 2. &lt;= is more efficient size = 0; table.clear(); for (int i = 0; i &lt; capacity; i++) table.add(null); for (Entry&lt;K, V&gt; entry : set) &#123; put(entry.getKey(), entry.getValue()); &#125; &#125; @Override /** Return a string repersentation for this map */ public String toString() &#123; StringBuilder builder = new StringBuilder("["); for (Entry&lt;K, V&gt; entry: table) &#123; if (entry != null &amp;&amp; table.size() &gt; 0) builder.append(entry); &#125; builder.append("]"); return builder.toString(); &#125;&#125; 再哈希法再哈希法处理冲突123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228import java.util.ArrayList;public class MyHashMap&lt;K, V&gt; implements MyMap&lt;K, V&gt; &#123; private static int DEFAULT_INITIAL_CAPACITY = 4; private static int MAMIMUM_CAPACITY = 1 &lt;&lt; 30; private int capacity; private static float DEFAULT_MAX_LOAD_FACTOR = 0.5f; private float loadFactorThreshold; private int size = 0; private ArrayList&lt;MyMap.Entry&lt;K, V&gt;&gt; table; public MyHashMap() &#123; this(DEFAULT_INITIAL_CAPACITY, DEFAULT_MAX_LOAD_FACTOR); &#125; public MyHashMap(int initialCapacity) &#123; this(initialCapacity, DEFAULT_MAX_LOAD_FACTOR); &#125; public MyHashMap(int initialCapacity, float loadFactorThreshold) &#123; if (initialCapacity &gt; MAMIMUM_CAPACITY) this.capacity = MAMIMUM_CAPACITY; else this.capacity = trimToPowerOf2(initialCapacity); this.loadFactorThreshold = loadFactorThreshold; table = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; capacity; i++) &#123; table.add(null); &#125; &#125; @Override public void clear() &#123; size = 0; removeEntries(); &#125; @Override public boolean containsKey(K key) &#123; if (get(key) != null) return true; else return false; &#125; @Override public boolean containsValue(V value) &#123; for (int i = 0; i &lt; capacity; i++) &#123; if (table.get(i) != null &amp;&amp; table.get(i).getValue() == value) return true; &#125; return false; &#125; @Override public java.util.Set&lt;Entry&lt;K, V&gt;&gt; entrySet() &#123; java.util.Set&lt;Entry&lt;K, V&gt;&gt; set = new java.util.HashSet&lt;&gt;(); for (int i = 0; i &lt; capacity; i++) &#123; if (table.get(i) != null) &#123; set.add(table.get(i)); &#125; &#125; return set; &#125; @Override public V get(K key) &#123; int hash1 = hash(key.hashCode()); int index = hash1; int j = 0; while (table.get(index) != null) &#123; if (table.get(index).getKey().equals(key)) &#123; return table.get(index).getValue(); &#125; // Secondary hash: (k + j * h'(key)) % N index = hash1 + j++ * hash2(hash1); index %= capacity; &#125; return null; &#125; @Override /** Return true if this map contains no entries */ public boolean isEmpty() &#123; return size == 0; &#125; @Override /** Return a set consisting of the keys in this map */ public java.util.Set&lt;K&gt; keySet() &#123; java.util.Set&lt;K&gt; set = new java.util.HashSet&lt;&gt;(); for (int i = 0; i &lt; capacity; i++) &#123; if (table.get(i) != null) set.add(table.get(i).getKey()); &#125; return set; &#125; @Override /** Add an entry (key, value) into the map */ public V put(K key, V value) &#123; int hash1 = hash(key.hashCode()); int index = hash1; int j = 0; while (table.get(index) != null) &#123; // The key is already in the map if (table.get(index).getKey().equals(key)) &#123; Entry&lt;K, V&gt; entry = table.get(index); V oldValue = entry.getValue(); // Replace old value with new value entry.value = value; table.set(index, entry); // Return the old value for the key return oldValue; &#125; // Secondary hash: (k + j * h'(key)) % N index = hash1 + j++ * hash2(hash1); index %= capacity; &#125; // Check load factor if (size &gt;= capacity * loadFactorThreshold) &#123; if (capacity == MAMIMUM_CAPACITY) throw new RuntimeException("Exceeding maximum capacity"); rehash(); &#125; // Add a new entry(key, value) to hashtable table.set(index, new MyMap.Entry&lt;K, V&gt;(key, value)); size++; return value; &#125; @Override /** Remove the entry for the specified key */ public void remove(K key) &#123; int hash1 = hash(key.hashCode()); int index = hash1; int j = 0; // Remove the first entry that matched the key while (table.get(index) != null) &#123; if (table.get(index).getKey().equals(key)) &#123; table.remove(index); size--; // Decrease size break; // Remove just one entry that matches the key &#125; // Secondary hash: (k + j * h'(key)) % N index = hash1 + j++ * hash2(hash1); index %= capacity; &#125; &#125; @Override /** Return the number of entries in this map */ public int size() &#123; return size; &#125; @Override /** Return a set consisting of values in this map */ public java.util.Set&lt;V&gt; values() &#123; java.util.Set&lt;V&gt; set = new java.util.HashSet&lt;&gt;(); for (int i = 0; i &lt; capacity; i++) &#123; if (table.get(i) != null) set.add(table.get(i).getValue()); &#125; return set; &#125; /** Hash function */ private int hash(int hashCode) &#123; return supplementalHash(hashCode) &amp; (capacity - 1); &#125; /** Ensure the hashing is evenly distributed */ private static int supplementalHash(int h) &#123; h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12); return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4); &#125; /** Secondary hash function */ private int hash2(int hash) &#123; return (7 - hash) &amp; (7 - 1); &#125; /** Return a power of 2 for initialCapacity */ private int trimToPowerOf2(int initialCapacity) &#123; int capacity = 1; while (capacity &lt; initialCapacity) &#123; capacity &lt;&lt;= 1; &#125; return capacity; &#125; /** Remove all entries from map */ private void removeEntries() &#123; table.clear(); &#125; /** Rehash the map */ private void rehash() &#123; java.util.Set&lt;Entry&lt;K, V&gt;&gt; set = entrySet(); capacity &lt;&lt;= 1; // Same as capacity *= 2. &lt;= is more efficient size = 0; // Reset size table.clear(); for (int i = 0; i &lt; capacity; i++) table.add(null); for (Entry&lt;K, V&gt; entry : set) &#123; put(entry.getKey(), entry.getValue()); &#125; &#125; @Override /** Return a string repersentation of this map */ public String toString() &#123; StringBuilder builder = new StringBuilder("["); for (Entry&lt;K, V&gt; entry : table) &#123; if (entry != null &amp;&amp; table.size() &gt; 0) &#123; builder.append(entry); &#125; &#125; builder.append("]"); return builder.toString(); &#125;&#125;]]></content>
      <categories>
        <category>HashMap</category>
      </categories>
      <tags>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[345. Reverse Volwels of a String]]></title>
    <url>%2F2019%2F03%2F08%2F345.html</url>
    <content type="text"><![CDATA[编写一个函数，以字符串作为输入，反转该字符串中的元音字母。 错误点有两处，看代码注释 345. 反转字符串中的元音字母123456789101112131415161718192021222324252627282930class Solution &#123; public String reverseVowels(String s) &#123; char[] res = s.toCharArray(); int start = 0; int end = res.length - 1; while (start &lt; end) &#123; if (isVowels(res[start]) &amp;&amp; isVowels(res[end])) &#123; char tmp = res[start]; res[start] = res[end]; res[end] = tmp; start++; end--; &#125; else if (!isVowels(res[start])) &#123; start++; &#125; else if(!isVowels(res[end])) &#123; end--; &#125; &#125; //这里return一个字符串的方法要注意 return new String(res); &#125; public static boolean isVowels(char ch) &#123; //犯错的地方 //前面忘了写 ch= ch+32 和 ch+=32的区别 ch = ch &gt;= 'A' &amp;&amp; ch &lt;= 'Z' ? ch += 32 : ch; return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u'; &#125;&#125;]]></content>
      <categories>
        <category>Easy</category>
      </categories>
      <tags>
        <tag>String</tag>
        <tag>Two Pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[344. Reverse String]]></title>
    <url>%2F2019%2F03%2F08%2F344.html</url>
    <content type="text"><![CDATA[反转字符串LeetCode 334 英文版 中文版 题目编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组char[]的形式给出。不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用O(1)的额外空间解决这一问题。 示例 1: 输入: “hello” 输出: “olleh” 示例 2: 输入: “A man, a plan, a canal: Panama” 输出: “amanaP :lanac a ,nalp a ,nam A” Java代码 头尾两个指针 12345678910111213141516171819202122232425/** * @description: * @author: rhsphere * @since: 2019-10-29 10:30 by jdk 1.8 */public class ReverseStrings &#123; public void reverseString(char[] s) &#123; if (s == null || s.length &lt;= 0) return; reverse(s); &#125; private void reverse(char[] chars) &#123; int start = 0; int end = chars.length - 1; while (start &lt; end) &#123; char tmp = chars[start]; chars[start] = chars[end]; chars[end] = tmp; start++; end--; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Easy</category>
      </categories>
      <tags>
        <tag>String</tag>
        <tag>Two Pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[828. Unique Letter String]]></title>
    <url>%2F2019%2F03%2F07%2F828.html</url>
    <content type="text"><![CDATA[如果一个字符在字符串S中有且仅有出现一次，那么我们称其为独特字符。对于给定字符串S，计算其所有非空子串的独特字符的个数，即 UNIQ(substring)。如果出现两个或者多个相同的子串，将其认为是不同的两个子串。 In each loop, We caculate cur[i], which represent the sum of Uniq() for all substrings whose last char is S.charAt(i). For example,S = ‘ABCBD’When i = 2, cur[2] = Uniq(‘ABC’) + Uniq(‘BC’) + Uniq(‘C’)When i = 3, cur[3] = Uniq(‘ABCB’) + Uniq(‘BCB’) + Uniq(‘CB’) + Uniq(‘B’) Notice, we append char ‘B’ into each previous substrings. Only in substrings ‘CB’ and ‘B’, the char ‘B’ can be identified as uniq. The contribution of ‘B’ from cur[2] to cur[3] is i - showLastPosition[‘B’]. At the same time, in substrings ‘ABCB’, ‘BCB’, the char ‘B’ can‘t’ be identified as uniq any more, the previous contribution of ‘B’ should be removed. So we have’cur[i] = cur[i - 1] - contribution[S.charAt(i)] + (i - showLastPosition[S.charAt(i)])Then the new contribution[S.charAt(i)] = i - showLastPosition[S.charAt(i)] The final result is the sum of all cur[i]. 828. 独特字符串12345678910111213141516171819class Solution &#123; public int uniqueLetterString(String S) &#123; int res = 0; if (S == null || S.length() == 0) return res; int[] showLastPosition = new int[128]; int[] contribution = new int[128]; int cur = 0; for (int i = 0; i &lt; S.length(); i++) &#123; char x = S.charAt(i); cur -= contribution[x]; contribution[x] = (i - (showLastPosition[x] - 1)); cur += contribution[x]; showLastPosition[x] = i + 1; res += cur; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>Hard</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[91. Decode Ways]]></title>
    <url>%2F2019%2F03%2F07%2F91.html</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Medium</category>
      </categories>
      <tags>
        <tag>String</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[栈、队列和优先队列]]></title>
    <url>%2F2019%2F03%2F06%2Fstack-queue-priorityQueue.html</url>
    <content type="text"><![CDATA[可以使用数组线性表实现栈，使用链表实现队列。 栈(Stack)将数组线性表定义为栈类中的数据域，而不是使用继承ArrayList的方法是因为，一般来说加强或扩展类的功能时才使用继承的方式。AbstractList &lt;— Vector &lt;— StackArrayList和Vector类是一样的。如果不需要同步使用ArrayList类。Stack方法： peak() 返回栈顶元素而不移除它 pop() 返回并移除栈顶元素 push(e) 添加元素到栈里 search(e) 检测指定元素是否在栈中 组合的方式实现栈GenericStack.java12345678910111213141516171819202122232425262728293031import java.util.ArrayList;public class Generictack &#123; private ArrayList&lt;E&gt; list = new ArrayList&lt;&gt;(); public int getSize() &#123; return list.size(); &#125; public E peek() &#123; return list.get(getSize() - 1); &#125; public void push(E e) &#123; list.add(e); &#125; public E pop() &#123; E e = list.get(getSize() -1); list.remove(getSize() -1); return e; &#125; public boolean isEmpty() &#123; return list.isEmpty(); &#125; @Override public String toString() &#123; return "stack: " + list.toString(); &#125;&#125; 用栈存储素数TestGenericStack.java1234567891011121314151617181920212223242526272829303132public class TestGenericStack &#123; public static void main(String[] args) &#123; GenericStack&lt;Integer&gt; stack = new GenericStack&lt;&gt;(); final int NUMBER_OF_PRIMES = 50; int count = 0; for (int i = 2; count &lt; NUMBER_OF_PRIMES; i++) &#123; if (isPrime(i)) &#123; stack.push(i); count++; &#125; &#125; System.out.println("The first 50 prime numbers in descending order: "); for (int i = 1; !stack.isEmpty(); i++)&#123; if (i % 10 == 0) System.out.printf("%3d\n", stack.pop()); else System.out.printf("%3d ", stack.pop()); &#125; System.out.println(); &#125; private static boolean isPrime(int n) &#123; for (int i = 2; i &lt;= n / 2; i++) &#123; if (n % i == 0) return false; &#125; return true; &#125;&#125; 队列(Queue)java API中java.util.Queue是一个接口可以用Queue作为父类引用，LinkedList作为实例java.util.Queue&lt;TreeNode&gt; queue = new java.util.LinkedList&lt;&gt;(); Queue是LinkedList的父类接口继承关系：Collection &lt;— Queue &lt;— Deque &lt;— LinkedList Queue &lt;— AbstractQueue &lt;— PriorityQueueQueue的方法： offer(e) 插入元素e到队列中 poll() 获取并移除队头(front)元素，，队为空返回null remove() 获取并移除队头(front)元素，队为空抛出异常 peek() 获取但不移除对头元素，队为空返回null element() 获取但不移除对头元素，队为空抛出异常 使用继承和组合的方式实现队列和栈都是可行的，但是组合更好一点，因为可以定义一个全新的栈类和队列类，而不需要继承ArrayList和LinkedList中不必要和不合适的方法。 类仅在它们需要被加强或修改时，才会使用继承！！！！ 使用组合的方式实现队列组合的方式实现Queue1234567891011121314151617import java.util.LinkedList;public class GenericQueue&lt;E&gt; &#123; private LinkedList&lt;E&gt; list = new LinkedList&lt;&gt;(); public void enqueue(E e) &#123; list.addFirst(e); &#125; public E dequeu() &#123; return list.removeFirst(); &#125; public int getSize() &#123; return list.size(); &#125; @Override public String toString() &#123; return "Queue: " + list.toString(); &#125;&#125; 继承关系实现Queue继承关系实现Queue1234567891011121314public class GenericQueue&lt;E&gt; extends java.util.LinkedList&lt;E&gt; &#123; public void enqueue(E e) &#123; addLast(e); &#125; public E dequeue() &#123; return removeFirst(); &#125; public int getSize() &#123; return size(); &#125;&#125; 优先队列(PriorityQueue)对于使用Comparable和Comparator实现的Heap类见文章堆排序 用堆实现优先队列普通队列是一种先进先出的数据结构，元素在rear添加，在front删除。在优先队列中，元素被赋予优先级，当访问元素时，具有最高优先级的元素最先删除。Largest-in, first-Out 高进先出在java API中继承顺序如下：Queue &lt;— AbstractQueue &lt;— PriorityQueue 可以使用堆实现优先队列，其中根节点是队列中具有最高优先级的对象。 使用Comparable接口 用Comparable实现泛型PriorityQueue1234567891011121314public class MyPriorityQueue&lt;E extends Comparable&lt;E&gt;&gt; &#123; private Heap&lt;E&gt; heap = new Heap&lt;&gt;(); public void enqueue(E newOject) &#123; heap.add(newObject); &#125; public E dequeue() &#123; return heap.remove(); &#125; public int getSize() &#123; return heap.getSize(); &#125;&#125; 用Comparator实现泛型PriorityQueue用Comparator实现泛型PriorityQueue123456789101112131415161718192021import java.util.Comparator;public class MyPriorityQueue&lt;E&gt; &#123; private Comparator&lt;? super E&gt; comparator; private Heap&lt;E&gt; heap; MyPriorityQueue(Comparator&lt;? super E&gt; comparator) &#123; this.comparator = comparator; this.heap = new Heap&lt;&gt;(comparator); &#125; public void enqueue(E newObject) &#123; heap.add(newObject); &#125; public E dequeue() &#123; return heap.remove(); &#125; public int getSize() &#123; return heap.getSize(); &#125;&#125;]]></content>
      <categories>
        <category>List</category>
      </categories>
      <tags>
        <tag>Stack</tag>
        <tag>Queue</tag>
        <tag>PriorityQueue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表]]></title>
    <url>%2F2019%2F03%2F05%2FLinkedList.html</url>
    <content type="text"><![CDATA[LinkedList是用链表结构存储数据的，很适合数据的动态插入和删除，而随机访问和遍历的速度则较慢。另外，它还提供了List接口中没有定义的方法，专门用于操作表头和表尾元素，可以当作堆栈、队列和双向队列使用。 链表LinkedList由于ArrayList是用数组实现的，所以 get(int index) 和 set(int index, E e) 方法可以通过下标访问和修改元素，也可以用 add(E e) 方法在线性表末尾添加元素，它们是高效的。但是 add(int index, E e) 和 remove(int index) 方法的效率很低，因为需要移动潜在的大量元素。为了提高在表中开始位置添加和删除元素的效率，可以采用链式结构来实现线性表。 节点每个节点都包含元素和一个名为next的数据域，next指向下一个元素。如果节点是线性表中的最后一个，那么它的指针数据域next所包含的值是null。 LinkedList节点类12345678910 // This class is only used in LinkedList, so it is private. // This class does not need to access any // instance members of LinkedList, so it is defined static.private static class Node&lt;E&gt; &#123; E element; Node&lt;E&gt; next; public Node(E element) &#123; this.element = element; &#125;&#125; 实现addFirst(E e)方法addFirst(E e)方法12345678public void addFirst(E e) &#123; Node&lt;E&gt; newNode = new Node&lt;&gt;(e); newNode.next = head; head = newNode; size++; if (tail == null) tail = head;&#125; 实现addLast(E e)方法addLast(E e)方法12345678910public void addLast(E e) &#123; Node&lt;E&gt; newNode = new Node&lt;&gt;(e); if (tail == null) &#123; head = tail = newNode; &#125; else &#123; tail.next = newNode; tail = tail.next; &#125; size++;&#125; 实现add(int index, E e)方法add(int index, E e)方法1234567891011121314151617public void add(int index, E e) &#123; if (index == 0) &#123; //addFirst &amp;&amp; addLast contains size++ addFirst(e); &#125; else if (index &gt;= size) &#123; addLast(e); &#125; else &#123; Node&lt;E&gt; current = head; for (int i = 1; i &lt; index; i++) &#123; current = current.next; &#125; Node&lt;E&gt; tmp = current.next; current.next = new Node&lt;&gt;(e); (current.next).next = tmp; size++; &#125;&#125; 实现removeFirst()方法removeFirst()方法12345678910public E removeFirst() &#123; if (size == 0) &#123; return null; &#125; else &#123; Node&lt;E&gt; tmp = head; head = head.next; size--; return tmp.element; &#125;&#125; 实现removeLast()方法removeLast()方法123456789101112131415161718public E removeLast() &#123; if (size == 0) &#123; return null; &#125; else if (size == 1) &#123; Node&lt;E&gt; tmp = head; head = tail = null; size = 0; return tmp.element; &#125; else &#123; Node&lt;E&gt; current = head; for (int i = 0; i &lt; size - 2; i++) current = current.next; Node&lt;E&gt; tmp = tail; tail.next = null; size--; return tmp.element; &#125;&#125; 实现remove(int index)方法remove(int index)方法1234567891011121314151617public E remove(int index) &#123; if (index &lt; 0 || index &gt;= size) &#123; return null; &#125; else if (index == 0) &#123; return removeFirst(); &#125; else if (index == size -1) &#123; return removeLast(); &#125; else &#123; Node&lt;E&gt; previous = head; for (int i = 1; i &lt; index; i++) previous = previous.next; Node&lt;E&gt; current = previous.next; previous.next = current.next; size--; return current.element; &#125; &#125; MyLinkedList具体实现MyLinkedList具体实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247import java.util.Iterator;public class MyLinkedList&lt;E&gt; extends MyAbstractList&lt;E&gt; &#123; private Node&lt;E&gt; head, tail; public MyLinkedList() &#123; &#125; public MyLinkedList(E[] objects) &#123; super(objects); &#125; public E getFirst() &#123; if (size == 0) &#123; return null; &#125; else &#123; return head.element; &#125; &#125; public E getLast() &#123; if (size == 0) &#123; return null; &#125; else &#123; return tail.element; &#125; &#125; public void addFirst(E e) &#123; Node&lt;E&gt; newNode = new Node&lt;&gt;(e); newNode.next = head; head = newNode; size++; if (tail == null) tail = head; &#125; public void addLast(E e) &#123; Node&lt;E&gt; newNode = new Node&lt;&gt;(e); if (tail == null) &#123; head = tail = newNode; &#125; else &#123; tail.next = newNode; tail = tail.next; &#125; size++; &#125; @Override public void add(int index, E e) &#123; if (index == 0) &#123; //addFirst &amp;&amp; addLast contains size++ addFirst(e); &#125; else if (index &gt;= size) &#123; addLast(e); &#125; else &#123; Node&lt;E&gt; current = head; for (int i = 1; i &lt; index; i++) &#123; current = current.next; &#125; Node&lt;E&gt; tmp = current.next; current.next = new Node&lt;&gt;(e); (current.next).next = tmp; size++; &#125; &#125; @Override public void clear() &#123; size = 0; head = tail = null; &#125; @Override public boolean contains(E e) &#123; if (size == 0) &#123; return false; &#125; else &#123; Node&lt;E&gt; current = head; while (current != null) &#123; if (current.element == e) return true; current = current.next; &#125; &#125; return false; &#125; @Override public E get(int index) &#123; if (index &lt; 0 || index &gt;= size) &#123; return null; &#125; else if (index == 0) &#123; return getFirst(); &#125; else if (index == size -1) &#123; return getLast(); &#125; else &#123; Node&lt;E&gt; current = head.next; for (int i = 1; i &lt; index; i++) current = current.next; return current.element; &#125; &#125; @Override public int indexOf(E e) &#123; if (head.element == e) &#123; return 0; &#125; else if (tail.element == e) &#123; return size - 1; &#125; else &#123; Node&lt;E&gt; current = head.next; int index = 1; while (current != null) &#123; if (current.element == e) return index; current = current.next; index++; &#125; &#125; return -1; &#125; @Override public int lastIndexOf(E e) &#123; int index = -1; Node&lt;E&gt; current = head; for (int i = 0; i &lt; size; i++) &#123; if (current.element == e) index = i; current = current.next; &#125; return index; &#125; public E removeFirst() &#123; if (size == 0) &#123; return null; &#125; else &#123; Node&lt;E&gt; tmp = head; head = head.next; size--; return tmp.element; &#125; &#125; public E removeLast() &#123; if (size == 0) &#123; return null; &#125; else if (size == 1) &#123; Node&lt;E&gt; tmp = head; head = tail = null; size = 0; return tmp.element; &#125; else &#123; Node&lt;E&gt; current = head; for (int i = 0; i &lt; size - 2; i++) current = current.next; Node&lt;E&gt; tmp = tail; tail.next = null; size--; return tmp.element; &#125; &#125; @Override public E remove(int index) &#123; if (index &lt; 0 || index &gt;= size) &#123; return null; &#125; else if (index == 0) &#123; return removeFirst(); &#125; else if (index == size -1) &#123; return removeLast(); &#125; else &#123; Node&lt;E&gt; previous = head; for (int i = 1; i &lt; index; i++) previous = previous.next; Node&lt;E&gt; current = previous.next; previous.next = current.next; size--; return current.element; &#125; &#125; @Override public E set(int index, E e) &#123; if (index &lt; 0 || index &gt; size -1) &#123; return null; &#125; else &#123; Node&lt;E&gt; current = head; for (int i = 0; i &lt; index; i++) current = current.next; current.element = e; return current.element; &#125; &#125; @Override public String toString() &#123; StringBuilder res = new StringBuilder("["); Node&lt;E&gt; current = head; for (int i = 0; i &lt; size; i++) &#123; res.append(current.element); current = current.next; if (current != null) &#123; res.append(", "); &#125; else &#123; res.append("]"); &#125; &#125; return res.toString(); &#125; @Override public Iterator&lt;E&gt; iterator() &#123; return new LinkedListIterator(); &#125; private class LinkedListIterator implements Iterator&lt;E&gt; &#123; private Node&lt;E&gt; current = head; @Override public boolean hasNext() &#123; return (current != null); &#125; @Override public E next() &#123; E e = current.element; current = current.next; return e; &#125; @Override public void remove() &#123; &#125; &#125; // This class is only used in LinkedList, so it is private. // This class does not need to access any // instance members of LinkedList, so it is defined static. private static class Node&lt;E&gt; &#123; E element; Node&lt;E&gt; next; public Node(E element) &#123; this.element = element; &#125; &#125;&#125; 抽象类和接口MyList接口MyList接口12345678910111213141516171819202122232425public interface MyList&lt;E&gt; extends Iterable&lt;E&gt; &#123; void add(E e); void add(int index, E e); void clear(); boolean contains(E e); E get(int index); int indexOf(E e); boolean isEmpty(); int lastIndexOf(E e); boolean remove(E e); E remove(int index); Object set(int index, E e); int size(); &#125; MyAbstractList抽象类MyAbstractList抽象类123456789101112131415161718192021222324252627282930313233343536public abstract class MyAbstractList&lt;E&gt; implements MyList&lt;E&gt; &#123; protected int size = 0 ; protected MyAbstractList() &#123; &#125;; protected MyAbstractList(E[] objects) &#123; for (int i = 0; i &lt; objects.length; i++) add(objects[i]); &#125; @Override public void add(E e) &#123; add(size, e); &#125; @Override public boolean isEmpty() &#123; return size == 0; &#125; @Override public boolean remove(E e) &#123; if (indexOf(e) &gt;= 0) &#123; remove(indexOf(e)); return true; &#125; else &#123; return false; &#125; &#125; @Override public int size() &#123; return size; &#125;&#125;]]></content>
      <categories>
        <category>List</category>
      </categories>
      <tags>
        <tag>LinkedList</tag>
        <tag>List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组线性表]]></title>
    <url>%2F2019%2F03%2F04%2FArrayList.html</url>
    <content type="text"><![CDATA[ArrayList是最常用的List实现类，内部是通过数组实现的，它允许对元素进行快速随机访问。数组的缺点是每个元素之间不能有间隔，当数组大小不满足时，需要增加存储能力，就要将已经有数组的数据复制到新的存储空间中。当从ArrayList的中间位置插入或者删除元素时，需要对数组进行复制、移动时，代价比较高。因此，它适合随机查找和遍历，不适合插入和删除。 List常用的List方法： add 在最后或特定位置加入新的元素 clear 清除所有元素 contains 是否含有指定元素 get 获取特定索引元素 indexOf 返回特定元素第一次出现的索引，没有则返回-1 lastIndexOf 返回特定元素最后一次出现的索引，没有则返回-1 isEmpty 判断是否为空 iterator 返回迭代器 remove 移除特定元素 size 返回List大小 subList 根据传入的两个索引返回子列表 常用的List实现类有: ArrayList： 擅长随机访问的列表 LinkedList： 擅长插入和删除操作的列表 Vector： 与ArrayList类似，线程安全的列表 MyArrayList和MyLinkedList可以使用ArrayList和LinkedList来存储线性表。使用数组实现ArrayList，使用链表实现LinkedList，前者开销比后者小。但是如果需要在线性表的开始位置插入和删除元素，那么LinkedList的效率会高一点。下表总结了ArrayList和LinkedList中方法的时间复杂度。 方法 ArrayList LinkedList add(e: E) O(1) O(1) add(index: int, e: E) O(n) O(n) clear() O(1) O(1) contains(e: E) O(n) O(n) get(index: int) O(1)** O(n) indexOf(e: E) O(n) O(n) isEmpty() O(1) O(1) lastIndexOf(e: E) O(n) O(n) remove(e: E) O(n) O(n) size() O(1) O(1) remove(index: int) O(n) O(n) set(index: int, e: E) O(n) O(n) addFirst(e: E) O(n) O(1)** removeFirst() O(n) O(1)** ArrayList部分细节使用数组来实现动态数据结构，处理方法是：当数组不能再存储线性表的新元素时，创建一个更大的新数组来替换当前数组。 add(int index, E e)添加元素到指定位置123456789101112131415public void add(int index, E e) &#123; ensureCapacity(); for (int i = size - 1; i &gt;= index; i--) &#123; data[i + 1] = data[i]; &#125; data[index] = e; size++; &#125;private void ensureCapacity() &#123; if (size &gt;= data.length) &#123; E[] newData = (E[]) new Object[2 * size + 1]; System.arraycopy(data, 0, newData, 0, size); data = newData; &#125;&#125; clear()通过创建一个新数组并且将其复制给data，老的数组和保存在数组中的数据变成垃圾，将自动被JVM回收。clear方法1234public void clear() &#123; data = (E[]) new Object[INITIAL_CAPACITY]; size = 0;&#125; remove(int index)最后一个元素不再使用，设置为null。remove方法123456789public E remove(int index) &#123; checkIndex(index); E e = data[index]; for (int j = index; j &lt; size - 1; j++) data[j] = data[j + 1]; data[size - 1] = null; size--; return e;&#125; ArrayList具体实现采用集合的实现模式，在MyList接口中提供通用的操作，抽象类部分实现了包括集合操作的addAll、removeAll和containsAll等方法，最后在MyArrayList类中实现了数组线性表。为了便于手机查看，采用倒序的显示方式。将接口、抽象类和测试用例放在最后。 MyArrayList实现类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144package algorithms.arrayList;import java.util.Iterator;public class MyArrayList&lt;E&gt; extends MyAbstractList&lt;E&gt; &#123; private static final int INITIAL_CAPACITY = 16; @SuppressWarnings("unchecked") private E[] data = (E[]) new Object[INITIAL_CAPACITY]; public MyArrayList() &#123; &#125;; public MyArrayList(E[] objects) &#123; for (int i = 0; i &lt; objects.length; i++) add(objects[i]); &#125; @Override public void add(int index, E e) &#123; ensureCapacity(); for (int i = size - 1; i &gt;= index; i--) &#123; data[i + 1] = data[i]; &#125; data[index] = e; size++; &#125; @SuppressWarnings("unchecked") @Override public void clear() &#123; data = (E[]) new Object[INITIAL_CAPACITY]; size = 0; &#125; @Override public boolean contains(E e) &#123; for (int i = 0; i &lt; size; i++) &#123; if (e.equals(data[i])) return true; &#125; return false; &#125; @Override public E get(int index) &#123; checkIndex(index); return data[index]; &#125; @Override public int indexOf(E e) &#123; for (int i = 0; i &lt; size; i++) &#123; if (e.equals(data[i])) return i; &#125; return -1; &#125; @Override public int lastIndexOf(E e) &#123; for (int i = size - 1; i &gt;= 0; i--) &#123; if (e.equals(data[i])) return i; &#125; return -1; &#125; @Override public E remove(int index) &#123; checkIndex(index); E e = data[index]; for (int j = index; j &lt; size - 1; j++) data[j] = data[j + 1]; data[size - 1] = null; size--; return e; &#125; @Override public E set(int index, E e) &#123; checkIndex(index); E old = data[index]; data[index] = e; return old; &#125; @Override public String toString() &#123; StringBuilder res = new StringBuilder("["); for (int i = 0; i &lt; size; i++) &#123; res.append(data[i]); if (i &lt; size - 1) res.append(", "); &#125; return res.toString() + "]"; &#125; @SuppressWarnings("unchecked") public void trimToSize() &#123; if (size != data.length) &#123; E[] newData = (E[]) new Object[size]; System.arraycopy(data, 0, newData, 0, size); data = newData; &#125; &#125; @Override public Iterator&lt;E&gt; iterator() &#123; return new ArrayListIterator(); &#125; @SuppressWarnings("unchecked") private void ensureCapacity() &#123; if (size &gt;= data.length) &#123; E[] newData = (E[]) new Object[2 * size + 1]; System.arraycopy(data, 0, newData, 0, size); data = newData; &#125; &#125; private void checkIndex(int index) &#123; if (index &lt; 0 || index &gt;= size) throw new IndexOutOfBoundsException("index " + index + " ouf of bounds"); &#125; private class ArrayListIterator implements Iterator&lt;E&gt; &#123; private int current = 0; @Override public boolean hasNext() &#123; return (current &lt; size); &#125; @Override public E next() &#123; return data[current++]; &#125; @Override public void remove() &#123; MyArrayList.this.remove(current); &#125; &#125;&#125; 接口、抽象类和测试用例MyList接口MyList接口123456789101112131415161718192021222324252627282930313233package algorithms.arrayList;public interface MyList&lt;E&gt; extends Iterable&lt;E&gt; &#123; void add(E e); void add(int index, E e); void clear(); boolean contains(E e); E get(int index); int indexOf(E e); boolean isEmpty(); int lastIndexOf(E e); boolean remove(E e); E remove(int index); Object set(int index, E e); int size(); boolean addAll(MyList&lt;E&gt; otherList); boolean removeAll(MyList&lt;E&gt; otherList); boolean retainAll(MyList&lt;E&gt; otherList); &#125; MyAbstractList抽象类MyAbstractList抽象类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778package algorithms.arrayList;public abstract class MyAbstractList&lt;E&gt; implements MyList&lt;E&gt; &#123; protected int size = 0 ; protected MyAbstractList() &#123; &#125;; protected MyAbstractList(E[] objects) &#123; for (int i = 0; i &lt; objects.length; i++) add(objects[i]); &#125; @Override public void add(E e) &#123; add(size, e); &#125; @Override public boolean isEmpty() &#123; return size == 0; &#125; @Override public boolean remove(E e) &#123; if (indexOf(e) &gt;= 0) &#123; remove(indexOf(e)); return true; &#125; else &#123; return false; &#125; &#125; @Override public int size() &#123; return size; &#125; @Override public boolean addAll(MyList&lt;E&gt; otherList) &#123; boolean changed = false; for ( int i = 0; i &lt; otherList.size(); i++) &#123; E e = otherList.get(i); if (!contains(e)) &#123; add(e); changed = true; &#125; &#125; return changed; &#125; @Override public boolean removeAll(MyList&lt;E&gt; otherList) &#123; boolean changed = false; for (int i = 0; i &lt; otherList.size(); i++) &#123; E e = otherList.get(i); if (contains(e)) &#123; remove(e); changed = true; &#125; &#125; return changed; &#125; @Override public boolean retainAll(MyList&lt;E&gt; otherList) &#123; boolean changed = false; for (int i = size - 1; i &gt;= 0; i--) &#123; E e = otherList.get(i); if (!otherList.contains(e)) &#123; remove(e); changed = true; &#125; &#125; return changed; &#125;&#125; MyArrayList测试用例MyArrayList测试用例123456789101112131415161718192021222324252627282930313233343536package algorithms.arrayList;public class TestMyArrayList &#123; public static void main(String[] args) &#123; String[] array1 = &#123;"Tom", "George", "Peter", "Jean", "Jane"&#125;; MyList&lt;String&gt; list1 = new MyArrayList&lt;&gt;(array1); String[] array2 = &#123;"Tom", "George", "Michael", "Michelle", "Daniel"&#125;; MyList&lt;String&gt; list2 = new MyArrayList&lt;&gt;(array2); System.out.println("Create two MyArrayLists:"); print(list1, list2); System.out.println("Invoke list1.addAll(list2):"); list1.addAll(list2); print(list1, list2); System.out.println("Recreate list1 and list2 with the same initial values," + "\ninvoke list1.removeAll(list2), and displays list1 and list2:"); list1.clear(); list1.addAll(new MyArrayList&lt;&gt;(array1)); list1.removeAll(list2); print(list1, list2); System.out.println("Recreate list1 and list2 with the same initial values," + "\ninvokes list1.retainAll(list2), and displays list1 and list2:"); list1.clear(); list1.addAll(new MyArrayList&lt;&gt;(array1)); list1.retainAll(list2); print(list1, list2); &#125; public static void print(MyList&lt;String&gt; list1, MyList&lt;String&gt; list2) &#123; System.out.println("List1: " + list1); System.out.println("List2: " + list2); System.out.println(); &#125;&#125;]]></content>
      <categories>
        <category>List</category>
      </categories>
      <tags>
        <tag>ArrayList</tag>
        <tag>List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一讲|先想后写——TCS三步构思法]]></title>
    <url>%2F2019%2F02%2F26%2Ftone-content-structure.html</url>
    <content type="text"><![CDATA[职场写作最忌讳打开电脑就写，请你先想再写。TCS法三个步骤完成构思过程，即tone、content和structure，对应基调、内容和结构。 基调为王，七种文案的标志性语气第一步，基调，文章以基调为“王”。基调对了，事半功倍；基调错了，哪怕你传递的信息再重要，我也不会关注。正确的基调能传递出文章真正的价值，也就是你的价值。职场写作可以分成四大类，那么每一类都需要传递你的什么价值呢？ 第一，总结类，写的是成绩，呈现的是你的潜力； 第二，调查报告类，写的是调查结果，呈现的是你求实的态度； 第三，申请类，内容是提问，呈现的是你主动的思考方式； 第四，计划类，写的是阶段任务，呈现的是你的责任感。 如果明白了要呈现自己什么价值，那你拿捏起文章的基调来，正确的概率就会很高。 以常见的六种具体文案为例，探讨一下它们的标志性的基调。 年终总结，基调要求：有深度不要写成一份业绩的流水账——因为你的工作结果，领导在看你的总结之前就知道。可他为什么还要看？他要读到你的分析能力；他希望你能从对工作感性的认知，上升到理性的规律性的总结；他需要你协助他，对未来做出更正确的决定。由此来看，年终总结不是回顾，而是行动指南。好的年终总结应该： 会将工作成果写出意义，会提供难得的一线经验、不同的视角； 会在罗列了贡献之后，找出问题或机遇，以及怎样解决这个问题，或抓住这个机遇。这就是“有深度”。 进展汇报，基调要求：不讨教在进展汇报里，不能只提问题，向领导讨教，而应该给出方案，向领导汇报。讨教的公式是：您告诉我该怎么做。汇报的公式是：我这样做，您同意吗？这里我想提醒你，哪怕领导没有要求你写进展汇报，你也要养成定期向他汇报的习惯。你需要将解决问题过程中的一些重要发现、关键结论、阶段性成果等小胜利，实时呈现给他，让他读出你的认真，让他看到你不断提高工作能力的过程。 调查报告，基调要求：实事求是在收集充分的事实资料后，你的措辞是“资料显示、数字表明”，而不是“我认为、我估计”。这种报告才能展现事情的真相，才会有让人惊喜的收获。 请示，基调要求：有主见有的人这么写： “客户投诉如下，请指示。”不管是找领导要人、要钱，或其他任何资源，一定要有清晰的主见。比如申请款项，你要给一个量化的标准让领导来裁决，不能模糊不清，让他无据可依、无处下手。让他做选择题的时候，你也需要提供最佳选项。另外，部门主管向上级递交请示的时候，不能采用传声筒的语气。不要写“他们抱怨”或“他们声称”，要写“我注意到” “我相信我的团队会……”，这才是有担当、有主见的语气。 批复，基调要求：态度明确不能出现这样的措辞：“似属可行” “酌情办理”。 项目计划，基调要求：“可交付”不能仅仅写行为。一个项目的成功，不是行动了就可以，而是众多可交付结果的总和。 比如：“选择外部供应商”，这是写行为，改为可交付的结果：“确定外部供应商”。 又比如：“草拟消费者调查报告”，这又是写行为，改为可交付结果：“递交消费者调查报告”。 这里我再和你多说一点。最好的项目计划书，是按照 OKR目标管理工具来写的。O：Objective 目标，KR：Key Results 关键结果。简单地说，计划就是由目标和关键结果构成。其中，大目标可以分解成小目标，关键结果是用来衡量这些目标有没有完成的。按照这个工具来写，你的基调自然就是可交付的结果。 以上就是构思的第一步——基调。 从“作者逻辑”切换到“读者逻辑”TCS的第二步，C：content，内容。你意识到了吗？我们在学校里的写作，读者是教授，他读你的文章的时候是有薪水拿的。在职场上的写作，可不是这样。职场上的读者，大多是“甲方读者”，比如领导、客户、重要合作伙伴，等等。也就是说，他们没有义务读完你的文章，他们可以随时终止阅读。怎么才能让这些甲方读者被你的内容吸引呢？请遵照这个原则： 先从“作者逻辑”切换到“读者逻辑”，提供“所有必需信息”，然后按照“要话先说”的顺序排列。也就是说， 你的文章每个部分都要对读者有价值。你写第一句话，是为了让他继续看第二句话；你写第二句话，是为了让他继续看第三句话。 举个例子，如果要写一份给投资人的商业计划书，俗称项目BP(Business Plan)。我们先做发散思维，想一想在初次接触时，投资人需要哪些信息来判断是否对项目有信心，是否愿意投资参与该项目？然后，为这些信息排序。我最担心你一上来就急着展示自己公司有多厉害，这是作者逻辑。没搭好台就展示自己，操之过急。相反，文章应该从分析整个行业下手，彰显市场空缺。搭建好舞台后，才有机会介绍自己。风险投资人也是要最大限度地规避风险的。而先选择行业，再选择个体，是他规避风险的方式，是读者逻辑。按照这个逻辑，文章怎样写呢？ 第一部分，写 “项目愿景”。 也就是，你要做一件什么样的大事。这部分需要有一句高度精炼的话，比如黄太吉的“打造以煎饼果子为核心的中式时尚快餐连锁品牌”。对方会问，这件事为什么值得做？于是你给出 “市场痛点”。比如，摩拜单车是为了解决最后一公里的交通痛点。如果投资人根本不认为这是个痛点，后面一切都白写了。再往下，是 “解决方案”。论证的是，我们正在做的这个事业，真正能解决得了这个痛点，这把钥匙能开得了这把锁。OK,读者表示认同。然后，他会想，“市场潜力”大吗？这时，你该展示市场调查结果了，包括市场规模、用户画像、竞品分析等等。那他会接着问，为什么要投你们，而不是别人呢？你要阐述自己的 “独特优势”。包括行业经验、核心技术、牛人团队，等等。OK, 这时读者对你有点儿感觉了。 下一部分，趁他对你有感觉的时候，拉着他一块儿画饼，你要写 “发展规划”了。写清楚盈利模式和发展路径。也许你觉得奇怪，为什么这个内容现在才写？其实投资人很有经验，他只要决定和你一块儿干，他会在后期帮你一起完善盈利模式，清晰发展路径。 最后，做 “财务分析”，告诉他，你们缺多少钱。为什么把融资额度放最后写呢？你想想看，有经验的销售想把东西卖给你的时候，通常不会一上来就报价的。他们都是把商品的价值点全部讲完以后，才把价格说出来，这个时候出现的数字，会让对方觉得是个合理的数字。至于 “退出机制” “利润分红”这些内容，在初次接触中并不重要，它们都有谈判的空间，所以可以不写。在“要话先说”的顺序下，文章环环相扣，你前一部分阐述得精彩，读者才有兴趣问下一个问题，了解下一个部分。 “向下想三层”，假设变结论进入构思的第三步，TCS的S，structure结构。在你的文章里，可以用向下想三层的逻辑搭建金字塔结构。金字塔的塔尖，是你鲜明的观点或建议，而下面两层，是证据。在这个金字塔里，塔尖，你鲜明的观点或建议，是 “投钱给我们吧”。读者自然会问：为什么？金字塔第二层，两方面：因为有市场，因为我们强。读者又问：有市场？——哪块市场？你们强？——强在哪里？金字塔进入第三层的阐述。这种顺序，让读者先读到塔尖，这样，不仅他能理解你更快，甚至认同你都更快。因为塔尖就像一个熠熠生辉的宝石，抢先占据了他的阅读记忆，也许他会惴惴不安，也许他会兴奋不已，于是，在他接下来的阅读中，他会自己有意无意地将下面的证据与塔尖做链接，这个被说服过程由他自己来完成了。这就是先想再写的TCS构思法。如果不这么做，文章可能会一点一点地偏离方向，最后主张模糊、脉络不明。而修改一份粗糙的文案，花费时间和力气更多。 压缩三分之一的文字写完以后，还有一个步骤，压缩，删掉三分之一的文字。相信我，你可以做得到。 商务写作谨遵KISS原则：keep it short and simple。 句中不能有多余的词，段落中不能有多余的句子。你可能会问我：文章到底是要简洁还是详实呢？文字表达要简洁，内容提供要详实。深度阐述和实例细节，会让文章更长，但不是冗长。 “用最少的字表达最多的意思”，这是我们追求的语言审美境界。可以用这三个方法来做到 “减无可减”： 把注水的文字压缩掉：“大概”、“一般来说”、“话说回来”，等等。 把“在我看来、我认为、我相信”之类的短语删掉，这是你写的文章，没有必要反复提醒读者这是你的观点。 把意思重复的句子压缩掉：相信读者是聪明人。 简洁的文字体现自律。 本讲小结第一讲要结束了。在这一讲中，你要养成先想再写，然后再删的写作习惯。写之前，做好TCS三步构思——基调、内容、结构。 第一步， 基调为王，用正确的基调传递出4类文案的真正价值；第二步， 内容，提供“所有必需信息”，从“作者逻辑”切换到“读者逻辑”，并要话先说；第三步， 结构，用向下想三层的金字塔结构，把你的假设，变成结论，用结论去说服他人。最后， 商务写作的KISS原则要求我们压缩文章，我教了你三个方法。]]></content>
      <categories>
        <category>得到</category>
      </categories>
      <tags>
        <tag>得到，职场写作，软技能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[得到|怎样提升你的职场写作能力]]></title>
    <url>%2F2019%2F02%2F24%2Fimprove-writing-skills-in-workplace.html</url>
    <content type="text"><![CDATA[本文源自得到课程《有效提升你的职场写作能力》。作者戴愫老师，一名跨文化研究者，也是一名企业培训师。本系列共6讲和1个小结，干货满满，由思路清晰，思维缜密的戴愫老师娓娓道来。前两讲是基础课。养成正确的写作习惯——先想再写，然后删。写之前要“想”，想什么呢？用TCS三步构思法——基调、内容、结构。在基础课里，你会学到，在看似人人都会写的邮件里，蕴藏着怎样的高级套路。第三讲和第四讲，教你怎样给文章组织结构。当需要写复杂的文案时，怎样用四大思维能力组织一个高价值的文章，并且怎样写第一段，让文章的价值最大化。最后两讲，带你润色语言，为文章锦上添花——如何写出有权威性，又有亲和力的措辞，也就是让语言有质感、有温度。版权归得到App所有，本文及相关内容仅供我个人总结和学习。 三类职场人士的困惑是什么？戴愫老师和很多学员做过深度交流，有三类职场人士： 第一类，职场小兵。他们专业技能强，需要简洁有力地从专业视角影响读者；他们经常需要写一些文章分享信息、阐述观点，比如项目进度报告、会议纪要、工作计划、可行性报告等。 第二类，职场老兵。他们需要通过写营运类报告，列出工作过程和结果，并把“成果”变成“功劳”，证明自己是未来的管理人才。 第三类，职场管理层。需要用高层的故事线来组织文章逻辑。比如说经常需要书写管理类报告，描述清楚商业逻辑，以便公司做出战略决策。 很多人有以下困惑： 因为工作太忙，需要快速成文的方法； 因为没有受过专门的商务写作的训练，分不清商务写作、文学写作、学术写作的清晰界线； 不知道如何从工作中收集一手资料，并从资料上构筑观点； 不知道如何以公司战略为风向标，提出自己的诉求，争取资源； 不知道怎样通过写作，把自己从“做事”的模式，调整为“做贡献”的心态； 写作时 容易用空洞的言辞，缺乏实质内容。 书面沟通到底是一项什么样的技能？书面沟通的形式是什么？单向，还是双向？书面沟通是一种单向沟通。你写，发给他，他读；或他写，发给你，你读。这是它最大的缺陷！没有一个正常成年人喜欢“被通知、被命令”，大家都喜欢“被商量、被探讨”。这意味着，我们作为作者，要通过“单向沟通的形式”，让读者读出“双向沟通的幻觉”。制造这种幻觉很重要。为什么？我们来看第二点。 判断一次沟通是不是100分，标准是什么？这个标准是：你明白我的意思了，或者我明白你的意思了？不，这只是60分的沟通。我们把这件事儿办成了？这是80分。为什么只是80分，如果说这件事情是办成了，但我以后再也不想与你合作了，这就是赢了这场战役，失去了整个战争嘛，不行的。那怎么做到100分呢？100分沟通的标准是，我和你理性、感性都达成一致了。注意，感性也要求达成一致。职场上永远不要以为把事情搞定有多么难，真正难搞定的是“人”。哪怕是个纯技术问题，也是“人”的作为和不作为。 达成一次100分沟通的基本前提是什么？是“信任”。 信任是超越一切沟通形式、一切沟通技巧最基础的前提。汉字的“信”，左边一个人，右边一个言，我们正常的顺序是，先相信这个人，再相信他说的话。这个顺序有可能放在每次书面沟通中吗？没可能。很多时候，你和读者没有见过面，哪怕你们见过面，他对你的人格也不一定了解。所以，我们需要学习：怎样在文章中大量使用信息化语言，在文字上与读者建立起信任，让他在不认识你，不熟知你的前提下，直接相信你写的话。 书面沟通这项技能的本质作为写作者的你要用大量的信息化语言，在文字上与读者建立起信任（这是基本前提），并且，让读者通过单向沟通的形式，读出双向沟通的幻觉（这可以通过写作内容和文字表达来实现），最后，双方理性、感性都达成一致（这是100分沟通的衡量标准）。 重复一遍，书面沟通这项技能本质上就是：作为写作者的你要用大量的信息化语言，在文字上与读者建立起信任，让读者通过单向沟通的形式，读出双向沟通的幻觉，最后双方理性、感性都达成一致。 学完这门课，你能学到那些？戴愫老师曾经用这门课，在线下教授了上万名职场人士，他们反馈： 不仅会写了，而且写得更快了； 这堂写作课还帮助他们重塑了个人品牌； 他们通过写作打开了工作思维，写作为他们赢得了信任和尊重，从而，他们在公司里承担了更多的责任，职场道路开阔了。 在写作时，有效表达只是最基本的层次，有效沟通才是终极目标。每一次写作，并不是自己做了一次信息传递，每一次写作，你都在为读者创造一次阅读体验。一篇好文章，不会让读者读完后困惑地问“so what”(所以呢?)，而是发出“wow”(diao a!)的赞叹。]]></content>
      <categories>
        <category>得到</category>
      </categories>
      <tags>
        <tag>得到，职场写作，软技能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[认识SSM框架和Redis]]></title>
    <url>%2F2018%2F10%2F26%2FSSM-framework-Redis.html</url>
    <content type="text"><![CDATA[文章对以下要点进行总结和归纳：1)了解Spring IoC和Spring AOP的基础概念；2)了解MyBatis的特点；3)了解Spring MVC的特点；4)了解为什么要使用NoSQL(Redis)及Redis的优点；5)掌握SSM和Redis的基本结构框图和各种技术的作用。 Spring框架Spring框架是Java应用最广的框架，它优秀的理念包括 IoC (Inversion of Control， 控制反转)和 AOP (Aspect Oriented Programming， 面向切面编程)。 Spring IoC简介Spring IoC（Inversion of Control，控制反转）承担了一个资源管理、整合、即插即拔的功能。举个例子，在Java中我们为国家插座设计两种接口，那我们就可以为两种插座分别new两个对象，但是如果要更改上千次这种插座，难道要new很多对象吗？所以不用new的方式创建对象，而是使用配置的方式，然后使用配置的方式，然后让Spring IoC容器自己通过配置去找到插座。不需要去找资源(Bean)，只要向Spring IoC容器描述所需资源，Spring IoC自己会找到你所需要的资源，这就是Spring IoC的理念。这样就把Bean之间的依赖关系解耦了，更容易写出结构清晰的程序。除此之外，Spring IoC还提供对Java Bean生命周期的管理，可以延迟加载，可以在其生命周期内定义一些行为等，更加有效地使用和管理Java资源。如果使用new的方式来使用插座，代码如下。使用插座11234User user = new User();Socket socket = new Socket1();user.setSocket(socket);user.useSocket(); 这样会有一个弊端，如果使用其他插座，就需要修改代码。可以使用配置的方式代替new的方式创建对象，让Spring IoC容器通过配置去找到插座。使用Spring IoC注入插座1个用户1234&lt;bean id="socket" class="Socket1" /&gt;&lt;bean id="user" class="xxx.User"&gt; &lt;spanroperty name="socket" ref="socket" /&gt;&lt;/bean&gt; 只需要修改XML配置文件，就可以切换：切换插座的实现类12345- &lt;bean id="socket" class="Socket1" /&gt;+ &lt;bean id="socket" class="Socket2" /&gt;&lt;bean id="user" class="xxx.User"&gt; &lt;spanroperty name="socket" ref="socket" /&gt;&lt;/bean&gt; 显然，IoC的目标就是为了管理Bean而存在的。 Spring AOPIoC的目标就是为了管理Bean，而Bean是Java面向对象(OOP)的基础设计，比如声明一个用户类、插座类等都是基于面向对象的概念。有些情况是面向对象没办法处理的。举个例子，生产部门的订单、生产部门、财务部门三者符合OOP的设计理念。订单发出，生产部门审批通过准备付款，但是财务部门发现订单的价格超支了，需要取消订单。 显然超支限定已经不只是影响财务部门了，还会影响生产部门之前所做的审批，需要把它们作废。把预算超支这个条件称为切面，它影响了订单、生产部门和财务部门3个OOP对象。在现实中，这样的切面条件跨越了3个甚至更多的对象，并且影响了它们的协作。所以只用OOP并不完善，还需要面向切面的编程，通过它去管理在切面上的某些对象之间的协作。Spring AOP常用于数据库事务的编程，很多情况都如同上而的例子，我们在做完第一步数据库数据更新后，不知道下一步是否会成功，如果下一步失收，会使用数据库事务的回滚功能去回滚事务，使得第一步的数据库更新也作废。在Spring AOP实现的数据库事务管理中，是以异常作为消息的。在默认的情况下(可以通过Spring的配置修改)，只要Spring接收到了异常信息，它就会将数据库的事务回滚，从而保证数据的一致性。这样我们就知道在Spring的事务管理中只要让它接收到异常信息，它就会回滚事务，而不需要通过代码来实现这个过程。比如上面的例子，可用一段伪代码来进行一些必要的说明。Spring AOP处理订单伪代码12345678910private void proceed(Order order) &#123; //判断生产部门是否通过订单，数据库记录订单 boolean pflag = productionDept.isPass(order); if(pflag) &#123;//如果生产部门通过进行财务部门审批 if (financialDept.isOverBudget(order)) &#123;//财务审批是否超限 //抛出异常回滚事务，之前的订单操作也会被回滚 throw new RuntimeException("预算超限！！"); &#125; &#125;&#125; Spring AOP的编程屏蔽了数据库代码，只需关注业务代码，知道只要发生了一场异常，Spring会回滚事务就足够了。 MyBatis简介MyBatis的前身是Apache的开源项目iBatis，是一个基于 Java的持久层框架。2010年这个项目由Apache software foundation迁移到Google code，并更名为MyBatis。2013年11月，MyBatis迁移到GitHub上，目前由GitHub提供维护。MyBatis的优势在于灵活，它几乎可以代替JDBC，同时提供了接口编程。目前MyBatis的数据访问层 DAO(Data Access Objects)是不需要实现类的，它只需要一个接口和XML(或者注解)。MyBatis提供自动映射、动态SQL、级联、缓存、注解、代码和SQL分离等特性，使用方便，同时也可以对SQL进行优化。因为其具有封装少、映射多样化、支持存储过程、可以进行SQL优化等特点，使得它取代了Hibernate成为了Java互联网中首选的持久框架。Hibernate作为一种十分流行的框架，它有其无可替代的优势，这里我们有必要讨论一下它和MyBatis的区别。由于MyBatis和Hibernate都是持久层框架，都会涉及数据库，所以首先定义一个数据库表一角色表(t_role)。角色表的sql语句12345create table t_role( 编号 int(12) primary key， 角色名称 varchar(60)， 备注 varchar(1024)); 用一个POJO(Plain Ordinary Java Object)和这张表定义的字段对应起来。定义角色POJO123456789package com.learn.chapter1.pojo;public class Role implements java.io.Serializable &#123; private Integer id; private String roleName; private String note; /** * setter and getter **/&#125; 无论是MyBatis还是Hibernate都是依靠某种方法，将数据库的表和POJO映射起来的，这样就可以操作POJO来完成相关的逻辑了。 Hibernate简介映射规则 语言 映射方法 MyBatis 使用注解方式会受到一定的限制，通常使用XML方式实现映射关系 Hibernate XML和注解提供映射规则 把POJO对象和数据库表相互映射的框架称为对象关系映射(Object Relational Mapping，ORM，或O/RM，或O/R mapping)框架。Hibernate的设计理念是完全面向POJO的，不需要编写SQL就可以通过映射关系来操作数据库，是一种全表映射的体现；MyBatis需要提供SQL去运行。Hibernate映射文件12345678910111213141516171819&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN" "http://www.hibernate.rg/dtd/hibernate-mapping-3.0.dtd"&gt;&lt;hibernate-mapping&gt; &lt;class name="com.learn.chapter1.pojo.Role" tbale="t_role"&gt; &lt;id name="id" type="java.lang.Integer"&gt; &lt;column name="id" /&gt; &lt;generator class="identity" /&gt; &lt;/id&gt; &lt;spanroperty name="roleName" type="string"&gt; &lt;column name="role_name" length="60" not-null="true" /&gt; &lt;/property&gt; &lt;spanroperty name="note" type="string"&gt; &lt;column name="note" length="512" /&gt; &lt;/property&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 首先，对POJO和表t_role进行了映射配置，把两者映射起来了。然后，对POJO进行操作，从而影响t_role表的数据，比如对其增删改查可以按照如下操作。Hibernate通过Session操作数据库数据123456789101112131415161718192021222324252627282930Session session = null;Transaction tx = null; try &#123; //打开Session session = HibernateUtil.getSessionFactory().openSession(); //事务 tx = session.beginTransaction(); //POJO Role role = new Role(); role.setId(1); role.setRoleName("rolename1"); role.setNote("note1"); //保存 Role role2 = (Role) session.get(Role.class， 1); //查询 role2.setNote("修改备注"); session.update(role2); //更新 System.err.println(role2.getRoleName()); session.delete(role2); //删除 tx.commit(); //提交事务&#125; catch (Exception ex) &#123; if (tx != null &amp;&amp; tx.isActive()) &#123; tx.rollback(); //回滚事务 &#125; ex.printStackTrace();&#125; finally &#123; if (session != null &amp;&amp; session.isOpen()) &#123; session.close(); &#125;&#125; 这里没有SQL，因为Hibernate会根据映射关系来生成对应的SQL。 MyBatis可以自己拟定SQL规则，能精确定义SQL，从而符合移动互联网高并发、大数据、高性能、高响应的需求。MyBatis也需要映射文件把POJO和数据库的表对应起来。MyBatis映射文件1234567891011121314151617181920212223242526272829&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.learn.chapter1.mapper.RoleMapper"&gt; &lt;resultMap id="roleMap" type="com.learn.chaper1.pojo.Role"&gt; &lt;id property="id" column="id" /&gt; &lt;result property="roleName" column="role_name" /&gt; &lt;result property="note" column="note" /&gt; &lt;/resultMap&gt; &lt;select id="getRole" resultMap="roleMap"&gt; select id， role_name， note from t_rle where id = #&#123;id&#125; &lt;/select&gt; &lt;delete id="deleteRole" parameterType="int"&gt; delete from t_role where id = #&#123;id&#125; &lt;/delete&gt; &lt;insert id="insertRole" parameterType="com.learn.chapter1.pojo.Role"&gt; insert into t_role(role_name， note) values(#&#123;roleName&#125;， #&#123;note&#125;) &lt;/insert&gt; &lt;update id="updateRole" parameterType="com.learn.chapter1.pojo.Role"&gt; update t_role set role_name = #&#123;roleName&#125;， note = #&#123;note&#125; where id = #&#123;id&#125; &lt;/update&gt; &lt;/mapper&gt; 这里的resultMap元素用于定义映射规则，而实际上MyBatis在满足一定的规则下，完成自动映射，而增删改查对应着insert、delete、select、update四个元素。mapper元素中的namespace属性，要和一个接口的全限定名保持一致，而里面的SQL的id也需要和接口定义的方法完全保持一致，定义MyBatis映射文件。定义MyBatis映射文件123456789package com.learn.chapter1.mapper;import com.learn.chapter1.pojo.Role;public interface RoleMapper &#123; public Role getRole(Integer id); public int deleteRole(Integer id); public int insertROle(Role role); public int updateROle(Role role);&#125; 定义了MyBatis映射文件，不需要定义一个实现类。显然MyBatis在业务逻辑上和Hibernate是大同小异的。其区别在于，MyBatis需要提供接口和SQL，这意味着工作量会比较大，但是由于自定义SQL、映射关系，所以灵活性、可优化性超过了Hibernate。互联网可优化性、灵活性是十分重要的，因为一条SQL的性能可能相差十几倍到几十倍。 Hibernate和MyBatis的区别Hibernate和MyBatis的增、删、改、查，对于业务逻辑层来说大同小异，对于映射层而言Hibernate的配置不需要接口和SQL，相反MyBatis是需要的。对于Hibernate而言，不需要编写大量的SQL，就可以完全映射，同时提供了日志、缓存、级联(级联比MyBatis强大)等特性，此外还提供HQL( Hibernate Query Language)对POJO进行操作，使用十分方便，但是它也有致命的缺陷。由于无须SQL，当多表关联超过3个的时候，通过Hibernate的级联会造成太多性能的丢失，又或者我现在访问一个财务的表，然后它会关联财产信息表，财产又分为机械、原料等，显然机械和原料的字段是不一样的，这样关联字段只能根据特定的条件变化而变化而Hibernate无法支持这样的变化。遇到存储过程，Hibernate只能作罢。更为关键的是性能，在管理系统的时代，对于性能的要求不是那么苛刻，但是在互联网时代性能就是系统的根本，响应过慢就会丧失客户，试想一下谁会去用一个经常需要等待超过10秒以上的应用呢?以上的问题MyBatis都可以解决，MyBatis可以自由书写SQL、支持动态SQL、处理列表、动态生成表名、支持存储过程。这样就可以灵活地定义查询语句，满足各类需求和性能优化的需要，这些在互联网系统中是十分重要的。但MyBatis也有缺陷。首先，它要编写SQL和映射规则，其工作量稍微大于Hibernate。 其次，它支持的工具也很有限，不能像Hibernate那样有许多的插件可以帮助生成映射代码和关联关系，而即使使用生成工具，往往也需要开发者进一步简化，MyBatis通过手工编码，工作量相对大些。所以对于性能要求不太苛刻的系统，比如管理系统、ERP等推荐使用Hibernate;而对于性能要求高、响应快、灵活的系统则推荐使用MyBatis。 Spring MVC简介也许你还在问为什么使用Spring MVC，Struts 2.x不才是主流吗？看SSH的概念多火!其实很多初学者都混淆了一个概念，SSH时间上指的是Struts 1.x + Spring + Hibernate，这个概念已经有十几年的历史了。在Structs 1.x的时代，Structs1.x是当之无愧的MVC框架的霸主，但是在新的MVC框架涌现的时代，形式已经完全不是这样的了，Structs 2.x借助了Structs 1.x的好名声，让国内开发者认为Structs 2.x是霸主继任者（其实两者在技术上没有任何关系），导致国内的很多程序员大多数学习基于Structs 2.x的框架，有一个貌似很火的概念出来了S2SH(Struts 2.x + Spring + Hibernate)整合开发。根据JRebel厂商统计，Spring MVC的市场占有率是40%，而Structs 2.x只有可怜的6%。Spring MVC是目前Java Web框架当之无愧的霸主。Spring MVC和三层架构是什么关系，可能很多读者会抢答：MVC：Model + View + Controller (数据模型+视图+控制器)三层架构：Prensentation tier + Application tier + Data tier（展现层+应用层+数据访问层）那MVC和三层架构有什么关系呢？但是实际上MVC只存在三层架构的展现层，M实际上是数据模型，是包含数据的对象。在Spring MVC里，有一个专门的类叫Model，用来和V之间的数据交互、传值；V指的是视图页面，包含JSP、freeMarker、Velocity、Thymeleaf、Tile等；C当然就是控制器（Spring MVC的注解@Controller的类）。而三层架构是整个应用的架构，是由Spring框架负责管理的。一般项目中会有Service层、DAO层，这两个反馈在应用层和数据访问层。 Java EE应用的分层模型经典的Java EE架构大致上都可以分为如下几层： Domain Object(领域对象)层。此层有一系列的POJO(Plain Object Java Object，普通的传统的Java对象)组成，这些对象是该系统的Domain Object(领域对象)，往往包含了各自所需实现的业务逻辑方法。 DAO(Data Access Object，数据访问对象)层。此层由一系列的DAO组件组成，这些DAO实现了对数据库的创建、查询、更新和删除（CRUD）等原子操作。 Service(业务逻辑)层。此层由一系列的业务逻辑对象组成，这些业务逻辑对象实现了系统所需的业务逻辑方法。这些业务逻辑方法可能仅仅用于暴露Domain Object对象所实现的业务逻辑方法，也可能是依赖DAO组件实现的业务逻辑方法。 Controller(控制器)层。此层由一系列控制器组成，这些控制器用于拦截用户请求，并调用业务逻辑组件的业务逻辑方法，处理用户请求，并根据处理结果向不同的表现层组件转发。 View(表现)层。此层由一系列的JSP页面、Velocity页面、PDF文档视图组件组成，负责手机用户请求，并显示处理结果。Java EE应用的组件总体而言，Java EE应用应该大致包括如下几类组件： 表现层组件。主要负责收集用户输入数据，或者想客户显示系统状态。最常用的表现层技术是JSP，但JSP并不是唯一的表现层技术。表现层还可以由Velocity、FreeMarker和Tapestry等技术完成，或者使用普通的应用程序充当表现层组件，甚至可以是小型智能设备。 控制器组件。关于Java EE的MVC框架，其提供了一个前端核心控制器，核心控制器负责拦截用户请求，并将请求转发给用户实现的控制器组件。这些用户实现的控制器组件则负责调用业务逻辑方法，处理用户请求。 业务逻辑组件。这是系统的核心组件，实现系统的业务逻辑。通常，一个业务逻辑方法对应一次用户操作。一个业务逻辑方法应该是一个整体，因此要求对业务逻辑方法增加事务性。业务逻辑方法仅仅实现也呜呜逻辑，不应该进行数据库访问。因此，业务逻辑组件中不应该出现原始的MyBatis、Hibernate和JDBC等API。最重要的原因是：保证业务逻辑方法的实现与具体的持久层访问技术分离。当系统需要在不同持久层技术之间切换时，系统的业务逻辑组件无序任何改变。 DAO组件。这个类型的对象比较缺乏变化，每个DAO组件都提供Domain Object对象基本的创建、查询、更新和删除等操作，这些操作对应于数据库的CRUD（创建、查询、更新和删除）等原子操作。当然，如果采用不同的持久层访问技术，DAO组件的会完全不同。为了实现业务逻辑组件的实现与DAO组件的实现分离，程序应该为每个DAO组件都提供接口，业务逻辑组件面向DAO接口编程，这样才能提供更好的解耦。 领域对象组件。领域对象（Doamin Object）抽象了系统的对象模型。通常而言，这些领域对象的状态都必须保存在数据库里。因此，每个领域对象通常对应一个或多个数据表，领域对象通常需要提供对数据记录的访问方式。 最流行的NoSQL – RedisNoSQL(Not Only SQL)存储的数据是半结构化的，Redis成为主要的NoSQL工具。 响应速度快。 支持6种数据类型：字符串、哈希结构、列表、集合、可排序集合和基数。比如字符串可以存储Java基础数据类型，哈希可以存储对象，列表可以存储List对象等。 操作都是原子的。 MultiUtility工具：Redis可以再如缓存、、消息传递队列中使用（Reids支持“发布+订阅”的消息模式），在应用程序如Web应用程序绘画、网站页面点击数等任何短暂的数据中使用。 SSM+Redis结构框图及概述在Java Web中，以Spring + Spring MVC + MyBatis（SSM）作为主流框架，SSM+Redis的结构框图如下： Spring IoC承担了一个资源管理、整合、即插即拔的功能。 Spring AOP可以提供切面管理，特别是书U哭事务管理的功能。 Spring MVC用于把模型、视图和控制器分层，组合成了一个有机灵活的系统。 MyBatis提供了一个数据库访问的持久层，通过MyBatis-Spring项目，它便能和Spring无缝对接。 Redis作为缓存工具，它提供了高速度处理数据和缓存数据的功能，使得系统大部分只需要访问缓存，而无须从数据库磁盘中重复读/写；在一些需要高速运算的场合中，也可以先用它来完成运算，再把数据批量存入数据库，这样便能极大地提升互联网系统的性能和响应能力。 在后面会讲解这些技术的使用方法、原理和优化方法。]]></content>
      <categories>
        <category>Java EE</category>
      </categories>
      <tags>
        <tag>Spring， Spring MVC， MyBatis， Redis</tag>
      </tags>
  </entry>
</search>
