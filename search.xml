<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[设计模式之禅|6大设计原则]]></title>
    <url>%2F2019%2F03%2F23%2Fsolid-principles.html</url>
    <content type="text"><![CDATA[曾经对“设计模式”(Design Pattern)很膜拜，以为是最高大上的东西。现在看来更多的是前人总结的经验吧，了解一下就可以了，关键是要用的时候“熟能生巧”。最开始看的时候也正在学习Java，配合着这本书中的Java代码，感觉各种神奇。其实，Java语言设计之初为了避免像C++般复杂却过于简化了语法，结果大大降低了本身的表达能力。很多本来可以很简洁的代码，必须绕来绕去得写出来，这个时候就很需要利用设计模式来整理代码逻辑。另一方面，设计模式也还是有些用途的，尤其是在开发大型软件系统，很注重系统架构的设计和功能模块的解耦的场合。 题外话，UML类图中类之间的关系有：泛化 = 实现 &gt; 组合 &gt; 聚合 &gt; 关联 &gt; 依赖 泛化(Generalization)： 继承关系，子类继承父类 继承用实线三角箭头指向父类 实现(Realization)： 对接口的实现，类实现一个接口 继承接口用虚线三角箭头指向接口 组合(Composition)： 整体与部分的关系,但部分不能离开整体而单独存在 实心菱形，菱形指向整体 聚合(Aggregation)： 整体与部分的关系,且部分可以离开整体而单独存在 空心菱形，菱形指向整体 关联(Association)： 拥有的关系，让一个类知道另一个类的属性方法 实线箭头，箭头指向被关联的类 依赖(Dependency)： 一种使用的关系，即一个类的实现需要另一个类的协助，所以尽量不要使用双向的相互依赖，代码体现：局部变量、方法的参数或者调用类的静态方法 虚线箭头，指向被使用者 软件分析与设计是编码前的2个阶段，分析仅与业务有关，而与技术无关，设计以分析为基础，与具体技术有关。 紧耦合 类间耦合过重 接口封装过度 类间解耦，弱耦合 单一职责原则单一职责原则的英文名称是Single Responsibility Principle，简称是SRP。这个原则存在争议之处在对职责的定义，什么是类的职责，以及怎么划分类的职责。 RBAC模式（Role-Based Access Control，基于角色的访问控制，通过分配和取消角色来完成用户权限的授予和取消，使动作主体（用户）与资源的行为（权限）分离）。把用户的信息抽取成一个BO（Business Object, 业务对象），把行为抽取成一个Biz（Business Logic，业务逻辑）。 SRP的定义是：应该有且仅有一个原因引起类的变更。SRP的原话解释： There should never be more than one reason for a class to change.就一个类而言，应该只有一个引起它变化的原因。 单一职责原则的优点： 可以降低类的复杂度，实现什么职责都有清晰明确的定义； 提高类的可读性； 提高系统的可维护性； 变更引起的风险降低，变更是必然的，如果单一职责原则遵守的好，一个接口修改只对相应地实现类有影响，对其他的接口无影响，这对系统的扩展性、维护性都有非常大的帮助。 单一职责原则要求一个接口或类只有一个原因引起变化，也就是一个接口或类只有一个职责，它就负责一件事。一个职责就是一个接口。对于接口，我们在设计的时候一定要做到单一，但是对于实现类就需要多方面考虑了，可能不会满足单一职责原则。单一职责适用于接口、类，同时也适用于方法。一个方法尽可能做一件事情。 里氏替换原则在实际项目中，每个子类对应不同的业务含义，使用父类作为参数，传递不同的子类完成不同的业务逻辑，非常完美。里氏替换原则(LSP:Liskov Substitution Principle)的定义： 第一种定义，也是最正宗的定义： If for each object o1 of type S there is an object o2 of type T such that for all programs P defined in terms of T, the behavior of P is unchanged when o1 is substituted for o2 then S is a subtype of T.（如果对每一个类型为S的对象o1，都有类型为T的对象o2，使得以T定义的所有程序P在所在的对象o1都代换为o2时，程序P的行为没有发生变化，那么类型S是类型T的字类型。） 第二种定义：Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it.（所有引用基类的地方必须能透明地使用其子类的对象。） 继承的优点： 代码共享，减少创建类的工作量，每个子类都拥有父类的方法和属性。 提高代码的重用性。 子类可以形似父类，但又异于父类。 提高代码的可扩展性，只需实现父类的方法。 提高产品或项目的开放性。 继承的缺点： 继承是侵入性的。只要继承，就必须拥有父类的所有属性和方法。 降低代码的灵活性。子类必须拥有父类的属性和方法。 增强了耦合性。当父类的常量、变量和方法被修改时，必须要考虑子类的修改，而且在缺乏规范的环境下，这种修改可能带来非常糟糕的结果——大片代码需要重构。 在类中调用其他类时务必要使用父类或接口，如果不能使用负累或接口，则说明类的设计已经违背了LSP原则。里氏替换原则包含了4层含义： 子类必须完全实现父类的方法如果子类不能完整地实现父类的方法，或者父类的某些方法在子类中已经发生”畸变”，则建议断开父子继承关系，采用依赖、聚集、组合等关系代替继承。 子类可以有自己的个性子类可以有自己的行为和外观，也就是方法和属性。 覆盖或实现父类的方法时输入参数可以被放大子类的方法可以重载（Overload）父类的方法，并把输入参数设置成为父类的方法的输入参数的父类（即把输入参数放大）。这时，通过父类的引用调用这个方法，实际调用的还是父类的方法，子类的方法由于只是重载而不是覆写（Override），会被隐藏掉。子类可以覆写（Override）父类的方法。 覆写或实现父类的方法时输出结果可以被缩小父类的方法返回值是一个类型T，子类的相同方法（重载或覆写）的返回值为S，那么里氏替换原则就要求S必须小于等于T，也就是说，要么S和T是同一个类型，要么S是T的子类。 如果是覆写，父类和子类的同名方法的输入参数相同，两个方法的范围值S小于等于T，这是覆写的要求，这才是重中之重，子类覆写父类的方法，天经地义。 如果是重载，则要求方法的输入参数类型或数量不相同，在里氏替换原则要求下，就是子类的输入参数宽于或等于父类的输入参数，也就是说你写的这个方法是不会被调用的，参考上面讲的前置条件。 依赖倒置原则依赖正置就是类间的依赖是实实在在的实现类间的依赖。 依赖倒置原则（Dependence Inversion Principle, DIP）的定义：High level modules should not depend upon low level modules. Both should depend upon abstractions. Abstractions should not depend upon details. Details should depend upon abstractions.翻译过来，有三重含义： 高层模块不应该依赖底层模块，两者都应该依赖其抽象。 抽象不应该依赖细节。 细节应该依赖抽象。 高层模块和低层模块容易理解，每一个逻辑的实现都是由原子逻辑组成的，不可分割的原子逻辑就是低层模块，原子逻辑的再组装就是高层模块。在Java中，抽象是指接口或抽象类，两者都不是不能直接被实例化的；细节就是实现类，实现接口或继承抽象类而产生的类就是细节，其特点就是可以直接被实例化。依赖倒置原则在Java语言中的表现就是： 模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的。 接口或抽象类不依赖于实现类。 实现类依赖与接口或抽象类。 更加精髓的定义就是 “面向接口编程”——面向对象设计的精髓之一。 采用依赖倒置原则可以减少类间的耦合性，提高系统的稳定性，降低并发开发引起的风险，提高代码的可读性和可维护性。 依赖是可以传递的。只要做到抽象依赖，即使是多层的依赖传递也无所畏惧。 依赖倒置原则要求我们在程序代码中传递参数时或在关联关系中，尽量 引用层次高的抽象层类，即使用 接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等，而不要用具体类来做这些事情。 最佳实践： 每个类尽量都有接口或抽象类，或者抽象类和接口两者都具备。接口负责定义public属性和方法，并且声明与其他对象的依赖关系，抽象类负责公共构造部分的实现，实现类准确的实现业务逻辑，同时在适当的世界对父类进行细化。 变量的表名类型尽量是接口或者抽象类。 任何类都不应该从具体类派生。 尽量不要覆写基类的方法。 结合里氏替换原则使用。 对象的依赖关系又三种方式来传递： 构造函数传递依赖对象 Setter方法传递依赖对象 接口声明依赖对象 接口隔离原则接口的两种类型： 实例接口（Object Interface），在Java中声明一个类，然后用new关键字产生一个实例，它是对一个类型的事物的描述，就是一种接口。 类接口（Class Interface），Java中经常使用的interface关键字定义的接口。接口是我们设计时对外提供的契约。 接口隔离原则(ISP：Interface Segregation Principle)定义：使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。 根据接口隔离原则，当一个接口太大时，我们需要将它分割成一些更细小的接口，使用该接口的客户端仅需知道与之相关的方法即可。每一个接口应该承担一种相对独立的角色，不干不该干的事，该干的事都要干。 看到这里好像接口隔离原则与单一职责原则是相同的。其实接口隔离原则与单一职责原则的审视角度是不相同的，单一职责原则要求的是类和接口职责单一，注重的是职责，这是业务逻辑上的划分，而接口隔离原则要求接口的方法尽量少。 接口隔离原则是对接口进行规范约束，其包含的以下4层含义： 接口要尽量小这是接口隔离原则的核心定义。但是”小”是有限度的，首先就是不能违反单一职责原则，已经做到单一职责的接口不应该再分。即，根据接口隔离原则拆分接口时，首先必须满足单一职责原则。 接口要高内聚高内聚就是提高接口、类、模块的处理能力，减少对外的交互。具体到接口隔离原则就是，要求在接口中尽量少公布public方法，接口是对外的承诺，承诺越少对系统的开发越有利，变更的风险也就越少，同时也有利于降低成本。 定制服务定制服务就是单独为一个个体提供优良的服务。要求就是：只提供访问者需要的方法。 接口设计是有限度的接口的设计粒度越小，系统越灵活。但是，灵活的同时也带来了结构的复杂化，开发难度增加，可维护性降低。所以接口设计一定要注意适度。 最佳实践： 一个接口只服务于一个子模块或业务逻辑。 通过业务逻辑压缩接口中的public方法，接口时常去回顾，尽量让接口达到“满身筋骨肉”，而不是“肥嘟嘟”的一大堆方法。 已经被污染了的接口，尽量去修改，若变更的风险较大，则采用适配器模式进行转化处理。 了解环境，拒绝盲从。环境不同，接口拆分的标准就不同，深入了解业务逻辑，根据实际情况设计接口。 迪米特法则最小知识原则（Least Knowledge Principle，LKP）： 一个对象应该对其他对象有最少的了解。 通俗地讲，一个类应该对自己需要耦合或调用的类知道得最少。最小知识原则包含以下4层含义： 只和朋友交流Only talk to your immedate friends（只和直接朋友通信。）两个对象之间的耦合就成为朋友关系。 类和类之间的关系是建立在类间的，而不是方法间。朋友类：出现在在成员变量、方法的输入输出参数中的类成为成员朋友类，而出现在方法内部的类不属于朋友类。 朋友间也是有距离的朋友类之间也不应该暴露太多方法。尽量不要对外公布太多的public和非静态的public变量，尽量内敛，多使用protected、package-private、protected等访问权限。 是自己的就是自己的如果一个方法放在本类中，既不增加类间关系，也对本类不产生负面影响，就放置在本类中。 谨慎使用Serializable可能会因为对类的更改未在服务器和客户端之间同步而引起序列化失败问题。 迪米特法则的核心观念就是类间解耦，弱耦合 开闭原则开闭原则(OCP:Open-Closed Principle)的定义：Software entities like classes, modules and functions should be open for extension but closed for modifications.（一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。）一个软件实体（模块、类、接口、方法）应该通过 扩展来实现变化，而不是通过修改已有的代码来实现变化。 开闭原则是最基本的原则，是其他原则和设计模式的精神。 开闭原则的重要性： 开闭原则对测试的影响所有已经投产的代码都是有意义的，并且都不受系统规则的约束。如果通过修改而不是扩展代码来应对需求变化，需要重新测试已经修改的代码。 开闭原则可以提高复用性在面向对象的设计中，所有的逻辑都是从原子逻辑组合而来的，而不是在一个类中独立实现一个业务逻辑。 开闭原则可以提高可维护性 面向对象开发的要求快速的应对变化，需要在设计之初就考虑所有可能变化的因素，然后留下接口。 需求变化的三种类型： 逻辑变化可以通过修改原有类中的方法的方式来完成 子模块变化通过扩展来应对 可见视图变化可见视图是提供给客户使用的界面，该部分的变化一般会引起连锁反应，但还是可以通过扩展来完成变化，这就要看原来的设计是否灵活。 应对需求变化的原则： 保持历史的纯洁性，不去修改历史。 应对需求变化的三种方法： 修改接口不可靠的，该方案应该被直接否定。 修改实现类该方法在项目有明确的章程或优良的架构设计时，是一个非常优秀的方法，但是仍有缺陷。 通过扩展实现变化好方法，修改少，风险小。 最佳实践： 抽象约束首先通过接口或抽象类约束扩展，对扩展进行边界限定，不允许出现在接口或抽象类中不存在的public方法；第二，参数类型，引用对象尽量使用接口或者抽象类，而不是实现类；第三，抽象层尽量保持稳定，一旦确定既不允许修改。 元数据(metadata)控制模块行为尽量使用元数据(用来描述环境和数据的数据，通俗的说就是配置参数)来控制程序的行为，减少重复开发。 制定项目章程对于项目来说，约定优于配置。 封装变化第一，将相同的变化封装到一个接口或抽象类中；第二，将不同的变化封装到不同的接口或抽象类中，不应该有两个不同的变化出现在同一个接口或抽象类中。]]></content>
      <categories>
        <category>DPModel</category>
      </categories>
      <tags>
        <tag>DPModel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一讲|先想后写——TCS三步构思法]]></title>
    <url>%2F2019%2F02%2F26%2Ftone-content-structure.html</url>
    <content type="text"><![CDATA[职场写作最忌讳打开电脑就写，请你先想再写。TCS法三个步骤完成构思过程，即tone、content和structure，对应基调、内容和结构。 基调为王，七种文案的标志性语气第一步，基调，文章以基调为“王”。基调对了，事半功倍；基调错了，哪怕你传递的信息再重要，我也不会关注。正确的基调能传递出文章真正的价值，也就是你的价值。职场写作可以分成四大类，那么每一类都需要传递你的什么价值呢？ 第一，总结类，写的是成绩，呈现的是你的潜力； 第二，调查报告类，写的是调查结果，呈现的是你求实的态度； 第三，申请类，内容是提问，呈现的是你主动的思考方式； 第四，计划类，写的是阶段任务，呈现的是你的责任感。 如果明白了要呈现自己什么价值，那你拿捏起文章的基调来，正确的概率就会很高。 以常见的六种具体文案为例，探讨一下它们的标志性的基调。 年终总结，基调要求：有深度不要写成一份业绩的流水账——因为你的工作结果，领导在看你的总结之前就知道。可他为什么还要看？他要读到你的分析能力；他希望你能从对工作感性的认知，上升到理性的规律性的总结；他需要你协助他，对未来做出更正确的决定。由此来看，年终总结不是回顾，而是行动指南。好的年终总结应该： 会将工作成果写出意义，会提供难得的一线经验、不同的视角； 会在罗列了贡献之后，找出问题或机遇，以及怎样解决这个问题，或抓住这个机遇。这就是“有深度”。 进展汇报，基调要求：不讨教在进展汇报里，不能只提问题，向领导讨教，而应该给出方案，向领导汇报。讨教的公式是：您告诉我该怎么做。汇报的公式是：我这样做，您同意吗？这里我想提醒你，哪怕领导没有要求你写进展汇报，你也要养成定期向他汇报的习惯。你需要将解决问题过程中的一些重要发现、关键结论、阶段性成果等小胜利，实时呈现给他，让他读出你的认真，让他看到你不断提高工作能力的过程。 调查报告，基调要求：实事求是在收集充分的事实资料后，你的措辞是“资料显示、数字表明”，而不是“我认为、我估计”。这种报告才能展现事情的真相，才会有让人惊喜的收获。 请示，基调要求：有主见有的人这么写： “客户投诉如下，请指示。”不管是找领导要人、要钱，或其他任何资源，一定要有清晰的主见。比如申请款项，你要给一个量化的标准让领导来裁决，不能模糊不清，让他无据可依、无处下手。让他做选择题的时候，你也需要提供最佳选项。另外，部门主管向上级递交请示的时候，不能采用传声筒的语气。不要写“他们抱怨”或“他们声称”，要写“我注意到” “我相信我的团队会……”，这才是有担当、有主见的语气。 批复，基调要求：态度明确不能出现这样的措辞：“似属可行” “酌情办理”。 项目计划，基调要求：“可交付”不能仅仅写行为。一个项目的成功，不是行动了就可以，而是众多可交付结果的总和。 比如：“选择外部供应商”，这是写行为，改为可交付的结果：“确定外部供应商”。 又比如：“草拟消费者调查报告”，这又是写行为，改为可交付结果：“递交消费者调查报告”。 这里我再和你多说一点。最好的项目计划书，是按照 OKR目标管理工具来写的。O：Objective 目标，KR：Key Results 关键结果。简单地说，计划就是由目标和关键结果构成。其中，大目标可以分解成小目标，关键结果是用来衡量这些目标有没有完成的。按照这个工具来写，你的基调自然就是可交付的结果。 以上就是构思的第一步——基调。 从“作者逻辑”切换到“读者逻辑”TCS的第二步，C：content，内容。你意识到了吗？我们在学校里的写作，读者是教授，他读你的文章的时候是有薪水拿的。在职场上的写作，可不是这样。职场上的读者，大多是“甲方读者”，比如领导、客户、重要合作伙伴，等等。也就是说，他们没有义务读完你的文章，他们可以随时终止阅读。怎么才能让这些甲方读者被你的内容吸引呢？请遵照这个原则： 先从“作者逻辑”切换到“读者逻辑”，提供“所有必需信息”，然后按照“要话先说”的顺序排列。也就是说， 你的文章每个部分都要对读者有价值。你写第一句话，是为了让他继续看第二句话；你写第二句话，是为了让他继续看第三句话。 举个例子，如果要写一份给投资人的商业计划书，俗称项目BP(Business Plan)。我们先做发散思维，想一想在初次接触时，投资人需要哪些信息来判断是否对项目有信心，是否愿意投资参与该项目？然后，为这些信息排序。我最担心你一上来就急着展示自己公司有多厉害，这是作者逻辑。没搭好台就展示自己，操之过急。相反，文章应该从分析整个行业下手，彰显市场空缺。搭建好舞台后，才有机会介绍自己。风险投资人也是要最大限度地规避风险的。而先选择行业，再选择个体，是他规避风险的方式，是读者逻辑。按照这个逻辑，文章怎样写呢？ 第一部分，写 “项目愿景”。 也就是，你要做一件什么样的大事。这部分需要有一句高度精炼的话，比如黄太吉的“打造以煎饼果子为核心的中式时尚快餐连锁品牌”。对方会问，这件事为什么值得做？于是你给出 “市场痛点”。比如，摩拜单车是为了解决最后一公里的交通痛点。如果投资人根本不认为这是个痛点，后面一切都白写了。再往下，是 “解决方案”。论证的是，我们正在做的这个事业，真正能解决得了这个痛点，这把钥匙能开得了这把锁。OK,读者表示认同。然后，他会想，“市场潜力”大吗？这时，你该展示市场调查结果了，包括市场规模、用户画像、竞品分析等等。那他会接着问，为什么要投你们，而不是别人呢？你要阐述自己的 “独特优势”。包括行业经验、核心技术、牛人团队，等等。OK, 这时读者对你有点儿感觉了。 下一部分，趁他对你有感觉的时候，拉着他一块儿画饼，你要写 “发展规划”了。写清楚盈利模式和发展路径。也许你觉得奇怪，为什么这个内容现在才写？其实投资人很有经验，他只要决定和你一块儿干，他会在后期帮你一起完善盈利模式，清晰发展路径。 最后，做 “财务分析”，告诉他，你们缺多少钱。为什么把融资额度放最后写呢？你想想看，有经验的销售想把东西卖给你的时候，通常不会一上来就报价的。他们都是把商品的价值点全部讲完以后，才把价格说出来，这个时候出现的数字，会让对方觉得是个合理的数字。至于 “退出机制” “利润分红”这些内容，在初次接触中并不重要，它们都有谈判的空间，所以可以不写。在“要话先说”的顺序下，文章环环相扣，你前一部分阐述得精彩，读者才有兴趣问下一个问题，了解下一个部分。 “向下想三层”，假设变结论进入构思的第三步，TCS的S，structure结构。在你的文章里，可以用向下想三层的逻辑搭建金字塔结构。金字塔的塔尖，是你鲜明的观点或建议，而下面两层，是证据。在这个金字塔里，塔尖，你鲜明的观点或建议，是 “投钱给我们吧”。读者自然会问：为什么？金字塔第二层，两方面：因为有市场，因为我们强。读者又问：有市场？——哪块市场？你们强？——强在哪里？金字塔进入第三层的阐述。这种顺序，让读者先读到塔尖，这样，不仅他能理解你更快，甚至认同你都更快。因为塔尖就像一个熠熠生辉的宝石，抢先占据了他的阅读记忆，也许他会惴惴不安，也许他会兴奋不已，于是，在他接下来的阅读中，他会自己有意无意地将下面的证据与塔尖做链接，这个被说服过程由他自己来完成了。这就是先想再写的TCS构思法。如果不这么做，文章可能会一点一点地偏离方向，最后主张模糊、脉络不明。而修改一份粗糙的文案，花费时间和力气更多。 压缩三分之一的文字写完以后，还有一个步骤，压缩，删掉三分之一的文字。相信我，你可以做得到。 商务写作谨遵KISS原则：keep it short and simple。 句中不能有多余的词，段落中不能有多余的句子。你可能会问我：文章到底是要简洁还是详实呢？文字表达要简洁，内容提供要详实。深度阐述和实例细节，会让文章更长，但不是冗长。 “用最少的字表达最多的意思”，这是我们追求的语言审美境界。可以用这三个方法来做到 “减无可减”： 把注水的文字压缩掉：“大概”、“一般来说”、“话说回来”，等等。 把“在我看来、我认为、我相信”之类的短语删掉，这是你写的文章，没有必要反复提醒读者这是你的观点。 把意思重复的句子压缩掉：相信读者是聪明人。 简洁的文字体现自律。 本讲小结第一讲要结束了。在这一讲中，你要养成先想再写，然后再删的写作习惯。写之前，做好TCS三步构思——基调、内容、结构。 第一步， 基调为王，用正确的基调传递出4类文案的真正价值；第二步， 内容，提供“所有必需信息”，从“作者逻辑”切换到“读者逻辑”，并要话先说；第三步， 结构，用向下想三层的金字塔结构，把你的假设，变成结论，用结论去说服他人。最后， 商务写作的KISS原则要求我们压缩文章，我教了你三个方法。]]></content>
      <categories>
        <category>得到</category>
      </categories>
      <tags>
        <tag>得到，职场写作，软技能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[得到|怎样提升你的职场写作能力]]></title>
    <url>%2F2019%2F02%2F24%2Fimprove-writing-skills-in-workplace.html</url>
    <content type="text"><![CDATA[本文源自得到课程《有效提升你的职场写作能力》。作者戴愫老师，一名跨文化研究者，也是一名企业培训师。本系列共6讲和1个小结，干货满满，由思路清晰，思维缜密的戴愫老师娓娓道来。前两讲是基础课。养成正确的写作习惯——先想再写，然后删。写之前要“想”，想什么呢？用TCS三步构思法——基调、内容、结构。在基础课里，你会学到，在看似人人都会写的邮件里，蕴藏着怎样的高级套路。第三讲和第四讲，教你怎样给文章组织结构。当需要写复杂的文案时，怎样用四大思维能力组织一个高价值的文章，并且怎样写第一段，让文章的价值最大化。最后两讲，带你润色语言，为文章锦上添花——如何写出有权威性，又有亲和力的措辞，也就是让语言有质感、有温度。版权归得到App所有，本文及相关内容仅供我个人总结和学习。 三类职场人士的困惑是什么？戴愫老师和很多学员做过深度交流，有三类职场人士： 第一类，职场小兵。他们专业技能强，需要简洁有力地从专业视角影响读者；他们经常需要写一些文章分享信息、阐述观点，比如项目进度报告、会议纪要、工作计划、可行性报告等。 第二类，职场老兵。他们需要通过写营运类报告，列出工作过程和结果，并把“成果”变成“功劳”，证明自己是未来的管理人才。 第三类，职场管理层。需要用高层的故事线来组织文章逻辑。比如说经常需要书写管理类报告，描述清楚商业逻辑，以便公司做出战略决策。 很多人有以下困惑： 因为工作太忙，需要快速成文的方法； 因为没有受过专门的商务写作的训练，分不清商务写作、文学写作、学术写作的清晰界线； 不知道如何从工作中收集一手资料，并从资料上构筑观点； 不知道如何以公司战略为风向标，提出自己的诉求，争取资源； 不知道怎样通过写作，把自己从“做事”的模式，调整为“做贡献”的心态； 写作时 容易用空洞的言辞，缺乏实质内容。 书面沟通到底是一项什么样的技能？书面沟通的形式是什么？单向，还是双向？书面沟通是一种单向沟通。你写，发给他，他读；或他写，发给你，你读。这是它最大的缺陷！没有一个正常成年人喜欢“被通知、被命令”，大家都喜欢“被商量、被探讨”。这意味着，我们作为作者，要通过“单向沟通的形式”，让读者读出“双向沟通的幻觉”。制造这种幻觉很重要。为什么？我们来看第二点。 判断一次沟通是不是100分，标准是什么？这个标准是：你明白我的意思了，或者我明白你的意思了？不，这只是60分的沟通。我们把这件事儿办成了？这是80分。为什么只是80分，如果说这件事情是办成了，但我以后再也不想与你合作了，这就是赢了这场战役，失去了整个战争嘛，不行的。那怎么做到100分呢？100分沟通的标准是，我和你理性、感性都达成一致了。注意，感性也要求达成一致。职场上永远不要以为把事情搞定有多么难，真正难搞定的是“人”。哪怕是个纯技术问题，也是“人”的作为和不作为。 达成一次100分沟通的基本前提是什么？是“信任”。 信任是超越一切沟通形式、一切沟通技巧最基础的前提。汉字的“信”，左边一个人，右边一个言，我们正常的顺序是，先相信这个人，再相信他说的话。这个顺序有可能放在每次书面沟通中吗？没可能。很多时候，你和读者没有见过面，哪怕你们见过面，他对你的人格也不一定了解。所以，我们需要学习：怎样在文章中大量使用信息化语言，在文字上与读者建立起信任，让他在不认识你，不熟知你的前提下，直接相信你写的话。 书面沟通这项技能的本质作为写作者的你要用大量的信息化语言，在文字上与读者建立起信任（这是基本前提），并且，让读者通过单向沟通的形式，读出双向沟通的幻觉（这可以通过写作内容和文字表达来实现），最后，双方理性、感性都达成一致（这是100分沟通的衡量标准）。 重复一遍，书面沟通这项技能本质上就是：作为写作者的你要用大量的信息化语言，在文字上与读者建立起信任，让读者通过单向沟通的形式，读出双向沟通的幻觉，最后双方理性、感性都达成一致。 学完这门课，你能学到那些？戴愫老师曾经用这门课，在线下教授了上万名职场人士，他们反馈： 不仅会写了，而且写得更快了； 这堂写作课还帮助他们重塑了个人品牌； 他们通过写作打开了工作思维，写作为他们赢得了信任和尊重，从而，他们在公司里承担了更多的责任，职场道路开阔了。 在写作时，有效表达只是最基本的层次，有效沟通才是终极目标。每一次写作，并不是自己做了一次信息传递，每一次写作，你都在为读者创造一次阅读体验。一篇好文章，不会让读者读完后困惑地问“so what”(所以呢?)，而是发出“wow”(diao a!)的赞叹。]]></content>
      <categories>
        <category>得到</category>
      </categories>
      <tags>
        <tag>得到，职场写作，软技能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[认识SSM框架和Redis]]></title>
    <url>%2F2018%2F10%2F26%2FSSM-framework-Redis.html</url>
    <content type="text"><![CDATA[文章对以下要点进行总结和归纳：1)了解Spring IoC和Spring AOP的基础概念；2)了解MyBatis的特点；3)了解Spring MVC的特点；4)了解为什么要使用NoSQL(Redis)及Redis的优点；5)掌握SSM和Redis的基本结构框图和各种技术的作用。 Spring框架Spring框架是Java应用最广的框架，它优秀的理念包括 IoC (Inversion of Control， 控制反转)和 AOP (Aspect Oriented Programming， 面向切面编程)。 Spring IoC简介Spring IoC（Inversion of Control，控制反转）承担了一个资源管理、整合、即插即拔的功能。举个例子，在Java中我们为国家插座设计两种接口，那我们就可以为两种插座分别new两个对象，但是如果要更改上千次这种插座，难道要new很多对象吗？所以不用new的方式创建对象，而是使用配置的方式，然后使用配置的方式，然后让Spring IoC容器自己通过配置去找到插座。不需要去找资源(Bean)，只要向Spring IoC容器描述所需资源，Spring IoC自己会找到你所需要的资源，这就是Spring IoC的理念。这样就把Bean之间的依赖关系解耦了，更容易写出结构清晰的程序。除此之外，Spring IoC还提供对Java Bean生命周期的管理，可以延迟加载，可以在其生命周期内定义一些行为等，更加有效地使用和管理Java资源。如果使用new的方式来使用插座，代码如下。使用插座11234User user = new User();Socket socket = new Socket1();user.setSocket(socket);user.useSocket(); 这样会有一个弊端，如果使用其他插座，就需要修改代码。可以使用配置的方式代替new的方式创建对象，让Spring IoC容器通过配置去找到插座。使用Spring IoC注入插座1个用户1234&lt;bean id="socket" class="Socket1" /&gt;&lt;bean id="user" class="xxx.User"&gt; &lt;spanroperty name="socket" ref="socket" /&gt;&lt;/bean&gt; 只需要修改XML配置文件，就可以切换：切换插座的实现类12345- &lt;bean id="socket" class="Socket1" /&gt;+ &lt;bean id="socket" class="Socket2" /&gt;&lt;bean id="user" class="xxx.User"&gt; &lt;spanroperty name="socket" ref="socket" /&gt;&lt;/bean&gt; 显然，IoC的目标就是为了管理Bean而存在的。 Spring AOPIoC的目标就是为了管理Bean，而Bean是Java面向对象(OOP)的基础设计，比如声明一个用户类、插座类等都是基于面向对象的概念。有些情况是面向对象没办法处理的。举个例子，生产部门的订单、生产部门、财务部门三者符合OOP的设计理念。订单发出，生产部门审批通过准备付款，但是财务部门发现订单的价格超支了，需要取消订单。 显然超支限定已经不只是影响财务部门了，还会影响生产部门之前所做的审批，需要把它们作废。把预算超支这个条件称为切面，它影响了订单、生产部门和财务部门3个OOP对象。在现实中，这样的切面条件跨越了3个甚至更多的对象，并且影响了它们的协作。所以只用OOP并不完善，还需要面向切面的编程，通过它去管理在切面上的某些对象之间的协作。Spring AOP常用于数据库事务的编程，很多情况都如同上而的例子，我们在做完第一步数据库数据更新后，不知道下一步是否会成功，如果下一步失收，会使用数据库事务的回滚功能去回滚事务，使得第一步的数据库更新也作废。在Spring AOP实现的数据库事务管理中，是以异常作为消息的。在默认的情况下(可以通过Spring的配置修改)，只要Spring接收到了异常信息，它就会将数据库的事务回滚，从而保证数据的一致性。这样我们就知道在Spring的事务管理中只要让它接收到异常信息，它就会回滚事务，而不需要通过代码来实现这个过程。比如上面的例子，可用一段伪代码来进行一些必要的说明。Spring AOP处理订单伪代码12345678910private void proceed(Order order) &#123; //判断生产部门是否通过订单，数据库记录订单 boolean pflag = productionDept.isPass(order); if(pflag) &#123;//如果生产部门通过进行财务部门审批 if (financialDept.isOverBudget(order)) &#123;//财务审批是否超限 //抛出异常回滚事务，之前的订单操作也会被回滚 throw new RuntimeException("预算超限！！"); &#125; &#125;&#125; Spring AOP的编程屏蔽了数据库代码，只需关注业务代码，知道只要发生了一场异常，Spring会回滚事务就足够了。 MyBatis简介MyBatis的前身是Apache的开源项目iBatis，是一个基于 Java的持久层框架。2010年这个项目由Apache software foundation迁移到Google code，并更名为MyBatis。2013年11月，MyBatis迁移到GitHub上，目前由GitHub提供维护。MyBatis的优势在于灵活，它几乎可以代替JDBC，同时提供了接口编程。目前MyBatis的数据访问层 DAO(Data Access Objects)是不需要实现类的，它只需要一个接口和XML(或者注解)。MyBatis提供自动映射、动态SQL、级联、缓存、注解、代码和SQL分离等特性，使用方便，同时也可以对SQL进行优化。因为其具有封装少、映射多样化、支持存储过程、可以进行SQL优化等特点，使得它取代了Hibernate成为了Java互联网中首选的持久框架。Hibernate作为一种十分流行的框架，它有其无可替代的优势，这里我们有必要讨论一下它和MyBatis的区别。由于MyBatis和Hibernate都是持久层框架，都会涉及数据库，所以首先定义一个数据库表一角色表(t_role)。角色表的sql语句12345create table t_role( 编号 int(12) primary key， 角色名称 varchar(60)， 备注 varchar(1024)); 用一个POJO(Plain Ordinary Java Object)和这张表定义的字段对应起来。定义角色POJO123456789package com.learn.chapter1.pojo;public class Role implements java.io.Serializable &#123; private Integer id; private String roleName; private String note; /** * setter and getter **/&#125; 无论是MyBatis还是Hibernate都是依靠某种方法，将数据库的表和POJO映射起来的，这样就可以操作POJO来完成相关的逻辑了。 Hibernate简介映射规则 语言 映射方法 MyBatis 使用注解方式会受到一定的限制，通常使用XML方式实现映射关系 Hibernate XML和注解提供映射规则 把POJO对象和数据库表相互映射的框架称为对象关系映射(Object Relational Mapping，ORM，或O/RM，或O/R mapping)框架。Hibernate的设计理念是完全面向POJO的，不需要编写SQL就可以通过映射关系来操作数据库，是一种全表映射的体现；MyBatis需要提供SQL去运行。Hibernate映射文件12345678910111213141516171819&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN" "http://www.hibernate.rg/dtd/hibernate-mapping-3.0.dtd"&gt;&lt;hibernate-mapping&gt; &lt;class name="com.learn.chapter1.pojo.Role" tbale="t_role"&gt; &lt;id name="id" type="java.lang.Integer"&gt; &lt;column name="id" /&gt; &lt;generator class="identity" /&gt; &lt;/id&gt; &lt;spanroperty name="roleName" type="string"&gt; &lt;column name="role_name" length="60" not-null="true" /&gt; &lt;/property&gt; &lt;spanroperty name="note" type="string"&gt; &lt;column name="note" length="512" /&gt; &lt;/property&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 首先，对POJO和表t_role进行了映射配置，把两者映射起来了。然后，对POJO进行操作，从而影响t_role表的数据，比如对其增删改查可以按照如下操作。Hibernate通过Session操作数据库数据123456789101112131415161718192021222324252627282930Session session = null;Transaction tx = null; try &#123; //打开Session session = HibernateUtil.getSessionFactory().openSession(); //事务 tx = session.beginTransaction(); //POJO Role role = new Role(); role.setId(1); role.setRoleName("rolename1"); role.setNote("note1"); //保存 Role role2 = (Role) session.get(Role.class， 1); //查询 role2.setNote("修改备注"); session.update(role2); //更新 System.err.println(role2.getRoleName()); session.delete(role2); //删除 tx.commit(); //提交事务&#125; catch (Exception ex) &#123; if (tx != null &amp;&amp; tx.isActive()) &#123; tx.rollback(); //回滚事务 &#125; ex.printStackTrace();&#125; finally &#123; if (session != null &amp;&amp; session.isOpen()) &#123; session.close(); &#125;&#125; 这里没有SQL，因为Hibernate会根据映射关系来生成对应的SQL。 MyBatis可以自己拟定SQL规则，能精确定义SQL，从而符合移动互联网高并发、大数据、高性能、高响应的需求。MyBatis也需要映射文件把POJO和数据库的表对应起来。MyBatis映射文件1234567891011121314151617181920212223242526272829&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.learn.chapter1.mapper.RoleMapper"&gt; &lt;resultMap id="roleMap" type="com.learn.chaper1.pojo.Role"&gt; &lt;id property="id" column="id" /&gt; &lt;result property="roleName" column="role_name" /&gt; &lt;result property="note" column="note" /&gt; &lt;/resultMap&gt; &lt;select id="getRole" resultMap="roleMap"&gt; select id， role_name， note from t_rle where id = #&#123;id&#125; &lt;/select&gt; &lt;delete id="deleteRole" parameterType="int"&gt; delete from t_role where id = #&#123;id&#125; &lt;/delete&gt; &lt;insert id="insertRole" parameterType="com.learn.chapter1.pojo.Role"&gt; insert into t_role(role_name， note) values(#&#123;roleName&#125;， #&#123;note&#125;) &lt;/insert&gt; &lt;update id="updateRole" parameterType="com.learn.chapter1.pojo.Role"&gt; update t_role set role_name = #&#123;roleName&#125;， note = #&#123;note&#125; where id = #&#123;id&#125; &lt;/update&gt; &lt;/mapper&gt; 这里的resultMap元素用于定义映射规则，而实际上MyBatis在满足一定的规则下，完成自动映射，而增删改查对应着insert、delete、select、update四个元素。mapper元素中的namespace属性，要和一个接口的全限定名保持一致，而里面的SQL的id也需要和接口定义的方法完全保持一致，定义MyBatis映射文件。定义MyBatis映射文件123456789package com.learn.chapter1.mapper;import com.learn.chapter1.pojo.Role;public interface RoleMapper &#123; public Role getRole(Integer id); public int deleteRole(Integer id); public int insertROle(Role role); public int updateROle(Role role);&#125; 定义了MyBatis映射文件，不需要定义一个实现类。显然MyBatis在业务逻辑上和Hibernate是大同小异的。其区别在于，MyBatis需要提供接口和SQL，这意味着工作量会比较大，但是由于自定义SQL、映射关系，所以灵活性、可优化性超过了Hibernate。互联网可优化性、灵活性是十分重要的，因为一条SQL的性能可能相差十几倍到几十倍。 Hibernate和MyBatis的区别Hibernate和MyBatis的增、删、改、查，对于业务逻辑层来说大同小异，对于映射层而言Hibernate的配置不需要接口和SQL，相反MyBatis是需要的。对于Hibernate而言，不需要编写大量的SQL，就可以完全映射，同时提供了日志、缓存、级联(级联比MyBatis强大)等特性，此外还提供HQL( Hibernate Query Language)对POJO进行操作，使用十分方便，但是它也有致命的缺陷。由于无须SQL，当多表关联超过3个的时候，通过Hibernate的级联会造成太多性能的丢失，又或者我现在访问一个财务的表，然后它会关联财产信息表，财产又分为机械、原料等，显然机械和原料的字段是不一样的，这样关联字段只能根据特定的条件变化而变化而Hibernate无法支持这样的变化。遇到存储过程，Hibernate只能作罢。更为关键的是性能，在管理系统的时代，对于性能的要求不是那么苛刻，但是在互联网时代性能就是系统的根本，响应过慢就会丧失客户，试想一下谁会去用一个经常需要等待超过10秒以上的应用呢?以上的问题MyBatis都可以解决，MyBatis可以自由书写SQL、支持动态SQL、处理列表、动态生成表名、支持存储过程。这样就可以灵活地定义查询语句，满足各类需求和性能优化的需要，这些在互联网系统中是十分重要的。但MyBatis也有缺陷。首先，它要编写SQL和映射规则，其工作量稍微大于Hibernate。 其次，它支持的工具也很有限，不能像Hibernate那样有许多的插件可以帮助生成映射代码和关联关系，而即使使用生成工具，往往也需要开发者进一步简化，MyBatis通过手工编码，工作量相对大些。所以对于性能要求不太苛刻的系统，比如管理系统、ERP等推荐使用Hibernate;而对于性能要求高、响应快、灵活的系统则推荐使用MyBatis。 Spring MVC简介也许你还在问为什么使用Spring MVC，Struts 2.x不才是主流吗？看SSH的概念多火!其实很多初学者都混淆了一个概念，SSH时间上指的是Struts 1.x + Spring + Hibernate，这个概念已经有十几年的历史了。在Structs 1.x的时代，Structs1.x是当之无愧的MVC框架的霸主，但是在新的MVC框架涌现的时代，形式已经完全不是这样的了，Structs 2.x借助了Structs 1.x的好名声，让国内开发者认为Structs 2.x是霸主继任者（其实两者在技术上没有任何关系），导致国内的很多程序员大多数学习基于Structs 2.x的框架，有一个貌似很火的概念出来了S2SH(Struts 2.x + Spring + Hibernate)整合开发。根据JRebel厂商统计，Spring MVC的市场占有率是40%，而Structs 2.x只有可怜的6%。Spring MVC是目前Java Web框架当之无愧的霸主。Spring MVC和三层架构是什么关系，可能很多读者会抢答：MVC：Model + View + Controller (数据模型+视图+控制器)三层架构：Prensentation tier + Application tier + Data tier（展现层+应用层+数据访问层）那MVC和三层架构有什么关系呢？但是实际上MVC只存在三层架构的展现层，M实际上是数据模型，是包含数据的对象。在Spring MVC里，有一个专门的类叫Model，用来和V之间的数据交互、传值；V指的是视图页面，包含JSP、freeMarker、Velocity、Thymeleaf、Tile等；C当然就是控制器（Spring MVC的注解@Controller的类）。而三层架构是整个应用的架构，是由Spring框架负责管理的。一般项目中会有Service层、DAO层，这两个反馈在应用层和数据访问层。 Java EE应用的分层模型经典的Java EE架构大致上都可以分为如下几层： Domain Object(领域对象)层。此层有一系列的POJO(Plain Object Java Object，普通的传统的Java对象)组成，这些对象是该系统的Domain Object(领域对象)，往往包含了各自所需实现的业务逻辑方法。 DAO(Data Access Object，数据访问对象)层。此层由一系列的DAO组件组成，这些DAO实现了对数据库的创建、查询、更新和删除（CRUD）等原子操作。 Service(业务逻辑)层。此层由一系列的业务逻辑对象组成，这些业务逻辑对象实现了系统所需的业务逻辑方法。这些业务逻辑方法可能仅仅用于暴露Domain Object对象所实现的业务逻辑方法，也可能是依赖DAO组件实现的业务逻辑方法。 Controller(控制器)层。此层由一系列控制器组成，这些控制器用于拦截用户请求，并调用业务逻辑组件的业务逻辑方法，处理用户请求，并根据处理结果向不同的表现层组件转发。 View(表现)层。此层由一系列的JSP页面、Velocity页面、PDF文档视图组件组成，负责手机用户请求，并显示处理结果。Java EE应用的组件总体而言，Java EE应用应该大致包括如下几类组件： 表现层组件。主要负责收集用户输入数据，或者想客户显示系统状态。最常用的表现层技术是JSP，但JSP并不是唯一的表现层技术。表现层还可以由Velocity、FreeMarker和Tapestry等技术完成，或者使用普通的应用程序充当表现层组件，甚至可以是小型智能设备。 控制器组件。关于Java EE的MVC框架，其提供了一个前端核心控制器，核心控制器负责拦截用户请求，并将请求转发给用户实现的控制器组件。这些用户实现的控制器组件则负责调用业务逻辑方法，处理用户请求。 业务逻辑组件。这是系统的核心组件，实现系统的业务逻辑。通常，一个业务逻辑方法对应一次用户操作。一个业务逻辑方法应该是一个整体，因此要求对业务逻辑方法增加事务性。业务逻辑方法仅仅实现也呜呜逻辑，不应该进行数据库访问。因此，业务逻辑组件中不应该出现原始的MyBatis、Hibernate和JDBC等API。最重要的原因是：保证业务逻辑方法的实现与具体的持久层访问技术分离。当系统需要在不同持久层技术之间切换时，系统的业务逻辑组件无序任何改变。 DAO组件。这个类型的对象比较缺乏变化，每个DAO组件都提供Domain Object对象基本的创建、查询、更新和删除等操作，这些操作对应于数据库的CRUD（创建、查询、更新和删除）等原子操作。当然，如果采用不同的持久层访问技术，DAO组件的会完全不同。为了实现业务逻辑组件的实现与DAO组件的实现分离，程序应该为每个DAO组件都提供接口，业务逻辑组件面向DAO接口编程，这样才能提供更好的解耦。 领域对象组件。领域对象（Doamin Object）抽象了系统的对象模型。通常而言，这些领域对象的状态都必须保存在数据库里。因此，每个领域对象通常对应一个或多个数据表，领域对象通常需要提供对数据记录的访问方式。 最流行的NoSQL – RedisNoSQL(Not Only SQL)存储的数据是半结构化的，Redis成为主要的NoSQL工具。 响应速度快。 支持6种数据类型：字符串、哈希结构、列表、集合、可排序集合和基数。比如字符串可以存储Java基础数据类型，哈希可以存储对象，列表可以存储List对象等。 操作都是原子的。 MultiUtility工具：Redis可以再如缓存、、消息传递队列中使用（Reids支持“发布+订阅”的消息模式），在应用程序如Web应用程序绘画、网站页面点击数等任何短暂的数据中使用。 SSM+Redis结构框图及概述在Java Web中，以Spring + Spring MVC + MyBatis（SSM）作为主流框架，SSM+Redis的结构框图如下： Spring IoC承担了一个资源管理、整合、即插即拔的功能。 Spring AOP可以提供切面管理，特别是书U哭事务管理的功能。 Spring MVC用于把模型、视图和控制器分层，组合成了一个有机灵活的系统。 MyBatis提供了一个数据库访问的持久层，通过MyBatis-Spring项目，它便能和Spring无缝对接。 Redis作为缓存工具，它提供了高速度处理数据和缓存数据的功能，使得系统大部分只需要访问缓存，而无须从数据库磁盘中重复读/写；在一些需要高速运算的场合中，也可以先用它来完成运算，再把数据批量存入数据库，这样便能极大地提升互联网系统的性能和响应能力。 在后面会讲解这些技术的使用方法、原理和优化方法。]]></content>
      <categories>
        <category>Java EE</category>
      </categories>
      <tags>
        <tag>Spring， Spring MVC， MyBatis， Redis</tag>
      </tags>
  </entry>
</search>
