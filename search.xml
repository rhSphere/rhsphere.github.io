<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[第一讲|先想后写——TCS三步构思法]]></title>
    <url>%2F2019%2F02%2F26%2Ftone-content-structure.html</url>
    <content type="text"><![CDATA[职场写作最忌讳打开电脑就写，请你先想再写。TCS法三个步骤完成构思过程，即tone、content和structure，对应基调、内容和结构。 基调为王，七种文案的标志性语气第一步，基调，文章以基调为“王”。基调对了，事半功倍；基调错了，哪怕你传递的信息再重要，我也不会关注。正确的基调能传递出文章真正的价值，也就是你的价值。职场写作可以分成四大类，那么每一类都需要传递你的什么价值呢？ 第一，总结类，写的是成绩，呈现的是你的潜力； 第二，调查报告类，写的是调查结果，呈现的是你求实的态度； 第三，申请类，内容是提问，呈现的是你主动的思考方式； 第四，计划类，写的是阶段任务，呈现的是你的责任感。 如果明白了要呈现自己什么价值，那你拿捏起文章的基调来，正确的概率就会很高。 以常见的六种具体文案为例，探讨一下它们的标志性的基调。 年终总结，基调要求：有深度不要写成一份业绩的流水账——因为你的工作结果，领导在看你的总结之前就知道。可他为什么还要看？他要读到你的分析能力；他希望你能从对工作感性的认知，上升到理性的规律性的总结；他需要你协助他，对未来做出更正确的决定。由此来看，年终总结不是回顾，而是行动指南。好的年终总结应该： 会将工作成果写出意义，会提供难得的一线经验、不同的视角； 会在罗列了贡献之后，找出问题或机遇，以及怎样解决这个问题，或抓住这个机遇。这就是“有深度”。 进展汇报，基调要求：不讨教在进展汇报里，不能只提问题，向领导讨教，而应该给出方案，向领导汇报。讨教的公式是：您告诉我该怎么做。汇报的公式是：我这样做，您同意吗？这里我想提醒你，哪怕领导没有要求你写进展汇报，你也要养成定期向他汇报的习惯。你需要将解决问题过程中的一些重要发现、关键结论、阶段性成果等小胜利，实时呈现给他，让他读出你的认真，让他看到你不断提高工作能力的过程。 调查报告，基调要求：实事求是在收集充分的事实资料后，你的措辞是“资料显示、数字表明”，而不是“我认为、我估计”。这种报告才能展现事情的真相，才会有让人惊喜的收获。 请示，基调要求：有主见有的人这么写： “客户投诉如下，请指示。”不管是找领导要人、要钱，或其他任何资源，一定要有清晰的主见。比如申请款项，你要给一个量化的标准让领导来裁决，不能模糊不清，让他无据可依、无处下手。让他做选择题的时候，你也需要提供最佳选项。另外，部门主管向上级递交请示的时候，不能采用传声筒的语气。不要写“他们抱怨”或“他们声称”，要写“我注意到” “我相信我的团队会……”，这才是有担当、有主见的语气。 批复，基调要求：态度明确不能出现这样的措辞：“似属可行” “酌情办理”。 项目计划，基调要求：“可交付”不能仅仅写行为。一个项目的成功，不是行动了就可以，而是众多可交付结果的总和。 比如：“选择外部供应商”，这是写行为，改为可交付的结果：“确定外部供应商”。 又比如：“草拟消费者调查报告”，这又是写行为，改为可交付结果：“递交消费者调查报告”。 这里我再和你多说一点。最好的项目计划书，是按照 OKR目标管理工具来写的。O：Objective 目标，KR：Key Results 关键结果。简单地说，计划就是由目标和关键结果构成。其中，大目标可以分解成小目标，关键结果是用来衡量这些目标有没有完成的。按照这个工具来写，你的基调自然就是可交付的结果。 以上就是构思的第一步——基调。 从“作者逻辑”切换到“读者逻辑”TCS的第二步，C：content，内容。你意识到了吗？我们在学校里的写作，读者是教授，他读你的文章的时候是有薪水拿的。在职场上的写作，可不是这样。职场上的读者，大多是“甲方读者”，比如领导、客户、重要合作伙伴，等等。也就是说，他们没有义务读完你的文章，他们可以随时终止阅读。怎么才能让这些甲方读者被你的内容吸引呢？请遵照这个原则： 先从“作者逻辑”切换到“读者逻辑”，提供“所有必需信息”，然后按照“要话先说”的顺序排列。也就是说， 你的文章每个部分都要对读者有价值。你写第一句话，是为了让他继续看第二句话；你写第二句话，是为了让他继续看第三句话。 举个例子，如果要写一份给投资人的商业计划书，俗称项目BP(Business Plan)。我们先做发散思维，想一想在初次接触时，投资人需要哪些信息来判断是否对项目有信心，是否愿意投资参与该项目？然后，为这些信息排序。我最担心你一上来就急着展示自己公司有多厉害，这是作者逻辑。没搭好台就展示自己，操之过急。相反，文章应该从分析整个行业下手，彰显市场空缺。搭建好舞台后，才有机会介绍自己。风险投资人也是要最大限度地规避风险的。而先选择行业，再选择个体，是他规避风险的方式，是读者逻辑。按照这个逻辑，文章怎样写呢？ 第一部分，写 “项目愿景”。 也就是，你要做一件什么样的大事。这部分需要有一句高度精炼的话，比如黄太吉的“打造以煎饼果子为核心的中式时尚快餐连锁品牌”。对方会问，这件事为什么值得做？于是你给出 “市场痛点”。比如，摩拜单车是为了解决最后一公里的交通痛点。如果投资人根本不认为这是个痛点，后面一切都白写了。再往下，是 “解决方案”。论证的是，我们正在做的这个事业，真正能解决得了这个痛点，这把钥匙能开得了这把锁。OK,读者表示认同。然后，他会想，“市场潜力”大吗？这时，你该展示市场调查结果了，包括市场规模、用户画像、竞品分析等等。那他会接着问，为什么要投你们，而不是别人呢？你要阐述自己的 “独特优势”。包括行业经验、核心技术、牛人团队，等等。OK, 这时读者对你有点儿感觉了。 下一部分，趁他对你有感觉的时候，拉着他一块儿画饼，你要写 “发展规划”了。写清楚盈利模式和发展路径。也许你觉得奇怪，为什么这个内容现在才写？其实投资人很有经验，他只要决定和你一块儿干，他会在后期帮你一起完善盈利模式，清晰发展路径。 最后，做 “财务分析”，告诉他，你们缺多少钱。为什么把融资额度放最后写呢？你想想看，有经验的销售想把东西卖给你的时候，通常不会一上来就报价的。他们都是把商品的价值点全部讲完以后，才把价格说出来，这个时候出现的数字，会让对方觉得是个合理的数字。至于 “退出机制” “利润分红”这些内容，在初次接触中并不重要，它们都有谈判的空间，所以可以不写。在“要话先说”的顺序下，文章环环相扣，你前一部分阐述得精彩，读者才有兴趣问下一个问题，了解下一个部分。 “向下想三层”，假设变结论进入构思的第三步，TCS的S，structure结构。在你的文章里，可以用向下想三层的逻辑搭建金字塔结构。金字塔的塔尖，是你鲜明的观点或建议，而下面两层，是证据。在这个金字塔里，塔尖，你鲜明的观点或建议，是 “投钱给我们吧”。读者自然会问：为什么？金字塔第二层，两方面：因为有市场，因为我们强。读者又问：有市场？——哪块市场？你们强？——强在哪里？金字塔进入第三层的阐述。这种顺序，让读者先读到塔尖，这样，不仅他能理解你更快，甚至认同你都更快。因为塔尖就像一个熠熠生辉的宝石，抢先占据了他的阅读记忆，也许他会惴惴不安，也许他会兴奋不已，于是，在他接下来的阅读中，他会自己有意无意地将下面的证据与塔尖做链接，这个被说服过程由他自己来完成了。这就是先想再写的TCS构思法。如果不这么做，文章可能会一点一点地偏离方向，最后主张模糊、脉络不明。而修改一份粗糙的文案，花费时间和力气更多。 压缩三分之一的文字写完以后，还有一个步骤，压缩，删掉三分之一的文字。相信我，你可以做得到。 商务写作谨遵KISS原则：keep it short and simple。 句中不能有多余的词，段落中不能有多余的句子。你可能会问我：文章到底是要简洁还是详实呢？文字表达要简洁，内容提供要详实。深度阐述和实例细节，会让文章更长，但不是冗长。 “用最少的字表达最多的意思”，这是我们追求的语言审美境界。可以用这三个方法来做到 “减无可减”： 把注水的文字压缩掉：“大概”、“一般来说”、“话说回来”，等等。 把“在我看来、我认为、我相信”之类的短语删掉，这是你写的文章，没有必要反复提醒读者这是你的观点。 把意思重复的句子压缩掉：相信读者是聪明人。 简洁的文字体现自律。 本讲小结第一讲要结束了。在这一讲中，你要养成先想再写，然后再删的写作习惯。写之前，做好TCS三步构思——基调、内容、结构。 第一步， 基调为王，用正确的基调传递出4类文案的真正价值；第二步， 内容，提供“所有必需信息”，从“作者逻辑”切换到“读者逻辑”，并要话先说；第三步， 结构，用向下想三层的金字塔结构，把你的假设，变成结论，用结论去说服他人。最后， 商务写作的KISS原则要求我们压缩文章，我教了你三个方法。]]></content>
      <categories>
        <category>得到</category>
      </categories>
      <tags>
        <tag>得到，职场写作，软技能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[得到|怎样提升你的职场写作能力]]></title>
    <url>%2F2019%2F02%2F24%2Fimprove-writing-skills-in-workplace.html</url>
    <content type="text"><![CDATA[本文源自得到课程《有效提升你的职场写作能力》。作者戴愫老师，一名跨文化研究者，也是一名企业培训师。本系列共6讲和1个小结，干货满满，由思路清晰，思维缜密的戴愫老师娓娓道来。前两讲是基础课。养成正确的写作习惯——先想再写，然后删。写之前要“想”，想什么呢？用TCS三步构思法——基调、内容、结构。在基础课里，你会学到，在看似人人都会写的邮件里，蕴藏着怎样的高级套路。第三讲和第四讲，教你怎样给文章组织结构。当需要写复杂的文案时，怎样用四大思维能力组织一个高价值的文章，并且怎样写第一段，让文章的价值最大化。最后两讲，带你润色语言，为文章锦上添花——如何写出有权威性，又有亲和力的措辞，也就是让语言有质感、有温度。版权归得到App所有，本文及相关内容仅供我个人总结和学习。 三类职场人士的困惑是什么？戴愫老师和很多学员做过深度交流，有三类职场人士： 第一类，职场小兵。他们专业技能强，需要简洁有力地从专业视角影响读者；他们经常需要写一些文章分享信息、阐述观点，比如项目进度报告、会议纪要、工作计划、可行性报告等。 第二类，职场老兵。他们需要通过写营运类报告，列出工作过程和结果，并把“成果”变成“功劳”，证明自己是未来的管理人才。 第三类，职场管理层。需要用高层的故事线来组织文章逻辑。比如说经常需要书写管理类报告，描述清楚商业逻辑，以便公司做出战略决策。 很多人有以下困惑： 因为工作太忙，需要快速成文的方法； 因为没有受过专门的商务写作的训练，分不清商务写作、文学写作、学术写作的清晰界线； 不知道如何从工作中收集一手资料，并从资料上构筑观点； 不知道如何以公司战略为风向标，提出自己的诉求，争取资源； 不知道怎样通过写作，把自己从“做事”的模式，调整为“做贡献”的心态； 写作时 容易用空洞的言辞，缺乏实质内容。 书面沟通到底是一项什么样的技能？书面沟通的形式是什么？单向，还是双向？书面沟通是一种单向沟通。你写，发给他，他读；或他写，发给你，你读。这是它最大的缺陷！没有一个正常成年人喜欢“被通知、被命令”，大家都喜欢“被商量、被探讨”。这意味着，我们作为作者，要通过“单向沟通的形式”，让读者读出“双向沟通的幻觉”。制造这种幻觉很重要。为什么？我们来看第二点。 判断一次沟通是不是100分，标准是什么？这个标准是：你明白我的意思了，或者我明白你的意思了？不，这只是60分的沟通。我们把这件事儿办成了？这是80分。为什么只是80分，如果说这件事情是办成了，但我以后再也不想与你合作了，这就是赢了这场战役，失去了整个战争嘛，不行的。那怎么做到100分呢？100分沟通的标准是，我和你理性、感性都达成一致了。注意，感性也要求达成一致。职场上永远不要以为把事情搞定有多么难，真正难搞定的是“人”。哪怕是个纯技术问题，也是“人”的作为和不作为。 达成一次100分沟通的基本前提是什么？是“信任”。 信任是超越一切沟通形式、一切沟通技巧最基础的前提。汉字的“信”，左边一个人，右边一个言，我们正常的顺序是，先相信这个人，再相信他说的话。这个顺序有可能放在每次书面沟通中吗？没可能。很多时候，你和读者没有见过面，哪怕你们见过面，他对你的人格也不一定了解。所以，我们需要学习：怎样在文章中大量使用信息化语言，在文字上与读者建立起信任，让他在不认识你，不熟知你的前提下，直接相信你写的话。 书面沟通这项技能的本质作为写作者的你要用大量的信息化语言，在文字上与读者建立起信任（这是基本前提），并且，让读者通过单向沟通的形式，读出双向沟通的幻觉（这可以通过写作内容和文字表达来实现），最后，双方理性、感性都达成一致（这是100分沟通的衡量标准）。 重复一遍，书面沟通这项技能本质上就是：作为写作者的你要用大量的信息化语言，在文字上与读者建立起信任，让读者通过单向沟通的形式，读出双向沟通的幻觉，最后双方理性、感性都达成一致。 学完这门课，你能学到那些？戴愫老师曾经用这门课，在线下教授了上万名职场人士，他们反馈： 不仅会写了，而且写得更快了； 这堂写作课还帮助他们重塑了个人品牌； 他们通过写作打开了工作思维，写作为他们赢得了信任和尊重，从而，他们在公司里承担了更多的责任，职场道路开阔了。 在写作时，有效表达只是最基本的层次，有效沟通才是终极目标。每一次写作，并不是自己做了一次信息传递，每一次写作，你都在为读者创造一次阅读体验。一篇好文章，不会让读者读完后困惑地问“so what”(所以呢?)，而是发出“wow”(diao a!)的赞叹。]]></content>
      <categories>
        <category>得到</category>
      </categories>
      <tags>
        <tag>得到，职场写作，软技能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[认识SSM框架和Redis]]></title>
    <url>%2F2018%2F10%2F26%2FSSM-framework-Redis.html</url>
    <content type="text"><![CDATA[文章对以下要点进行总结和归纳：1)了解Spring IoC和Spring AOP的基础概念；2)了解MyBatis的特点；3)了解Spring MVC的特点；4)了解为什么要使用NoSQL(Redis)及Redis的优点；5)掌握SSM和Redis的基本结构框图和各种技术的作用。 Spring框架Spring框架是Java应用最广的框架，它优秀的理念包括 IoC (Inversion of Control， 控制反转)和 AOP (Aspect Oriented Programming， 面向切面编程)。 Spring IoC简介Spring IoC（Inversion of Control，控制反转）承担了一个资源管理、整合、即插即拔的功能。举个例子，在Java中我们为国家插座设计两种接口，那我们就可以为两种插座分别new两个对象，但是如果要更改上千次这种插座，难道要new很多对象吗？所以不用new的方式创建对象，而是使用配置的方式，然后使用配置的方式，然后让Spring IoC容器自己通过配置去找到插座。不需要去找资源(Bean)，只要向Spring IoC容器描述所需资源，Spring IoC自己会找到你所需要的资源，这就是Spring IoC的理念。这样就把Bean之间的依赖关系解耦了，更容易写出结构清晰的程序。除此之外，Spring IoC还提供对Java Bean生命周期的管理，可以延迟加载，可以在其生命周期内定义一些行为等，更加有效地使用和管理Java资源。如果使用new的方式来使用插座，代码如下。使用插座11234User user = new User();Socket socket = new Socket1();user.setSocket(socket);user.useSocket(); 这样会有一个弊端，如果使用其他插座，就需要修改代码。可以使用配置的方式代替new的方式创建对象，让Spring IoC容器通过配置去找到插座。使用Spring IoC注入插座1个用户1234&lt;bean id="socket" class="Socket1" /&gt;&lt;bean id="user" class="xxx.User"&gt; &lt;spanroperty name="socket" ref="socket" /&gt;&lt;/bean&gt; 只需要修改XML配置文件，就可以切换：切换插座的实现类12345- &lt;bean id="socket" class="Socket1" /&gt;+ &lt;bean id="socket" class="Socket2" /&gt;&lt;bean id="user" class="xxx.User"&gt; &lt;spanroperty name="socket" ref="socket" /&gt;&lt;/bean&gt; 显然，IoC的目标就是为了管理Bean而存在的。 Spring AOPIoC的目标就是为了管理Bean，而Bean是Java面向对象(OOP)的基础设计，比如声明一个用户类、插座类等都是基于面向对象的概念。有些情况是面向对象没办法处理的。举个例子，生产部门的订单、生产部门、财务部门三者符合OOP的设计理念。订单发出，生产部门审批通过准备付款，但是财务部门发现订单的价格超支了，需要取消订单。 显然超支限定已经不只是影响财务部门了，还会影响生产部门之前所做的审批，需要把它们作废。把预算超支这个条件称为切面，它影响了订单、生产部门和财务部门3个OOP对象。在现实中，这样的切面条件跨越了3个甚至更多的对象，并且影响了它们的协作。所以只用OOP并不完善，还需要面向切面的编程，通过它去管理在切面上的某些对象之间的协作。Spring AOP常用于数据库事务的编程，很多情况都如同上而的例子，我们在做完第一步数据库数据更新后，不知道下一步是否会成功，如果下一步失收，会使用数据库事务的回滚功能去回滚事务，使得第一步的数据库更新也作废。在Spring AOP实现的数据库事务管理中，是以异常作为消息的。在默认的情况下(可以通过Spring的配置修改)，只要Spring接收到了异常信息，它就会将数据库的事务回滚，从而保证数据的一致性。这样我们就知道在Spring的事务管理中只要让它接收到异常信息，它就会回滚事务，而不需要通过代码来实现这个过程。比如上面的例子，可用一段伪代码来进行一些必要的说明。Spring AOP处理订单伪代码12345678910private void proceed(Order order) &#123; //判断生产部门是否通过订单，数据库记录订单 boolean pflag = productionDept.isPass(order); if(pflag) &#123;//如果生产部门通过进行财务部门审批 if (financialDept.isOverBudget(order)) &#123;//财务审批是否超限 //抛出异常回滚事务，之前的订单操作也会被回滚 throw new RuntimeException("预算超限！！"); &#125; &#125;&#125; Spring AOP的编程屏蔽了数据库代码，只需关注业务代码，知道只要发生了一场异常，Spring会回滚事务就足够了。 MyBatis简介MyBatis的前身是Apache的开源项目iBatis，是一个基于 Java的持久层框架。2010年这个项目由Apache software foundation迁移到Google code，并更名为MyBatis。2013年11月，MyBatis迁移到GitHub上，目前由GitHub提供维护。MyBatis的优势在于灵活，它几乎可以代替JDBC，同时提供了接口编程。目前MyBatis的数据访问层 DAO(Data Access Objects)是不需要实现类的，它只需要一个接口和XML(或者注解)。MyBatis提供自动映射、动态SQL、级联、缓存、注解、代码和SQL分离等特性，使用方便，同时也可以对SQL进行优化。因为其具有封装少、映射多样化、支持存储过程、可以进行SQL优化等特点，使得它取代了Hibernate成为了Java互联网中首选的持久框架。Hibernate作为一种十分流行的框架，它有其无可替代的优势，这里我们有必要讨论一下它和MyBatis的区别。由于MyBatis和Hibernate都是持久层框架，都会涉及数据库，所以首先定义一个数据库表一角色表(t_role)。角色表的sql语句12345create table t_role( 编号 int(12) primary key， 角色名称 varchar(60)， 备注 varchar(1024)); 用一个POJO(Plain Ordinary Java Object)和这张表定义的字段对应起来。定义角色POJO123456789package com.learn.chapter1.pojo;public class Role implements java.io.Serializable &#123; private Integer id; private String roleName; private String note; /** * setter and getter **/&#125; 无论是MyBatis还是Hibernate都是依靠某种方法，将数据库的表和POJO映射起来的，这样就可以操作POJO来完成相关的逻辑了。 Hibernate简介映射规则 语言 映射方法 MyBatis 使用注解方式会受到一定的限制，通常使用XML方式实现映射关系 Hibernate XML和注解提供映射规则 把POJO对象和数据库表相互映射的框架称为对象关系映射(Object Relational Mapping，ORM，或O/RM，或O/R mapping)框架。Hibernate的设计理念是完全面向POJO的，不需要编写SQL就可以通过映射关系来操作数据库，是一种全表映射的体现；MyBatis需要提供SQL去运行。Hibernate映射文件12345678910111213141516171819&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN" "http://www.hibernate.rg/dtd/hibernate-mapping-3.0.dtd"&gt;&lt;hibernate-mapping&gt; &lt;class name="com.learn.chapter1.pojo.Role" tbale="t_role"&gt; &lt;id name="id" type="java.lang.Integer"&gt; &lt;column name="id" /&gt; &lt;generator class="identity" /&gt; &lt;/id&gt; &lt;spanroperty name="roleName" type="string"&gt; &lt;column name="role_name" length="60" not-null="true" /&gt; &lt;/property&gt; &lt;spanroperty name="note" type="string"&gt; &lt;column name="note" length="512" /&gt; &lt;/property&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 首先，对POJO和表t_role进行了映射配置，把两者映射起来了。然后，对POJO进行操作，从而影响t_role表的数据，比如对其增删改查可以按照如下操作。Hibernate通过Session操作数据库数据123456789101112131415161718192021222324252627282930Session session = null;Transaction tx = null; try &#123; //打开Session session = HibernateUtil.getSessionFactory().openSession(); //事务 tx = session.beginTransaction(); //POJO Role role = new Role(); role.setId(1); role.setRoleName("rolename1"); role.setNote("note1"); //保存 Role role2 = (Role) session.get(Role.class， 1); //查询 role2.setNote("修改备注"); session.update(role2); //更新 System.err.println(role2.getRoleName()); session.delete(role2); //删除 tx.commit(); //提交事务&#125; catch (Exception ex) &#123; if (tx != null &amp;&amp; tx.isActive()) &#123; tx.rollback(); //回滚事务 &#125; ex.printStackTrace();&#125; finally &#123; if (session != null &amp;&amp; session.isOpen()) &#123; session.close(); &#125;&#125; 这里没有SQL，因为Hibernate会根据映射关系来生成对应的SQL。 MyBatis可以自己拟定SQL规则，能精确定义SQL，从而符合移动互联网高并发、大数据、高性能、高响应的需求。MyBatis也需要映射文件把POJO和数据库的表对应起来。MyBatis映射文件1234567891011121314151617181920212223242526272829&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.learn.chapter1.mapper.RoleMapper"&gt; &lt;resultMap id="roleMap" type="com.learn.chaper1.pojo.Role"&gt; &lt;id property="id" column="id" /&gt; &lt;result property="roleName" column="role_name" /&gt; &lt;result property="note" column="note" /&gt; &lt;/resultMap&gt; &lt;select id="getRole" resultMap="roleMap"&gt; select id， role_name， note from t_rle where id = #&#123;id&#125; &lt;/select&gt; &lt;delete id="deleteRole" parameterType="int"&gt; delete from t_role where id = #&#123;id&#125; &lt;/delete&gt; &lt;insert id="insertRole" parameterType="com.learn.chapter1.pojo.Role"&gt; insert into t_role(role_name， note) values(#&#123;roleName&#125;， #&#123;note&#125;) &lt;/insert&gt; &lt;update id="updateRole" parameterType="com.learn.chapter1.pojo.Role"&gt; update t_role set role_name = #&#123;roleName&#125;， note = #&#123;note&#125; where id = #&#123;id&#125; &lt;/update&gt; &lt;/mapper&gt; 这里的resultMap元素用于定义映射规则，而实际上MyBatis在满足一定的规则下，完成自动映射，而增删改查对应着insert、delete、select、update四个元素。mapper元素中的namespace属性，要和一个接口的全限定名保持一致，而里面的SQL的id也需要和接口定义的方法完全保持一致，定义MyBatis映射文件。定义MyBatis映射文件123456789package com.learn.chapter1.mapper;import com.learn.chapter1.pojo.Role;public interface RoleMapper &#123; public Role getRole(Integer id); public int deleteRole(Integer id); public int insertROle(Role role); public int updateROle(Role role);&#125; 定义了MyBatis映射文件，不需要定义一个实现类。显然MyBatis在业务逻辑上和Hibernate是大同小异的。其区别在于，MyBatis需要提供接口和SQL，这意味着工作量会比较大，但是由于自定义SQL、映射关系，所以灵活性、可优化性超过了Hibernate。互联网可优化性、灵活性是十分重要的，因为一条SQL的性能可能相差十几倍到几十倍。 Hibernate和MyBatis的区别Hibernate和MyBatis的增、删、改、查，对于业务逻辑层来说大同小异，对于映射层而言Hibernate的配置不需要接口和SQL，相反MyBatis是需要的。对于Hibernate而言，不需要编写大量的SQL，就可以完全映射，同时提供了日志、缓存、级联(级联比MyBatis强大)等特性，此外还提供HQL( Hibernate Query Language)对POJO进行操作，使用十分方便，但是它也有致命的缺陷。由于无须SQL，当多表关联超过3个的时候，通过Hibernate的级联会造成太多性能的丢失，又或者我现在访问一个财务的表，然后它会关联财产信息表，财产又分为机械、原料等，显然机械和原料的字段是不一样的，这样关联字段只能根据特定的条件变化而变化而Hibernate无法支持这样的变化。遇到存储过程，Hibernate只能作罢。更为关键的是性能，在管理系统的时代，对于性能的要求不是那么苛刻，但是在互联网时代性能就是系统的根本，响应过慢就会丧失客户，试想一下谁会去用一个经常需要等待超过10秒以上的应用呢?以上的问题MyBatis都可以解决，MyBatis可以自由书写SQL、支持动态SQL、处理列表、动态生成表名、支持存储过程。这样就可以灵活地定义查询语句，满足各类需求和性能优化的需要，这些在互联网系统中是十分重要的。但MyBatis也有缺陷。首先，它要编写SQL和映射规则，其工作量稍微大于Hibernate。 其次，它支持的工具也很有限，不能像Hibernate那样有许多的插件可以帮助生成映射代码和关联关系，而即使使用生成工具，往往也需要开发者进一步简化，MyBatis通过手工编码，工作量相对大些。所以对于性能要求不太苛刻的系统，比如管理系统、ERP等推荐使用Hibernate;而对于性能要求高、响应快、灵活的系统则推荐使用MyBatis。 Spring MVC简介也许你还在问为什么使用Spring MVC，Struts 2.x不才是主流吗？看SSH的概念多火!其实很多初学者都混淆了一个概念，SSH时间上指的是Struts 1.x + Spring + Hibernate，这个概念已经有十几年的历史了。在Structs 1.x的时代，Structs1.x是当之无愧的MVC框架的霸主，但是在新的MVC框架涌现的时代，形式已经完全不是这样的了，Structs 2.x借助了Structs 1.x的好名声，让国内开发者认为Structs 2.x是霸主继任者（其实两者在技术上没有任何关系），导致国内的很多程序员大多数学习基于Structs 2.x的框架，有一个貌似很火的概念出来了S2SH(Struts 2.x + Spring + Hibernate)整合开发。根据JRebel厂商统计，Spring MVC的市场占有率是40%，而Structs 2.x只有可怜的6%。Spring MVC是目前Java Web框架当之无愧的霸主。Spring MVC和三层架构是什么关系，可能很多读者会抢答：MVC：Model + View + Controller (数据模型+视图+控制器)三层架构：Prensentation tier + Application tier + Data tier（展现层+应用层+数据访问层）那MVC和三层架构有什么关系呢？但是实际上MVC只存在三层架构的展现层，M实际上是数据模型，是包含数据的对象。在Spring MVC里，有一个专门的类叫Model，用来和V之间的数据交互、传值；V指的是视图页面，包含JSP、freeMarker、Velocity、Thymeleaf、Tile等；C当然就是控制器（Spring MVC的注解@Controller的类）。而三层架构是整个应用的架构，是由Spring框架负责管理的。一般项目中会有Service层、DAO层，这两个反馈在应用层和数据访问层。 Java EE应用的分层模型经典的Java EE架构大致上都可以分为如下几层： Domain Object(领域对象)层。此层有一系列的POJO(Plain Object Java Object，普通的传统的Java对象)组成，这些对象是该系统的Domain Object(领域对象)，往往包含了各自所需实现的业务逻辑方法。 DAO(Data Access Object，数据访问对象)层。此层由一系列的DAO组件组成，这些DAO实现了对数据库的创建、查询、更新和删除（CRUD）等原子操作。 Service(业务逻辑)层。此层由一系列的业务逻辑对象组成，这些业务逻辑对象实现了系统所需的业务逻辑方法。这些业务逻辑方法可能仅仅用于暴露Domain Object对象所实现的业务逻辑方法，也可能是依赖DAO组件实现的业务逻辑方法。 Controller(控制器)层。此层由一系列控制器组成，这些控制器用于拦截用户请求，并调用业务逻辑组件的业务逻辑方法，处理用户请求，并根据处理结果向不同的表现层组件转发。 View(表现)层。此层由一系列的JSP页面、Velocity页面、PDF文档视图组件组成，负责手机用户请求，并显示处理结果。Java EE应用的组件总体而言，Java EE应用应该大致包括如下几类组件： 表现层组件。主要负责收集用户输入数据，或者想客户显示系统状态。最常用的表现层技术是JSP，但JSP并不是唯一的表现层技术。表现层还可以由Velocity、FreeMarker和Tapestry等技术完成，或者使用普通的应用程序充当表现层组件，甚至可以是小型智能设备。 控制器组件。关于Java EE的MVC框架，其提供了一个前端核心控制器，核心控制器负责拦截用户请求，并将请求转发给用户实现的控制器组件。这些用户实现的控制器组件则负责调用业务逻辑方法，处理用户请求。 业务逻辑组件。这是系统的核心组件，实现系统的业务逻辑。通常，一个业务逻辑方法对应一次用户操作。一个业务逻辑方法应该是一个整体，因此要求对业务逻辑方法增加事务性。业务逻辑方法仅仅实现也呜呜逻辑，不应该进行数据库访问。因此，业务逻辑组件中不应该出现原始的MyBatis、Hibernate和JDBC等API。最重要的原因是：保证业务逻辑方法的实现与具体的持久层访问技术分离。当系统需要在不同持久层技术之间切换时，系统的业务逻辑组件无序任何改变。 DAO组件。这个类型的对象比较缺乏变化，每个DAO组件都提供Domain Object对象基本的创建、查询、更新和删除等操作，这些操作对应于数据库的CRUD（创建、查询、更新和删除）等原子操作。当然，如果采用不同的持久层访问技术，DAO组件的会完全不同。为了实现业务逻辑组件的实现与DAO组件的实现分离，程序应该为每个DAO组件都提供接口，业务逻辑组件面向DAO接口编程，这样才能提供更好的解耦。 领域对象组件。领域对象（Doamin Object）抽象了系统的对象模型。通常而言，这些领域对象的状态都必须保存在数据库里。因此，每个领域对象通常对应一个或多个数据表，领域对象通常需要提供对数据记录的访问方式。 最流行的NoSQL – RedisNoSQL(Not Only SQL)存储的数据是半结构化的，Redis成为主要的NoSQL工具。 响应速度快。 支持6种数据类型：字符串、哈希结构、列表、集合、可排序集合和基数。比如字符串可以存储Java基础数据类型，哈希可以存储对象，列表可以存储List对象等。 操作都是原子的。 MultiUtility工具：Redis可以再如缓存、、消息传递队列中使用（Reids支持“发布+订阅”的消息模式），在应用程序如Web应用程序绘画、网站页面点击数等任何短暂的数据中使用。 SSM+Redis结构框图及概述在Java Web中，以Spring + Spring MVC + MyBatis（SSM）作为主流框架，SSM+Redis的结构框图如下： Spring IoC承担了一个资源管理、整合、即插即拔的功能。 Spring AOP可以提供切面管理，特别是书U哭事务管理的功能。 Spring MVC用于把模型、视图和控制器分层，组合成了一个有机灵活的系统。 MyBatis提供了一个数据库访问的持久层，通过MyBatis-Spring项目，它便能和Spring无缝对接。 Redis作为缓存工具，它提供了高速度处理数据和缓存数据的功能，使得系统大部分只需要访问缓存，而无须从数据库磁盘中重复读/写；在一些需要高速运算的场合中，也可以先用它来完成运算，再把数据批量存入数据库，这样便能极大地提升互联网系统的性能和响应能力。 在后面会讲解这些技术的使用方法、原理和优化方法。]]></content>
      <categories>
        <category>Java EE</category>
      </categories>
      <tags>
        <tag>Spring， Spring MVC， MyBatis， Redis</tag>
      </tags>
  </entry>
</search>
