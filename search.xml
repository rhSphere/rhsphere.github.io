<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JavaScript]]></title>
    <url>%2Fweb%E5%89%8D%E7%AB%AF%2F2019%2F01%2F14%2FJavaScript.html</url>
    <content type="text"><![CDATA[JavaScript 是面向对象的语言，但 JavaScript 不使用类。 在 JavaScript 中，不会创建类，也不会通过类来创建对象（就像在其他面向对象的语言中那样）。 JavaScript 基于 prototype，而不是基于类的。 1234567891011'use strict' //声明变量varES6 支持反引号 ``多行字符串&lt;script src="/static/js/abc.js" type="javascript"&gt;&lt;/script如果有很多变量需要连接，用+号就比较麻烦。ES6新增了一种模板字符串，表示方法和上面的多行字符串一样，但是它会自动替换字符串中的变量：var name = '小明';var age = 20;var message = `你好, $&#123;name&#125;, 你今年$&#123;age&#125;岁了!`;alert(message); 单双引号均可 但是JavaScript的对象有个小问题，就是键必须是字符串。但实际上Number或者其他数据类型作为键也是非常合理的。 为了解决这个问题，最新的ES6规范引入了新的数据类型Map Set和Map类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在Set中，没有重复的key。 遍历Array可以采用下标循环，遍历Map和Set就无法使用下标。为了统一集合类型，ES6标准引入了新的iterable类型，Array、Map和Set都属于iterable类型。 具有iterable类型的集合可以通过新的for … of循环来遍历。 for … of循环是ES6引入的新的语法，请测试你的浏览器是否支持 此时abs(x)函数的参数x将收到undefined，计算结果为NaN。 要避免收到undefined，可以对参数进行检查：12345function foo(a, b, ...rest) &#123; console.log('a = ' + a); console.log('b = ' + b); console.log(rest);&#125; 解构赋值变量提升JavaScript的函数定义有个特点，它会先扫描整个函数体的语句，把所有申明的变量“提升”到函数顶部：为了解决块级作用域，ES6引入了新的关键字let，用let替代var可以申明一个块级作用域的变量： 在一个对象中绑定函数，称为这个对象的方法。在一个方法内部，this是一个特殊变量，它始终指向当前对象，也就是xiaoming这个变量。所以，this.birth可以拿到xiaoming的birth属性。 12345678910111213function getAge() &#123; var y = new Date().getFullYear(); return y - this.birth;&#125;var xiaoming = &#123; name: '小明', birth: 1990, age: getAge&#125;;xiaoming.age(); // 25, 正常结果getAge(); // NaN 单独调用函数getAge()怎么返回了NaN？请注意，我们已经进入到了JavaScript的一个大坑里。 JavaScript的函数内部如果调用了this，那么这个this到底指向谁？ 答案是，视情况而定！ 如果以对象的方法形式调用，比如xiaoming.age()，该函数的this指向被调用的对象，也就是xiaoming，这是符合我们预期的。 如果单独调用函数，比如getAge()，此时，该函数的this指向全局对象，也就是window。 坑爹啊！ 虽然在一个独立的函数调用中，根据是否是strict模式，this指向undefined或window，不过，我们还是可以控制this的指向的！ 要指定函数的this指向哪个对象，可以用函数本身的apply方法，它接收两个参数，第一个参数就是需要绑定的this变量，第二个参数是Array，表示函数本身的参数。 用apply修复getAge()调用： 另一个与apply()类似的方法是call()，唯一区别是： apply()把参数打包成Array再传入； call()把参数按顺序传入。 比如调用Math.max(3, 5, 4)，分别用apply()和call()实现如下： 返回闭包时牢记的一点就是：返回函数不要引用任何循环变量，或者后续会发生变化的变量。如果一定要引用循环变量怎么办？方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变：注意这里用了一个“创建一个匿名函数并立刻执行”的语法： 123(function (x) &#123; return x * x;&#125;)(3); // 9 理论上讲，创建一个匿名函数并立刻执行可以这么写：1function (x) &#123; return x * x &#125; (3); 但是由于JavaScript语法解析的问题，会报SyntaxError错误，因此需要用括号把整个函数定义括起来1(function (x) &#123; return x * x &#125;) (3); 通常，一个立即执行的匿名函数可以把函数体拆开，一般这么写：123(function (x) &#123; return x * x;&#125;)(3); 说了这么多，难道闭包就是为了返回一个函数然后延迟执行吗？ 当然不是！闭包有非常强大的功能。举个栗子： 在面向对象的程序设计语言里，比如Java和C++，要在对象内部封装一个私有变量，可以用private修饰一个成员变量。 在没有class机制，只有函数的语言里，借助闭包，同样可以封装一个私有变量。我们用JavaScript创建一个计数器： generator还有另一个巨大的好处，就是把异步回调代码变成“同步”代码。这个好处要等到后面学了AJAX以后才能体会到。 没有generator之前的黑暗时代，用AJAX时需要这么写代码： 总结一下，有这么几条规则需要遵守： 不要使用new Number()、new Boolean()、new String()创建包装对象； 用parseInt()或parseFloat()来转换任意类型到number； 用String()来转换任意类型到string，或者直接调用某个对象的toString()方法； 通常不必把任意类型转换为boolean再判断，因为可以直接写if (myVar) {…}； typeof操作符可以判断出number、boolean、string、function和undefined； 判断Array要使用Array.isArray(arr)； 判断null请使用myVar === null； 判断某个全局变量是否存在用typeof window.myVar === ‘undefined’； 函数内部判断某个变量是否存在用typeof myVar === ‘undefined’。 最后有细心的同学指出，任何对象都有toString()方法吗？null和undefined就没有！确实如此，这两个特殊值要除外，虽然null还伪装成了object类型。 var ajax = ajaxGet(‘http://…’);ajax.ifSuccess(success) .ifFail(fail); 这种链式写法的好处在于，先统一执行AJAX逻辑，不关心如何处理结果，然后，根据结果是成功还是失败，在将来的某个时候调用success函数或fail函数。 古人云：“君子一诺千金”，这种“承诺将来会执行”的对象在JavaScript中称为Promise对象。 window.setInterval(“javascript function”,milliseconds); myVar= window.setTimeout(“javascript function”, milliseconds);]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F%E6%9D%82%E8%B0%88%2F2019%2F01%2F14%2Fhello-world.html</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL学习笔记]]></title>
    <url>%2FMySQL%2F2019%2F01%2F14%2FSQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</url>
    <content type="text"><![CDATA[#SQL语句基础Structured Query Language操作和检索关系型数据库的标准语言，标准的SQL语句可以用于操作任何关系数据库。一般程序员负责： 在数据库中检索信息 对数据库的信息进行更新 改变数据库的结构DBA负责： 更改系统的安全设置 增加或回收用户对数据库、表的许可权限 行：表中的一个记录 有时也被称为记录主键：一列或者一组列，其值能够唯一标识表中的每一行。便于更新和删除特定的行。 ##SQL语句类型 查询语句:主要是由select关键字完成，查询语句是SQL语句中最复杂、功能最丰富的语句 DML（Data Manipulation L, 数据操作语言）语句：主要有insert、update和delete三个关键字完成 DDL（Data Defination L，数据定义语言）语句：主要由create、alter、drop和truncate四个关键字完成 DCL（Data Control L, 数据控制语言）语句：主要由grant和revoke两个关键字完成 为数据库用户授权，或者访问指定用户的权限 事务控制语句：主要有commit、rollback和savepoint三个关键字完成 ##DDL语句 创建表 12345678910111213141516create table [SchemaName.]tableName( columnName datatype [default expr]);create table test ( test_id int, test_price decimal, test_name varchar(255) default 'xxx', test_desc text, test_img blob, test_date datetime);create table thesame as select * from user_inf;#选中和user_inf完全相同的字段和数据建表 修改表 1234567891011121314151617181920212223242526#增加列定义alter table tableNameadd( column_name datatype [default expr],);alter table hehe add hehe_id int;alter table hehe add( aaa varchar(255) default 'xxx', bbb varchar(255) );#修改列定义alter table hehemodify hehe_id varchar(255);#同时修改列名alter table hehechange hehe_id abc int;#将表重命名alter table heherename to wawa;#修改列名alter table TABLENAME change old_ColNAME new_ColNAME char(int ect..); 删除表 1drop table wawa; ##数据库约束 5种完整性约束 NOT NULL:非空约束，指定某列不能为空 UNIQUE:唯一约束，制定某列或某几列不能重复 PRIMARY KEY:主键，指定该列的值可以唯一地标识该记录 FOREIGN KEY:外键，指定该行记录从属于主表中的一条记录，主要用于保证参照完整性 CHECK: 约束分类 单列约束 多列约束-指定约束的两个时机 建表的同时为相应的数据制定约束 以修改表的方式来增加约束 NOT NULL约束 123456789101112131415create table hehe( id int not null, name varchar(255) defalut 'ldp' not null, gender varchar(2) null );alter table hehemodify gender varchar(2) not null;alter table hehemodify name varchar(2) null;alter table hehemodify name varchar(255) default 'abc' null; UNIQUE约束保证指定列或者指定列组合不允许出现重复值 123456789101112131415161718192021222324252627#列级约束语法建立约束，create table unique_test( id int not null, name varchar(255) unique );create table test( id int not null, name varchar(255). pass varchar(255), unique （name)， constraint uk unique(pass));create table test1( id not null, name varchar(255), pass varchar(255), constraint uk1 unique(name, pass));alter table test1 drop index uk1;alter table test1 add unique(name, pass);alter table test1 modify name varchar(255) unique; PRIMARY KEY约束主键约束相当于非空约束和唯一约束，即主键约束的列即不允许出现重复值，也不允许出现null值；如果对多列组合建立主键约束，则多列里包含的每一列都不能为空，但只要求这些列组合不能重复。主键列的值用于唯一标识表中的一条记录。建表时使用列级约束 12345create table primary_test( id int primary key, name varchar(255)); 建表时创建主键约束，使用表级约束法12345678create table primary_test1( id int not null, name varchar(255), pass varchar(255), #对于MySQL而言，test1_pk主键约束名无效，PRIMARY是主键约束名 constraint test1_pk primary key(id) ); 建表时以多列建立组合主键，使用表级约束1234567891011121314create table primary_test2( name varchar(255), pass varchar(255));alter table primary_test2drop primary key;alter table primary_test2add primary key(name, pass);alter table primary_test2modify name varchar(255) primary key; 建立自增长的主键约束123456create table primary_test3( id int auto_increment primary key, name varchar(255), pass varchar(255))； FOREIGEN KEY约束MySQL会为该外键约束命名为tableName_ibfk_n从表的外键参照的只能是主表的主键列或者唯一键列。主表记录不允许被删除。外键约束通常用于定义两个实体之间的一对多、一对一的关联关系。对于一对多的关联关系，通常再多的一端增加外键列；一对一的关联关系，选择任意一方来增加外键列，被增加外键列的表被称为从表；对于多对多的关联关系，需要额外增加一个连接表来记录他们的关联关系。列级约束法建立外键约束直接使用references关键字1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#列级约束法create table teacher_table( teacher_id int auto_increment, teacher_name varchar(255), primary key(teacher_id));create table student_table( student_id int auto_increment primary key, student_name varchar(255), java_teacher int references teacher_table(teacher_id));#表级约束法create table teacher_table1( teacher_id int auto_increment, teacher_name varchar(255), primary key(teacher_id));create table student_table1( student_id int auto_increment primary key, student_name varchar(255), java_teacher int， foreign key(java_teacher) references teacher_table1(teacher_id));#表级约束法,显示指定外键约束的名字create table teacher_table2( teacher_id int auto_increment, teacher_name varchar(255), primary key(teacher_id));create table student_table2( student_id int auto_increment primary key, student_name varchar(255), java_teacher int， constraint student_teacher_fk foreign key(java_teacher) references teacher_table2(teacher_id));#多列组合的外键约束，则必须使用表级约束法create table teacher_table3( teacher_name varchar(255), teacher_pass varchar(255) primary key(teacher_name, teacher_pass));create table student_table3( student_id int auto_increment primary key, student_name varchar(255), java_teacher_name varchar(255)， java_teacher_pass varchar(255), foreign key(java_teache_name, java_teacher_pass) references teacher_table3(teacher_name, teacher_pass));#删除alter table student_table3drop foreign key student_table3_ibfk_1;#修改alter table student_table3add foreign key(java_teacher_name, java_teacher_pass) references teacher_table3(teacher_name, teacher_pass); 自关联1234567create table foreign_test( foreign_id int auto_increment primary key, foreign_name varchar(255), refer_id int, foreign key(refer_id) references foreign_test(foreign_id)); 级联删除、或者从表都设置为null123456789101112131415create table teacher_table4( teacher_id int auto_increment, teacher_name varchar(255), primary key(teacher_id));create table student_table4( student_id int auto_increment primary key, student_name varchar(255), java_teacher int, foreign key(java_teacher) references teacher_table4(teacher_id) on delete cascade #或者用on delete set null); 索引创建方式： 定义主键约束、唯一约束、和外键约束是，系统自动创建索引 手动删除方式： 数据表被删除时，自动 手动 1234567891011create index index_name on tableName (colum[, column]...);create index emp_last_name_idxon emplees(last_name);create index emp_last_name_idx1on emplees(first_name, last_name);drop index emp_last)name_idx2on emplees;show index from tableName; ##DML完成三个任务： 插入新数据 修改已有数据 删除不需要的数据 insert into语句插入语句，每次只能插入一条记录 1234insert into tableName(column) values(value);insert into student_table2(student_name)select techer_name from tescher_table2; update 语句修改多条记录 12update table_name set column1 = value[, column2 = value2]where condition; delete from语句整行的删除 12delete from tableNamewhere teacher_id &gt; 2; ##表单查询*表示所有列12345678910select * from teacher_table;select student_name from student_tablewhere java_teacher &gt; 3;select teacher_id + 5 from teacher_table;select * from teacher_tablewhere teacher_id * 3 &gt; 4; select 需要指明选择什么，以及在哪里选择数据格式是表示问题，而不是检索问题检索不同的值 select distinct id from tableNmae;检索前五个select prod_name from Products limit 5 offset 5;捷径select prod_name from Products limit 5, 5; 排序select prod_name from Productsorder by prod_name;多列排序select prod_id, prod_price, prod_namefrom Productsorder by prod_price, prod_name;按列位置排序select prod_id, prod_price, prod_namefrom Productsorder by 2, 3; 降序排序select prod_id, prod_price, prod_namefrom Productsorder by prod_price desc; 多列降序排序：必须对每一个列指定desc关键字select prod_id, prod_price, prod_namefrom Productsorder by prod_price desc, prod_name; 过滤数据只检索所需数据需要指定搜索条件（search criteria),搜索条件也叫过滤条件（filter condition)select prod_name, prod_pricefrom Productswhere prod_price = 3.49; 同时使用order by和where时，应该让order by在where后面 select prod_name, prod_price from Productswhere prod_price &lt; 10; select vend_id, prod_name from Productswhere vend_id &lt;&gt; ‘DLL01’; select prod_name, prod_price from Productswhere prod_price between 5 and 10; select prod_name from Products where prod_price is null; select cust_name from Customers where cust_email is null; 组合where子句 and操作符select prod_id, prod_price, prod_namefrom Productswhere vend_id = ‘DLL01’ and prod_price &lt;= 4; orselect prod_name, prod_price from Productswhere vend_id = ‘DLL01’ or vend_id = ‘BRS01’; and的优先级比or更高，使用圆括号分组select prod_name, prod_price from Productswhere (vend_id = ‘DLL01’ or vend_id = ‘BRS01’) and prod_price &gt;= 10; in有很多合法选项时，in更加清楚、直观select prod_name, prod_pricefrom Productswhere vend_id in (‘DLL01’, ‘BRS01’)order by prod_price; notnot否定in、between、exists子句select prod_name from Productswhere not vend_id = ‘DLL01’order by prod_name desc; ##通配符过滤 likeselect prod_id, prod_namefrom Productswhere prod_name like ‘Fish%’; select prod_id, prod_name from Productswhere prod_name like ‘%bean bag%’; select prod_id, prod_namefrom Productswhere prod_name like ‘__ inch teddy bear’; %字符匹配多个字符，_只匹配一个字符 select cust_contact from Customerswhere cust_contact like ‘J%’order by cust_contact; select cust_contact from Customerswhere cust_contact like ‘[^JM]%’order by cust_contact; select concat(vend_name, vend_country) from vendorsorder by vend_name;select concat(rtrim(vend_name), rtrim(vend_country))from vendors order by vend_name; select concat(vend_name, vend_country) as vend_titlefrom Vendors order by vend_name; select concat(vend_name, ‘( ‘, vend_country, ‘)’)as vend_title from Vendors order by vend_name;123select prod_id, quantity, item_price, quantity*item_price as expanded_pricefrom OrderItemswhere order_num = 20008; select order_num from Orders where year(order_date) = 2012; ##汇总数据select avg(prod_price) as avg_price from Products;select avg(prod_price) as avg_pricefrom Productswhere vend_id = ‘DLL01’; count()函数 确定行中的数目或符合特定条件的行的数目。1select count(*) as num_cust from Customers; select count(cust_email) as num_cust from Customers; select sum(quantity) as items_ordered from OrderItemswhere order_num = 20005; 12select sum(quantity*item_price) as total_price from OrderItemswhere order_num = 20005; select sum(quantity) as items_ordered from OrderItemswhere order_num = 20005; select avg(distinct prod_price) as avg_price from Products where vend_id = ‘DLL01’; 123select vend_id, count(*) as num_prods from productsgroup by vend_idhaving count(*) &gt;= 3; where过滤行，having过滤分组 12345678select cust_id, count(*) as order from Ordersgroup by cust_idhaving count(*) &gt;= 2;select cust_id, count(*) as ordersfrom Ordersgroup by cust_idhaving count(*) &gt; 1; where在分组前行过滤，having在分组后 12345678910select vend_id, count(*) as num_prodsfrom Productswhere prod_price &gt;= 4group by vend_idhaving count(*) &gt;= 2;select vend_id, count(*) as num_prodsfrom Productsgroup by vend_idhaving count(*) &gt;= 2; order by group by 对产生的输出排序 对行分组，但输出可能不是分组的排序，只可能使用选择列或者表达式列 12345678select order_num, count(*) as items from OrderItemsgroup by order_numhaving count(*) &gt;= 3;select order_num, count(*) as items from OrderItemsgroup by order_numhaving count(*) &gt;= 3order by items, order_num; ##子查询查询（query）一般指的是select语句子查询（subquery)嵌套的查询,总是从内向外嵌套 1234#查询订单号select order_num from OrderItems where prod_id ='RGAN01';select cust_id from Orders where order_num in(select order_num from OrderItems where prod_id ='RGAN01'); 避免硬编码顾客id，使用子查询12345select cust_name, cust_contact from Customers where cust_id in (select cust_id from Orders where order_num in (select order_num from OrderItems where prod_id = 'RGAN01')); 作为子查询的select语句只能查询单个列使用子查询并不总是执行这类数据检索的最有效方法。 123456#检索特定顾客的订单数目select count(*) as orders from Orders where cust_id = '1000000001';#全检索所有顾客的订单数，并按照顾客姓名排序select cust_name, cust_state, (select count(*) from Orders where Orders.cust_id = Customers.cust_id) as ordersfrom Customers order by cust_name; 完全限定列名：指定表名和列名，告诉SQL语言，比较Orders表中的cust_id和当前正从Customers表中检索的cust_id。如果不这样写DBMS会认为是要对Orders表中的cust_id自身进行比较。 ##联结表创建联结表，指定要联结的所有表以及关联他们的方式123select vend_name, prod_name, prod_pricefrom Vendors, Productswhere Vendors.vend_id = Products.vend_id; 笛卡尔积（cartesian product)没有联结条件的关系返回的结果为笛卡尔积。检索出来的行的树木将是第一个表中的行数乘以第二个表中的行数。select vend_name, prod_name, prod_pricefrom Vendors, Products; 内联结（inner join)等值联结（equijoin），基于两个表之间的相等测试 select vend_name, prod_name, prod_pricefrom Vendors inner join Productson Vendors.vend_id = Products.vend_id; 连接多个表select prod_name, vend_name, prod_price, quantityfrom OrderItems, Products, Vendorswhere Products.vend_id = Vendors.vend_id and OrderItems.prod_id = Products.prod_idand order_num = 20007; select cust_name, cust_contact from Customers where cust_id in (select cust_id from Orders where order_num in (select order_num from OrderItems where prod_id = ‘RGAN01’));使用联结表改写上面的语句：select cust_name, cust_contactfrom Customers, Orders, OrderItemswhere Customers.cust_id = Orders.cust_idand Orders.order_num = OrderItems.order_numand prod_id = ‘RGAN01’; 联结是SQL中一个中重要、最强大的特性，有效使用联结需要对挂系数据库有基本的了解。 ##创建使用高级联结使用表别名：缩短SQL语句；允许在一条select语句中多次使用相同的表。 select cust_name, cust_contact from Customers as C, Orders as O, OrderItems as OIwhere C.cust_id = O.cust_id and OI.order_num = O.order_numand prod_id = ‘RGAN01’; 使用不同联结：自联结（self-join)、自然联结（naturanl join)、外联结(outer join) 自联结 要给Jim Jones同一公司的所有顾客发送一封信件。首先找出Jim Jones工作的公司，然后找到该公司的所有顾客。select cust_id, cust_name, cust_contactfrom Customers where cust_name = (select cust_name from Customers where cust_contact = ‘Jim Jones’);等价方法select c1.cust_id, c1.cust_name, c1.cust_contactfrom Customers as c1, Customers as c2 where c1.cust_name = c2.cust_nameand c2.cust_contact = ‘Jim Jones’; 自然联结12345678910111213select C.*, O.order_num, O.order_date, OI.prod_id, OI.quantity, OI.item_pricefrom Customers as C, Orders as O, OrderItems as OIwhere C.cust_id = O.cust_id and OI.order_num = O.order_numand prod_id = 'RGAN01';select Customers.cust_id, Orders.order_numfrom Customers inner join Orders on Customers.cust_id = Orders.cust_id;select Customers.cust_id, Orders.order_num from CUstomers left outer join Orderson Customers.cust_id = Orders.cust_id;select Customers.cust_id, Orders.order_num from Customers right outer join Orderson Orders.cust_id = Customers.cust_id; SQL聚集函数1234avg() count() max() min() sum()select Customers.cust_id, count(Orders.order_num) as num_ord from Customers inner join Orders on Customers.cust_id = Orders.cust_id group by Customers.cust_id;select Customers.cust_id, count(Orders.order_num) as num_ord from Customers left outer join Orders on Customers.cust_id = Orders.cust_id group by Customers.cust_id; select into 语句从一个表复制到另一个表create table CustCopy as select * from Customers; 更新和删除数据使用UPDATE时一定要细心，因为稍有不注意，就会更新表中的所有行。基本的update语句：1）需要更新的表，2）列名和他们的新值，3）确定要更新那些行的过滤条件update Customers set cust_email = &#39;kim@thetoystore.com‘ where cust_id = ‘1000000005’;update Customers set cust_email = &#39;kim@thetoystore.com‘, cust_contact = ‘Sam Roberts’ where cust_id = ‘1000000005’; SQL中空字符串用’’表示，是一个值，而NULL表示没有值。 alter table Vendors drop column vend_phone; 删除表的内容可以用：delete from custcopy; 和 truncate custcopy;删除表 drop table custcopy; 视图不包含任何列或数据，包含的是一个查询，被封装起来。视图： 重用SQL语句。 简化复杂的SQL操作 使用表的一部分而不是整个表。 保护数据。 更改数据格式和表示。create view 只能创建不存在的视图drop view viewName 删除视图 create view ProductCustomers as select cust_name, cust_contact, prod_id from Customers, Orders, OrderItems where Customers.cust_id = Orders.cust_id and OrderItems.order_num = Orders.order_num; select cust_name, cust_contact from ProductCustomers where prod_id = ‘RGAN01’;]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
</search>
